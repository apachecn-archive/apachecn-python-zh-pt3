# 十六、当心 OOP

*   我的观点是 OOP 是对社区犯下的最大的欺诈之一。事实是 OOP 最重要的一个方面是几十年前设计的方法:子程序和数据的封装。其余的都是糖霜。我曾经说过封装是对象编程所提供的 70%,但是我想我要把它改成 90%。—Thomas Kurtz，见于《编程大师》(O'Reilly，2009)，第 91 和 93 页。[达特茅斯大学的托马斯·库尔茨教授和约翰·凯米尼教授在 1963-64 年间共同开发了 BASIC 语言。Kemeny 在 1986 年获得了 IEEE 计算机先锋奖，同样的工作，Kurtz 在 1991 年获得了该奖。这次采访时，80 岁的库尔茨已经退休 15 年，不再写代码了。]
*   Potok 等人的一项研究表明，OOP 和过程化方法之间的生产率没有显著差异。—维基百科，面向对象编程。

时隔多年，OOP 仍然备受争议。[<sup>1</sup>](#Fn1)c++语言(C 带类)并没有取代 C 语言。对类的一个宣称的理由是通过继承的代码重用(an 是一种关系)。当然，我们已经通过剪切粘贴和导入库文件(模块)实现了代码重用。一些类与它们的应用耦合得如此紧密，以至于它们不容易被重用。通过类重用代码的优势在工业界比在学校问题中更受重视。根据没有继承的对象和类进行编程有时被称为基于对象的编程。

也就是说，我曾经使用继承将四个处理向量的函数(方法)导入到一个`Vector`类中。那些函数只适用于我使用向量编程的特定问题，我不希望我的`Vector`类被重新设计。但这更多的是两个类的组合(a 有一个关系),而不是继承。

继承的另一个优点是，对父代码的单个更改就是对其所有子代码的更改，因为所有子代码的共性只存在于一个地方:父代码。然而，即使对于没有类的程序，通用性也可以被分解到函数中。

类最有用的优点是封装(将函数和数据捆绑成一种新的数据类型，一种抽象， [<sup>2</sup>](#Fn2) 并创建一种迷你语言来操纵它们)。如果类模拟了现实中的某些东西，甚至是程序员对某个问题的观点，那么程序员就可以根据对象而不是它们的单个部分来思考和编写代码。从物体的角度思考就像从和弦而不是单个音符的角度思考音乐一样。这听起来很棒，但是我从未遇到过从抽象数据类型中受益匪浅的有价值的问题。我所遇到的是人为的问题，这些问题被设计成需要封装以供学生学习——例如，汽车和摩托车从车辆继承而来。

封装就是设计，一个高效的设计往往来自于把几个低效的设计扔出去。你可以花很多时间来尝试生成一个泛型类。专家给我们以下建议:

1.  尽量写出与现实紧密对应的自然函数。类(抽象)的全部意义在于它们应该使思考和编程更加直观。与其试图设计一个接近最优的类，不如设计一个易于扩展的类。
2.  尽管许多声明承诺从面向对象分析到设计的平稳过渡，但实际上这种过渡一点也不平稳。——Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides(“四人组”)，设计模式，可重用面向对象软件的要素(Addison-Wesley，1995)，第 11 页和第 353 页。

随着封装的出现，数据隐藏在私有数据中，也就是说，数据要么不能被访问，要么只能通过限制修改的 getters 和 setters 来访问。用户可以重写这个类，这样就可以无限制地访问私有数据，但这将是一个不同的类。如果一个类经过了很好的测试，那么使用这个类的程序中的错误就不太可能在这个类中被发现。当然，对于任何库模块中经过良好测试的函数也是如此。

很少谈论对象的是对象之间相互通信的方式。根据一些 OOP 专家的观点，高效的消息传递是至关重要的。

当我编写第一个神经网络程序时，我认为创建节点类是有意义的，因为网络是由节点组成的。不幸的是，Node 类似乎让事情变得复杂了。于是我重写了网络，没有上任何课。然后我决定重新编写网络程序，作为只有一个对象的神经网络类。这不应该有任何意义，因为那样的话，该对象将没有其他对象与之交互。有什么意义？但是，事实上，它简化了编程。由于许多内部实例变量的半全局属性，我不必在类方法中传递或返回它们。由于网络很小，全球化的负面影响不会发生。尽管如此，我最终还是重新编写了这个程序，但没有这个类。

具有类的多态性支持运算符重载。例如，当处理向量时，我们可以重载一个`Vector`类中的所有操作符，并最终编写如下代码

```py
F = 3*(B+C)/4 - A/2,

```

而不是:

```py
F = vectMinus(scalarMult(3/4, VectAdd(B,C)), scalarMult(1/2, A)).

```

现在你明白我为什么构建了一个`Vector`类了。运算符重载产生了积极的影响——大约十行代码。这种努力是值得的，主要是因为我的学生学会了如何构建一个类，并将其应用于一个严重的问题:用漂亮的 Nelder-Mead 算法进行搜索。

Java 允许程序员重载函数，但不允许重载操作符。在 Python 中，可以重载操作符，但不能重载函数。我认为这是因为在 Python 中，任何函数都会接受使用星号(*)操作符的可变大小和类型的参数列表(签名)。参见下面的代码。单个`doIt()`函数实际上是过载的。

```py
def doIt(*args):
    if len(args) == 1:
        print(args[0])
        return
    if type(args[1]) == list:
        print('list')
    else:
        print(args[1])
#-------------------------------
def main():
    doIt(1)        # output: 1
    doIt(1,'A')    # output: A
    doIt(1,[1,2,]) # output: list

```

在 C++和 Python 中，可以重载已经存在的运算符，但不能引入新的运算符。继续我的向量例子，如果我想写一行关于叉积的代码，我不能使用字母“`x`”作为操作符。相反，我必须编写类似于`A = B.crossProd(C),`或`A = Vector.crossProd(B,C`的代码，或者重载星号(`*`)操作符。

工业界告诉我们，在可以根据对象编写代码的大型程序中，类是有意义的。在大多数学校问题中，这种意识似乎是缺乏的。

题外话。你能想出一个不能按比例绘制的简单几何图形吗？答案在脚注里。 [<sup>3</sup>](#Fn3) 结束题外话。

Footnotes [1](#Fn1_source)

见维基百科/面向对象编程/批评。

  [2](#Fn2_source)

编程中的抽象被认为有两个部分:接口和实现。类接口是方法的集合，例如，getters、setters、finders、modifiers、reporters 等。—用于处理数据。实现由私有方法和该类所有方法主体中的基本语句组成。好处是细节从界面中抽象出来(隐藏起来)。这使得编程更容易。对于所有的类，你需要的方法类型的最小数量是六个:构造函数、getter、setter、mutator(改变对象的一部分)、对象的比较(=，！=，也可能>)，还有一台打印机。在 Python 中，你实际上不需要 getters 和 setter——例如，`Oop.x = 5`和`Oop.setX(5)`是不必要的。

  [3](#Fn3_source)

没有带单位的叉积图可以按比例绘制。如果向量`A`和`B`具有以米为单位的标量，那么垂直叉积向量`C = AxB`将具有以平方米为单位的标量。还要注意，向量中的标量必须都没有单位，或者必须都有相同的单位。否则量级就不存在了。这是一位物理老师告诉我的，奇怪的是，我从未在数学书上发现这个事实。后来我在大卫·r·考斯顿的另一本优秀的书《生物学家的数学》(伦敦:爱德华·阿诺德，1977 年)第 37 页发现了这个错误。作者试图通过测量茎的长度和花的数量来找出两种植物之间的“距离”。