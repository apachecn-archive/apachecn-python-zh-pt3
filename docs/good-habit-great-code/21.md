# 21.动态规划

前言。一章的序言是不寻常的，但是动态编程需要一些动机。

## 有史以来最深刻的学术笑话

一位教授正在路灯柱附近寻找他掉的钥匙，这时他以前的一个学生走过。“你丢了钥匙吗，教授？”学生问。

“是的，我做了，”教授回答。

“好吧，我来帮你找，”学生说。

找了几分钟后，学生问道:“你知道你最有可能把它们掉在路灯柱的哪一边吗？”

“哦，”教授说，“我把它们丢在那边大楼旁边的某个地方了。”

“什么！”学生大声说道。“那你为什么在这里找他们？”

“哦，这里的光线好得多，所以搜索起来更容易。”

## 理查德·海明的回忆录

Alan Chynoweth 提到我过去常常在物理桌上吃饭。我和数学家们一起吃饭，我发现我已经知道了相当多的数学知识；事实上，我没学到多少东西。正如他所说，物理桌是一个令人兴奋的地方，但我认为他夸大了我的贡献。听肖克利、布拉顿、巴丁、约翰逊、肯·麦凯和其他人的音乐非常有趣，我学到了很多东西。但不幸的是诺贝尔奖来了，升职来了，很多都走了。餐厅的另一边是一张化学桌。我曾和其中一位研究员戴夫·麦考尔一起工作过；此外，他当时正在追求我们的秘书。我走过去说:“你介意我加入你吗？”他无法拒绝，于是我开始和他们一起吃了一段时间。我开始问，“你所在领域的重要问题是什么？”大约一周后，“你在研究什么重要的问题？”又过了一段时间，有一天我来了，我说，“如果你正在做的事情不重要，如果你认为它不会带来什么重要的东西，那你为什么要在贝尔实验室研究它？”从那以后我就不受欢迎了。我不得不找别人一起吃饭！那是在春天。

秋天，戴夫·麦考尔在大厅里拦住我说:“海明，你的那句话刺痛了我的心。整个夏天我都在思考这个问题，即在我的领域里有哪些重要的问题。“我没有改变我的研究，”他说，“但我认为这是非常值得的。”我说，“谢谢你，戴夫，”然后继续。我注意到几个月后他被任命为部门主管。前几天我注意到他是国家工程学院的成员。我注意到他成功了。在科学和科学圈里，我从未听说过那张桌子上其他任何人的名字。他们不能问自己，“在我的领域里，什么是重要的问题？”——理查德·海明(摘自理查德·海明 1986 年 3 月 7 日《你和你的研究》。整个演讲都在网上。读一下。)

## 旅行者

这位旅行者，看到通往真理的道路，大吃一惊。那里杂草丛生。“哈，”他说，“我看很久没有人经过这里了。”后来他发现每一棵杂草都是一把独特的刀。“好吧，”他最后咕哝道，“无疑还有别的路。”—斯蒂芬·克莱恩，《战争是仁慈的及其他台词》(1899)。

引言。欢迎来到动态编程，以及本书最难的章节。为什么这么难的题目会放在一本针对仍在开发中的程序员的书里？答案是，我们通过尝试派生和编码困难的算法来建立派生和编码困难的算法的技能。这是唯一的办法。

历史。在 20 世纪 40 年代末和 50 年代初，数学家理查德·贝尔曼 [<sup>1</sup>](#Fn1) 博士是兰德公司雇佣来解决军事和工业问题的众多数学家之一。他观察到他和他的一些同事经常使用相同的方法来解决某些类型的问题。他创造了术语动态编程来描述这些方法。 [<sup>2</sup>](#Fn2) 他的技术著作《动态编程》于 1957 年出版，同年第一种高级编程语言 Fortran 问世。[<sup>3</sup>](#Fn3)1962 年，他和合著者斯图尔特·德雷福斯(Stuart Dreyfus)发表了第二篇论述:应用动态编程。 [<sup>4</sup>](#Fn4)

术语“动态规划”不是特别具有描述性，但是“线性规划”是一个新的术语，指的是通过处理线性不等式系统来解决问题的过程。动态编程通过处理递归函数方程组来解决问题。另外，贝尔曼在他有趣的自传中承认，他喜欢“动态”这个词。

定义。运筹学中的术语“动态规划”是指多阶段决策的数学理论，即在一个过程的不同阶段做出最佳决策，通常是通过创建最佳政策函数。这是它的典型特征。“动态编程”中的“编程”一词在这个术语被创造出来的时候甚至在今天都意味着调度或计划。有时，策略函数用于查找单个(通常是最优)值，例如，最短路径的长度而不是路径本身(到达目标的方向)。

既然微积分以通过消失导数的方式寻找最大值和最小值而闻名，那么动态编程给最优化研究带来了什么？工业和军事中常见的应用问题通常是离散的，不是连续的，因此没有导数。应用问题通常有太多的变量，以至于微积分表达式变得太难计算，即使对计算机来说也是如此。

The Method of Dynamic Programming (DP)

1.  通过减少参数、选择、决策、容量、对象的数量或整数域的大小，将问题简化为子案例，即在每一步减少问题的维度。然后将这些子案例减少到更多的子案例，再减少到更多的子案例。这样做，直到子案例很容易解决。
2.  所有的子案例必须以相似的(递归的)方式产生。
3.  任何情况或阶段的值必须由其直接子情况的值的某种组合来确定，通常(但不总是)作为子情况的最大值或最小值。这就是所谓的优化原则，并导致一个最佳的政策功能。
4.  修剪在实践中通常是必要的。找到一种计算重叠(共享)子案例(如果它们存在)不超过一次的方法。[每个子案例只会比其父案例稍微简单一点。如果每个子案例都比其父案例简单得多，那么就没有必要进行动态编程。仅仅以任何方式将一个问题分解成子问题，然后用蛮力来解决它们就可以了。]

请注意:在计算机科学中，DP 已经意味着一种递归算法，它不会对一个子问题求值两次。参见维基百科。根据你试图解决的问题选择你的定义。

动态编程有三种(很多人说是两种)形式:

*   表单 a)一种迭代算法，构建一个过去计算的表格，用于进行新的计算(称为自底向上方法)
*   形式 b)一种递归算法，不涉及累积内存，只是重复计算相同的子情况(称为自顶向下方法)
*   形式 c)一种递归算法，它记住先前计算的子情况(也称为自顶向下方法)。

注意，上面的表格 b 违反了动态编程的第四个属性。因此，有些人不认为形式 b 是动态规划。然而，表格 b 满足运筹学 DP 的定义特征，是编写的最简单的 DP 函数，有时足以解决手边的问题，并且是编写表格 c 的第一步，这反过来通常有助于产生更快的表格 a。因此，表格 b 至少是动态编程工具箱的一部分。

函数方程。DP 的子情况通常涉及函数方程，即至少包含一个函数的方程。这里有一个简单的例子(Denardo，第 28 页)。假设你在用一对公平骰子掷出 7 之前，想知道掷出 3 的概率:![$$ f\left(3,7\right)=? $$](A461100_1_En_21_Chapter_IEq1.gif)。一掷中得 3 的概率是![$$ \frac{2}{36} $$](A461100_1_En_21_Chapter_IEq2.gif)。得到 7 的概率是![$$ \frac{6}{36} $$](A461100_1_En_21_Chapter_IEq3.gif)。两者都得不到的概率是![$$ 1-\frac{2}{36}-\frac{6}{36} $$](A461100_1_En_21_Chapter_IEq4.gif)。那么我们的答案就是无限几何级数:

![$$ f\left(3,7\right)=\frac{2}{36}+\left(1-\frac{2}{36}-\frac{6}{36}\right)\frac{2}{36}+{\left(1-\frac{2}{36}-\frac{6}{36}\right)}^2\frac{2}{36}+{\left(1-\frac{2}{36}-\frac{6}{36}\right)}^3\frac{2}{36}+\dots $$](A461100_1_En_21_Chapter_Equ1.gif)

①

这一系列可以用预先计算公式求解:

![$$ a+ ar+a{r}^2+a{r}^3+\cdots =\sum \limits_{k=0}^{\infty }a{r}^k=\frac{a}{1-r},\mathrm{for} \mid r\mid <1 $$](A461100_1_En_21_Chapter_IEq5.gif)

如果你想不起公式了怎么办？一个简单的想法是将级数视为函数方程(1):

![$$ f\left(3,7\right)=\frac{2}{36}+\left(1-\frac{2}{36}-\frac{6}{36}\right)f\left(3,7\right) $$](A461100_1_En_21_Chapter_IEq6.gif)

而现在只要求解 x: ![$$ x=\frac{2}{36}+\frac{28x}{36}\Rightarrow \frac{8x}{36}=\frac{2}{36}\Rightarrow x=f\left(3,7\right)=\frac{1}{4} $$](A461100_1_En_21_Chapter_IEq7.gif)。因此，如果你知道函数方程，那么你永远不需要记住无穷几何级数公式。，除了|r| < 1。顺便说一句，你如何检查等式(1)的有效性？答案在脚注里。 [<sup> 5 </sup>](#Fn5) 函数方程是方便的工具，可以帮助我们解决问题，也可以简化计算。

自下而上、自上而下和记忆化。考虑尝试生成第五个斐波那契数。一个自然的解决方案是用 DP 来表示，即，用降维的递归函数方程来嵌入原始问题:

*   `(5) f[5] = f[4] + f[3]`
*   `(4) f[4] = f[3] + f[2]`
*   `(3) f[3] = f[2] + f[1]`
*   `(2) f[2] = f[1] + f[0]`
*   `(1) f[1] = 1`
*   `(0) f[0] = 0`

在这个自下而上的例子中，我们只需要在第(2)行计算一次`f[2]`，然后在第(3)和(4)行使用它。如果我们想自顶向下工作，我们需要调用第(3)和(4)行的`f[2]`。但是当我们最终在第(2)行计算`f[2]`时，我们可以保存结果，而不需要在第 3 行和第 4 行重新计算。

如果您让初学者编写一个 Python 函数来打印第 n 个斐波那契数，他或她可能会编写一个简单的迭代函数，如下所示:

```py
def fib1 (num): # ITERATION, bottom-up (form a)
    if num < 3: return 1
    a = b = 1
    for i in range(2, num):
        a, b = b, a+b
    return b
#--------------------------------------------------------------

```

如果你让初学者递归地解决同一个问题，你会得到这样的结果:

```py
def fib2 (num): # RECURSION, top-down (form b)
    if num < 3: return 1
    return fib2(num-1) + fib2(num-2)
#--------------------------------------------------------------

```

需要注意的是，自顶向下(实际上是递归)方法是指初始函数调用从一端开始，直到调用到达另一端才获得值，然后返回数字。因为实际的计算直到自顶向下的调用到达另一端才能开始，所以嵌入自顶向下方法的是自底向上方法。既然如此，为什么会有人选择自顶向下的方法呢？回答:较慢的自顶向下方法比较快的自底向上方法更容易编写。

在这里，自上而下的方法非常低效。它重复计算完全相同的子案例。我们可以通过引入动态(变化的)查找表来改进`fib2`。这个技巧叫做记忆化。 [<sup>6</sup>](#Fn6) 下面是两个版本。第一个将早期的数字保存在一个半全局列表中。第二个版本将早期的数字保存在 Python 字典中，该字典的地址随每次递归调用一起传递。

```py
def fib3 (num): # RECURSION with memoization, top-down (form c)
    if num < len(fibNums): return fibNums[num]
    fibNums.append(fib2(num-1) + fib2(num-2))
    return fibNums.pop()
fibNums =[0,1,1]
#--------------------------------------------------------------

def fib4 (num, Dict): # RECURSION with memoization, top-down, (form c)
    if num in Dict: return Dict[num]
    Dict[num] = fib4(num-1, Dict) + fib4(num-2, Dict)
    return Dict[num]

    print(fib4(12, {1:1, 2:1})) # The call.
#--------------------------------------------------------------

```

通过检查导致第 n 个斐波那契数的递归调用树，可以得到一个重要的观察结果。每一层(除了最下面的几层)的节点数都是上一层的两倍。有了记忆，计算机只能沿着树的一边往下走，除了为每一层回忆一个以前计算过的数字之外，永远不会分叉。这是极端的修剪。这是将指数运行时间变为线性运行时间。这就是为什么递归动态编程通常与记忆相结合。 [<sup>7</sup>](#Fn7)

运筹学的一个问题。每当我们意识到一个问题可以被简化为一个更简单的情况，而这个情况又可以以同样的方式被简化为一个更简单的情况，那么我们可能就在谈论动态编程。考虑著名的吉普问题(又名穿越沙漠问题)。没有要求你解决这个难题，只需要注意解决方案的形式。 [<sup>8</sup>](#Fn8)

问题。(兰德 1946)假设我们有一辆吉普车，它能载足够的汽油行驶 d 英里。为了在平坦贫瘠的地形上穿越 2d 英里的距离，有必要建立中间的汽油贮藏处。假设吉普车的燃料消耗是恒定的，并且在任何时候，吉普车可以将它携带的任何数量的燃料留在缓存中，或者可以收集在前一次旅行中留在缓存中的任何数量的燃料，只要它的燃料负载不超过一个满箱。家得宝有无限量的汽油。两个问题自然出现:1)应该如何定位贮藏处，以最小化行驶 2d 英里所需的汽油总支出，以及 2)吉普车到达目的地的总行驶距离是多少？——r . Bellman，《动态编程》(普林斯顿，1957)，第 103 页，问题 54(此处转述)。

评论。有许多不同的方案来进行 2d 穿越沙漠的旅行。请考虑以下情况。假设我们从 11 箱汽油开始，来回移动 d/4 的距离，每次放下半箱。在第十一次旅行中，我们到达了 d/4，还剩下 5-3/4 罐。通过重复该过程，我们移动到 d/2，剩下 3 个罐。然后我们移动到 3d/4，剩下 1-3/4 个坦克。然后我们移动到 d 点，还剩一个油箱，刚好够我们飞完最后一程到达 2d 点。这是一个解决方案(11 辆坦克)，但我们可以做得更好。

通过动态规划求解(N.J. Fine，美国数学月刊，第 54 卷，1947 年，第 458-462 页)。让我们考虑递归函数方程。我们定义 f (t) = d，其中 t 是满满一箱汽油，d 以英里为单位。 [<sup>9</sup>](#Fn9)

那么 f (2t) = d/3 + d，为什么呢？吉普车前进了 d/3 英里，储存了三分之一的油箱，然后返回家得宝。在第二次旅行中，它到达缓存并重新装满油箱，问题简化为 f (t)。

接下来 f (3t) = d/5 + d/3 + d，为什么？吉普车前进到 d/5，放下 3/5 的油箱，然后返回。然后它重复这一行程。在第三次也是最后一次旅行中，吉普车带着 4/5 的油箱到达储藏处，还有 6/5 的油箱在等着它。这是两个满罐，问题以与前一种情况相同的方式减少。

接下来 f (4t) = d/7 + d/5 + d/3 + d，为什么？吉普车开始前进 d/7 英里，放下 5/7 的坦克。它重复这个旅程两次以上。在第四次旅行中，吉普车带着 6/7 的油箱到达第一个缓存，发现相当于 15/7 的油箱在等待。这是 3 个满罐，问题以与前一种情况相同的方式减少。

因此，我们看到 n 个满罐的缓存模式:f (nt) = d，d/3，d/5，d/7，d/9，d/11，…，d/(2n-1)。带着 n 箱燃料向前行进到沙漠中的距离可以表示为递归函数方程:

f (nt) = d/(2n-1) + f ((n-1)t)，其中 f (t) = d。

因此，在家得宝有 8 个油箱的情况下，吉普车可以向前行驶 f(8t)= d+d/3+d/5+d/7+d/9+d/11+d/13+d/15≈2.02d。当然，在有 8 个油箱的情况下，吉普车将行驶 8d 的总距离(来回)。其核心思想是将原问题的解反复嵌入一族越来越小维度(这里是整数域)的递归函数方程中。

<colgroup><col align="left"> <col align="left"></colgroup> 
| 英里距离 | 在装满的吉普车油箱中测量燃油 |
| :-- | :-- |
| 2d | eight |
| 三维（three dimension 的缩写） | Fifty-seven |
| 4d | Four hundred and nineteen |
| 5d | Three thousand and ninety-two |
| 6d | Twenty-two thousand eight hundred and forty-six |
| 7d | One hundred and sixty-eight thousand eight hundred and four |
| 8d | One million two hundred and forty-seven thousand two hundred and ninety-eight |
| 9d | Nine million two hundred and sixteen thousand three hundred and fifty-four |
| 10d | Sixty-eight million one hundred thousand one hundred and fifty-one |

因为奇数分母的分数序列是发散的，所以吉普车的行驶距离(理论上)没有限制。看看右边的桌子。n 箱燃油的行驶距离也可以以封闭形式给出:

![$$ 1+\frac{1}{3}+\frac{1}{5}+\cdots +\frac{1}{2n-1}=\sum \limits_{k=1}^n\kern0.50em \frac{1}{2k-1} $$](A461100_1_En_21_Chapter_IEq8.gif)

注意:这不是一般第 n 种情况的证明(“我们可以看到模式”)，也不是最优性证明。贝尔曼的书包含了许多页的 DP 定理的存在性和唯一性证明，这些证明只有数学专家才能理解。

我们现在将考察四个经典的动态规划问题。最理想的方法是在考虑我的解决方案之前，试着在每个问题上取得一些进展。其他解决方案和问题可以在互联网上找到。

问题 1。最短路径。

在下面的(无环有向) [<sup>10</sup>](#Fn10) 图中我们求从任意节点到节点 9 的最短路径。

还是我们？难道我们不寻求一个函数(最优策略)给定一个节点，告诉我们下一个节点移动到最优路径吗？这不符合 DP 的精神吗？既有也有。产生一个函数来指导我们选择下一个节点是贝尔曼最初如何描述 DP 的。这就是工业所需要的。然而，要从任何当前节点找到下一个最佳节点，我们必须首先从当前节点找到整个最佳路径。所以，我们不能缺一不可。 [<sup>11</sup>](#Fn11)

![A461100_1_En_21_Figa_HTML.jpg](A461100_1_En_21_Figa_HTML.jpg)

这个数字摘自 Eric V. Denardo 的《动态编程模型和应用》(Dover，2003)，第 9 页。11 条可能路径中最短的是通过节点 1、3、4、5、7、9，总长度或成本为 19。奇怪的是，贪婪(近视)算法产生长度为 27 的最长路径(1，2，4，6，8，9)。

首先，把图形图片翻译成电脑数据。这将是一个关联列表，即一个列表列表:一个节点列表，其中每个节点都有自己的直接转发邻居列表以及到这些邻居的距离。Python 提供了内置的字典数据类型来帮助我们处理这些信息。以下数据结构可用于(不变)自顶向下和自底向上算法:

```py
graph = {1:[(1,2), (2,3)], # (d,n) = (distance to next node, next node)
         2:[(12,5),(6,4)],
         3:[(3,4), (4,6)],
         4:[(4,5), (15,7), (7,8), (3,6)],
         5:[(7,7)],
         6:[(7,8), (15,9)],
         7:[(3,9)],
         8:[(10,9)],
         9:[(0,0)], }

```

现在问问你自己，在任何一个节点上，你需要什么样的信息，才能以最优路径到达我们的目标(这里是节点 9)。您需要一个直接转发邻居列表以及从您当前位置(节点)到每个邻居的距离。该信息已经在问题陈述中给出(`graph`数据结构)。您需要的最后一条信息是从每个邻居(I)到目标的最佳距离 f (i)。这就是递归的用武之地。找到从邻居节点到目标节点的最短距离与我们在当前节点上问的问题完全相同，只是维度(节点中剩余路径的长度)略有减少。寻找这样一个递归函数通常需要很大的独创性。如果能够找到并解决，那么未来的求解者将能够在每个阶段做出最优决策。尽管这种思想是递归的，但我们编写的函数可以是迭代的，也可以是递归的，就像我们看到的两个 Fibonacci 函数一样。

我们的函数 f (i)表示节点 I 和节点 9 之间的最小(最佳)距离。显然，![$$ f(9)=0 $$](A461100_1_En_21_Chapter_IEq9.gif)。然而

* ![$$ f(i)=\underset{j}{\min}\left({d}_{ij}+f(j)\right) $$](A461100_1_En_21_Chapter_IEq10.gif)，【贝尔曼方程】

其中 d <sub>ij</sub> 是从节点 I 转发到最近的邻居节点 j 的距离。注意![$$ i<j $$](A461100_1_En_21_Chapter_IEq11.gif)，并且 f ( j)是从节点 j 转发到节点 9 的最小距离。在 DP 理论中，从技术上讲，当递归函数被导出时，优化问题就解决了。 [<sup>12</sup>](#Fn12) 

上面简洁的措辞需要更加具体。因此，通过查看图形图片或`graph`数据结构，使用公式(*)手动写出九个等式`f(9)` = 0 至`f(1)` = 19。警告:不要跳过这一步。答案(做完后检查)后面给。

下一段包含了确定最小路径长度的关键思想，而不必检查每条可能路径的长度。但是，我们必须将每个节点与一个数字相关联(从该节点到节点 9 的最小距离)。

当我们来到节点 6 时，我们必须评估到目标的两个(短)距离。当我们到达节点 4 时，我们只需要检查四个(而不是五个)距离，因为节点 6 现在只与一个距离(最佳距离)相关联，而不是两个距离。当我们来到节点 3 时，我们只需要检查两个距离，而不是七个距离，因为节点 4 只与一个距离相关联，而节点 6 只与一个距离相关联。这就是记忆化动态编程的修剪能力。这让我们看到了你的第一个任务。我的代码(解决方案)遵循分配。

*   作业 1。写一个名为`fa` (form a)的迭代函数，只接收一个节点(`graph`数据是全局的)，返回从那个节点到目标节点的距离(9)。这个短函数的关键思想是递归函数方程(*)。您必须创建一个本地数据结构来保存从每个节点到目标节点的最佳距离。我把我的数据结构命名为`data`。我的笔记告诉我，第一个函数花了我 50 分钟来编写，又花了 10 分钟来重构。
*   作业 2。写一个名为`fb` (form b)的递归函数(无记忆化剪枝)只接收一个节点(`graph`数据是全局的)，返回该节点到目标节点的距离(9)。
*   作业 3。编写一个名为`fc`(形式 c)的递归函数，它是对函数`fb`的修改，包括记忆化。
*   作业 4。编写一个函数`determineMinimumPathAndDistance`来调用`fb`、`fc`或`fa`，并返回最短路径和该路径的长度。

九个方程式

![$$ {\displaystyle \begin{array}{l}f(9)=0\\ {}f(8)=10+f(9)=10\\ {}f(7)=3+f(9)=3\\ {}f(6)=\min \Big\{\begin{array}{l}7+f(8)=7+10\\ {}15+f(9)=15+0\end{array}=15\\ {}f(5)=7+f(7)=10\end{array}} $$](A461100_1_En_21_Chapter_Equa.gif)

![$$ {\displaystyle \begin{array}{l}f(4)=\min \Big\{\begin{array}{l}4+f(5)=4+10\\ {}15+f(7)=15+3\\ {}7+f(8)=7+10\\ {}3+f(6)=3+15\end{array}=14\\ {}f(3)=\min \Big\{\begin{array}{l}3+f(4)=3+14\\ {}4+f(6)=4+15\end{array}=17\\ {}f(2)=\min \Big\{\begin{array}{l}12+f(5)=12+10\\ {}6+f(4)=6+14\end{array}=20\\ {}f(1)=\min \Big\{\begin{array}{l}1+f(2)=1+20\\ {}2+f(3)=2+17\end{array}=19\end{array}} $$](A461100_1_En_21_Chapter_Equab.gif)

```py
The

Author's Four Solutions

"""+===============-========-========-========-========-======+
   ||      DYNAMIC PROGRAMMING (shortest route problem)        ||
   ||          by M. Stueben (October 8, 2017)               ||
   ||                                                        ||
   || Description: This program contains three functions (fa, ||   ||              fb, and fc) which each determine the next  ||   ||              node to move to in proceeding by the shortest    ||   ||              path to goal node 9\. Then each of these    ||   ||              functions is used to find the shortest route   ||   ||              and its distance from node 1 to node 9\.       ||
   || Reference:   Eric V. Denardo, Dynamic Programming      ||   ||              (Dover, 2003), pages 6-19\.                ||
   || Language:    Python Ver. 3.4                           ||
   || Graphics:    None                                      ||
   +===========-========-========-========-========-==========+
"""

####################<BEGINING OF PROGRAM>######################
#============<GLOBAL CONSTANTS and GLOBAL IMPORTS>=============
graph = {1:[(1,2),  (2,3)], # Each neighbor node moves us towards goal node 9.
         2:[(12,5), (6,4)], # (d,n) = (distance to next node

, next node)
         3:[(3,4), (4,6)],
         4:[(4,5), (15,7),(7,8),(3,6)],
         5:[(7,7)],
         6:[(7,8), (15,9)],
         7:[(3,9)],
         8:[(10,9)],
         9:[(0,0)], }
count = 0                    # Counts the number of recursive calls.
#==============================================================

def printResults(distance, path, func):
    print('--', func.__name__,'min path:', path)
    print('   distance =', distance, 'recursive calls =', count)
#==============================================================

def fb(node):                # Recursion with NO memoization.
    global count; count  += 1
    if node == 9: return 0
    shortest =  min([dist + fb(neighbor) for (dist, neighbor) in graph[node]])
    return shortest          # = shortest distance from current node to goal node

.
#==============================================================

def fc(node, dict = {}):     # Recursion with memoization.
    global count; count += 1;
    if node == 9: return 0
    data = []                # data = [(dist to goal, neighbor),...]

    for (dist, neighbor) in graph[node]:
        if neighbor in dict:
            data.append((dist + dict[neighbor], neighbor))
        else:
            neighborsDistToGoal = fc(neighbor, dict)
            data.append((dist + neighborsDistToGoal, neighbor))
            dict[neighbor] = neighborsDistToGoal

    shortest = min(data)[0]
    return shortest # = shortest distance

from current node to the goal node.
#==============================================================

def fa (node):
    data = ['-',0,0,0,0,0,0,0,0,0,] # = distances of each node to goal node (9).
    for n in range (8, 0, -1):
        data[n] = min([dist + data[neighbor] for (dist, neighbor) in graph[n]])
    return data[node]
#==============================================================

def determineMinimumPathAndDistance(func, node):
    global count; count = 0
    minimumPath         = [node]
    shortestDistance    = 0

    while node != 9:
        (_, dist, node)  = min([(dist + func(neighbor), dist, neighbor)
                               for (dist, neighbor) in graph[node]])
        minimumPath.append(node)
        shortestDistance += dist
    return shortestDistance, minimumPath
#==========================<MAIN>==============================

def main():
    for func in (fb, fc, fa):
        distance, path = determineMinimumPathAndDistance(func, node=1)
        printResults(distance, path, func)
#--------------------------------------------------------------

if __name__ == '__main__':
   from time import clock

; START_TIME = clock();
   main(); print('- '*16);
   print('Program run time:%6.2f'%(clock()-START_TIME), 'seconds.')
########################<END OF PROGRAM>#######################

```

输出:

```py
-- fb min path: [1, 3, 4, 5, 7, 9]
   distance = 19 recursive calls = 63
-- fc min path: [1, 3, 4, 5, 7, 9]
   distance = 19 recursive calls = 16
-- fa min path: [1, 3, 4, 5, 7, 9]
   distance = 19 recursive calls = 0
- - - - - - - - - - - - - - - -
Program run time:  0.06 seconds.

```

一百万次呼叫的时间如下:

*   函数运行时间:16.5 秒，63 次递归调用，最大递归深度 27。
*   `fc`(函数运行时间:8.5 秒，16 次递归调用，最大递归深度 4。
*   `fa`功能运行时间:6.5 秒。

我的经验一直是迭代 DP 比递归 DP 快。然而，当我第一次运行这个测试时，`fc`比`fa`快了许多倍。我知道我在比较时间时犯了一些错误，但是是什么错误呢？也许读者在看脚注之前就能猜到。 [<sup>13</sup>](#Fn13)

代码注释:

1.  当主函数中的`for`循环实际上简化了代码的阅读时，这是一种罕见的情况。但是，这段代码的目的是演示这三个功能，而不是解决一个问题。
2.  函数`determineMinimumPathAndDistance`包括抛弃的下划线变量(' _ ')。
3.  为什么我在图中把距离放在邻居之前，而不是相反？答:`min`函数只检查元组或列表中的第一个元素。当用 Python 调用带有元组或列表的`min`或`max`函数时，这是一个有用的设计技巧。
4.  请注意，我使用了所谓的幻数，而不是将这些数字分配给标识符——例如`rootNode = 9`。这使得代码更容易理解，但如果放在一个更大的程序中，则更难扩展或调试。

尽管记忆化使得函数更难编写，但记忆化(通过递归或迭代)赋予了动态编程强大的功能。如果读者已经到了这一步而没有写任何代码，那么是时候把书放在一边，回去从记忆和理解两方面写代码了。卡住了就偷看。

现在是一个惊喜。写完简单的`fb`，我们可以用装饰器将`fc`定义为`fb`:

```py
def memoize(function):
    from sys  import setrecursionlimit; setrecursionlimit(100) # default = 1000
    dict = {}
    def wrapper(num):
       if num not in dict:
          dict[num] = function(num)
       return dict[num]
    wrapper.__name__ = function.__name__ # In case we need the function's name.
    return wrapper
#==============================================================

@memoize
def fb(node):              # Recursion with NO memoization.
    global count; count  += 1
    if node == 9: return 0
    shortest =  min([dist + fb(neighbor) for (dist, neighbor) in graph[node]])
    return shortest        # = shortest distance from current node to goal node.

```

修饰的缺点是 1)它将代码放在两个不同的位置，2)它需要更多的递归，3)它更慢，4)如果您没有掌握修饰语法，代码更难理解。

这里有些奇怪的东西。可以这样构造`graph`:

```py
graph = {9:[(10,8), (3,7), (15,6)],
         8:[(7,6), (7,4)],
         7:[(7,5), (15,4)],
         6:[(3,4), (4,3)],
         5:[(4,4),(12,2)],
         4:[(3,3), (6,2)],
         3:[(2,1)],
         2:[(1,1)],
         1:[(0,0)], }

```

因此，新邻居(I)是馈入给定节点(j)的节点，而不是来自给定节点的邻居。那么贝尔曼方程是这样的:![$$ f(j)=\underset{i}{\min}\left({d}_{ij}+f(i)\right) $$](A461100_1_En_21_Chapter_IEq12.gif)，其中![$$ i<j $$](A461100_1_En_21_Chapter_IEq13.gif)，f (i)是从节点 I 回到节点 1 的距离，![$$ f(1)=0 $$](A461100_1_En_21_Chapter_IEq14.gif)。哪种形式比较好？据我所知，都不是。如果您感兴趣，以下是三种表单的代码:

```py
#---1\. Returns distance only (form a).
def f(n): # ITERATIVE, bottom-up, memoization.
    ff = [0,0,0,0,0,0,0,0,0,0,]
    for i in range(1, n+1):
        ff[i] = min([(ff[j]+d) for (d,j) in graph[i]])
    return ff[n] # = dist. from node n down to node 1.
#--------------------------------------------------------------

#---2\. Returns distance

only (form b).
def f(n): # RECURSIVE, top-down, no memoization.
    if n == 1: return 0
    return min([ d+f(neighbor) for (d, neighbor) in graph[n] ]) # Bellman equation
#--------------------------------------------------------------

#---3\. Returns distance only (form c).
def f(n): # RECURSIVE, top-down, memoization.
    dist = []
    for (d, neighbor) in graph[n]:
        if neighbor not in f.dict: f.dict[neighbor] = f(neighbor)
        dist.append( d + f.dict[neighbor] )
    return min(dist)
f.dict = {0:0, 1:0} # A global dictionary makes the code easier to understand.
#--------------------------------------------------------------

```

贝尔曼和斯图尔特·e·德雷福斯一起写了第二本关于动态编程的书。15 年后，德雷福斯写了另一本关于动态编程的书，其中包括 187 个已解决的问题。德雷福斯和他的合著者提出了以下建议:

*   根据教授这门学科的丰富经验，我们确信，只有通过学生的积极参与，才能学会使用动态编程来制定和解决问题的艺术。再多的被动听课或阅读文本材料也不能让学生准备好阐述和解决新问题。学生必须首先从经验中发现，正确的公式并不像阅读教科书上的解答时那样简单。然后，通过大量独立解决问题的实践，他将获得对主题的感觉，最终使正确的表述变得容易和自然。由于这个原因，这本书包含了大量的教学问题。这个学生必须自己做这些题。任何学生在认真尝试解决问题之前阅读解决方案，后果自负。当面对考试或面对现实世界的问题时，他几乎肯定会后悔这种被动。不要只是阅读解决方案，并认为“当然，这就是如何做到这一点。”——斯图亚特·德雷福斯和阿威里尔·m·劳，《动态程序设计的艺术和理论》(学术出版社，1977)，页 xi。

一个自然的问题是:为什么不是所有的教科书都包含大量的算出的例子？我的观点:1)找到好的例子很难，也很费时间。2)作者担心批评可能来自他们的非最优解。3)作者要么已经记住了这些例子，要么可以毫不费力地构建它们，并且没有意识到如果没有这些例子，他们的文本对其他人来说是不容易理解的。

有人说，以身作则不仅仅是一种教学方式，而是唯一的教学方式。我会更进一步。应该给学生许多他们觉得不容易的问题，但这些问题可以通过给出的例子中说明的原理来解决(参见维基百科，s.v. Moore method)。我们已故的朋友乔治·波利亚是这样说的:

*   “解决问题的教学是意志的教育。在解决对他来说不太容易的问题时，学生学会了在不成功中坚持，学会了欣赏微小的进步，学会了等待重要的想法，学会了在想法出现时全力以赴。如果学生在学校没有机会熟悉为解决问题而斗争的各种情绪，他的数学教育就在最重要的一点上失败了。”—乔治·波利亚，如何解决，2 <sup>nd</sup> Ed。(《双日》，1957)，第 94 页。

问题二。0-1 背包问题(又名货物装载问题)。

一个背包的最大容量是 20 磅.给定的一组物品，每个都有重量和美元值，可以放在背包中。确定背包在容量限制下所能容纳的最大元总值。(稍后我们将确定放入背包的物品，以实现价值最大化。但是作为初学者，我们先做简单的问题。)

0-1 表示任何特定重量的物品只能装载一件。因此，该物品要么包含在背包中(1)，要么不包含在背包中(0)。以下是我们将使用的值:

```py
value          cost (= weight); C = 8
             v[1] = 15,     w[1] = 1
             v[2] = 10,     w[2] = 5
             v[3] =  9,     w[3] = 3
             v[4] =  5,     w[4] = 4

```

回想一下，在动态编程中，原始问题被递归地分解成更小的问题。背包可以具有更小的容量(`j`)或者允许更少的物品(索引为`i`)进入背包。因此，我们可以用两种不同的方法来减少问题的规模(维度)。下表中的数字代表所有可能的子情况。我们考虑将物品放入背包的顺序并不重要。答案在右下角。这个表格/矩阵是如何产生的？

```py
              The matrix (M) is a table of values
                  0  1  2  3  4  5  6  7  8 <--remaining capacity of knapsack
                +--------------------------
       0th item | 0  0  0  0  0  0  0  0  0
       1st item | 0 15 15 15 15 15 15 15 15
       2nd item | 0 15 15 15 15 15 25 25 25
       3rd item | 0 15 15 15 24 24 25 25 25
       4th item | 0 15 15 15 24 24 25 25 29 Answer = max value = 29 = M[4][8]
                                     Best weight set: [4, 3, 1]

```

请注意:`j`值是后面代码中的索引。因此，这种方案不适用于非整数的重量/成本。

考虑尝试将第`i`件物品(重量`w[i]`和价值`v[i]`放入剩余容量`j`的部分装满(或空)的背包中。换句话说，我们寻求单元格`M[i][j]`的值。只会出现三种情况:

*   案例一。(最简单)。我们永远不能把`w[i]`放在背包里，因为光是`w[i]`就比`C`大。背包中当前的值是最优的。因此，`M[i][j] = M[i-1][j]`。
*   案例二。我们不应该把重量`w[i]`放在背包里，因为`w[i]`会推出其他重量，使背包比有`w[i]`的重量更有价值。(我们怎么会知道这个呢？你马上就会看到。)又来了，`M[i][j] = M[i-1][j]`。
*   案例三。我们应该将`w[i]`重量放入背包中，但是之后我们将不得不取出背包中的一些物品(或者不取出)，并用较小重量的最佳组合来填充剩余空间(如果有的话)。这个最佳组合已经确定为`M[i-1][j-w[i]]`。由此，

    ```py
    M[i][j] = v[i]+ M[i-1][j-w[i]].

    ```

我们可以结合案例 2 和案例 3:

```py
M[i][j] = max( M[i-1][j], v[i]+M[i-1][j-w[i]] )

```

再看案例 2 和案例 3。假设背包(容量= `C`)中没有足够的剩余空间来插入考虑中的当前物品(重量`w[i]`)。这并不意味着我们不能插入它。我们简单地清空背包，将考虑中的物品放入背包——这将背包容量减少到已经考虑的数目(`C – w[i]`)——然后重新装载容量减少的背包。我们如何知道将哪些物品放入背包？这个问题的答案已经在`j = C – w[i]`下面的表格里了。然后我们决定:插入物品(可能会推出一些其他物品)是否会增加背包的价值(与不插入相比)？

将使这种编码更容易的是向数据集`w`和`v`附加两个零。

```py
    if w[0] != 0 or v[0] != 0:
        w = [0] + w
        v = [0] + v

```

这些零是必需的，因为如果我们不小心的话，索引`i-1`最终会减少到`-1`。如果我们不添加零，那么我们将需要更多的`if`语句，这将使代码更加复杂。为了测试你的程序，这里有一些数据集及其答案:

```py
# Data set 1
w = [ 1,  5, 3, 4]     # weights with index i.
v = [15, 10, 9, 5]     # values

  with index i, not j.
C = 8                  # Answer: max val = 29; weights = [4, 3, 1]
#-----------------------------

# DATA SET 2
w = [1,  2,  3,  4,  5,  6,  7,  8,  9,]   # w[i]
v = [7,  4,  5, 15,  9, 12, 11, 10,  3,]   # v[i]
C = 20                 # Answer: max value: 49; weights: [7, 6, 4, 2, 1]
#-----------------------------

# DATA SET 3
w = [1,2,3,4,5,6,7,8,9]
v = [5,2,8,1,9,7,4,3,6]
C = 20                 # Answer: max val = 31; weights =[6, 5, 3, 2, 1]
                       # Note that 6+5+3+2+1 = 17, not C = 20.
#-----------------------------

# DATA SET 4
w = [ 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,]
v = [12, 2,11, 1, 9,10, 4,15, 6, 7, 8,14, 3, 5, 9,]
C = 25           # Answer: max value = 59 weights = [8, 6, 5, 3, 2, 1]
C = 50           # Answer: max value = 81 weights = [12, 11, 8, 6, 5, 3, 2, 1]
C = 60           # Answer: max value = 88 weights = [12, 11, 10, 8, 6, 5, 3, 2, 1]
#-----------------------------

```

编写迭代函数来返回任何数据集的最大值。我的迭代函数如下。它引用先前给出的数据集`w`、`v`和`C`中的任何一个。

```py
def knapsackI(w,v,C): # Iterative: returns max value.
#---Special case (impossible).
    if w == []:
        return (0, [])

#---Append zero weights and values to make the top row and left col zeros.
    w = [0]+w
    v = [0]+v

#---Set matrix size.
    rowMax = len(w)
    colMax = C + 1

#---Create empty matrix, filled with zeros. Note: Because of w[0] = 0 and
#   v[0] = 0, the top row and left col are complete as zeros.
    M = [[0 for j in range(colMax)] # j = col index.
            for i in range(rowMax)] # i = row index.

#This is what we have so far:
#                      0  1  2  3  4  5  6  7  8 <--capacities of the knapsack (j)
#                    +--------------------------
#       i = 0th item | 0  0  0  0  0  0  0  0  0
#       i = 1st item | 0  0  0  0  0  0  0  0  0
#  M =  i = 2nd item | 0  0  0  0  0  0  0  0  0
#       i = 3rd item | 0  0  0  0  0  0  0  0  0
#       i = 4th item | 0  0  0  0  0  0  0  0  0

#---Fill the matrix with values from the bottom-up, starting at 1.
    for i in range(1,rowMax):
        for j in range(1,colMax):
            if w[i] > j:              # Case 1: weight exceeds capacity C.
                M[i][j] = M[i-1][j]
            else:
                M[i][j] = max(  M[i-1][j],  v[i]+M[i-1][j-w[i]]  ) # cases 2 & 3

#---Select the answer (lower-right corner) and return it.
    return M[rowMax-1][colMax-1]
#--------------------------------------------------------------

```

现在我们不用记忆递归地写同样的函数(形式 b)。我用两种不同的方式编写了这个函数:

```py
def knapsackR(i,j,w,v): # RECURSIVE, NO MEMOIZATION (returns max value only)
#---Special case.
    if w == []:
       return (0)

#---Append zero weights.
    if w[0] != 0 or v[0] != 0:
        w = [0] + w
        v = [0] + v
        i += 1

#---Base cases.
    if i == 0 or j == 0:
        return 0 # base cases

#---Recursive cases.
    if w[i] > j:
        return knapsackR(i-1,j,w,v)
    return max(knapsackR(i-1,j,w,v), v[i] + knapsackR(i-1,j-w[i],w,v))

# The call: print('Maximum value =', knapsackR(len(w)-1, C, w, v))
#------------------------------------------- Knapsack problem--

```

注意 b 型递归方法比迭代方法要短得多，也简单得多。不幸的是，每个递归调用都要考虑“特殊情况”。这是低效的。特殊情况只需要在第一次呼叫时考虑。下一个版本弥补了这种低效率。也许，在看之前，你可以通过设计来确定我是如何做到的，而不是通过`if`语句。我的代码如下:

```py
def knapsackRR(w,v,C): # RECURSIVE, NO MEMOIZATION (returns max value only)
#---Special case.
    if w == []:
       return (0)

#---Append zero weights, if necessary.
    if w[0] != 0 or v[0] != 0:
        w = [0] + w
        v = [0] + v
#--------------------------------------------------------------
    def f(i,j): # <-- Helper function. Remember this trick.
#------Base cases.
       if i == 0 or j == 0:
           return 0 # base cases

#------Recursive cases.
       if w[i] > j:
           return f(i-1,j)

       return max(f(i-1,j), v[i] + f(i-1,j-w[i]))
#--------------------------------------------------------------
#---Call the recursive function

with lower-left indices of the implicit matrix.
    return(f(len(w)-1,C))

# The call: print('Maximum value =', knapsackRR(w,v,C)
#--------------------------------------------------------------

```

(`knapsackR`和`knapsackRR`)哪种形式更好？我更喜欢`knapsackRR`，因为`knapsackRR(w,v,C)`比`knapsackR(len(w)-1, C, w, v))`更简单。

接下来，我们寻求返回最优的权重集以放入背包，而不仅仅是最大值。我们通过回溯来做到这一点。先做迭代函数。你需要一些关于如何做这件事的提示吗？也许不是，因为是没有提示的解决方法建立了我们的技能。如果你想要的话，提示在下一段。

从矩阵右下角的底部开始:`M[maxRow-1][maxCol-1]`。如果这个数字大于它正上方的数字，那么我们在我们的答案(特定权重列表)中包括`w[i]`，并向上移动一行`i = i-1`，并向左移动一段距离`w[i]` ( `j` = `j - w[i]`，并重复。如果该数字不大于它上面的数字，那么我们只是向上移动，并且不将`w[i]`包括在我们的最佳权重集合中。就这么简单。下面是我的代码，它只是`knapsackI`函数的一些附加代码:

```py
def knapsackII(w,v,C): # Iterative: returns both max value and list of weights.
#---Special case:
    if w == []:
        return (0, [])

#---Append zero weights and values, then when the "empty" matrix

is created, the top row and left column are correct as zeros.
    w = [0]+w
    v = [0]+v

#---Set matrix size.
    rowMax = len(w)
    colMax = C + 1

#---Create empty matrix with top row and left col correct as zeros.
    M = [[0 for j in range(colMax)] # j = col index.
            for i in range(rowMax)] # i = row index.

#---Fill the matrix with values from the bottom-up.
    for i in range(rowMax):
        for j in range(colMax):
            if w[i] > j:
                M[i][j] = M[i-1][j]
            else:
                M[i][j] = max(  M[i-1][j],  v[i]+M[i-1][j-w[i]]  )
    maxValue = M[rowMax-1][colMax-1]

#---Backtrack through matrix to find weights to give the maxValue. Without the w[0] = 0 (and v[0] = 0), this code
#   would ignore the first weight. Thefinal value if i-1
#   in M[i-1][j] would refer to the last row of M,
#   instead of the first row.

    i = rowMax-1
    j = colMax-1                      # i,j is the lower-right corner of M.
    bestWeights = w[1:]               # Ignore the 0th weight element.
    wPtr = len(bestWeights)-1         # wPtr is a pointer to the weight
                                      # currently under consideration

.

   for n in range(len(bestWeights)):
        if M[i-1][j] < M[i][j]:
           j -= bestWeights[wPtr]     # Keep this weight.
        else:
           bestWeights.pop(wPtr)      # Remove a weight from bestWeights list.
        wPtr -= 1
        i    -= 1
    return maxValue, bestWeights
#--------------------------------------------------------------

```

只要再写一个函数，我们就完成了 0-1 背包问题。这是一个带记忆的递归函数。我们希望在不构建矩阵的情况下找到权重的最优集合和最大值。因为回溯和矩阵完全一样，这应该很容易，对吗？我做了一个假设，把这个任务变成了一场噩梦。我很快编写了一个函数，它在前面的所有测试案例中都运行良好，但是如果有一个物品的重量大于空背包的容量，它就会失败。

```py
w = [0,  1,  5, 3,  8]   # weights with index i.
v = [0, 15, 10, 9, 50]   # values  with index i, not j.
C = 8                    # Answer: max val = 50; weights = [8]

```

我的递归函数一直声称要么有一个超出范围的列表索引错误，要么之前计算的值的字典没有保存必要的值。解决方案是在递归开始之前将矩阵的顶行和左列放入记忆字典。这是编程(调试)算法如此困难的另一个例子。编码者没有意识到必须在代码中反映的微妙关系。以下是更正后的代码:

```py
def knapsackRR(w,v,C): # Recursive: returns both max value and list of weights.
                       # Uses a dictionary (dict) for memoization.

#---This function recursively finds the max value while building a dictionary.
    def f(i,j, dict): # <-- Helper function
        if i == 0 or j == 0:
           return 0 # Base cases
        if w[i] > j:
            if (i,j) not in dict:
               dict[i,j] = f(i-1,j, dict)
            return dict[i,j]

        if (i-1,j) not in dict:
           dict[i-1,j] = f(i-1,j, dict)
        a = dict[i-1,j]

        if (i-1,j-w[i]) not in dict:
           dict[i-1,j-w[i]] = f(i-1,j-w[i], dict)
        b = v[i] + dict[i-1,j-w[i]]

        dict[i,j] = max(a,b)
        return dict[i,j]
#    ----------------<End of helper function>------------------

#---Special case:
    if w == []:
        return (0, [])

#---Having w[0] = 0 and v[0] = 0 simplifies the code.
    if w[0] != 0 or v[0] != 0:
        w = [0] + w
        v = [0] + v

#---Make (i,j) the lower right-hand corner of table.
    i = len(w)-1
    j = C

#---Set up dictionary base cases (top row and left column).
    dict = {}
    for ii in range(i+1):
        dict[(ii,0)] = 0 # <-- Necessary (Omitting this was my 3-day mistake.)
    for jj in range(j+1):
        dict[(0,jj)] = 0 # <-- Necessary (Omitting this was my 3-day mistake.)

#---Find max value.
    maxValue = f(i,j, dict)

#---Backtrack through dictionary to find best weights.
    bestWeights = w[1:]                 # Ignore the 0th weight.
    wPtr = len(bestWeights)-1           # = weight pointer
    for n in range(len(bestWeights)):
        if (dict[(i-1, j)] < dict[(i,j)]):
           j -= bestWeights[wPtr]
        else:
           bestWeights.pop(wPtr)   # Remove a weight from bestWeights.
        wPtr -= 1
        i    -= 1
    return maxValue, bestWeights
#--------------------------------------------------------------

```

在工业界，测试有时是在要测试的功能之前编写的。在某种程度上，我做到了。我有一个简单的数据集，答案显而易见:

```py
w = [0,  1,  5, 3, 4]     #
v = [0, 15, 10, 9, 5]     #
C = 8                     # Answer: max val = 29; weights = [4, 3, 1]

```

但这还不足以成为一项测试。背包函数需要测试一千次:

```py
def runKnapsackTests(runs = 10):
    print('Wait. Now running tests.')
    from random import randint, random
    for n in range(runs):
        if n % 100 == 0: print('.', end = '') # crude animation for time.
        arrayLength = randint( 0, 30)
        sm          = randint( 1, 20)   # sm = smallest possible value in array.
        lg          = randint(20, 40)   # lg = largest  possible value in array.
        w           = list({randint(sm,lg) for j in range(arrayLength)})
        C           = int(random() * sum(w))
        v           = [randint(1,40) for j in range(len(w))]
        ans1 = knapsackII(w,v,C)
        ans2 = knapsackRR(w,v,C)
        if ans1 != ans2:
           print('\n==FAILED!: w =', w, 'v =', v, 'C =', C )
           print('Iterative results =', ans1)
           print('Recursive results =', ans2)
           return
    print('\nPassed', runs, 'tests.')
#--------------------------------------------------------------

```

有了复杂的算法，你永远不能相信自己的想法。必须运行数千个随机测试才能宣称代码已经完成。

请注意这个粗糙的动画，它告诉用户所取得的进展。我们可以在使用 Windows 的 Python 程序结束时发出警报。

```py
def noise():
    import winsound
    winsound.Beep(1500,500) # Frequency, milliseconds
    winsound.MessageBeep()
    soundfile =  'c:/windows/media/chimes.wav'
    soundfile =  'c:/windows/media/tada.wav'
    soundfile =  'c:/windows/media/Alarm10.wav' # 01 to 10
    soundfile =  'c:/windows/media/Ring01.wav'  # 01 to 10
    winsound.PlaySound(soundfile, winsound.SND_FILENAME)

```

递归形式比迭代形式节省了多少空间？非常少:矩阵越大，字典就需要越大。迭代形式比递归形式快一点，即使递归代码被调整了。

背包问题是一个很好记忆的问题，因为它的解决方案是典型的动态规划策略。天才理查德·贝尔曼发现这些问题有多容易？我们知道:

*   这些问题虽然出现在许多不同的领域，但有一个共同的特点——它们极其困难。——理查德·贝尔曼，动态编程(多佛，2003)，转载自 1957 年版，第八页。

然而，我们受益于个人电脑、更快的电脑、互联网、更方便的操作系统、语法简单的语言、强大的内置指令和有用的数据类型等。

问题三。矩阵括号计数。

假设我们有几个矩阵要按固定顺序相乘，例如`A×B×C×D×E×F`。有许多不同的方法(实际上有 42 种)插入括号来得到我们的答案——例如，`((((A×B)×C)×D)×E)×F`和`(A×((B×C)×(D×E)))×F`。这是我们的问题:

给定 n 个按固定顺序相乘的矩阵，有多少种方法给矩阵加上括号？

前四个数字很简单

```py
A           ‡ f(1) = 1
A×B         ‡ f(2) = 1
A×B×C       ‡ f(3) = 2
A×B×C×D     ‡ f(4) = 5
A×B×C×D×E   ‡ f(5) = ?
A×B×C×D×E×F ‡ f(6) = ? etc.

```

我们可以通过用所有可能的方法将它分成两组来解决这个问题，从而减少先前解决的案例的维度。如果有 4 个矩阵(`A×B×C×D`)，那么我们只需要考虑`A×(B×C×D)`、`(A×B)×(C×D)`和`(A×B×C)×D`。在这里，`A×(B×C)×D`这个词并没有被忽略。它是通过在`(A×B×C)×D`中将`(A×B×C)`拆分成所有可能的对而得到的。换句话说，

```py
f(4) = f(1)*f(3) + f(2)*f(2) + f(3)*f(1) = 1*2 + 1*1 + 2*1 = 5.

```

现在，在你的头脑中，不用笔和纸，确定有多少种方法可以插入`f(5)`的括号。答案如下。

数学上我们可以这样陈述我们的成对观察:

![$$ f(n)=\Big\{{\displaystyle \begin{array}{l}1,\mathrm{if}\ n=1\ \mathrm{or}\ \mathrm{else}\\ {}\sum \limits_{k=1}^{n-1}f(k)f\left(n-k\right)\end{array}} $$](A461100_1_En_21_Chapter_Equb.gif)

![$$ {\displaystyle \begin{array}{l}f(1)=1\\ {}f(2)=f(1)\times f(1)=1\times 1=1\\ {}f(3)=f(1)\times f(1)+f(2)\times f(1)=1\times 1+1\times 1=2\\ {}f(4)=f(1)\times f(3)+f(2)\times f(2)+f(3)\times f(1)=1\times 2+1\times 1+2\times 1=5\\ {}f(5)=f(1)\times f(4)+f(2)\times f(3)+f(3)\times f(2)+f(4)\times f(1)=14\\ {}f(6)=f(1)\times f(5)+f(2)\times f(4)+f(3)\times f(3)+f(4)\times f(2)+f(5)\times f(1)=42\end{array}} $$](A461100_1_En_21_Chapter_Equba.gif)

我们的递归函数方程 f (n)是前面单元格的乘积之和。没有涉及最大值或最小值，但它仍然被认为是动态规划，就像斐波纳契函数和吉普问题。你的工作是写一个递归函数(无记忆)来返回这个数字。我的代码如下:

```py
def f(n): # recursive only
#---base case
    if n == 1:
       return 1

#---recursive cases (n >= 2).
    total = 0
    for k in range(1, n):
        total += f(k)*f(n-k)
    return total
#--------------------------------------------------------------

```

顺便说一下，得到的数字称为加泰罗尼亚数字:1，1，2，5，14，42，132，429，1430，4862，16796，58786，208012，742900，2674440，9694845，35357670，129644790，477638700，1767263190，673190 第一个数字的索引是 1，而不是 0，例如，f (1) = 1，f (2) = 1，f (3) = 2，f (4) = 5，等等。第零个加泰罗尼亚数为零:f (0) = 0。

我的代码是 form b。我们需要动态编程的记忆，使这成为一个更快的函数。用迭代和递归的方式重写它。我的代码如下。

```py
def f(n, ff = [0, 1]): # recursive with memoization
#---base case
    if n == 1:
       return 1

#---recursive cases (n >= 2).
    total = 0
    for k in range(1, n):
        if n-k >= len(ff):
            ff.append(f(n-k))
        total += ff[k]*ff[n-k]
    return total
#--------------------------------------------------------------

def f(n): # iterative
    ff = [0, 1]
    for i in range(2, n+1):
        total = 0
        for k in range(1, i):
           total += ff[k]*ff[i-k]
        ff.append(total)
    return ff[n]
#-------------------------------------------------------------

```

问题 4。矩阵圆括号。我们现在来看动态编程中的一个著名问题。你可能还记得矩阵乘法是不可交换的——也就是说，`A×B`通常与`B×A`不同。但是矩阵乘法是结合律——例如`A×(B×C)` = `(A×B)×C`。如果你用一个 4×3 的矩阵(`A`)乘以一个 3×2 的矩阵(`B`)，你最终要做 24 次(= 4×3×2)乘法才能得到`A×B`。如果你把这个结果乘以一个 2 乘 5 的矩阵`C`，你最终会做 64 次(= 4×3×2 + 4×2×5)乘法来得到`(A×B)×C`。如果我们把这三个矩阵按不同的顺序相乘:`A×(B×C)`，那么我们需要做 90 次(= 3×2×5 + 4×3×5)的乘法。一阶更好。这是我们的问题:

将一组要按固定顺序相乘的矩阵用括号括起来，以尽量减少乘法次数。

有必要检查每对要相乘的矩阵是否相容，即左矩阵的列数等于右矩阵的行数。否则，我们就是在编码废话。

对于 20 个矩阵，使用蛮力，我们将不得不考虑大约 17 亿种情况。如果我们使用记忆化，那么许多子案例重叠，不需要重新计算，只需回忆。请注意，我们没有被要求在代码中乘以任何矩阵。

如果你不知道如何将递归应用于一个特定的问题，有一个心理学技巧可能会有所帮助。开始写出一个又一个基本案例。(这就是我对这个问题的看法。)当我解决三个矩阵的情况时，我突然发现这种情况可以简化为两个各有两个矩阵的情况。在那一点上，我看到了所有大型矩阵集合的递归模式。

选择符号花了一些时间。以下是我的一个输入与输出。矩阵`A`为 4×3；矩阵`B`为 3×2，矩阵`C`为 2×5，矩阵`D`为 5×10，矩阵`E`为 10×4。0 用于表示获得特定矩阵所需的乘法次数。对于`ABC`，这个数字在`(AB)C`的最佳形式下是 64。

```py
    initialMatrixList = [(0, 'A', 4, 3), (0, 'B', 3,  2),
                         (0, 'C', 2, 5), (0, 'D', 5, 10), (0, 'E', 10, 4)]

#   Output: expr = (AB)((CD)E) value = 236 # optimum placement of parentheses

```

然后我的字典(关联`initialMatrixList`)就变成了这个样子(手动排序):

```py
  dictionary (dict)
num    key     value
 1\.     A: (0,   'A',             4,  3)
 2\.     B: (0,   'B',             3,  2)
 3\.     C: (0,   'C',             2,  5)
 4\.     D: (0,   'D',             5, 10)
 5\.     E: (0,   'E',             10, 4)
 6\.    AB: (24,  '(AB)',          4,  2)
 7\.    BC: (30,  '(BC)',          3,  5)
 8\.    CD: (100, '(CD)',          2, 10)
 9\.    DE: (200, '(DE)',          5,  4)
10\.   ABC: (64,  '((AB)C)',       4,  5)
11\.   BCD: (160, '(B(CD))',       3, 10)
12\.   CDE: (180, '((CD)E)',       2,  4)
13\.  ABCD: (204, '((AB)(CD))',    4, 10)
14\.  BCDE: (204, '(B((CD)E))',    3,  4)
15\. ABCDE: (236, '((AB)((CD)E))', 4,  4)

```

对于密钥`ABCD`，最小乘法次数为 204，但只有四个矩阵像这样`(AB)(CD)`相乘时。我的代码如下:

```py
def f(M): # Recursive chain matrix multiplication

with NO MEMOIZATION
#    Example:
#    M = [(0, 'A',4,3), (0, 'B',3,2,),  (0, 'C',2,5,), (0, 'D',5,3,)]
#         (0 = value (multiplications), 'A' = expression, 4 = rows, 3 = cols)
#    answer = 'expr = (AB)(CD) value = 78'

    n = len(M)      # = 4 in the example above.
    if n == 1:      # A trivial, but necessary, base case.
        return M[0] # M[0] = (0, 'A',4,3) in the example above.

    if n == 2:  # This base case combines two previously computed expressions.
                # Almost all of the function's work is done here, because the
                # magic line (for n > 2) repeatedly calls this base case.
       value = M[0][0]+M[1][0]+M[0][2]*M[0][3]*M[1][3]
       key = '(' + M[0][1] + M[1][1] + ')' # Insert parentheses = (AB) in ex. above.
       rows = M[0][2]
       col  = M[1][3]
       return (value, key, rows, col)

    if n > 2:  # Recursive case.
        best = []
        for k in range(1,n):
             best.append(  f([ f(M[:k]), f(M[k:]) ])  ) # The magic line.
    return min(best) # min evaluates on the first component

of each tuple.
#--------------------------------------------------------------

```

如果您没有自己解决这个问题，并且不能理解我的代码，那么您可能需要复制我的代码，用 print 语句加载它，然后运行它来理解它是如何工作的。我需要用我在网上或书中找到的代码做很多次。

```py
def f(M, dict = {}): # Recursive chain matrix multiplication with memoization.
    n = len(M)
    if n == 1:
        return M[0]
    if n == 2:
       key = '('+ M[0][1]+'x'+M[1][1]+')'
       if key not in dict:
           result = M[0][0]+M[1][0]+M[0][2]*M[0][3]*M[1][3], \
                   '('+M[0][1]+'x'+M[1][1]+')',   M[0][2],   M[1][3],
           dict[key] = result
       return (dict[key])
    if n > 2:
        best = []

        for k in range(1,n):
             best.append(  f([ f(M[:k], dict), f(M[k:], dict) ], dict) )
    return min(best)
#--------------------------------------------------------------

```

接下来是迭代函数，它使用相同的符号。你可能没有足够的时间来尝试这个问题。在你提交之前，先看看我的代码有多长。祝你好运。

```py
def f(matrices): # Iterative using memoization
#---Check data format.
    for m in matrices:
        assert len(m) == 4 #  example: m = (0, 'A', 4, 3)
        assert m[0]   == 0
        assert 65 <= ord(m[1]) <= 90
        assert type(m[2]) == type(m[3]) == int
    for n in range(len(matrices)-1):
        assert matrices[n][3] == matrices[n+1][2]

#---Calculate the number of matrices
    limit = len(matrices)

#   HELPER FUNCTION
    def insertInDict (A,B,dict):
       # Example: if A = (0, 'A', 4, 3) and B = (0, 'B', 3, 2), then
       # key = 'AB' and result = (24, '(AB)', 4, 2)
       key        = A[1]+B[1]
       value      = A[0]+B[0]+A[2]*A[3]*B[3]
       expression = '('+A[1]+B[1]+')'
       result     = value, expression, A[2], B[3]
       dict[key]  = result

#   HELPER FUNCTION

    def dictKey(Lst):
        # Example: Lst =[(0, 'B', 3, 2), (0, 'C', 2, 5)] returns key = 'BC'.
        key = ''
        for x in Lst:
            key += ''.join(x[1])
        return key

#   HELPER FUNCTION
    def mult (key1, key2, dict):
        # This function multiplies two matrix expressions (denoted by their
        # keys) and puts the result in the dictionary with a new key.
        newKey = key1 + key2
        A = dict[key1]
        B = dict[key2]
        value  = A[0]+B[0]+A[2]*A[3]*B[3]
        expression = '('+A[1]+B[1]+')'
        # Below, we tack on the newKey with the result and return both.
        result = value, expression, A[2], B[3], newKey
        return result

#---Create empty dictionary.
    dict = {}

#---Insert singles into dictionary--e.g., (0, 'A', 4, 3) with a key of 'A'
    for n in range(0,limit):
           key = matrices[n][1]
           dict[key] = matrices[n]

#---insert the rest (doubles, triples, quads, etc.) into dictionary.
#   This is a complicated function/algorithm with FOUR loops.
    for i in range(2,limit+1):       # i = len(Lst)
        for j in range(0,limit-i+1): # Lst below starts at position j.
               Lst = [matrices[j+n] for n in range(0, i)]
#              Example: Lst = [(0, 'A', 4, 3), (0, 'B', 3, 2), (0, 'C', 2, 5)] 

               candidates = []
             # Strategy: Split any Lst into two consecutive parts. (This can be
             #           done several ways.) Then multiply the two parts and
             #           place the result in the candidates list. Then only the
             #           candidate with the least value goes into the dictionary

               for k in range(1,len(Lst)):
                   key1 = dictKey(Lst[:k]) # = left  part of Lst.
                   key2 = dictKey(Lst[k:]) # = right part of Lst.
                   candidates.append(mult(key1, key2, dict))
               best = min(candidates)
               dict[best[4]] = best[:-1] # The key is at the end (index 4).
    printDictionary(dict)

#---Return dictionary value

with key equal to all matrix letters.
    finalKey = ''
    for tuple in matrices:
        finalKey += tuple[1]
    return dict[finalKey]
#--------------------------------------------------------------

```

也许读者可以改进，或者至少在不到 10 天的时间内完成。我能在五天内写完这个程序吗？也许，如果我被一个期限所激励的话。我能把这个问题分配给我的高中生吗？我总有几个学生比我编码快得多。只有那几个学生能解决这个问题。

我可以把作业分成小部分，然后让学生把这些部分组合起来解决大问题。偶尔我会这样做，但是这种教学策略有两个缺点。

首先，老师在给学生做作业。他们只是在解决简单的部分。尽管如此，他们还是看到了大局。第二个事实是，当把完成的部分放在一起时，一些学生甚至还没有完成第一部分。这通常不是因为缺乏智力。一些学生有严重的拖延症，任何小的分心都会使他们失去联系。衰老有时会解决这个问题。

为了在高级编程课程或数学优等生课程中提供足够的指导，我一直认为有必要向接近顶端的位置而不是中间的位置教学，并调整分数，以便 a 比其他任何分数都多，并且很少有学生(如果有的话)得到 D 或 f。这当然是分数膨胀，它有其不利的一面。这也让我不再给优等生布置没有挑战性的作业。这是最好的教学方式吗？对我在教高级班的学生来说，是的；对其他老师和其他学生来说，肯定不是，而且有充分的理由。这个世界既需要容易的老师，也需要难的老师。即使是同一所学校教的同一门课，既需要轻松的老师，也需要辛苦的老师。一种尺寸不适合所有人。

总之，我希望读者在这些文章中发现了一些有价值的东西，如果没有超过哲学的话，那就是我们必须做我们的主题，以充分和自信地教授它。(G.B .哈里森是对的。)祝你以后编程好运。

Footnotes [1](#Fn1_source)

1979 年，理查德·贝尔曼因其在动态编程方面的工作获得了 IEEE 荣誉奖章(电气工程的最高奖项)。1985 年，为了表彰他的贡献，设立了数学生物科学的贝尔曼奖。

  [2](#Fn2_source)

我发现最早使用“动态编程”这个术语的是理查德·贝尔曼，“论动态编程理论”，美国国家科学院院刊，38 (8)，716–719(1952)，可以在网上找到。在这里，他说，“由于 Wald [Wald 的统计决策函数，John Wiley & Sons，1950]，动态规划的理论与序列分析的理论(1947)密切相关。]“亚伯拉罕·瓦尔德于 1950 年死于一次飞机失事，享年 48 岁。在这篇论文中，贝尔曼引用了其他几篇关于决策过程的技术论文，如 Arrow，K.J .，Blackwell，d .，Girshick，M.A .，“序列决策问题的贝叶斯和极大极小解”，计量经济学，17，214–244(1949)。

在 DVD《贝尔曼方程式》(米沙媒体，2013 年)中，贝尔曼的一个妻子说，贝尔曼告诉她，当时动态编程正在兴起。如果他没有发现它(实际上正式化了这个方法，给它命名，并写了一本书阐述它的用途)，那么别人会发现的。Bellman 在 RAND 的同事 Harold J. Kushner 曾经在一次演讲中说:“Bellman 并没有完全发明动态编程，许多其他人对它的早期发展做出了贡献。但没有人像贝尔曼那样抓住它的本质，分离出它的基本特征，并展示出它在控制和运筹学以及在生物和社会科学应用中的全部潜力。”

  [3](#Fn3_source)

Fortran 在许多程序中取代了汇编语言，从而使这些程序的规模平均缩小了 20 倍。参见维基百科，s.v. Fortran。1957 年几乎没有计算机，部分原因是它们太贵了，而且现存的计算机计算能力很弱。处理速度和内存大小都极其有限。计算机内存正从水银管转换成铁芯。操作系统和编辑器都很粗糙。这些机器是用汇编语言编程的。第一台商用计算机(带有 5000 个真空管的 UVIVAC I)直到 1952 年才发货，定价为 159，000 美元。最终价格涨到了 150 万美元。作为对比，我记得我母亲在 50 年代末抱怨说，她很难用每周 20 美元为一个四口之家购买食品杂货。贝尔曼在兰德公司工作，他们的计算机是 JOHNNIAC，由他们的工程师用空军的资金手工制造，于 1953 年首次投入使用。(机器)故障之间的平均空闲时间为 500 秒。在这样一台机器上运行一个复杂的程序是多么困难，这是很难表达的。在互联网上搜索弗雷德·约瑟夫·格伦伯格(1968)的 20 页《琼尼亚克的历史》。

  [4](#Fn4_source)

1973 年，贝尔曼患上了脑瘤，切除后他严重残疾。然而，他继续以很高的速度出版作品，直到 1984 年 63 岁去世。

"哈尔·沙佩里奥问我[贝尔曼]，你认为你会成为比 Erdős 更好的数学家吗？"“好多了，”我说。四双怀疑的眼睛立刻盯着我。我解释道。“Erdős 很有天赋，甚至可以说是天才，但他没有判断力。他解决的问题与他的能力不匹配。”我怀疑当时那些听众是否明白了我的意思。我想他们现在明白了。——理查德·贝尔曼，《飓风之眼》(世界科学，1984)，第 109 页。

这句话是在 1946 年前后说的。贝尔曼(博士预科)26 岁，匈牙利人保罗·erdős 35 岁。Erdős 后来成为世界上最多产、最受尊敬和钦佩的数学家之一。他的领域是解析数论，这是数学中最难的领域之一。贝尔曼最初专攻同一领域，最终放弃了应用数学。在我看来，这两位数学家不能相提并论。世界两者都需要。请注意，贝尔曼 1946 年的评论呼应了这一章的序言。

  [5](#Fn5_source)

根据同样的推理，f (7，3)的概率应该是，事实也确实如此。

  [6](#Fn6_source)

1968 年，英国人工智能先驱唐纳德·米基从词根“memo”中创造了“memoization”一词。

  [7](#Fn7_source)

那些不记得过去的人注定要重蹈覆辙。——乔治·桑塔亚纳，(1905)《常识中的理性》，《理性的一生》第 1 卷第 284 页。

  [8](#Fn8_source)

我在马丁·加德纳找到了答案，我最擅长的数学和逻辑难题(多佛，1994)。加德纳的早期著作(1961 年)给出了解决方案。我见过马丁·加德纳两次，发现他是一个非常热情和谦虚的人。加德纳于 2010 年去世。直到今天(2017 年)，还有每次都叫做 Gathering4Gardner 的会议。

  [9](#Fn9_source)

技术。注意。任何物理老师都坚持写 f (t) = d，两个字母都包含单位(油箱和英里)。大多数数学老师倾向于保持单位隐式，以更加关注数学结构:f (1) = d。物理老师是正确的。

  [10](#Fn10_source)

术语“非循环”意味着不可能有循环，而“有向”意味着所有链接都是单向的。这里我们用节点和链接(弧)来代替顶点和边，用图来代替网络。任何非循环有向图都可能有其节点被标记，使得任何链接(I，j)[从节点 I 到 j]都将具有 i < j 的性质。为什么？如果图是非循环的，那么至少有一个节点没有输入链接。标记节点 1，并删除该节点的所有传出链路。那么剩余的网络必须至少有一个节点没有输入链路(出于与前面相同的原因)。然后重复。

  [11](#Fn11_source)

参考:R. Bellman 和 S. Dreyfus，应用动态规划(普林斯顿，1962)，229 页，一个路由问题。

  [12](#Fn12_source)

技术。注意。这个特殊的递归函数方程(*)被称为贝尔曼方程，或者更准确地说，这个问题的贝尔曼方程。参见维基百科，s.v .贝尔曼方程。动态编程中的一些问题不需要最大值或最小值，例如，斐波那契函数、吉普问题和问题 3，稍后给出。

  [13](#Fn13_source)

每次通话开始前，我都忘了拆字典。因此，在第一次呼叫之后，`neighbor`总是在`dict`。对于最后的 999，999 次呼叫，从来不需要计算贝尔曼方程。哎呀！

  [14](#Fn14_source)

这个问题的早期参考是理查德·贝尔曼的《动态规划》(普林斯顿，1957)，第 45 页，问题 21。贝尔曼指的是在船上装货，而不是背包。在《动态规划的艺术和理论》(学术出版社，1977 年)的第 117 页，作者(Dreyfus 和 Law)暗示背包问题只是货物装载问题的 0-1 版本。今天，整本书都在讨论货物装载问题及其变体。