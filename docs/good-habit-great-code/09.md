# 9.停止编码

*   当我编码时，我有时会写一些行，希望它们能工作，但并不真正理解它们在做什么。—一名高中生正在上他的第四节编程课(2011 年 12 月)。

当你开始感到困惑的时候，停止编码。当我第一次把旅行推销员问题分配给我的学生时，我附加了以下建议:

*   你程序中的数据将会是一个 xy 坐标列表。让它成为列表的列表，而不是元组。并在第零个位置附加一个`id`-例如，

*   为什么要做列表的列表而不是元组的列表？因为你不知道以后会不会需要修改组件，而且元组是不可变的。为什么要附加一个`id`？因为您不知道以后是否需要为您的`xy`-坐标提供一个属性——例如，已访问和未访问——或者一个属性元组。

```
city = [[id, x-value, y-value], [id, x-value, y-value], ..., [id, x-value, y-value]]

```

我刚来写旅行推销员问题的时候，是用没有`id`的元组工作的。最终我开始失去对程序的控制。这些函数变得如此复杂(三个下标的括号),以至于修改起来很痛苦。是重新开始的时候了。基于我的失败，我知道可变列表和属性会简化程序。为什么当初我没有意识到这一点？因为我太专注于概念上的细节，所以我不能很好地考虑实现。只有当我的编码变得困难时，我才意识到我的设计错误。

如果你的程序开始变得如此复杂以至于你不能理解它，那么你必须重构或者完全重新开始。当你不得不重新开始的时候，好消息是你变得更聪明了，你的一些代码是可以挽救的。

在开始之前，你需要概述整个程序或算法吗？如果程序/算法异常复杂，那么你至少需要一些大纲。你会知道这一点，因为你会立即对这项任务感到不舒服。让我明确地说明这一点:你必须在编码前花时间思考你觉得复杂的项目。对于大多数学校的问题，我通常会同时设计和键入代码。任何人都可以用简单的程序做到这一点，但是有一定的难度，超过这个难度，动态编码就不能很好地工作。你需要找到自己的水平，知道什么时候可以，什么时候不能用快速肮脏的风格逃脱。 [<sup>2</sup>](#Fn2) 这并不容易，因为习惯很难打破，我们的自我卷入其中，我们想要跟上我们的同学。键入不能很好地一起工作的代码行不是编码，除了在名称上。也许我们已经吸取了教训。注意编码的心理学。

在键盘上勾画轮廓的一种方法是只写函数名(里面没有代码的存根，或者返回虚假数据的模拟)。 [<sup>3</sup>](#Fn3)

```
def doIt(x): # <--STUB
    pass

def doIt(x): # <--MOCK
    return 0

```

在计算机编程中有两种相互竞争的设计哲学:做正确的事情，越差越好。“做正确的事情”哲学同样关注软件设计的完整性、一致性、正确性、易用性和简单性。这是构建完美程序的一种尝试。而我们为什么不应该做这种尝试呢？这是专业软件设计师的哲学。为什么有人会说越差越好？原因如下:

1.  完整性是指程序中不被忽略的特殊情况。如果用户对这些特例不感兴趣，为什么要花大价钱编写代码呢？有时候完整是浪费时间。
2.  一致性对于团队来说是有用和必要的，但是对于孤独的程序员来说，半一致性已经足够好了。我们有限的时间可以用在更好的地方。
3.  如果其他人会使用你写的程序，易用性是很重要的。但是学校项目通常只由设计者来执行。除非易用性是任务的目标，否则它可能会妨碍其他目标。
4.  甚至希望程序正确的愿望也可能因为好的理由而被牺牲。我曾经看到过一些代码，为了加快程序速度，把距离公式![$$ \sqrt{x^2+{y}^2} $$](A461100_1_En_9_Chapter_IEq1.gif)换成了![$$ x+y $$](A461100_1_En_9_Chapter_IEq2.gif)。 [<sup> 4 </sup>](#Fn4) 如果我的近似程序运行 10 秒，而你的精确程序运行 3 分钟，你的精确程序会是人们想要使用的程序吗？有时我们会为正确付出过高的代价。

在这一点上做正确的事情的人会想打断。他们会指出我只是从例外中推理。既然每一种哲学都有例外，我的反对就毫无价值。更糟糕的是，这些例外正试图摧毁一种积极的哲学。置换哲学在哪里？很公平。越差越好学校确实有一套替代哲学。这就是:越差越好的哲学主张简单的设计是首要的。它表明，一致性、完整性、易用性、正确性和其他积极的属性更有可能从保持简单的简单设计中演化而来，而不是从追求完美的第一次尝试中演化而来。如果这些特征不是自己出现的，那么我们可以通过修改一个简单可行的程序来插入它们。“做正确的事情”的理念可能适用于花费数月时间设计程序的团队，但这不是一个孤独的程序员应该写程序的方式。

我对这场小辩论的看法是，学校课程完美的目标可能是迂腐的。优秀编程的标准也必须根据资源(主要是时间)和任务背后的动机来衡量。现在举个例子。

编程时间足够长的学生会注意到，他们反复编写调试代码来打印矩阵和其他数据结构。那么为什么不写一个通用的矩阵打印机，放在个人图书馆里呢？我的版本在下面。给它一个整数、浮点、字符串、布尔、`None`都混在一起的矩阵(这是 Python，记住)，代码会整齐地打印出所有垂直对齐的数据。

```
def printMatrix(Lst, decimalAccuracy = 2):
    print('---MATRIX:')
    if type (Lst) != list or type (Lst[0]) != list:
        print('*' * 45)
        print(' WARNING: The received parameter is NOT a \n',
               'matrix type. No printing was done.        ')
        print('*' * 45)
        return
    maxLength = 0
    for row in Lst:
        for x in row:
            if type(x) == float: x = round(x, decimalAccuracy)
            maxLength = max(len(str(x)), maxLength)
            if type(x) == float:
                 print('%11.2f'%x,      end='')
            elif type(x) == int:
                 print('%8d   '%x,      end='')
            elif type(x) == str:
                 print('%8s   '%x,      end='')
            elif type(x) == bool:
                 print('%8s   '%str(x), end='')
            elif x == None:
                 print('%8s   '%str(x), end='')
            else:
                 print(x, ' ')
        print()
    print('==============================')
    print('cell maxlength =', maxLength, '(8 is limit)')

```

大问题:曾经需要一个通用打印机(这个代码)吗？我打印过的唯一矩阵包含浮点数和整数。现在我似乎被这个小项目的酷冲昏了头脑:一台通用矩阵打印机。它被过度设计了。我违反了 YAGNI 原则(如果你不需要，就不要写代码)。在这里，越差肯定越好。

顺便说一下，这里有一个 Python 技巧来漂亮地打印一个列表:

```
    Lst = ['A', 2, [1,2,3], 4000, 0.123]
    print('', *Lst, sep='\n....')
"""
Output:
....A
....2
....[1, 2, 3]
....4000
....0.123
"""

```

下面的建议实际上包含了一些智慧:没有计划就是计划失败。三思而后行，编码一次。匆忙编码，永远调试。 [<sup>5</sup>](#Fn5) 记住一周的调试可以节省整整一个小时的规划。

Footnotes [1](#Fn1_source)

2003 年，在 ARML 举行的 H.S .数学竞赛中，我们学校的数学队队长在决赛前给队友们打了打气。他说他在实践中注意到他的许多队友忽略了他们有能力解决的问题。为什么呢？他们没有足够仔细地阅读问题，以发现给定信息中的微妙关系。他的建议是“在开始解决问题之前仔细阅读每个问题。”那年我们学校赢得了 ARML 奖。

  [2](#Fn2_source)

在互联网上搜索 BDUF(前期大设计)、RDUF(前期粗略设计)和“紧急设计”在没有编写过相同程序的原型(缩小版)的情况下，设计一个复杂的程序会有很大的问题。

  [3](#Fn3_source)

存根和模拟的定义各不相同。更安全的说法是使用“假货”

  [4](#Fn4_source)

错误会有多严重？设![$$ z=x+y $$](A461100_1_En_9_Chapter_IEq3.gif)，其中 x 和 y 均为非负，![$$ w=\sqrt{x^2+{y}^2} $$](A461100_1_En_9_Chapter_IEq4.gif) <sub>。那么最大的![$ \raisebox{1ex}{$z$}\!\left/ \!\raisebox{-1ex}{$w$}\right. $](A461100_1_En_9_Chapter_IEq5.gif)会变成什么样？答案是![$ \sqrt{2} $](A461100_1_En_9_Chapter_IEq6.gif)。</sub>

  [5](#Fn5_source)

罗伯特 l .克鲁斯，数据结构与程序设计，第二版。(普伦蒂斯-霍尔，1987)，第 55 页。