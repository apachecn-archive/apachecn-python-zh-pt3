# 十一、防御性编程

*   到 1949 年 6 月，人们开始意识到，要把一个程序做好并不像以前那样容易。我清楚地记得当我试图运行我的第一个重要程序时(用汇编代码或者机器语言)。我强烈地意识到，我余生的大部分时间都将用来寻找我自己程序中的错误。图灵显然也意识到了这一点，因为他在会议上发表了关于“检查大型例程”的讲话。—莫里斯·威尔克斯(图灵奖获得者，1967)，《计算机先驱回忆录》(麻省理工学院，1985)，页 145。

使用防御性编程。因为我们预先知道会有 bug，所以我们可以在几个方面变得积极主动。我们可以编写函数

1.  在参数到达函数后打印传递的参数(跟踪)，
2.  打印中间计算值，以及
3.  打印错误消息以捕捉坏数据(错误的类型、错误的大小、错误的顺序、被零除和越界错误)。这被称为错误处理和崩溃报告。在这里,`try/except`构造有时很有用。

所有这些都被称为防御性编程或脚手架，因为其中大部分最终都会被移除。

这里有一个来自工业界的技巧:有一个全局常数叫做，比如说，`errorCheck`或者`debug`。在每个错误代码块(断言、跟踪、打印输出、`try/except`、类型检查等)之前。)是

```py
if errorCheck:...

```

然后我们不清除错误代码；我们只要用`errorCheck = False`关掉它。在工业中，他们有时会将`errorCheck`设置为`0`(关闭所有检查)、`1 =`开启部分检查、`2` =开启更多检查等。

我最近写了几行代码来捕捉一个越界的变量。我按照习惯行事，甚至对自己说，“好吧，这是浪费时间。这个变量永远不会越界”，但在下一次运行时却发现这个变量越界了。诸如此类的重复经历让我成为谨慎编程的信徒。 [<sup>1</sup>](#Fn1)

防御性编程有一个危险:它可能会隐藏错误。考虑以下代码:

```py
def drawLine(m, b, image, start = 0, stop = WIDTH):
    step = 1
    start = int(start)
    stop =  int(stop)
    if stop-start < 0:
       step = -1
       print('WARNING: drawLine parameters were reversed.')
    for x in range(start, stop, step):
        index = int(m*x + b) * WIDTH + x
        if 0 <= index < len(image):
           image[index] = 255 # Poke in a white (= 255) pixel.

```

该功能从`start`运行到`stop`。如果`stop`小于`start`，它就后退一步，没有错误报告。也许我们希望这种错误在运行过程中被“修复”——隐藏起来——但是我认为我们至少应该打印一个警告，说明范围正在向后移动。也许我们应该中止这个项目。

给定矩阵 A，我们按照(i = row，j = col)约定引用单个元素(a <sub>ij</sub> )。类似地，当我们阅读一页文本时，我们首先固定在一行上，然后沿着一列阅读。不幸的是，存在竞争约定:在 xy 平面中，我们通过(x =col，y = row)绘制点，并且我们还使用(col，row)在计算机屏幕上绘制点，但是从左上角开始我们的“第一象限”,而不是左下角。因此，我们倾向于有时使用矩阵(行，列)方案，有时使用点绘图(列，行)方案。这是一个交叉的例子。我从(`r = row, c = col`)开始绘制矩阵，然后切换到(`x = col, y = row`)进行绘制。

```py
for r in range(8):
    for c in range(8):
        if M[r][c] == 1:
           x = c*70 + 85    
           y = r*70 + 105
           canvas.create_oval(x-25,y-25, x+25, y+25, fill = 'BLACK')

```

没有问题，因为代码很清楚。我展示这个只是为了说明竞争约定有时会出现在相同的代码块中。

在下一个例子中，我在对同一个函数的两次不同调用中交换了 x 和 y，但是 Python 代码仍然返回相同的正确答案。这怎么可能？答:我在传递索引(关键词)之前，先给它们起了名字。寓意:了解你的语言。

```py
def sub(x, y):
    return x-y
#-----------------------------
def main():
    print(add(x = 2, y = 1)) # Output: 1
    print(add(y = 1, x = 2)) # Output: 1

```

一位 YouTube 评论员建议永远不要使用`x`和`y`作为矩阵坐标，而是使用`row`和`col`。为什么呢？因为为应该是`(y,x),`的东西写`(x,y)`太容易了，而`(row, col)`不太可能互换。

Footnotes [1](#Fn1_source)

在一个函数中放置太多的错误陷阱会掩盖函数应该做的事情。在这种情况下，有时，陷阱应该移动到它们自己的功能中。