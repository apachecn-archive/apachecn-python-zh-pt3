# 十一、工作表：CSV 框架

当然，编程最重要的是程序。如果工具、技术、哲学和建议从来没有被应用于解决现实世界的问题，那么它们根本没有什么价值。有时那个问题非常具体，但其他时候它仅仅是一个更普遍问题的具体例子。这些一般性问题通常是库和框架的主题，它们可以为更具体的应用提供基础。

这使得框架处于一个有趣的位置，因为它们更关注于服务开发者的需求，而不是普通用户。目标是提供一个基础和一套工具来帮助其他人开发更具体的应用。支持更广泛的用途需要比通常直接解决问题更先进的技术。

然而，为了对其他开发人员有用，理想的目标是提供一种翻译服务，以便框架使用的高级技术允许其他开发人员使用更简单的技术来执行那些更高级的任务。在这方面，框架设计非常类似于其他形式的设计，但不是主要集中在视觉用户界面上，而是集中在应用的编程接口，即 API 上。

像这样看待框架是很重要的，因为如果你正在写一个框架，你的读者正在寻找一个工具来节省他们的时间和精力，这样他们就可以专注于他们独特的需求。框架应该提供一组特性，鼓励与其他类型的应用集成，因此有必要考虑其他应用应该如何工作。

已经有无数使用框架的例子，服务于各种各样的需求。它们都解决一类通用的问题，比如用于 Web 开发的 Django <sup>[1](#Fn1)</sup> ，用于数据库交互的 SQLAlchemy <sup>[2](#Fn2)</sup> ，以及用于网络协议的 Twisted <sup>[3](#Fn3)</sup> 。每一种都采用不同的方式向开发人员展示接口的风格和形式，突出了框架可以操作的各种方式。

本章将展示一个框架，它使用的声明性语法类似于 Django 和 Elixir 中使用的语法。这种方法的选择在很大程度上是基于风格的，即使有其他方法可以使用，详细研究其中一种方法将突出许多在编写框架时必须做出的决定。您将看到本书中展示的所有技术结合起来形成一个单一的、内聚的整体，公开一个提供许多有用特性的公共 API。

本章要解决的一个特殊问题是需要处理以逗号分隔值的行存储信息的文件，通常称为 CSV 文件。这些方法可用于分隔一行中的值、分隔行本身以及对每行中的单个值进行编码等任务，这就是为什么它会成为一个非常复杂的主题。

Python 已经提供了一个`csv`模块来帮助处理 CSV 文件。 <sup>[4](#Fn4)</sup> 与其试图复制它的功能，不如使用`csv`在幕后完成大部分繁重的工作。相反，我们要做的是在`csv`之上构建一个层，使它更容易与其他应用一起工作和集成。本质上，我们只是在现有 API 的基础上提供了一个新的 API，希望我们能让它更友好一些。

## 构建声明性框架

使用类似于 Django 或 Elixir 的声明性语法构建框架需要几个步骤，但是这个过程本身并不那么困难。然而，在此过程中做出决策是事情变得棘手的地方。在这一章中，我们将概述建立这样一个框架所需的各个步骤，以及你必须做出的许多决定的例子。然而，每一个都必须为你自己的项目特别制作。

但你不会孤军奋战。过程中的每一个决策点都会概述各种选择的利弊，这样你就可以自信地做出明智的选择。从一开始就做出正确的决策将有助于确保您的框架能够经受住未来的升级，以及那些不同意您观点的人的批评。只要确保你的决定背后有有效的、真实的推理，你就会没事。

本章不会只给你留下理论，而是会一步一步地创建一个框架，这个框架简单到足以介绍基本概念，而不必花太多时间在特定于其目的的事情上。它还需要是一个很好的例子，说明什么时候应该使用声明性框架，这首先需要我们理解我们真正在看什么。单词 *step* 对你来说是一个重要的术语，因为后面的例子会被添加进去，为什么它们是脚本。

### 介绍声明式编程

从本质上来说，声明性框架是一个助手，可以使声明性编程变得更容易——或者在某些情况下，成为可能。当然，如果没有定义是什么使它成为声明性的，那么这个定义是没有用的，但是谢天谢地，几乎不需要什么介绍。毕竟，您已经看到了声明式编程的实际应用，并且可能已经使用了很长一段时间，甚至可能没有意识到这一点。

声明式编程是告诉程序你想要什么(声明)，而不是告诉它做什么(指示)。这种区别实际上更多的是关于程序员而不是程序，因为通常没有特殊的语法、解析或处理规则，也没有单一的方法来定义什么合格什么不合格。它通常被定义为命令式编程的对立面，在命令式编程中，程序员被期望概述计算机需要执行的每一个步骤。

考虑到这一点，很容易注意到更高级别的解释型语言，如 Python，比它们的低级同类，如 c，更适合于声明性编程。不必声明一个内存位置，指定它的类型，然后在内存中的那个位置存储一个值，只需分配一个变量，剩下的工作由 Python 完成。下面的代码生成一个名为 foo 的字符串变量，其中存储了“bar ”:

![img/330715_3_En_11_Figa_HTML.jpg](img/330715_3_En_11_Figa_HTML.jpg)

```py
>>> foo = 'bar'

```

这只是声明式编程的一种形式，使用一种语法。然而，当我们谈论 Python 中的声明性框架时，它通常指的是使用类声明来配置框架，而不是一组又长又复杂的配置指令。这是否是满足您需求的正确方法，需要对利弊进行更多的讨论。

### 建还是不建？

在过去的几年中，声明性框架在 Python 世界中已经成为一种上升趋势，但是理解它们并不总是解决给定问题的最佳方法是很重要的。像其他事情一样，决定是否使用声明式框架需要理解它到底是什么，它做什么，以及它对您的需求意味着什么。

声明式框架很好地将许多复杂的行为包装到一个简单的类声明中。这可以节省大量的时间，但是看起来也很像魔术，这是 Python 社区一直在与之斗争的东西。这是好是坏完全取决于您的 API 与用户对类声明的期望有多接近，以及您对那些期望可能失败的领域的文档记录有多好。

通过将类作为将您的意图传达给框架的主要方法，期望实例有意义是合理的。大多数情况下，实例指的是符合类声明定义的格式的一组特定数据。如果您的应用只处理一组定义明确的数据，那么拥有单独的实例就没什么用了。

声明性类旨在使用相同的框架创建许多不同的配置，每个配置都是为特定的数据配置而设计的。如果你只有一种数据格式可以使用——即使你有大量的数据——编写一个为可配置性而构建的框架是没有意义的。只需针对您的数据类型编写一个解决方案并使用它。

在其他情况下，您可能无法提前描述数据集的结构，而是必须根据所提供的数据来调整结构。在这些情况下，提供类声明没有什么价值，因为没有一个声明能够满足您正在处理的数据的需要。

对象的主要价值是通过实例方法对其内容执行操作的能力。因为一个声明性的框架会产生生成单个实例的定制类，所以这些实例应该能够执行有用的任务，如果没有框架的帮助，这些任务会变得更加困难。这不仅增加了它们的有用性，而且有助于确保生成的实例符合用户的期望。

回顾一下，声明性框架是一种很有价值的方法，如果您有:

*   许多可能的配置

*   每个配置都是预先知道的

*   任何给定配置的许多实例

*   可以在给定实例上执行的操作

本章描述的 CSV 框架需要处理大量可能的列和结构配置，每种类型都有许多示例文件。加载和保存数据等操作是常见的，而其他操作则是特定配置所特有的。

一旦完成，该框架将允许应用将 CSV 配置指定为如下类，并使用自动附加到该类的方法与它们进行交互。

为了确保你有合适的库，去[https://pypi.python.org/pypi/Sheets](https://pypi.python.org/pypi/Sheets)/下载 Sheets ZIP 文件。将其解压缩，并将所有文件夹和文件放入 Python 3.x Lib 目录中(或者使用 pip 来安装):

![img/330715_3_En_11_Figb_HTML.jpg](img/330715_3_En_11_Figb_HTML.jpg)

```py
import sheets

class EmployeeSheet(sheets.Row):
    first_name = sheets.StringColumn()
    last_name = sheets.StringColumn()
    hire_date = sheets.DateColumn()
    salary = sheets.FloatColumn()

```

所以让我们开始吧。

## 构建框架

任何声明性框架都有三个主要组件，尽管其中一个可能有不同的形式，或者根本没有:

*   *一个* *基类*:因为声明式框架都是关于声明类的，拥有一个公共基类来继承给了框架一个地方来挂接和处理 Python 遇到的声明。附加到这个基类的元类提供了必要的机制来在运行时检查声明并进行适当的调整。基类还负责表示框架封装的任何结构的实例，通常有各种方法附加到简单的公共过程。

*   *各种字段类型*:在类声明中有许多属性，通常称为字段。对于某些应用，更具体地称呼它们可能更有意义，但是对于本讨论，字段就足够了。这些字段用于管理由框架表示的结构中的单个数据属性，通常有不同的风格，每种风格都适合不同的一般数据类型，如字符串、数字和日期。字段的另一个重要方面是它们必须能够知道它们被实例化的顺序，因此声明中指定的顺序与后面使用的顺序相同。

*   一个 *选项容器*:严格来说，这不是一个必要的组件，大多数框架都使用某种类型的类级选项，这不应该在每个单独的字段上指定，因为那样不会很枯燥。因为子类化除了基类的选择之外不提供任何选项，所以必须使用一些其他的结构来管理这些选项。这些选项的声明和处理方式在不同的框架之间会有很大的不同；没有任何句法或语义标准。为了方便起见，这个容器通常还管理附加到类的字段。

作为一种语法辅助，大多数声明性框架还确保所有这三个组件都可以从一个位置导入。这允许最终用户代码有一个更简单的导入块，同时在一个可识别的名称空间中包含所有必要的组件。这个名称空间的名称应该有意义，以便在最终用户代码中易于阅读。框架本身的名称通常是一个理想的选择，但是描述性很重要，所以在阅读时要确保它是有意义的。

尽管可以在这个过程的后期决定如何命名这个框架，但是在早期就想好一个名字是很有帮助的，哪怕只是命名包含下面几节中描述的模块的包。使用类似于`csv`的占位符目前可以很好地工作，但是因为 Python 有自己的`csv`模块——我们也将依赖于它——重用这个名称会导致很多问题。因为 CSV 文件通常用于在电子表格应用之间交换数据，我们将把我们的小框架称为`sheets`。

看起来我们的旅程应该从基类开始，但是实际上这三个组件中的任何一个都可以是一个合理的起点。这往往取决于哪一块最需要思考，做的工作最多，或者首先需要测试。对于这个讨论，我们将从选项容器开始，因为它的创建不依赖于其他组件的实现细节。这避免了留下太多尚未描述的功能的模糊引用。

### 管理选项

选项组件的主要目的是存储和管理给定类声明的选项。这些选项不特定于任何一个字段，而是应用于整个类，或者用作单个字段可以选择性覆盖的默认值。现在，我们将把如何声明这些选项的问题放在一边，只关注容器本身及其相关需求。

从表面上看，选项只是名称到值的映射，所以我们可以使用一个简单的字典。毕竟，Python 有一个很棒的字典实现，简单肯定比复杂好。然而，编写我们自己的类为我们提供了一些非常方便的额外特性。

首先，我们可以验证为给定类定义的选项。可以根据它们的单个值、它们与其他选项的组合、它们对于给定执行环境的适用性以及它们是否是已知选项来验证它们。使用字典，我们只能简单地允许任何选项有任何类型的值，即使这毫无意义。

选项中的错误只有在依赖它们的代码因为它们不正确或丢失而阻塞时才会被发现，而这种类型的错误通常不是非常具有描述性的。对自定义对象进行验证意味着我们可以向试图使用不正确或无效选项的用户提供更有用的消息。

使用自定义类还意味着我们添加自己的自定义方法来执行任务，这些任务虽然有用，但要么是重复的，要么不属于其他任何地方。验证方法可以验证所有包含的选项是否合适，如果不合适，则显示有用的消息。还要记住，选项容器经常管理字段，因此可以为此添加一些方法；这些将在本节稍后介绍。

事实上，通过结合这两个特性，options 类甚至可以在所提供选项的上下文中验证字段声明。试着用一本普通的字典做那件事。

因为它可能最终封装了相当多的功能，我们将为选项容器设置一个新的模块，明确地命名为`options.py`。像大多数类一样，大部分工作将在`__init__()`方法中完成。出于我们的目的，这将接受所有已知的选项，将它们作为属性存储起来，并设置一些其他的属性，这些属性将在以后被其他方法使用。验证通常只在主动定义选项时有用，所以它属于自己的方法，以免陷入这个方法。

因此，我们来到你的框架中的下一个决定:你应该接受什么选择？不同的框架显然会有不同的需求，在一开始就尽可能完整地将它们布局出来是很重要的。别急，随时可以补充更多；最好是让他们早一点到位，而不是晚一点。

一个有用的经验法则是，选项应该总是有默认值。要求你的用户不仅编写一个类和提供字段，而且每次都提供选项会令人沮丧，特别是如果必需的选项经常具有相同的值。一般来说，如果某些东西确实是必需的，并且没有合理的默认值，那么它应该作为一个参数提供给需要它的方法，而不是定义为类的一个选项。

我们正在构建一个与 CSV 文件接口的框架，因此有许多选项可用。也许最明显的是文件的字符编码，但是当文件以文本模式打开时，Python 已经将文件内容转换为 Unicode。`open()`函数接受一个`encoding`参数，该参数允许字符串的`encode()`方法使用所有相同的编码。它默认为 UTF-8，这应该足以满足大多数常见的需求。

### 注意

读取文件时使用的编码似乎是一个完美的选择，因此您可以覆盖默认的 UTF-8 行为。不幸的是，标准的 CSV 接口要求文件在传入时已经打开，所以如果我们的框架遵循相同的接口，我们无法控制编码。控制它的唯一方法是改变接口来接受一个文件名而不是一个打开的文件对象。

CSV 文件中的一个常见变化是它们是否包含标题行，包含各列的标题。因为我们稍后将在框架中将列定义为字段，所以我们并不真正需要那个标题行，所以我们可以跳过它。但前提是我们知道它在那里。一个简单的布尔值(在更常见的情况下默认为`False`)就能很好地完成这个任务:

![img/330715_3_En_11_Figc_HTML.jpg](img/330715_3_En_11_Figc_HTML.jpg)

```py
class Options:
    """
    A container for options that control how a CSV file should be handled when
    converting it to a set of objects.

    has_header_row
        A Boolean indicating whether the file has a row containing header
        values. If True, that row will be skipped when looking for data.
        Defaults to False.
    """

    def __init__(self, has_header_row=False):
        self.has_header_row = has_header_row

```

这里我们有一个简单但有用的选项容器。在这一点上，它相对于字典的唯一好处是，除了我们指定的选项之外，它会自动禁止任何其他选项。稍后我们会回来添加一个更严格的验证方法。

如果你熟悉 Python 的`csv`模块，你可能已经知道它包含了多种选项，作为对不同方言支持的一部分。因为`sheets`实际上将遵从该模块的大部分功能，所以除了我们自己的选项之外，支持所有相同的选项是有意义的。事实上，为了更好地反映已经在使用的词汇，重命名我们的`Options`类`Dialect`是有意义的。

然而，让我们采取一种更具前瞻性的方法，而不是单独列出所有受`csv`支持的选项。我们依赖于我们控制之外的代码，试图跟上代码在未来可能引入的任何变化有点麻烦。特别是，我们可以支持任何现有的选项以及任何未来的选项，只需将任何额外的选项直接传递给`csv`本身。

为了在不命名选项的情况下接受它们，我们转向 Python 对使用双星号语法的额外关键字参数的支持。这些额外的选项可以作为字典存储起来，稍后将被传递给`csv`函数。接受它们作为一组关键字参数而不是一个字典有助于统一所有的选项，这在我们实际解析类声明之外的选项时非常重要:

![img/330715_3_En_11_Figd_HTML.jpg](img/330715_3_En_11_Figd_HTML.jpg)

```py
class Dialect:
    """
    A container for dialect options that control how a CSV file should be
    handled when converting it to a set of objects.

    has_header_row
        A Boolean indicating whether the file has a row containing header
        values. If True, that row will be skipped when looking for data.
        Defaults to False.

    For a list of additional options that can be passed in, see documentation
    for the dialects and formatting parameters of Python's csv module at
    http://docs.python.org/library/csv.html#dialects-and-formatting-parameters
    """

    def __init__(self, has_header_row=False, **kwargs):
        self.has_header_row = has_header_row
        self.csv_dialect = kwargs

```

这个类以后会增加更多的特性，但这已经足够了。在我们结束之前，我们还会再讨论几次，但是现在，让我们继续讨论这个小框架中最重要的部分:字段。

### 定义字段

字段通常只是特定数据的容器。因为它是一个通用术语，不同的学科可能会用更具体的东西来指代同一个概念。在数据库中，它们被称为列。在表单中，它们通常被称为输入。当执行一个函数或程序时，它们被称为参数。为了保持这个框架之外的一些观点，本章将把所有这样的数据容器称为字段，尽管对于`sheets`本身，术语“列”在命名单个类时更有意义。

首先要定义的是一个基本字段类，它将描述字段的含义。没有任何特定数据类型的任何细节，这个基类管理字段如何与系统的其余部分相适应，它们将有什么 API，以及子类被期望如何行为。因为我们的框架称它们为列，我们将启动一个名为`columns.py`的新模块并开始工作。

字段是 Python 对象，作为类声明的一部分进行实例化，并作为类的属性进行赋值。因此，`__init__()`方法是进入字段功能的第一个入口点，也是唯一可以将字段配置为声明的一部分的地方。`__init__()`的参数可能因字段类型而异，但通常至少有几个参数适用于所有字段，因此可以由基类处理。

首先，每个字段可以有一个标题。这使得代码更具可读性和可理解性，同时也为其他工具自动记录字段提供了一种方法，这些工具不仅记录了字段的属性名称，还记录了更有用的信息。计划验证不会有什么坏处，所以我们还将添加一种方法来指示字段是否是必需的:

![img/330715_3_En_11_Fige_HTML.jpg](img/330715_3_En_11_Fige_HTML.jpg)

```py
class Column:
    """
    An individual column within a CSV file. This serves as a base for attributes
    and methods that are common to all types of columns. Subclasses of Column
    will define behavior for more specific data types.
    """

    def __init__(self, title=None, required=True):
        self.title = title
        self.required = required

```

注意标题是可选的。如果没有提供标题，可以从字段被分配到的属性名称中收集一个简单的标题。不幸的是，这个领域还不知道这个名称是什么，所以我们将不得不在以后回来使用这个功能。我们还假设大多数字段都是必需的，所以这是默认设置，可以基于每个字段被覆盖。

### 小费

必填字段可能看起来对 CSV 框架没有太大价值，因为数据来自文件而不是直接来自用户，但它们可能很有用。对于像`sheets`这样的东西，它最终可以验证传入的文件或者将要保存到传出文件的数据。对于任何框架来说，在一开始就包含这个特性，以支持以后可以添加的特性，通常是一个好的特性。

对于框架的字段，您可能已经有了其他的想法。如果是这样，现在可以按照相同的基本模式随意添加它们。不过，不要担心一开始就计划好一切；以后还有很多机会添加更多。下一步是将字段正确地连接到它们相关的类。

### 将字段附加到类

我们需要设置钩子来从字段被分配到的类中获取额外的数据，包括字段的名称。这个新的`attach_to_class()`方法——顾名思义——负责将字段附加到它被分配到的类。即使 Python 自动地将属性添加到它们被赋值的类中，这种赋值并没有向属性传递任何东西，所以我们必须在元类中这样做。

首先，我们需要决定属性需要知道哪些关于它是如何被赋值的信息。在前一节准备了标题之后，很明显属性需要知道在分配时它被赋予了什么名称。通过在代码中直接获得该名称，我们可以避免将名称作为属性实例化的参数单独写出的麻烦。

框架的长期灵活性还将依赖于为属性提供尽可能多的信息，以便它们可以通过自省它们所附加的类来轻松提供高级功能。不幸的是，名字本身并没有说明属性现在所在的类，所以我们也必须在元类中提供这个属性。

最后，之前定义的选项，比如`encoding`，会对属性的行为产生一些影响。与其期望属性必须根据传入的类来检索这些选项，不如简单地接受这些选项作为另一个参数。这留给我们一个看起来像这样的`attach_to_class()`:

![img/330715_3_En_11_Figf_HTML.jpg](img/330715_3_En_11_Figf_HTML.jpg)

```py
class Column:
    """
    An individual column within a CSV file. This serves as a base for attributes
    and methods that are common to all types of columns. Subclasses of Column
    will define behavior for more specific data types.
    """

    def __init__(self, title=None, required=True):
        self.title = title
        self.required = required

    def attach_to_class(self, cls, name, options):
        self.cls = cls
        self.name = name
        self.options = options

```

仅这一点就允许属性对象的其他方法访问大量的信息，比如类名、在它上面声明的其他属性和方法、它是在哪个模块中定义的等等。然而，我们需要对这些信息执行的第一个任务要稍微平凡一些，因为我们仍然需要处理标题。如果在创建属性时没有指定标题，此方法可以使用名称来定义一个标题:

![img/330715_3_En_11_Figg_HTML.jpg](img/330715_3_En_11_Figg_HTML.jpg)

```py
class Column:
    """
    An individual column within a CSV file. This serves as a base for attributes
    and methods that are common to all types of columns. Subclasses of Column
    will define behavior for more specific data types.
    """

    def __init__(self, title=None, required=True):
        self.title = title
        self.required = required

    def attach_to_class(self, cls, name, options):
        self.cls = cls
        self.name = name
        self.options = options
        if self.title is None:
            # Check for None so that an empty string will skip this behavior
            self.title = name.replace('_', ' ')

```

这种添加接受带下划线的属性名，并使用多个单词将其转换为标题。我们可以强加其他约定，但是这足够简单，在大多数情况下是准确的，并且符合常见的命名约定。这种简单的方法将涵盖大多数用例，并且不难理解或维护。

正如评论所指出的，这个新特性的`if`测试违背了标准习惯用法，它明确地检查了`None`，而不是简单地让一个未指定的标题评估为`False`。在这里以“正确”的方式做事将会消除将空字符串指定为标题的能力，这可以明确地表示没有标题是必要的。

检查`None`允许空字符串仍然保留该字符串作为标题，而不是用属性名替换它。空标题有用的一个例子是作为一种方式来指示该列不需要在文件数据的显示中呈现。这也是一个很好的例子，说明注释对于理解一段代码的意图是至关重要的。

### 小费

尽管这个`attach_to_class()`方法不使用所提供的选项，但是将它包含在协议中通常是一个好主意。下一节将展示选项将作为类的一个属性可用，但是将它作为自己的参数传递会更清楚一些。如果您的框架需要将这些类级别的选项应用到单个字段，那么接受它作为参数比从类中提取它更容易。

### 添加元类

有了`attach_to_class()`方法，我们现在必须进入等式的另一边。毕竟`attach_to_class()`只能接收信息；元类负责提供这些信息。直到现在，我们甚至还没有开始研究这个框架的元类，所以我们需要从基础开始。

通过子类化`type`，所有的元类开始都是一样的。在这种情况下，我们还将添加一个`__init__()`方法，因为我们所需要的就是在 Python 完成它们之后处理类定义的内容。首先，元类需要识别类中定义的任何选项，并创建一个新的`Dialect`对象来保存它们。有几种方法可以解决这个问题。

最明显的选择是简单地将选项定义为类级别的属性。这将使以后定义单独的类变得容易，但是它会带来一些可能不太明显的问题。首先，它会搞乱主类名称空间。如果您试图创建一个类来处理包含编码文档信息的 CSV 文件，那么您可能有一个名为`encoding`的列。因为我们也有一个名为`encoding`的类选项，所以我们必须给我们的列起一个别的名字，以避免其中一个覆盖另一个并导致问题。

更实际的情况是，如果选项包含在它们自己的名称空间中，就更容易挑选出来。通过能够容易地识别哪些属性是选项，我们可以将它们作为参数传递给`Dialect`，并且立即知道是否有任何属性丢失或者是否指定了无效的名称。所以现在的任务是确定如何为选项提供新的名称空间，同时仍然将它们声明为主类的一部分。

最简单的解决方案是使用内部类。除了其他属性和方法，我们可以添加一个名为`Dialect`的新类来包含各种选项赋值。这样，我们可以让 Python 为我们创建和管理额外的名称空间，这样我们所要做的就是在属性列表中查找名称`Dialect`并将其提取出来。

### 小费

尽管内部的`Dialect`类与其他属性和方法一起驻留在主名称空间中，但是冲突的可能性要小得多，因为它只有一个名称，而不是几个。此外，我们使用以大写字母开头的名称，这对于属性和方法名称是不鼓励的，因此冲突的可能性更小。因为 Python 名称是区分大小写的，所以您可以自由地在类上定义一个名为`dialect`(注意小“d”)的属性，而不用担心会碰到这个`Dialect`类。

为了提取这个新的`Dialect`类，我们将转向这个框架中元类的第一个实现。因为这将有助于形成未来继承的基类，我们将把代码放入一个新的模块中，命名为`base.py`:

![img/330715_3_En_11_Figh_HTML.jpg](img/330715_3_En_11_Figh_HTML.jpg)

```py
from sheets import options

class RowMeta(type):
    def __init__(cls, name, bases, attrs):
        if 'Dialect' in attrs:
            # Filter out Python's own additions to the namespace
            items = attrs['Dialect'].__dict__.items()
            items = dict((k, v) for (k, v) in items if not k.startswith('__'))
        else:
            # No dialect options were explicitly defined
            items = {}
        dialect = options.Dialect(**items)

```

既然选项已经从类定义中提取出来，并且已经填充了一个`Dialect`对象，我们将需要对这个新对象做一些事情。我们从上一节中对`attach_to_class()`的定义中知道，它被传递给每个已定义的字段属性的方法，但是还有什么呢？

本着为以后保留尽可能多的信息的精神，我们将把它分配给类本身。但是因为大写的名字不如属性名好用，所以最好改名为更合适的名字。因为它还形成了框架内部工作的私有接口，所以我们可以在新名称前加上下划线，以进一步防止任何意外的名称冲突:

![img/330715_3_En_11_Figi_HTML.jpg](img/330715_3_En_11_Figi_HTML.jpg)

```py
from sheets import options

class RowMeta(type):
    def __init__(cls, name, bases, attrs):
        if 'Dialect' in attrs:
            # Filter out Python's own additions to the namespace
            items = attrs.pop('Dialect').__dict__.items()
            items = {k: v for k, v in items if not k.startswith('__')}
        else:
            # No dialect options were explicitly defined
            items = {}
        cls._dialect = options.Dialect(**items)

```

这个简单的更改将它从原来的类名称空间中移除，并以新名称`_dialect`插入。这两个名称都避免了与公共属性名称的冲突，但是这一更改使它使用了一个更标准的私有属性名称。以前，它使用标准样式命名一个类，因为这是它的定义方式。

至此，我们终于有了继续处理字段属性的所有内容。第一个任务是在类定义中找到它们，并对找到的任何一个调用`attach_to_class()`。这可以通过一个简单的属性循环轻松实现:

![img/330715_3_En_11_Figj_HTML.jpg](img/330715_3_En_11_Figj_HTML.jpg)

```py
from sheets import options

class RowMeta(type):
    def __init__(cls, name, bases, attrs):
        if 'Dialect' in attrs:
            # Filter out Python's own additions to the namespace
            items = attrs.pop('Dialect').__dict__.items()
            items = {k: v for k, v in items if not k.startswith('__')}
        else:
            # No dialect options were explicitly defined
            items = {}
        cls._dialect = options.Dialect(**items)

        for key, attr in attrs.items():
            if hasattr(attr, 'attach_to_class'):
                attr.attach_to_class(cls, key, cls._dialect)

```

这个简单的元类包含一个循环，该循环只检查每个属性，看它是否有一个`attach_to_class()`方法。如果是，则调用该方法，传入类对象和属性的名称。这样，所有的列都可以在过程的早期获得它们需要的信息。

### 鸭子打字

这个元类使用 hasattr()来检查 attach_to_class()方法的存在，而不是简单地检查属性是否是 Column 的实例。Column 的所有实例都应该有必要的方法，但是通过使用 hasattr()，我们可以为任何类型的对象打开它。您可以将 attach_to_class()添加到其他类型的属性、描述符甚至方法中，从而快速方便地访问更高级的功能。元类只检查它到底需要什么，其余的留给灵活性，这是 duck 类型化的主要好处。这个名字来自于众所周知的*鸭子测试*的应用概念，该测试声明“如果它像鸭子一样摇摇摆摆，像鸭子一样嘎嘎叫，那么它一定是一只鸭子，”以确定是否应该使用一个对象。

现在，填写剩下的`base.py`所需要的就是包含一个真正的基类，单个 CSV 定义可以继承这个基类。因为每个子类都是电子表格中的一行，所以我们可以将基类命名为`Row`来表示它的用途。目前它需要做的就是将`RowMeta`作为它的元类，它将自动获得必要的行为:

![img/330715_3_En_11_Figk_HTML.jpg](img/330715_3_En_11_Figk_HTML.jpg)

```py
#in base.py
class Row(metaclass=RowMeta):
    pass

```

### 将它整合在一起

从技术上讲，现在所有的部分都已经就绪，至少可以演示一个工作系统的基础，但是仍然有一个重要的部分需要处理。目前我们有三个不同的模块，每个模块都有一些需要在公共 API 中公开的部分。理想情况下，所有重要的部分都应该可以从一个中心导入获得，而不是三个，甚至更多。

如果您还没有创建模块，那么在与前面提到的其他脚本相同的目录中创建一个`__init__.py`模块。该文件可以是空的，并且仍然能够单独导入所有的包，但是只需一点努力，就可以更好地利用它。因为这是在简单地直接导入包名时导入的文件，所以我们可以使用它作为触发器，从所有其他文件中提取有用的部分:

![img/330715_3_En_11_Figl_HTML.jpg](img/330715_3_En_11_Figl_HTML.jpg)

打开`__init__.py`，把这段代码放进去:

```py
from sheets.base import *
from sheets.options import *

from sheets.columns import *

```

### 注意

通常，使用星号来导入所有内容是一个坏主意，因为它会使识别什么来自哪里变得更加困难。因为这个模块只是导入代码，并不做任何事情，所以这个问题并不存在。只要包是自己导入的，比如`import sheets`，就不会有对象来自哪里的困惑。因为我们不需要提到任何对象的名字，这也适用于我们可能添加到那些模块中的任何东西。

现在我们有足够的工作部件来表明框架可以工作，至少在非常基础的水平上。如果我们从框架代码本身向上创建一个`example.py`目录，那么`sheets`在`PYTHONPATH`上，我们现在可以创建一个类，它做一些非常简单的工作来显示它开始组合在一起:

![img/330715_3_En_11_Figm_HTML.jpg](img/330715_3_En_11_Figm_HTML.jpg)

```py
import sheets

class Example(sheets.Row):
    title = sheets.Column()
    description = sheets.Column()

if __name__ == '__main__':
    print(Example._dialect)
    print(Example.title)

```

然而，到目前为止，这实际上只是允许我们命名列。为了将它们与 CSV 文件中的数据对齐，我们需要知道字段在类中定义的顺序。

## 排序字段

目前，这些字段都可以作为类本身的属性使用。这允许您获得关于单个字段的一些信息，但前提是您知道字段的名称。如果没有名字，你就必须检查这个类的所有属性，并检查哪些属性是`Column`或者它的子类的实例。然而，即使您这样做了，您仍然不知道它们被定义的顺序，所以不可能用 CSV 文件中的数据来排列它们。

为了解决这两个问题，我们需要建立一个列列表，其中每个列都可以按照定义的顺序存储。但是首先，我们需要能够在运行时识别订单，而不需要询问开发人员。至少有三种不同的方法可以做到这一点，每种方法都有自己的好处。

### 宣布目标。__ _ _ _ 准备 _ _()

第 4 章展示了当 Python 处理组成类定义的代码块时，元类可以控制类名称空间的行为。通过在声明性元类上包含一个`__prepare__()`方法——在本例中是`RowMeta`——我们可以提供一个有序字典，然后它可以保持属性赋值本身的顺序。这就像导入一个有序字典实现并从一个定制的`__prepare__()`方法返回它一样简单:

![img/330715_3_En_11_Fign_HTML.jpg](img/330715_3_En_11_Fign_HTML.jpg)

```py
from collections import OrderedDict

from sheets import options

class RowMeta(type):
    def __init__(cls, name, bases, attrs):
        if 'Dialect' in attrs:
            # Filter out Python's own additions to the namespace
            items = attrs.pop('Dialect').__dict__.items()
            items = {k: v for k, v in items if not k.startswith('__')}
        else:
            # No dialect options were explicitly defined
            items = {}
        cls._dialect = options.Dialect(**items)

        for key, attr in attrs.items():
            if hasattr(attr, 'attach_to_class'):
                attr.attach_to_class(cls, key, cls._dialect)

    @classmethod
    def __prepare__(self, name, bases):
        return OrderedDict()

```

然而，这只是我们前进的一部分。现在名称空间字典包含了所有的类属性，并且知道它们的定义顺序，但是它没有解决只有 CSV 列的简单列表的问题。名称空间字典还将保存所有已定义的方法和其他各种属性，所以我们仍然需要从其中取出列，并将它们放入另一个列表中。

一个显而易见的方法是查看字典中的每个属性，检查它是否是列。这与本节前面提到的过程相同，但是现在的不同之处在于，您可以将复杂性隐藏在元类内部。

因为`__init__()`在整个主体被处理后运行，所以它的`attrs`参数将是一个包含所有属性的有序字典。剩下的工作就是循环遍历它们，找出找到的所有列。同样，本着鸭子打字的精神，我们将使用`attach_to_class()`来确定哪些属性是列。事实上，我们可以使用现有的循环，只需将新代码注入到内部的`if`块中。

为了在现实世界中使用它，需要将它放在更有用的地方，比如存储在类的`_dialect`属性中的`Dialect`对象。与其简单地从外部分配一个列表，不如让`Dialect`自己管理它，给它一个`add_column()`方法，我们可以从元类调用它:

![img/330715_3_En_11_Figo_HTML.jpg](img/330715_3_En_11_Figo_HTML.jpg)

```py
class Dialect:
    """
    A container for dialect options that control how a CSV file should be
    handled when converting it to a set of objects.

    has_header_row
        A Boolean indicating whether the file has a row containing header
        values. If True, that row will be skipped when looking for data.
        Defaults to False.

    For a list of additional options that can be passed in, see documentation
    for the dialects and formatting parameters of Python's csv module at
    http://docs.python.org/library/csv.html#dialects-and-formatting-parameters
    """

    def __init__(self, has_header_row=False, **kwargs):
        self.has_header_row = has_header_row
        self.csv_dialect = kwargs
        self.columns = []

    def add_column(self, column):
        self.columns.append(column)

```

既然`Dialect`知道如何保存字段记录，那么只需修改`RowMeta`就可以在发现列时将其添加到方言中。因为名称空间已经根据属性分配的时间进行了排序，所以我们可以确保它们以正确的顺序附加到类上。因此，我们可以简单地在列的`attach_to_class()`方法中添加对方言的`add_column()`的快速调用:

![img/330715_3_En_11_Figp_HTML.jpg](img/330715_3_En_11_Figp_HTML.jpg)

```py
class Column:
    """
    An individual column within a CSV file. This serves as a base for attributes
    and methods that are common to all types of columns. Subclasses of Column
    will define behavior for more specific data types.
    """

    def __init__(self, title=None, required=True):
        self.title = title
        self.required = required

    def attach_to_class(self, cls, name, dialect):
        self.cls = cls
        self.name = name
        self.dialect = dialect
        if self.title is None:
            # Check for None so that an empty string will skip this behavior
            self.title = name.replace('_', ' ')
        dialect.add_column(self)

```

### 注意

这个例子还将属性`options`的名称改为`dialect`，以与框架的其余部分保持一致。

现在，我们的代码有了一种简单的方法，可以按照原始顺序获取提供给类的列。然而，它有一个相当大的缺陷:`__prepare__()`技术只在 Python 版中可用。因为在此之前没有等效的功能，任何旧版本都需要使用完全不同的方法来解决这个问题。

我们可以利用 Python 的类处理的基本原则:类的主体作为代码块执行。这意味着每个列属性都是按照它们在类定义中的写入顺序进行实例化的。`Column`类已经有了一个在属性被实例化时运行的代码块，它可以被扩展一点以跟踪每个实例化。

### 专栏。__init__()

最明显的选择是我们已经有代码的地方:`__init__()`方法。当每个`Column`对象被实例化时，它被调用，因此它提供了一个方便的地方来跟踪这些对象被遇到的顺序。实际过程相当简单。它所需要的只是一个无论处理哪一列都可以在一个地方维护的计数器，以及每当发现一个新列就递增该计数器的一小段代码:

![img/330715_3_En_11_Figq_HTML.jpg](img/330715_3_En_11_Figq_HTML.jpg)

```py
class Column:
    """
    An individual column within a CSV file. This serves as a base for attributes
    and methods that are common to all types of columns. Subclasses of Column
    will define behavior for more specific data types.
    """

    # This will be updated for each column that's instantiated.
    counter = 0

    def __init__(self, title=None, required=True):
        self.title = title
        self.required = required
        self.counter = Column.counter
        Column.counter += 1

    def attach_to_class(self, cls, name, dialect):
        self.cls = cls
        self.name = name
        self.dialect = dialect
        if self.title is None:
            # Check for None so that an empty string will skip this behavior
            self.title = name.replace('_', ' ')
        dialect.add_column(self)

```

这段代码处理了部分问题。现在，每一列都有一个`counter`属性，表明它在其余列中的位置。

### 简单比复杂好

实际上，该计数器将跨所有的列维护，而不管它们被分配到哪个类。尽管这在技术上有点过分，但实际上不会伤害任何东西。每组列仍将在其对等列之间适当排序，因此它们可以正确排序而不会出现问题。更重要的是，重置每个类的计数器会使代码变得非常复杂。

首先，我们需要为每个可以附加列的类创建一个单独的计数器。在调用`attach_to_class()`之前，列不知道它们被分配到哪个类，所以我们必须在其中放一些代码来确定新类何时被处理。但是因为这是在计数器已经在`__init__()`中递增之后发生的，所以在将计数器分配给新类的新位置时，需要重置计数器。

为每个单独的类保留一个单独的计数器是完全可能的，但是这样做并不会给这个过程增加任何东西。因为更简单的形式在大多数情况下都是有效的，所以增加复杂性是不值得的。如果您有一个长期运行的进程，它定期动态地创建`Row`子类，那么计数器可能会溢出并导致问题。在这种情况下，您需要采取这些额外的步骤来确保一切继续正常工作。

下一步是使用该计数器强制对存储在`Dialect`对象上的列进行排序。在`__prepare__()`方法中，名称空间自己处理排序，所以没有其他事情要做。这里我们需要对字段列表进行显式排序，使用`counter`属性来确定顺序。

我们不能马上在`__init__()`中这样做，因为那样会得到所有属性的字典，而不仅仅是列。在使用它们的`attach_to_class()`方法进行处理之前，它不知道哪些属性是列。在用`attach_to_class()`处理完所有的列之后，对列表进行排序将会提供一个完整的列表，其中只有正确顺序的列。以下是您需要添加到`RowMeta`类的内容:

![img/330715_3_En_11_Figr_HTML.jpg](img/330715_3_En_11_Figr_HTML.jpg)

```py
from sheets import options

class RowMeta(type):
    def __init__(cls, name, bases, attrs):
        if 'Dialect' in attrs:
            # Filter out Python's own additions to the namespace
            items = attrs.pop('Dialect').__dict__.items()
            items = {k: v for k, v in items if not k.startswith('__')}
        else:
            # No dialect options were explicitly defined
            items = {}
        cls._dialect = options.Dialect(**items)
        for key, attr in attrs.items():
            if hasattr(attr, 'attach_to_class'):
                attr.attach_to_class(cls, key, cls._dialect)

        # Sort the columns according to their order of instantiation
        cls._dialect.columns.sort(key=lambda column: column.counter)

```

这个函数调用可能看起来比实际复杂一点。它只是调用一个标准的`sort()`操作，但是有一个函数将被调用来确定在排序项目时使用什么值。我们可以给`Column`添加一个方法，只返回计数器并使用它，但是因为它只在这里使用，一个`lambda`函数将内联做同样的工作。

### 简单比复杂好

另一种选择是在处理`attach_to_class()`的同时对列表进行排序。前面显示的默认`attach_to_class()`实现已经在提供的`Dialect`对象上调用了`add_column()`，所以这是一个很好的地方来完成这项工作。不幸的是，这样做需要一些额外的步骤。每次添加新列时尝试对整个列表进行排序是没有意义的，但是我们可以使用标准库中的`bisect`模块来更高效地保持顺序。

二等分模块提供了一个`insort()`方法，该方法将新项目插入到现有序列中，同时保留这些项目的有用顺序。然而，与标准的`sort()`不同，这个函数不接受关键参数，而是依赖于使用`<`操作符来比较两个项目。如果一个项目比另一个项目小，它在序列中会被放在更靠前的位置。这很有意义，但是如果不使用显式的`key`，我们需要在`Column`类上实现一个`__lt__()`方法来支持`insort()`。

事后排序只需要一行额外的代码，而尝试从头到尾排序会引入另一个导入和另一个对`Column`类的方法。通过这种方式，我们得到的唯一好处是能够看到到目前为止已经处理过的所有列的顺序，但是因为新列可能被放置在该顺序内的任何位置，所以在所有列都被处理完之前，它实际上没有多大用处。因此，最好保持事情简单，然后只对列表进行一次排序。

这种方法中添加的大部分代码在`__prepare__()`不可用时都是必需的，不管其他偏好如何。我们真正有空间使用不同方法的唯一领域是更新计数器值的地方。有几种不同的方法来管理这个价值。

到目前为止，我们已经使用了`Column`类的`__init__()`方法，因为它总是在实例化期间被调用，而且它已经有了一个基本的实现。麻烦在于，许多`__init__()`方法仅用于将参数值作为属性保存在对象上，因此程序员已经开始期待类似的行为。除了管理计数器，我们自己的`__init__()`方法完全符合这一期望。

因此，如果程序员想编写一个新的列，它不使用任何与基类`Column`相同的参数，那么很容易编写一个不调用`super()`的`__init__()`方法。如果不使用`super()`来触发最初的`__init__()`方法，新列将不会被正确排序。它的`counter`属性将始终与它之前处理的内容相同，因此`sort()`将无法可靠地确定它属于哪里。

你可能会说这里的问题在于程序员认为`__init__()`不做任何有价值的事情，但这不是解决问题的有效方法。如果有人忘记使用`super()`，我们仍然有一些方法可以让框架的用户变得更容易，有助于避免问题。

### 专栏。__ 新 _ _()

想想没有`__init__()`的实例化，下一个明确的选择是`__new__()`，它在流程的前面被调用。使用`__new__()`提供了一个不与`__init__()`竞争而做相同工作的机会，所以它们可以相互独立。对象的初始化仍然可以在`__init__()`中进行，让`__new__()`来管理计数器值:

![img/330715_3_En_11_Figs_HTML.jpg](img/330715_3_En_11_Figs_HTML.jpg)

```py
class Column:
    """
    An individual column within a CSV file. This serves as a base for attributes
    and methods that are common to all types of columns. Subclasses of Column
    will define behavior for more specific data types.
    """

    # This will be updated for each column that's instantiated.
    counter = 0

    def __new__(cls, *args, **kwargs):
        # Keep track of the order each column is instantiated
        obj = super(Column, cls).__new__(cls, *args, **kwargs)
        obj.counter = Column.counter
        Column.counter += 1
        return obj

    def __init__(self, title=None, required=True):
        self.title = title
        self.required = required

    def attach_to_class(self, cls, name, dialect):
        self.cls = cls
        self.name = name
        self.dialect = dialect
        if self.title is None:
            # Check for None so that an empty string will skip this behavior
            self.title = name.replace('_', ' ')
        dialect.add_column(self)

```

因为`__new__()`负责创建和返回新对象，所以`__new__()`中的代码比之前在`__init__()`中使用的有所增加。因此，我们需要在给对象分配计数器之前显式地创建对象。然后，该方法需要显式返回新对象，以便其他任何对象都可以访问它。

使用`__new__()`而不是`__init__()`仅仅是一种减少与定制实现冲突的方法。这可能不太可能，但是子类自己提供`__new__()`仍然是可能的，不使用`super()`这样做仍然会导致问题。还有一个选项可以进一步区分计数行为。

### 反击。__call__()

重要的是要明白，在实例化一个类时，还会调用另一个方法。从技术上讲，类对象本身是作为一个函数被调用的，这意味着在某个地方有一个`__call__()`方法会被调用。因为`__call__()`只作为一个实例方法执行，但是实例化发生在调用一个类的时候，我们需要把这个类看作其他东西的实例:一个*元类*。

这意味着我们可以创建一个元类来完全在`Column`类之外支持计数器功能。一个简单的带有`__call__()`方法的`CounterMeta`类可以自己跟踪计数器，然后`Column`可以使用它作为它的元类。这个方法的主体看起来本质上就像`__new__()`,因为它被称为过程中几乎相同的部分。需要使用`super()`创建对象并显式返回:

![img/330715_3_En_11_Figt_HTML.jpg](img/330715_3_En_11_Figt_HTML.jpg)

```py
class CounterMeta(type):
    """
    A simple metaclass that keeps track of the order that each instance
    of a given class was instantiated.
    """

    counter = 0

    def __call__(cls, *args, **kwargs):
        obj = super(CounterMeta, cls).__call__(*args, **kwargs)
        obj.counter = CounterMeta.counter
        CounterMeta.counter += 1
        return obj

```

现在，所有这些功能都被隔离到一个元类中，`Column`类变得简单了一些。它可以去掉所有的计数器处理代码，包括整个`__new__()`方法。现在维护计数行为所需要的就是使用`CounterMeta`作为它的元类:

![img/330715_3_En_11_Figu_HTML.jpg](img/330715_3_En_11_Figu_HTML.jpg)

```py
class Column(metaclass=CounterMeta):
    """
    An individual column within a CSV file. This serves as a base for attributes
    and methods that are common to all types of columns. Subclasses of Column
    will define behavior for more specific data types.
    """

    def __init__(self, title=None, required=True):
        self.title = title
        self.required = required

    def attach_to_class(self, cls, name, dialect):
        self.cls = cls
        self.name = name
        self.dialect = dialect
        if self.title is None:
            # Check for None so that an empty string will skip this behavior
            self.title = name.replace('_', ' ')
        dialect.add_column(self)

```

事实上，这个`CounterMeta`现在能够为任何需要它的类提供这种计数行为。通过简单地应用元类，给定类的每个实例都有一个附加的`counter`属性。然后，您可以使用该计数器根据实例化的时间对实例进行排序，就像`sheets`框架中的列一样。

### 选择一个选项

在这里提供的选项中，决定选择哪一个并不总是容易的。随着每一层灵活性的增加，复杂性也随之增加，最好是尽可能保持简单。当在 Python 3.x 环境中工作时，`__prepare__()`无疑是最好的选择。它不需要任何额外的类来支持它；它不需要在事实之后对列列表进行排序；而且它根本不需要接触`Column`类就可以工作。

Python 2 . x 早期版本的选项更加主观。你选择哪一个很大程度上取决于你对你的目标读者的期望，以及你允许你的代码有多复杂。更简单的解决方案需要用户更加警惕，所以你需要决定什么是最重要的。

因为这本书是为 Python 3.x 设计的，所以剩下的代码示例将使用`__prepare__()`。当然，对一组字段进行排序的能力只有在您有一组要处理的字段时才有用。

## 建立野外图书馆

在大多数声明性框架中，字段的主要功能是在本地 Python 对象和一些其他数据格式之间转换数据。在我们的例子中，另一种格式是包含在 CSV 文件中的字符串，因此我们需要一种方法在这些字符串和字段表示的对象之间进行转换。在我们进入具体字段类型的细节之前，我们需要设置一些管理数据转换的方法。

第一个方法`to_python()`，从文件中获取一个字符串，并将该字符串转换成一个本地 Python 值。每次从文件中读入一行时，都会对每一列执行该步骤，以确保您可以在 Python 中使用正确类型的值。因为不同类型的行为会有所不同，委托给像`to_python()`这样的方法允许您在单个类上改变这种特定的行为，而不必在一个`Column`类上这样做。

第二个方法是`to_string()`，它是`to_python()`的逆方法，在保存带有 Python 中赋值的 CSV 文件时会被调用。因为默认情况下`csv`模块处理字符串，所以该方法用于提供特定 CSV 格式所需的任何特殊格式。委托给该方法意味着每一列都可以有自己的选项来适应属于该字段的数据。

尽管每种类型的数据行为不同，但默认情况下，基类`Column`可以支持一个简单的用例。`csv`模块只处理以文本模式打开的文件，所以 Python 自己的文件访问在读取数据时管理到 Unicode 的转换。这意味着来自`csv`的值已经是一个字符串，可以很容易地使用:

![img/330715_3_En_11_Figv_HTML.jpg](img/330715_3_En_11_Figv_HTML.jpg)

```py
class Column:
    """
    An individual column within a CSV file. This serves as a base for attributes
    and methods that are common to all types of columns. Subclasses of Column
    will define behavior for more specific data types.
    """

    def __init__(self, title=None, required=True):
        self.title = title
        self.required = required

    def attach_to_class(self, cls, name, dialect):
        self.cls = cls
        self.name = name
        self.dialect = dialect
        if self.title is None:
            # Check for None so that an empty string will skip this behavior
            self.title = name.replace('_', ' ')
        dialect.add_column(self)

    def to_python(self, value):
        """
        Convert the given string to a native Python object.
        """
        return value

    def to_string(self, value):
        """
        Convert the given Python object to a string.
        """
        return value

```

现在我们可以开始为单个数据类型实现它们了。

### 斯普林菲尔德

最明显的开始字段是字符串，因为它可以包含任意数量的更具体形式的数据。标题、姓名、地点、描述和评论只是这些字段中更具体的值的一些例子，但是从技术角度来看，它们都以相同的方式工作。sheets 框架不需要关心你将要处理什么形式的字符串，只需要知道它们实际上都是字符串。

`csv`模块自己提供了字符串，所以这个类实际上不需要做太多事情。事实上，`to_python()`和`to_string()`根本不需要任何定制的实现，因为它们只需要返回给它们的东西。`StringColumn`提供的最重要的东西实际上是名称本身。

通过拥有根据与之交互的数据类型命名的属性，属性在某种程度上变得不言自明。不要仅仅使用一个通用的`Column`来描述字符串是如何来回传递的，你可以使用一个`StringColumn`来明确它是如何工作的:

![img/330715_3_En_11_Figw_HTML.jpg](img/330715_3_En_11_Figw_HTML.jpg)

```py
class StringColumn(Column):
    """
    A column that contains data formatted as generic strings.
    """
    pass

```

事实上，您甚至可以调用基类`StringColumn`而不仅仅是`Column`，因为它自己完成这项工作。不幸的是，这在子类化它的时候会引起混乱，因为需要像`IntegerColumn`这样的东西来子类化`StringColumn`。为了让事情更清楚，基类将保持`Column`，每个子类将只在它上面添加必要的特性，即使除了名字之外没有任何有用的东西可以添加。

### 整数列

下一个要添加的字段类型管理整数。数字在电子表格中使用得相当多，存储从年龄到销售数字到库存计数的一切。大多数情况下，这些数字是普通整数，可以使用内置的`int()`函数轻松转换:

![img/330715_3_En_11_Figx_HTML.jpg](img/330715_3_En_11_Figx_HTML.jpg)

```py
class IntegerColumn(Column):
    """
    A column that contains data in the form of numeric integers.
    """
    def to_python(self, value):
        return int(value)

```

`IntegerColumn`实际上并不需要实现一个`to_string()`方法，因为`csv`模块会自动调用`str()`，无论它被赋予什么值。因为这就是我们在`to_string()`方法中所做的一切，我们可以忽略它，让框架来处理这个任务。正如您将在其他列中看到的，当列可以指定更明确的格式时，`to_string()`最有用。简单地写出一个数字并不需要太多的灵活性。

### 浮动柱

电子表格中的许多数字比整数粒度更细，需要额外的信息来传递小数点后的值。浮点数是处理这些值的一种很好的方式，将它们作为一列来支持就像使用`IntegerColumn`一样简单。我们可以简单地用`float`替换`int`的所有实例，这样就完成了:

![img/330715_3_En_11_Figy_HTML.jpg](img/330715_3_En_11_Figy_HTML.jpg)

```py
class FloatColumn(Column):
    """
    A column that contains data in the form of floating point numbers.
    """
    def to_python(self, value):
        return float(value)

```

当然，在许多情况下，当查看浮点数或者将它们加在一起时，浮点数也有问题。这是由于小数点缺少定义的精度造成的:它根据给定值在代码中表示的好坏而浮动。为了更加明确和避免舍入误差之类的事情，我们求助于`DecimalColumn`。

### 十进制柱

像`FloatColumn`一样，它可以处理整数以外的数字。然而，`DecimalColumn`将依赖 Python 提供的`decimal`模块的功能，而不是使用浮点数。小数值尽可能多地保留原始数字的细节，这有助于防止舍入误差。这使得小数更适合用于货币电子表格。

在 Python 中，小数是使用`decimal`模块提供的，该模块提供了一个`Decimal`类来管理单个数字。因此，`DecimalColumn`需要将数字从 CSV 文件中的文本转换成 Python 中的`Decimal`对象，然后再转换回来。像浮点一样，`Decimal`本身已经可以很好地转换成字符串，所以`DecimalColumn`真正需要做的唯一转换是在读取值时从字符串转换成`Decimal`。因为 Decimal 是为处理字符串而设计的，所以它与迄今为止显示的其他列一样简单:

![img/330715_3_En_11_Figz_HTML.jpg](img/330715_3_En_11_Figz_HTML.jpg)

```py
import decimal

class DecimalColumn(Column):
    """
    A column that contains data in the form of decimal values,
    represented in Python by decimal.Decimal.
    """

    def to_python(self, value):
        return decimal.Decimal(value)

```

然而，这个方法与其他类中的方法有一点不同。其他每一个都有额外的副作用，如果值不能被正确转换，就会产生一个`ValueError`,我们稍后可以用它来支持验证。`Decimal`确实在实例化期间进行了验证，但是它从`decimal`模块`InvalidOperation`中引发了一个异常。为了与其他人的行为相匹配，我们需要抓住这一点，并将其提升为`ValueError`:

![img/330715_3_En_11_Figaa_HTML.jpg](img/330715_3_En_11_Figaa_HTML.jpg)

```py
import decimal

class DecimalColumn(Column):
    """
    A column that contains data in the form of decimal values,
    represented in Python by decimal.Decimal.
    """

    def to_python(self, value):
        try:
            return decimal.Decimal(value)
        except decimal.InvalidOperation as e:
            raise ValueError(str(e))

```

尽管`DecimalColumn`支持更专门化的数据类型，但它背后的代码仍然相当简单。相反，支持日期需要一些额外的复杂性。

### 日期列

日期在电子表格文档中也非常常见，它存储了从员工发薪日和假期到会议议程和出席情况的所有内容。像十进制值一样，日期需要使用单独的类来提供原生 Python 数据类型，但有一个显著的区别:日期没有普遍接受的字符串表示。有一些标准已经建立得相当好了，但是仍然有很多变化，从日期组件的位置到用于分隔它们的标点符号。

为了支持必要的灵活性，新的`DateColumn`将需要在实例化期间接受一个格式字符串，该字符串可用于解析文件中的值以及构造要存储在文件中的字符串。Python 日期已经使用了灵活的格式字符串语法， <sup>[5](#Fn5)</sup> ，所以没有必要专门为`sheets`发明一个新的。然而，为了在实例化期间指定格式，我们需要覆盖`__init__()`:

![img/330715_3_En_11_Figab_HTML.jpg](img/330715_3_En_11_Figab_HTML.jpg)

```py
class DateColumn(Column):
    """
    A column that contains data in the form of dates,
    represented in Python by datetime.date.

    format
        A strptime()-style format string.
        See http://docs.python.org/library/datetime.html for details
    """

    def __init__(self, *args, format='%Y-%m-%d', **kwargs):
        super(DateColumn, self).__init__(*args, **kwargs)
        self.format = format

```

请注意，format 对象有一个默认值，这使得它是可选的。通常最好为字段属性提供这样的默认值，以便用户可以快速启动并运行。之所以选择这里使用的默认值，是因为它相当常见，并且它按照从最不具体到最具体的顺序(分别从年到日)排列值。这有助于减少我们在日期格式不同的文化中可能遇到的歧义。但是，因为目标是处理现有数据，所以特定的`Row`类总是可以用给定文件使用的任何格式来覆盖这种行为。

既然格式在`DateColumn`对象上可用，下一步，就像对其他对象一样，是创建一个`to_python()`方法。Python 的`datetime`对象接受日期的每个组成部分作为一个单独的参数，但是因为`to_python()`只获得一个字符串，我们将需要另一种方法来完成它。另一种形式是名为`strptime()`的`datetime`类方法。

`strptime()`方法接受一个字符串值作为第一个参数，一个格式字符串作为第二个参数。然后根据格式字符串解析该值，并返回一个`datetime`对象。然而，我们实际上并不需要完整的`datetime`，所以我们也可以使用该对象的`date()`方法，只返回值的日期部分作为`date`对象:

![img/330715_3_En_11_Figac_HTML.jpg](img/330715_3_En_11_Figac_HTML.jpg)

```py
import datetime

class DateColumn(Column):
    """
    A column that contains data in the form of dates,
    represented in Python by datetime.date.

    format
        A strptime()-style format string.
        See http://docs.python.org/library/datetime.html for details
    """

    def __init__(self, *args, format='%Y-%m-%d', **kwargs):
        super(DateColumn, self).__init__(*args, **kwargs)
        self.format = format

    def to_python(self, value):
        """
        Parse a string value according to self.format
        and return only the date portion.
        """
        return datetime.datetime.strptime(value, self.format).date()

```

### 注意

模块的名字和类的名字，这就是为什么它被写了两次。

然而，这里写的`to_python()`有一个微妙的问题。到目前为止，所有其他列类型都可以接受一个字符串和一个本机对象作为`to_python()`中的值，但是如果您传入一个`date`对象而不是一个字符串，`strptime()`将失败，并返回一个`TypeError`。为了在 Python 中构造一行并将其保存在文件中，我们需要能够在这里接受一个`datetime`对象，它将在以后保存时被转换为一个字符串。

因为`to_python()`应该返回一个本地对象，所以这是一个非常简单的任务。它只需要检查传入的值是否已经是一个`date`对象。如果是这样，`to_python()`可以简单地返回，而不做任何工作。否则，它可以继续进行转换:

![img/330715_3_En_11_Figad_HTML.jpg](img/330715_3_En_11_Figad_HTML.jpg)

```py
class DateColumn(Column):
    """
    A column that contains data in the form of dates,
    represented in Python by datetime.date.

    format
        A strptime()-style format string.
        See http://docs.python.org/library/datetime.html for details
    """

    def __init__(self, *args, format='%Y-%m-%d', **kwargs):
        super(DateColumn, self).__init__(*args, **kwargs)
        self.format = format

    def to_python(self, value):
        """
        Parse a string value according to self.format
        and return only the date portion.
        """
        if isinstance(value, datetime.date):
            return value
        return datetime.datetime.strptime(value, self.format).date()

```

编写`to_python()`方法实际上是`DateColumn`类中最麻烦的部分。将现有的`date`值转换成字符串更加简单，因为有一个实例方法`strftime()`可以完成这项工作。它只接受一种格式并返回一个包含格式化值的字符串:

![img/330715_3_En_11_Figae_HTML.jpg](img/330715_3_En_11_Figae_HTML.jpg)

```py
import datetime

class DateColumn(Column):
    """
    A column that contains data in the form of dates,
    represented in Python by datetime.date.

    format
        A strptime()-style format string.
        See http://docs.python.org/library/datetime.html for details
    """
    def __init__(self, *args, format='%Y-%m-%d', **kwargs):
        super(DateColumn, self).__init__(*args, **kwargs)
        self.format = format

    def to_python(self, value):
        """
        Parse a string value according to self.format
        and return only the date portion.
        """
        if isinstance(value, datetime.date):
            return value
        return datetime.datetime.strptime(value, self.format).date()

    def to_string(self, value):
        """
        Format a date according to self.format and return that as a string.
        """
        return value.strftime(self.format)

```

### 小费

记住这两个方法名之间区别的一个有用的方法是，`p`代表“解析”,`f`代表“格式”

我们可以继续添加越来越多的字段，但是这里显示的内容涵盖了大多数 CSV 文件中的基本数据形式，以及在声明性框架中构建自己的字段属性所需的大多数技术。接下来，我们需要设置 CSV 功能，以便将这些数据类型应用到生活中。

## 回到 CSV

到目前为止，这一章是相当通用的，展示了可以应用于各种声明类框架的工具和技术。为了将它们投入实际使用，我们需要回到解析 CSV 文件的问题上来。本节中完成的大部分工作也适用于其他框架，但是将以特定于 CSV 的方式呈现。

首先要做的是看看 Python 自己的`csv`模块是如何工作的。完全重新发明轮子是没有意义的。理解现有的接口很重要，这样我们才能尽可能地匹配它。`csv`模块的功能由两种基本的对象类型提供:读取器和写入器。

读取器和写入器的配置方式相似。它们都接受一个文件参数、一个可选的方言和任意数量的关键字参数，这些参数指定了单独的方言参数来覆盖主方言。读取器和写入器之间的主要区别在于，读取器要求打开文件进行读访问，而写入器要求进行写访问。

对于读者来说，文件参数通常是一个`file`对象，但实际上可能是任何可迭代的对象，每次迭代产生一个字符串。因为`csv`模块还处理更复杂的换行符用法，比如在一个值中编码的换行符，所以你应该总是用参数`newline="`打开文件，以确保 Python 自己的换行符处理不会碍事。在下一个示例中，请确保运行该程序的目录中有 example.csv 文件:

![img/330715_3_En_11_Figaf_HTML.jpg](img/330715_3_En_11_Figaf_HTML.jpg)

```py
>>> import csv

>>> reader = csv.reader(open('example.csv', newline="))

```

一旦被实例化用于特定的文件和方言，CSV reader 对象就有了一个极其简单的接口:它是一个可迭代的对象。遍历一个阅读器将产生 CSV 文件中的每一行，作为一个可以在`csv`模块之外使用的数据结构。标准的`csv.reader`为每一行产生一个值列表，因为它唯一知道的是每一个值在行中的位置。

一个更高级的选项是`csv.DictReader`，它在实例化过程中也接受一系列列名，这样每一行都可以作为一个字典生成。我们的框架甚至更进一步，生成一个对象，将文件中的每个值转换为原生 Python 数据类型，并作为属性提供。

相比之下，编写器对象稍微复杂一些。因为简单迭代只允许读取值，而不是写入值，所以编写人员依靠两种方法来完成必要的工作。第一个是`writerow()`，顾名思义，向文件中写出一行。它的伙伴`writerows()`接受一系列行，这些行将按照它们在序列中的顺序写入文件。

根据所使用的编写器类型，行的具体构成会有所不同。与阅读器一样，`csv`模块提供了一些不同的选项。标准的`csv.writer`为每一行接受一个简单的值序列，将每一个值放在它在列表中找到的位置。更复杂的`DictWriter`接受一个字典，它使用实例化期间传入的列名序列来确定每个值应该写在行中的什么位置。

使用我们的框架的接口应该看起来尽可能像这些标准阅读器和编写器的接口。一个`sheets`阅读器应该是一个 iterable 对象，它产生自定义类的实例，所有的列属性都在这个类中定义。同样，作者应该接受同一个类的实例。在这两种情况下，类定义中列属性的顺序将用于确定值的去向。

然而，读者和作者的一个关键因素是行对象的概念。到目前为止，我们还没有任何这样的 sheets 框架对象，所以我们需要创建一个。作为一个基于类的框架，`sheets`已经准备好构建一个可以表示行的对象。列和方言已经在一个类中定义了，所以创建对象的理想方式是简单地用一组值实例化该类。这将引入前面几节中描述的方言和列类，以便生成一个可用的对象。

实现这种行为的明显地方是`__init__()`，但是从那里开始事情变得有点棘手。第一个问题是如何接受将填充属性的值。因为我们还不知道任何特定的`Row`子类的布局，我们将不得不接受所有的参数并处理`__init__()`方法本身的需求。

### 检查参数

与任何函数一样，`__init__()`的参数可以按位置或按关键字传递，但是这个决定在这里有特殊的影响，因为对象可以用两种方式之一进行实例化。当从一个 CSV 文件实例化时，正如下一节将显示的，最简单的方法是按位置传递值。然而，当手动构建实例时，通过关键字传递值也非常方便。因此，最好接受所有位置和关键字参数，并在内部管理它们。

两种无效参数的情况在一开始就很明显:太多的位置参数和关键字参数与任何列名都不匹配。每种情况都需要单独的代码来支持它，但是它们都很容易使用。对于位置的情况，我们可以简单地根据列数检查参数的数量:

![img/330715_3_En_11_Figag_HTML.jpg](img/330715_3_En_11_Figag_HTML.jpg)

```py
class Row(metaclass=RowMeta):
    def __init__(self, *args, **kwargs):
        # First, make sure the arguments make sense
        if len(args) > len(self._dialect.columns):
            msg = "__init__() takes at most %d arguments (%d given)"
            raise TypeError(msg % (len(self._dialect.columns), len(args)))

```

这处理了传入太多位置参数的情况，使用了显式定义参数时 Python 会发出的相同错误消息。下一步是确保所有提供的关键字参数都与现有的列名匹配。这很容易测试，方法是循环遍历关键字参数名称，并检查每个名称是否也出现在列名列表中。

因为方言只存储列的列表，而不是列名的列表，所以在测试它们之前，最简单的方法是在这里创建一个新的列名列表。稍后添加到`__init__()`的额外代码也将使用这个新列表，所以最好现在就创建它:

![img/330715_3_En_11_Figah_HTML.jpg](img/330715_3_En_11_Figah_HTML.jpg)

```py
class Row(metaclass=RowMeta):
    def __init__(self, *args, **kwargs):
        # First, make sure the arguments make sense
        column_names = [column.name for column in self._dialect.columns]

        if len(args) > len(column_names):
            msg = "__init__() takes at most %d arguments (%d given)"
            raise TypeError(msg % (len(column_names), len(args)))

        for name in kwargs:
            if name not in column_names:
                msg = "__init__() got an unexpected keyword argument '%s'"
                raise TypeError(msg % name)

```

这处理了明显的情况，但是还有一种情况没有涉及到:关键字参数的目标列也有位置参数。为了解决这个问题，我们来看看 Python 本身的行为。当遇到按位置和按关键字传递的参数时，Python 会抛出一个`TypeError`，而不是被迫决定使用两个值中的哪一个:

![img/330715_3_En_11_Figai_HTML.jpg](img/330715_3_En_11_Figai_HTML.jpg)

```py
>>> def example(x):
...     return x
...
>>> example(1)
1
>>> example(x=1)
1
>>> example(1, x=1)
Traceback (most recent call last):
  ...

TypeError: example() got multiple values for keyword argument 'x'

```

提供我们自己的`__init__()`的相同行为比前面的例子要复杂一点，但是仍然相当简单。我们只需要查看每个位置参数，并检查是否有关键字参数匹配相应的列名。

对于这种情况，一个有用的快捷方式是在列名数组上使用一个切片，只获取与位置参数一样多的名称。这样，我们不必查看不必要的名称，并且消除了在循环中通过索引查找列名的单独步骤:

![img/330715_3_En_11_Figaj_HTML.jpg](img/330715_3_En_11_Figaj_HTML.jpg)

```py
class Row(metaclass=RowMeta):
    def __init__(self, *args, **kwargs):
        # First, make sure the arguments make sense
        column_names = [column.name for column in self._dialect.columns]

        if len(args) > len(column_names):
            msg = "__init__() takes at most %d arguments (%d given)"
            raise TypeError(msg % (len(column_names), len(args)))

        for name in kwargs:
            if name not in column_names:
                msg = "__init__() got an unexpected keyword argument '%s'"
                raise TypeError(msg % name)

        for name in column_names[:len(args)]:
            if name in kwargs:
                msg = "__init__() got multiple values for keyword argument '%s'"
                raise TypeError(msg % name)

```

检查完所有的参数后，`__init__()`可以确定没有提供无效的参数。从这里开始，我们可以使用这些参数来填充对象本身的值。

### 填充值

在对象上填充值实际上涉及到两个步骤。第一个是由于`__init__()`接受位置和关键字参数。通过提供这两个选项，我们现在有两个不同位置的争论:`args`和`kwargs`。为了在一次传递中设置值，我们需要将它们组合成一个结构。

理想情况下，这个结构应该是一个字典，因为它结合了名称和值，所以我们需要将位置参数移动到已经由`kwargs`提供的字典中。为此，我们需要为每个按位置传入的值建立一个索引，并引用相应的列名，这样就可以将值赋给正确的名称。

上一节的最后一次检查已经提供了那个循环，所以我们可以重用那个块来给`kwargs`赋值。我们需要对循环进行的唯一更改是使用`enumerate()`来获取每一列的索引及其名称。然后，该索引可用于从`args`获取值:

![img/330715_3_En_11_Figak_HTML.jpg](img/330715_3_En_11_Figak_HTML.jpg)

```py
class Row(metaclass=RowMeta):
    def __init__(self, *args, **kwargs):
        # First, make sure the arguments make sense
        column_names = [column.name for column in self._dialect.columns]

        if len(args) > len(column_names):
            msg = "__init__() takes at most %d arguments (%d given)"
            raise TypeError(msg % (len(column_names), len(args)))

        for name in kwargs:
            if name not in column_names:
                msg = "__init__() got an unexpected keyword argument '%s'"
                raise TypeError(msg % name)

        for i, name in enumerate(column_names[:len(args)]):
            if name in kwargs:
                msg = "__init__() got multiple values for keyword argument '%s'"
                raise TypeError(msg % name)
            kwargs[name] = args[i]

```

现在，`kwargs`已经将所有值传递给了构造函数，每个值都映射到了适当的列名。接下来，在将这些值分配给对象之前，我们需要将它们转换成适当的 Python 值。要做到这一点，我们需要实际的列对象，而不仅仅是我们到目前为止一直在使用的名称列表。

还有一个小问题需要考虑。遍历列可以得到为该类定义的所有列，但是`kwargs`只包含传递给对象的值。我们需要决定如何处理没有可用值的列。当从 CSV 文件中提取数据时，这通常不是问题，因为文件中的每一行每一列都应该有一个条目。但是，当在 Python 中填充一个对象以便以后保存在文件中时，在实例化对象之后分配属性通常是有用的。

因此，这里最灵活的方法是简单地将`None`分配给任何没有值的列。检查必填字段可以作为一个单独的步骤来执行，当我们开始验证其他内容的字段时。现在，分配`None`就可以了:

![img/330715_3_En_11_Figal_HTML.jpg](img/330715_3_En_11_Figal_HTML.jpg)

```py
class Row(metaclass=RowMeta):
    def __init__(self, *args, **kwargs):
        # First, make sure the arguments make sense
        column_names = [column.name for column in self._dialect.columns]

        if len(args) > len(column_names):
            msg = "__init__() takes at most %d arguments (%d given)"
            raise TypeError(msg % (len(column_names), len(args)))

        for name in kwargs:
            if name not in column_names:
                msg = "__init__() got an unexpected keyword argument '%s'"
                raise TypeError(msg % name)

        for i, name in enumerate(column_names[:len(args)]):
            if name in kwargs:
                msg = "__init__() got multiple values for keyword argument '%s'"
                raise TypeError(msg % name)
            kwargs[name] = args[i]

        # Now populate the actual values on the object
        for column in self._dialect.columns:
            try:
                value = column.to_python(kwargs[column.name])
            except KeyError:
                # No value was provided
                value = None
            setattr(self, column.name, value)

```

有了这个功能，您就可以看到`Row`类自己运行了。它现在能够管理一组列，接受值作为输入，在加载时将它们转换为 Python 对象，并将这些值分配给适当的属性:

![img/330715_3_En_11_Figam_HTML.jpg](img/330715_3_En_11_Figam_HTML.jpg)

```py
>>> import sheets
>>> class Author(sheets.Row):
...     name = sheets.StringColumn()
...     birthdate = sheets.DateColumn()
...     age = sheets.IntegerColumn()
...
>>> ex = Author('Marty Alchin', birthdate='1981-12-17', age="28")
>>> ex.name
'Marty Alchin'
>>> ex.birthdate
datetime.date(1981, 12, 17)
>>> ex.age

28

```

现在我们终于可以实现与 CSV 文件交互的代码了。

### 读者

直接使用`csv`模块，通过实例化一个类并传入一个文件和必要的配置选项来获得一个读取器。sheets 框架允许每个定制的`Row`类直接在类上指定所有的列和方言参数，所以现在包含了我们需要的一切。与`csv`的直接类比是将一个文件和一个`Row`类传递给一个函数，然后该函数返回一个能够读取该文件的 reader 对象。

这种方法的问题在于，它需要任何想要使用读取器的代码来导入`sheets`模块，以便获得创建读取器对象的函数。相反，我们可以通过提供一个可以完成必要工作的类方法，只使用`Row`类本身。然后，方法需要接受的唯一参数是要读取的文件。为了匹配现有的`csv`命名约定，我们将调用这个新方法`reader()`。

为了像标准阅读器一样工作，我们自己的`reader()`需要返回一个 iterable 对象，为每次迭代生成一行。这是一个需要满足的简单要求，甚至不需要任何新对象就可以完成。记住，当第一次调用生成器函数时，它们实际上会返回一个 iterable 对象。然后在循环的每次迭代中执行生成器的主体，这是支持 CSV 阅读器的理想方式。

为了从 CSV 文件中获取值，`reader()`可以依赖现有的`csv`模块自己的阅读器功能。标准的`csv.reader`为文件中的每一行返回一个列表，不管实际值是什么意思，也不管它们的名字应该是什么。因为 row 类已经可以处理存储在序列(如列表)中的参数，所以将两者绑定在一起非常简单:

![img/330715_3_En_11_Figan_HTML.jpg](img/330715_3_En_11_Figan_HTML.jpg)

```py
import csv

class Row(metaclass=RowMeta):
    def __init__(self, *args, **kwargs):
        # First, make sure the arguments make sense
        column_names = [column.name for column in self._dialect.columns]

        if len(args) > len(column_names):
            msg = "__init__() takes at most %d arguments (%d given)"
            raise TypeError(msg % (len(column_names), len(args)))

        for name in kwargs:
            if name not in column_names:
                msg = "__init__() got an unexpected keyword argument '%s'"
                raise TypeError(msg % name)

        for i, name in enumerate(column_names[:len(args)]):
            if name in kwargs:
                msg = "__init__() got multiple values for keyword argument '%s'"
                raise TypeError(msg % name)
            kwargs[name] = args[i]

        # Now populate the actual values on the object
        for column in self._dialect.columns:
            try:
                value = column.to_python(kwargs[column.name])
            except KeyError:
                # No value was provided
                value = None
            setattr(self, column.name, value)

    @classmethod
        def reader(cls, file):
           for values in csv.reader(file):
           yield cls(*values)

```

然而，这忽略了从 CSV 文件中读取的一个重要方面。在文件中存储值的方式有很多变化，您可能需要指定一些选项来控制文件的处理方式。早些时候，`Dialect`类提供了在`Row`类上指定这些选项的方法，所以现在我们需要在对`csv.reader()`的调用中传递一些选项。特别是，这些选项存储在方言的`csv_dialect`属性中:

![img/330715_3_En_11_Figao_HTML.jpg](img/330715_3_En_11_Figao_HTML.jpg)

```py
@classmethod
    def reader(cls, file):
        for values in csv.reader(file, **cls._dialect.csv_dialect):
            yield cls(*values)

```

这包括了`csv`模块已经知道的选项，但是记住我们自己的`Dialect`类允许另一个选项来指示文件是否有标题行。为了在阅读器中支持该特性，我们需要添加一些额外的代码，如果方言指示第一行将是标题，则跳过该行:

![img/330715_3_En_11_Figap_HTML.jpg](img/330715_3_En_11_Figap_HTML.jpg)

```py
@classmethod
    def reader(cls, file):
        csv_reader = csv.reader(file, **cls._dialect.csv_dialect)

        # Skip the first row if it's a header
        if cls._dialect.has_header_row:
            csv_reader.__next__()

        for values in csv_reader:
            yield cls(*values)

```

因为阅读器需要提供的只是一个为每个对象生成一行的 iterable，所以这个方法现在做了它需要做的一切。然而，这并不是很超前的想法。因为我们正在构建一个以后可能需要改进的框架，所以至少考虑未来的扩展总是一个好主意。

一种更灵活的方法是创建一个新的可迭代类来完成同样的工作，而不是仅仅依赖于一个生成器函数。正如我们将在下一节看到的，作者也需要一个单独的类，所以构建这个新的 iterable 将创建一对更容易理解的类。首先，`reader()`方法变得简单多了:

![img/330715_3_En_11_Figaq_HTML.jpg](img/330715_3_En_11_Figaq_HTML.jpg)

```py
    @classmethod
      def reader(cls, file):
           return Reader(cls, file)

```

这将所有真正的工作委托给了一个新的`Reader`类，该类必须实现`__iter__()`和`__next__()`才能起到迭代器的作用。然而，有一些东西需要先存储在`__init__()`中，包括可以创建每个实例的 row 类和实际读取文件的`csv.reader`对象:

![img/330715_3_En_11_Figar_HTML.jpg](img/330715_3_En_11_Figar_HTML.jpg)

```py
class Reader:
    def __init__(self, row_cls, file):
        self.row_cls = row_cls
        self.csv_reader = csv.reader(file, **row_cls._dialect.csv_dialect)

```

`__iter__()`方法很容易支持，因为`Reader`本身就是迭代器。因此，唯一需要做的就是归还`self`:

![img/330715_3_En_11_Figas_HTML.jpg](img/330715_3_En_11_Figas_HTML.jpg)

```py
class Reader:
    def __init__(self, row_cls, file):
        self.row_cls = row_cls
        self.csv_reader = csv.reader(file, **row_cls._dialect.csv_dialect)

    def __iter__(self):
        return self

```

因为每次迭代都会调用`__next__()`,所以对于返回单个行对象这一明显的任务来说，它的逻辑会简单一些。它需要做的就是在`csv.reader`的迭代器上调用`__next__()`，将值传递给存储在`__init__()`中的 row 类:

![img/330715_3_En_11_Figat_HTML.jpg](img/330715_3_En_11_Figat_HTML.jpg)

```py
class Reader:
    def __init__(self, row_cls, file):
        self.row_cls = row_cls
        self.csv_reader = csv.reader(file, **row_cls._dialect.csv_dialect)

    def __iter__(self):
        return self

    def __next__(self):
        return self.row_cls(*self.csv_reader.__next__())

```

你会从第五章[中想起，当手动构建迭代器时，你必须小心引发`StopIteration`异常以避免无限循环。在这种情况下，我们不必直接这么做，因为`csv.reader`会自己这么做。一旦记录用完，我们自己的`__next__()`方法只需要让`StopIteration`过去而不被抓住。](05.html)

要实现的最后一个特性是标题行，它稍微复杂一些。在前面展示的生成器函数中，很容易在进入真正的循环之前处理标题行。作为一个手动迭代器，我们必须单独管理它，因为对于每条记录,`__next__()`将从开始被调用。

为此，我们需要保留一个布尔属性来指示我们是否仍然需要跳过标题行。开始时，该属性将与方言的`has_header_row`属性相同，但是一旦跳过了标题行，就需要重置该属性，以便`__next__()`可以每隔一段时间生成一条有效记录:

![img/330715_3_En_11_Figau_HTML.jpg](img/330715_3_En_11_Figau_HTML.jpg)

```py
class Reader:
    def __init__(self, row_cls, file):
        self.row_cls = row_cls
        self.csv_reader = csv.reader(file, **row_cls._dialect.csv_dialect)
        self.skip_header_row = row_cls._dialect.has_header_row

    def __iter__(self):
        return self

    def __next__(self):
        # Skip the first row if it's a header
        if self.skip_header_row:
            self.csv_reader.__next__()
            self.skip_header_row = False

        return self.row_cls(*self.csv_reader.__next__())

```

您可以通过提供一个简单的 CSV 文件并读入它来测试它。考虑一个包含粗略目录的文件，其中一列是章节号，另一列是章节标题。下面是如何编写一个`Row`来表示该文件并解析其内容:

![img/330715_3_En_11_Figav_HTML.jpg](img/330715_3_En_11_Figav_HTML.jpg)

```py
>>> import sheets
>>> class Content(sheets.Row):
...     chapter = sheets.IntegerColumn()
...     title = sheets.StringColumn()
...
>>> file = open('contents.csv', newline=“)
>>> for entry in Content.reader(file):
...     print('%s: %s' % (entry.chapter, entry.title))
...
1: Principles and Philosophy
2: Advanced Basics
3: Functions
4: Classes
5: Protocols
6: Object Management
7: Strings
8: Documentation
9: Testing
10: Distribution

11: Sheets: A CSV Framework

```

这就完成了从 CSV 文件中的行到单个 Python 对象的转换。因为`Content`类实例中的每一行，您还可以定义您喜欢的任何其他方法，并在处理来自文件的条目时使用这些方法。对于框架的另一面，我们需要一个编写器将这些对象移回 CSV 文件。

### 作家

与阅读器不同，CSV 编写器的接口需要一些实例方法，因此实现稍微复杂一些。这一次，一个生成器方法不能解决这个问题，所以我们需要添加一个新的类来管理文件写入行为。我们仍然可以依靠`csv`模块自身的行为来完成大部分繁重的工作，所以这个新类只需要管理`sheets`框架的附加特性。

界面的第一部分很简单。为了反映读取器的可用性，应该可以从`Row`子类的方法中访问写入器。这个方法也将接受一个 file 对象，但是这一次它必须返回一个新的对象，而不是立即对那个文件做任何事情。这使得这个`writer()`方法的实现本身很简单:

![img/330715_3_En_11_Figaw_HTML.jpg](img/330715_3_En_11_Figaw_HTML.jpg)

```py
    @classmethod
        def writer(cls, file):
            return Writer(file, cls._dialect)

```

### 注意

`SheetWriter`不能只处理文件，因为它与`Row`是分开的，否则无法访问任何方言选项。

然而，这显然没有做任何有用的事情，所以主要任务是创建并填充`SheetWriter`类。满足 writer 接口有两个必要的方法，`writerow()`和`writerows()`。前者负责获取单个对象并将一行写到文件中，而后者接受一系列对象，将它们作为文件中单独的一行写出。

在开始使用这些方法之前，`Writer`需要一些基本的初始化。它需要访问的第一个显而易见的信息是类的列列表。除此之外，它还需要 CSV 选项，但这些选项只在使用`csv`模块本身创建编写器时才需要，就像 reader 一样。最后，它需要访问`csv`不知道自己的选项`has_header_row`:

![img/330715_3_En_11_Figax_HTML.jpg](img/330715_3_En_11_Figax_HTML.jpg)

```py
class Writer:
    def __init__(self, file, dialect):
        self.columns = dialect.columns
        self._writer = csv.writer(file, dialect.csv_dialect)
        self.needs_header_row = dialect.has_header_row

```

在进入最重要的`writerow()`方法之前，请注意标题行选项在分配给类时实际上被命名为`needs_header_row`。这允许`writerow()`使用该属性作为标志来指示标题行是否仍然需要被写入。如果一开始不需要任何行，那么它从`False`开始，但是如果它以`True`的形式出现，那么一旦文件头实际写入文件，它就可以翻转到`False`。

为了写标题行本身，我们也可以使用`csv.writer`来写值行。`csv`模块不关心文件的整体结构是什么，所以我们可以传入一行标题值，它将像所有其他行一样被处理。这些头值来自类中每一列的`title`属性，但是我们可以使用字符串的`title()`方法使它们更友好一些:

![img/330715_3_En_11_Figay_HTML.jpg](img/330715_3_En_11_Figay_HTML.jpg)

```py
class Writer:
    def __init__(self, file, dialect):
        self.columns = dialect.columns
        self._writer = csv.writer(file, dialect.csv_dialect)
        self.needs_header_row = dialect.has_header_row

    def writerow(self, row):
        if self.needs_header_row:
            values = [column.title.title() for column in self.columns]
            self._writer.writerow(values)
            self.needs_header_row = False

```

有了这个标题，`writerow()`就可以继续写传递到方法中的实际行了。支持头部的代码已经列出了大部分需要做的事情。唯一的区别是，list comprehension 需要从传入的 row 对象中获取相应的值，而不是获取每一列的标题:

![img/330715_3_En_11_Figaz_HTML.jpg](img/330715_3_En_11_Figaz_HTML.jpg)

```py
class Writer:
    def __init__(self, file, dialect):
        self.columns = dialect.columns
        self._writer = csv.writer(file, dialect.csv_dialect)
        self.needs_header_row = dialect.has_header_row

    def writerow(self, row):
        if self.needs_header_row:
            values = [column.title.title() for column in self.columns]
            self._writer.writerow(values)
            self.needs_header_row = False
        values = [getattr(row, column.name) for column in self.columns]
        self._writer.writerow(values)

```

最后，作者还需要一个`writerows()`方法，该方法可以获取一系列对象并将它们作为单独的行写出。困难的工作已经完成，所以所有的`writerows()`需要做的就是为每个传入序列的对象调用`writerow()`:

![img/330715_3_En_11_Figba_HTML.jpg](img/330715_3_En_11_Figba_HTML.jpg)

```py
class Writer:
    def __init__(self, file, dialect):
        self.columns = dialect.columns
        self._writer = csv.writer(file, dialect.csv_dialect)
        self.needs_header_row = dialect.has_header_row

    def writerow(self, row):
        if self.needs_header_row:
            values = [column.title.title() for column in self.columns]
            self._writer.writerow(values)
            self.needs_header_row = False
        values = [getattr(row, column.name) for column in self.columns]
        self._writer.writerow(values)

    def writerows(self, rows):
        for row in rows:
            self.writerow(row)

```

有了 CSV 读取器和写入器，`sheets`框架就完成了。您可以添加更多的列类来支持额外的数据类型，或者根据您的具体需求添加更多的方言选项，但是框架总体上是完整的。您可以通过读取现有文件并将其写回新文件来验证全部功能。只要所有的方言参数都与文件的结构匹配，这两个文件的内容将是相同的:

![img/330715_3_En_11_Figbb_HTML.jpg](img/330715_3_En_11_Figbb_HTML.jpg)

```py
>>> import sheets
>>> class Content(sheets.Row):
...     chapter = sheets.IntegerColumn()
...     title = sheets.StringColumn()
...
>>> input = open('contents.csv', newline=“)
>>> reader = Content.reader(input)
>>> output = open('compare.csv', 'w', newline=“)
>>> writer = Content.writer(output)
>>> writer.writerows(reader)
>>> input.close()
>>> output.close()
>>> open('contents.csv').read() == open('compare.csv').read()

True

```

## 带着它

在本章中，你已经看到了如何使用 Python 提供的许多工具来规划、构建和定制一个框架。原本需要重复多次的复杂任务已经简化为可重用和可扩展的工具。然而，这只是本书中的技术如何结合起来完成如此复杂的任务的一个例子。剩下的就看你的了。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

参见姜戈， [`http://propython.com/django`](http://propython.com/django) 。

  [2](#Fn2_source)

参见“Python SQL 工具包和对象关系映射器”， [`http://propython.com/sqlalchemy`](http://propython.com/sqlalchemy) 。

  [3](#Fn3_source)

[`http://propython.com/twisted`见【T2 扭曲矩阵实验室】。](http://propython.com/twisted)

  [4](#Fn4_source)

参见【CSV 文件读写】 [`http://propython.com/csv-module`](http://propython.com/csv-module) 。

  [5](#Fn5_source)

参见“strftime()和 strptime()行为”， [`http://propython.com/datetime-formatting`](http://propython.com/datetime-formatting) 。

 </aside>