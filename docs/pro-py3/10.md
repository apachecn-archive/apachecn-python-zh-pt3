# 10.分配

一旦你有了一个可用的应用程序，下一步就是决定如何以及在哪里分发它。你可能是为自己写的，但最有可能的是你会有更广泛的读者，并有一个发布它的固定时间表。然而，在你这样做之前，有许多决定要做，任务要完成。这一过程主要包括包装和分销，但它始于许可。

## 批准

在向公众发布任何代码之前，您必须决定管理其使用的许可证。许可证将允许你向你的用户传达你打算如何使用你的代码，你期望其他人如何使用它，你从他们那里要求什么作为回报，以及你期望他们在与你的代码集成后授予他们自己的代码的用户什么权利。这些都是复杂的问题，不可能对每个项目都有一个通用的答案。相反，你需要考虑一些问题。

你自己的哲学起着关键作用，因为它会影响许多其他决定。有些人打算靠他们的代码谋生，这可能意味着源代码根本不会发布。相反，你的工作可以作为一种服务提供，客户可以付费使用。相比之下，你可能对帮助人们更好、更快、更容易或更可靠地学习做事感兴趣。也许最常见的许可证是 GPL。

### 通用公共许可证

当人们想到开源时，GNU 通用公共许可证(GPL) <sup>[1](#Fn1)</sup> 往往是首先想到的。作为自由软件运动的先锋之一，它的主要目标是保护软件用户的某些自由。GPL 要求，如果你将你的程序分发给其他人，你也必须让他们可以使用该程序的源代码。这样，他们可以自由地对你的代码进行他们认为合适的修改，以便更好地支持他们自己的需求。

此外，GPL 的承诺是，任何修改你的代码的用户只能在 GPL 或至少保证同样自由的许可下发布他们的修改。通过这种方式，软件的用户可以确信，如果它不能让他们满意，他们有办法让它变得更好，不管它离原作者有多远。

因为 GPL 对原始代码和链接到它的代码的任何修改都有要求，所以它有时被称为“病毒性的”这不一定是一种侮辱；它只是指这样一个事实，GPL 对任何使用它的东西都强制使用相同的许可。换句话说，它通过软件传播，就像传统病毒一样。这不是 GPL 独有的特性，但是这是商业世界中很多人在想到 GPL 和开源时首先想到的特性。

因为 GPL 的目标是保护计算机用户的自由，它可以被视为限制程序员的自由。程序员在不泄露源代码的情况下发布应用程序的自由限制了用户修改代码的自由。在这两种相反的力量中，GPL 通过对程序员的行为设置一些限制来保护用户的自由。

### GPL 和 Python

GPL 主要是为静态编译的语言编写的，比如 C 和 C++，所以它经常用“对象形式”的代码来表示，这些代码可能“静态链接”到其他代码。换句话说，当您创建一个 C++可执行文件时，编译器会插入您所引用的库中的代码，以生成一个独立的程序。这些术语是其词汇表的核心，但在应用于 Python 等动态语言时却不太容易理解。许多 Python 应用程序使用 GPL 是因为它的整体理念，但是它的术语还没有在 Python 应用程序的环境中经过法庭测试。

看起来这些细节并不重要，因为 Python 代码通常是作为源代码发布的。这里的术语*一般*都有例外，比如你用 py2exe 做了一个 Windows 编译的 Python 应用。毕竟，编译后的 Python 字节码并不与可能使用该代码的各种系统兼容。但是因为 GPL 也适用于任何其他使用该代码的应用程序，例如，如果一个静态编译的应用程序在内部为某些特性使用 GPL Python 代码，这些细节就变得很重要。这种使用是否会触发 GPL 对新应用程序源代码发布的要求还有待观察。

因为这些限制也必须传递给任何其他包含 GPL 代码的应用程序，所以可以使用的许可证是有限的。您可能考虑的任何其他许可证必须至少包括与 GPL 相同的限制，尽管如果必要的话可以添加额外的限制。这方面的一个例子是 AGPL。

### Affero 通用公共许可证

随着互联网的发展，用户在没有直接获得软件拷贝的情况下与软件进行交互已经变得很普遍。因为 GPL 依赖于代码的分发来触发也分发源代码的要求，所以诸如网站和邮件系统之类的在线服务免除了这一要求。一些人认为，这些豁免利用了 GPL 条款中的漏洞，违反了 GPL 的精神。

为了弥补这个漏洞，Affero 通用公共许可证(AGPL)应运而生。本许可证包含 GPL 的所有限制以及附加功能，即任何与软件交互的用户，即使是通过网络，都将触发分发条款。这样，包含 AGPL 代码的网站必须公开他们所做的任何修改的源代码，以及与它共享公共内部数据结构的任何附加软件。虽然被大众接受有点慢，但是开放源码倡议(OSI)的批准无疑给了这个许可证重要的支持。

### 注意

尽管 AGPL 的术语和哲学与 GPL 非常相似，但它对 Python 的适用性更清楚一些。因为只要与软件交互就会触发许可条款，所以代码是从静态语言(如 C)编译而来还是从动态语言(如 Python)构建而来并不重要。然而，这也有待于在 Python 案件中进行法庭测试。

因为 AGPL 比 GPL 本身更加严格，所以使用 AGPL 的项目有可能合并最初用标准 GPL 许可的代码。GPL 的所有保护都保持不变，只是增加了一些额外的保护。还有一种限制更少的 GPL 变体，叫做 LGPL。

### GNU 宽松通用公共许可证

因为 GPL 声明将一段代码静态链接到另一段代码会触发它的条款，所以许多小的实用程序库的使用频率比它们原本可能的要低。这些库通常不会自己构成一个完整的应用程序，但是因为它们的有用性需要与宿主应用程序紧密集成，所以许多开发人员避免使用它们，以避免他们自己的应用程序也绑定到 GPL。

GNU 宽松通用公共许可证(LGPL)就是通过删除静态链接条款来处理这些情况的。因此，在 LGPL 下发布的库可以在宿主应用程序中自由使用，而不需要宿主受 LGPL 或任何其他特定许可证的约束。即使是不打算发布任何源代码的专有商业应用程序也可以包含 LGPL 授权的代码。

但是，所有其他条款保持不变，因此，如果代码本身以任何方式分发，对 LGPL 代码的任何修改都必须作为源代码分发。出于这个原因，许多 LGPL 库都有非常灵活的接口，允许它们的宿主应用程序有尽可能多的选项，而不必直接修改代码。

本质上，LGPL 更倾向于使用开源的概念来培养一个更加开放的编程社区，而不是保护软件最终用户的权利。沿着这条路走下去是最自由的开源许可之一:BSD。

### 伯克利软件分发许可证

Berkeley Software Distribution(BSD)许可证提供了一种发布代码的方式，旨在促进尽可能多的采用。它通过对其他方使用、修改和分发代码施加相对较少的限制来做到这一点。事实上，许可证的整个文本仅由几个要点和一个免责声明组成。然而，将 BSD 称为单一许可证是用词不当，因为实际上有一些变体。在最初的形式中，许可证由四点组成:

*   向程序分发源代码要求代码保留原始版权、许可证文本及其免责声明。

*   将代码作为编译后的二进制程序分发时，需要将版权、许可文本和免责声明包含在随分发代码提供的文档或其他材料中。

*   任何用于推广最终产品的广告必须注明 BSD 许可代码包含在产品中。

*   未经许可本身以外的明确同意，不得使用开发软件的组织的名称或其任何贡献者的名称来专门认可该产品。

请注意，这根本不包含分发源代码的要求，即使是在分发编译后的代码时。相反，它只要求在任何时候都保留适当的归属，并且仍然明确涉及两个不同的当事方。这允许 BSD 许可的代码包含在专有的商业产品中，而不需要发布其背后的源代码，这使得它对大公司相当有吸引力。

然而，广告条款给试图使用 BSD 许可代码的组织带来了一些麻烦。主要问题是，由于代码本身易主，并由不同的组织维护，因此在任何广告材料中必须提到参与开发的每个组织的名称。在某些情况下，这可能是几十个不同的组织，占了广告空间的很大一部分，特别是当软件由于其他原因经常包含相当多的其他免责声明时。

为了解决这些问题，BSD 许可证的另一个版本被创建，没有广告条款。这个许可证被称为新的 BSD 许可证，它包含了原许可证的所有其他要求。广告条款的删除意味着 BSD 授权代码的管理变化对使用它的组织几乎没有影响，这大大扩展了它的吸引力。

BSD 许可证的另一个简化版本叫做简化 BSD 许可证。在这个版本中，甚至删除了非声明条款，只保留了包含许可证文本及其免责声明的要求。为了仍然避免不真实的认可，该版本中的免责声明包括一个额外的句子，该句子明确声明两个群体的观点是相互独立的。

### 其他许可证

这里列出的选项是一些更常用的选项，但是还有更多可用的选项。OSI 维护着一份开源许可清单<sup>[【2】](#Fn2)</sup>，这些许可已经被审查通过，被认为是维护了开源的理念。此外，自由软件基金会维护着它自己的许可证清单 <sup>[3](#Fn3)</sup> 这些许可证已经被批准为维护自由软件的理念。

### 注意

自由软件和开源软件之间的区别主要是哲学上的，但是也有一些现实世界的含义。简而言之，自由软件保留了该软件用户的自由，而开源软件关注的是软件开发模型。并非所有的许可证都被批准用于这两种用途，因此您可能需要决定哪一个对您更重要。

一旦你有了许可证，你就可以开始打包并把你的代码分发给其他可以使用它的人。

## 包装

单独分发一堆文件并不容易，所以你必须先把它们捆起来。这个过程被称为打包，但是它不应该与标准的 Python 包概念相混淆。传统上，一个包只是一个目录，其中有一个`__init__.py`文件，这个文件可以用作这个目录中包含的任何模块的名称空间。

出于分发的目的，软件包还包括文档、测试、许可证和安装说明。这些部件的排列方式使得单个部件可以很容易地取出并安装到合适的位置。通常，该结构如下所示:

```py
AppName/
    LICENSE.txt
    README.txt
    MANIFEST.in
    setup.py
    app_name/
        __init__.py
        ...
    docs/
        ...
    tests/
        __init__.py
        ...

```

如您所见，实际的 Python 代码包是整个应用程序包的子目录，它与其文档和测试并列。包含在`docs`目录中的文档可以包含您喜欢的任何形式的文档，但通常是用 reStructuredText 格式化的纯文本文件，如第 [8 章](08.html)所述。`tests`目录包含第 [9](09.html) 章中描述的测试。`LICENSE.txt`文件包含您选择的许可证的副本，而`README.txt`提供了对您的应用程序、其用途和特性的介绍。

这个整体包中更有趣的特性是`setup.py`和`MANIFEST.in`，它们不是应用程序代码的一部分。

### setup.py

在您的包中，`setup.py`是将您的代码实际安装到用户系统中适当位置的脚本。为了尽可能具有可移植性，这个脚本依赖于标准发行版中提供的`distutils`包。这个包包含一个`setup()`函数，它使用声明性的方法使这个过程更容易操作，也更通用。

位于`distutils.core`中的`setup()`函数接受大量的关键字参数，每个参数描述了包的一个特定特性。有些与整个软件包有关，而有些列出了软件包中包含的单个内容。这些参数中的三个是使用标准工具分发任何包所必需的:

*   `name`:这个字符串包含了包的公共名称，因为它将显示给那些寻找它的人。命名一个包可能是一项复杂而困难的任务，但是由于它非常主观，所以远远超出了本书的范围。

*   `version`:这是一个字符串，包含应用程序的用点分隔的版本号。第一次发布时通常会使用一个版本的`'0.1'`并从那里开始增加。第一个数字通常是表示兼容性承诺的主要版本。第二个是次要版本号，代表不破坏兼容性的错误修复或重要新功能的集合。第三种通常保留给没有引入新功能或其他错误修复的安全版本。

*   `url`:这个字符串引用了主网站，用户可以在这里了解更多关于应用程序的信息，找到更多的文档，请求支持，提交错误报告，或者执行其他任务。它通常充当围绕代码的信息和活动的中心枢纽。

除了这三个必需元素之外，还有几个可选参数可以提供关于应用程序的更多细节:

*   `author`:申请作者的姓名。

*   一个可以直接联系到作者的电子邮件地址。

*   `maintainer`:如果原作者不再维护该应用程序，则该字段包含现在负责该应用程序的人的姓名。

*   `maintainer_email`:可以直接联系到维护人员的电子邮件地址。

*   `description`:该字符串提供了程序目的的简要描述。可以把它想象成一个单行的描述，可以和其他描述一起显示在一个列表中。

*   `long_description`:顾名思义，这是一个更长的应用程序描述。当用户请求关于特定应用程序的更多细节时，通常会显示这个选项，而不是在列表中使用。因为这都是在 Python 代码中指定的，所以许多发行版只是将`README.txt`的内容读入这个参数。

除了这些元数据，`setup()`函数还负责维护分发应用程序所需的所有文件的列表，包括所有 Python 模块、文档、测试和许可证。与其他信息一样，这些细节是使用附加的关键字参数提供的。这里列出的所有路径都是相对于`setup.py`本身所在的主包目录的:

*   `license`:这是一个文件的名称，它包含了程序分发所依据的许可证的全文。通常这个文件被称为`LICENSE.txt`，但是通过显式地将它作为一个参数传入，它可以被命名为您喜欢的任何名称。

*   `packages`:该参数接受实际代码所在的包名列表。与 license 不同，这些值是 Python 导入路径，使用句点沿路径分隔各个包。

*   `package_dir`:如果你的 Python 包和`setup.py`不在同一个目录下，这个参数提供了一种方式告诉`setup()`在哪里可以找到它们。它的值是一个字典，将包名映射到它在文件系统中的位置。您可以使用的一个特殊键是一个空字符串，它将使用相关的值作为根目录来查找任何没有指定显式路径的包。

*   `package_data`:如果你的包依赖于不是直接用 Python 写的数据文件，那些文件只有在这个参数中被引用时才会被安装。它接受一个将包名映射到其内容的字典，但是与`package_dir`不同，这个字典中的值是列表，列表中的每个值都是应该包含的文件的路径规范。这些路径可能包含星号，表示要匹配的广泛模式，类似于您可以在命令行上查询的内容。

对于更复杂的配置，还有其他选择，但这些应该涵盖大多数基础。更多信息，请查阅`distutils`文档。 <sup>[4](#Fn4)</sup> 一旦你把这些部分放好，你就会有一个看起来像这样的`setup.py`:

```py
from distutils.core import setup

setup(name='MyApp',
      version='0.1',
      author='Marty Alchin',
      author_email='marty@propython.com',
      url='http://propython.com/',
      packages=['my_app', 'my_app.utils'],
)

```

### MANIFEST.in

除了指定应该在用户系统上安装什么文件之外，软件包发行版还包括许多对用户有用的文件，而不需要直接安装。这些文件，比如文档，应该对用户可用，但是没有任何代码值，所以它们不应该安装在可执行位置。`MANIFEST.in`文件控制如何将这些文件添加到包中。

`MANIFEST.in`是一个纯文本文件，由一系列命令填充，这些命令告诉`distutils`包中包含哪些文件。这些命令中使用的文件名模式遵循与命令行相同的约定，允许星号作为各种文件名的通配符。例如，一个简单的`MANIFEST.in`可能包含包的`docs`目录中的任何文本文件:

```py
include docs/*.txt

```

这个简单的指令将告诉`disutils`在 docs 目录中找到所有的文本文件，并将它们包含在最终的包中。通过用空格分隔图案，可以包括附加图案。有几个不同的命令可用，每个命令都有包含和排除版本:

*   `include`:最明显的选项，这个命令将查找所有匹配任何给定模式的文件，并将它们包含在包中。它们将被放在包中与它们在原始目录结构中相同的位置。

*   `exclude`:与`include`相反，它会告诉`distutils`忽略任何与这里给出的模式匹配的文件。这提供了一种避免包含某些文件的方法，而不必在一个`include`命令中明确列出每个包含的文件。一个常见的例子是将`exclude TODO.txt`放在一个专门包含所有文本文件的包中。

*   `recursive-include`:这个命令需要一个目录作为它的第一个参数，在任何文件名模式之前。然后，它在该目录及其任何子目录中查找匹配给定模式的任何文件。

*   `recursive-exclude`:和`recursive-include`一样，这个命令首先获取一个目录，然后是文件名模式。通过此命令找到的任何文件都不会包含在包中，即使它们是通过某个包含命令找到的。

*   `global-include`:该命令查找项目中的所有路径，不管它们在路径结构中的位置。通过查看目录内部，它的工作方式很像`recursive-include`，但是因为它查看所有目录，所以除了文件名模式之外，它不需要任何参数。

*   `global-exclude`:像`global-include`一样，它在源项目中的任何地方寻找匹配的文件，但是找到的文件被排除在最终的包之外。

*   这个命令不是寻找匹配的文件，而是接受一组目录，这些目录只是完整地包含在包中。

*   `prune`:像`graft`一样，这个命令接受一组目录，但是它将它们完全从包中排除，即使包中有匹配的文件。

有了`setup.py`和`MANIFEST.in`之后，`distutils`提供了一种简单的打包和分发的方法。

### sdist 命令

为了最终创建可发布的包，您的新`setup.py`实际上可以直接从命令行执行。因为这个脚本也用于以后安装软件包，所以您必须指定您希望它执行什么命令。稍后获得包的用户将使用`install`命令，但是要打包一个源代码发行版，命令是`sdist`:

```py
$ python setup.py sdist
running sdist
...

```

该命令处理在`setup.py`中所做的声明以及来自`MANIFEST.in`的指令，以创建一个包含您指定要分发的所有文件的归档文件。默认情况下，你得到的存档文件的类型取决于你运行的系统，但是`sdist`提供了一些你可以明确指定的选项。只需将逗号分隔的格式列表传递给`--format`选项，即可生成特定的类型:

*   `zip`:Windows 机器上的默认，这种格式创建一个 zip 文件。

*   在 Unix 机器上，包括 Mac OS，默认创建一个 gzipped tarball。要在 Windows 系统上创建这个归档文件，您需要安装一个`tar`的实现，比如可以通过 Cygwin 获得的那个。 <sup>[5](#Fn5)</sup>

*   `bztar`:这个命令在归档 tarball 上使用备用的 bzip 压缩。这也需要安装一个`tar`的实现。

*   `ztar`:这个使用更简单的`compress`算法来压缩 tarball。和其他的一样，使用这个选项需要一个`tar`的实现。

*   `tar`:如果有`tar`实用程序的实现，这个选项不使用压缩，而是简单地打包一个 tarball。

当您运行`sdist`命令时，您指定的每种格式的归档文件将被创建并放置在您的项目中一个新的`dist`目录中。每个档案的名称将简单地使用您在`setup.py`中提供的`name`和`version`，用连字符隔开。前面提供的例子会产生类似于`MyApp-0.1.zip`的文件。

![img/330715_3_En_10_Figa_HTML.jpg](img/330715_3_En_10_Figa_HTML.jpg)

让我们在一个例子中尝试所有前面的步骤。按照每个步骤创建您的 zip 包:

1.  创建一个可以通过命令提示符(如 c:\test)轻松访问的文件夹。

2.  在该文件夹中，创建以下两个名为 setup.py 和 MyApp.py 的文件:

    ```py
    #setup.py
    from distutils.core import setup
    setup(name='MyApp',
          version='0.1',
          author='Alchin and Browning',
          author_email='authors@propython.com',
          url='http://www.propython.com/',
    )
    # MyApp.py
    print("Hello Burton and Marty!")
    gone=input("Enter to close: ")

    ```

3.  Shell 退出到命令提示符下，进入测试目录，执行命令:

    ```py
    python setup.py sdist  (Enter)

    ```

4.  按回车键。(如果它没有启动 Python，您将需要检查您的搜索路径，并确保您的系统可以找到 Python。)

这将在**测试**文件夹中创建一个 **dist** 目录，其中包含您的包的 zip 文件。

当然，这只是一个非常简单的概述，但是您可以灵活地添加清单文件、更改压缩选项等等。

## 分配

一旦你有了这些文件，你将需要一种方法来把它们分发给公众。一种选择是简单地托管自己的网站，并从那里提供文件。这通常是向广大读者推销您的代码的最佳方式，因为您有机会以更易读的方式将文档放在网上，展示它的使用示例，提供已经在使用它的人的评价，以及您能想到的任何其他东西。

简单地自己托管它的唯一问题是，使用自动化工具很难找到它。许多软件包将依赖于其他应用程序的存在，因此能够从脚本内部直接安装它们通常是有用的，而不必导航到网站并找到正确的下载链接。理想情况下，他们能够将一个唯一的包名翻译成一种无需帮助就可以下载并安装该包的方式。

这就是 Python 包索引(PyPI) <sup>[6](#Fn6)</sup> 发挥作用的地方。PyPI 的秘密代号是“奶酪店”，暗指约翰·克立斯试图从麦克·帕林经营的商店购买奶酪的蒙蒂蟒蛇奶酪店。。。没有可用的。

PyPI 是 Python 包的在线集合，它们都遵循标准化的结构，因此更容易被发现。每个包都有一个惟一的名称，可以用来定位它，索引跟踪哪个版本是最新的，并引用该包的 URL。你所需要做的就是把你的包添加到索引中，这样你的用户会更容易使用它。

第一次上传到 PyPI 需要在网站上注册。PyPI 帐户将允许您稍后管理您的应用程序详细信息，并上传新版本和更新。一旦你有了一个帐户，你就可以运行`python setup.py register`在 PyPI 上为你的应用程序建立一个页面。这是一个交互式脚本，将为您注册帐户提供三个选项:

*   使用现有的 PyPI 帐户。如果您已经在 PyPI 网站上创建了一个帐户，您可以在这里指定您的用户名和密码。

*   注册一个新的 PyPI 帐户。如果您想在命令行创建一个帐户，您可以在这里输入您的详细信息，并在注册时创建帐户。

*   生成一个新的 PyPI 帐户。如果你想采用一种更简单的方法，这个选项将采用你已经在操作系统中使用的用户名，自动生成一个密码，并为该组合注册一个帐户。

一旦你选择了你的选项，注册脚本将会在本地保存你的账户信息，这样你就不用每次都经历那个步骤了。有了帐户后，脚本将使用`setup.py`中的信息向 PyPI 注册应用程序。特别是，`name`和`long_description`字段将组合成一个简单的网页，其他细节显示在一个列表中。

有了保存应用程序的页面，最后一步是使用`upload`命令上传代码本身。这必须作为发行版构建的一部分来完成，即使您之前已经构建了一个发行版。这样，您就可以准确地指定您想发送给 PyPI 的发行版的类型。例如，您可以在一个步骤中为 Windows 和非 Windows 用户上传包:

```py
$ python setup.py sdist --format=zip,gztar upload

```

发行版文件是根据应用程序的名称和发行版创建时的版本号来命名的。PyPI 中的条目还包含对版本号的引用，因此您不能多次上传相同版本的相同发行版类型。如果你尝试，你会从`setup.py`得到一个错误，表明你需要创建一个新的版本号来上传一个改变的发行版。

## 令人兴奋的 Python 扩展:秘密模块

Secrets 模块为 Python 程序员提供了一些方便的随机数和密码生成工具。它的主要特点是随机数算法的加密特性。

Python 3.6 中引入的 secrets 模块有许多可用的函数。一个是随机数生成。虽然其他一些库已经介绍了这一点，但研究一下仍然很有意思。

您的计算机操作系统会考虑所生成的随机数的确切性质，但通常对于加密工作，这个随机库会比 Python 中的其他随机数生成器做得更好。这种加密用途包括:密码、认证和令牌。请继续阅读，看看这个模块有多方便。

### 随机数

有相当多的随机令牌和随机数生成选项。为了了解它们是如何工作的，考虑下一个例子将在 0 到 100 之间选择一个随机数。

![img/330715_3_En_10_Figb_HTML.jpg](img/330715_3_En_10_Figb_HTML.jpg)

```py
#Secrets example 1
from secrets import *
x=1
while (x <= 10):
    print(randbelow(100))
    x+=1

```

在前面的例子中，我们从 1 到 100 中选择了 10 个随机值。不令人兴奋，但随机值的更好的加密表示。接下来，我们将考虑随机密码生成。

### 密码生成

在下一个示例中，我们将使用字符串库和机密库来生成包含 ASCII 字母、数字、标点符号和大写字母的密码:

![img/330715_3_En_10_Figc_HTML.jpg](img/330715_3_En_10_Figc_HTML.jpg)

```py
#Generate six digit passwd with letters, digits, punct, and upper
import string
from secrets import *
chars = string.ascii_letters + string.digits + string.punctuation + string.ascii_uppercase
password = ".join(choice(chars) for i in range(6))
print (password)

```

如果你需要一个用于加密工作的令牌，有包括 *urlsafe* 在内的选项。考虑以下示例:

![img/330715_3_En_10_Figd_HTML.jpg](img/330715_3_En_10_Figd_HTML.jpg)

```py
#Generate a token value which is URL-safe
from secrets import *
value = token_urlsafe(10)
print('token is: ',value)

```

这里我们使用的是*选择*，但是使用这个库，您可以尝试以下操作:

![img/330715_3_En_10_Fige_HTML.jpg](img/330715_3_En_10_Fige_HTML.jpg)

```py
#Generate a secrets random choice
from secrets import *
value = choice(['one', 'two', 'three'])
print (value)

```

最后，如果您想输入值并从中选择一个随机集，请尝试以下方法:

![img/330715_3_En_10_Figf_HTML.jpg](img/330715_3_En_10_Figf_HTML.jpg)

```py
#Generate a random choice based on only certain values
from secrets import *
foo=input('Enter 10 random values to choose from:  ')
wow=“.join([choice(foo) for i in range(3)])
print('These are three exciting choices at random:>   ',wow)

```

这里没有什么可以从僵尸的启示中拯救世界，但是这些例子仍然是 Python *secrets* 模块非常有趣的用法。

## 带着它

如您所见，使用 PyPI 打包和分发 Python 应用程序的过程实际上相当简单。除了 PyPI，建立一个专门的项目网站通常是一个好主意，在那里你可以更好地推广和支持你的代码。永远记住，分销不是最后一步。你的用户在使用你的代码时会期望一定的支持和互动，并希望改进它，所以最好找到一种能为你和你的用户支持这些目标的媒介。

所有不同规模、受众和目标的应用程序都是公平的分配对象。无论您是在编写一个小工具来帮助自动化常见任务，还是编写一个完整的框架来为其他用户的代码提供一组功能，都没有关系。下一章将向你展示如何从头到尾建立这样一个框架，建立在贯穿本书的许多技术之上。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

参见 GNU 操作系统，“GNU 通用公共许可证”， [`http://propython.com/gpl`](http://propython.com/gpl) 。

  [2](#Fn2_source)

参见开源倡议，“按名称许可”， [`http://propython.com/osi-licenses`](http://propython.com/osi-licenses) 。

  [3](#Fn3_source)

参见 GNU 操作系统，“关于它们的各种许可和评论”， [`http://propython.com/fsf-licenses`](http://propython.com/fsf-licenses) 。

  [4](#Fn4_source)

请参见分发 Python 模块”2。编写设置脚本， [`http://propython.com/distutils-setup`](http://propython.com/distutils-setup) 。

  [5](#Fn5_source)

[见【Cygwin】`http://propython.com/cygwin`](http://propython.com/cygwin)。

  [6](#Fn6_source)

参见 Python 包索引(PyPl)， [`http://propython.com/pypi`](http://propython.com/pypi) 。

 </aside>