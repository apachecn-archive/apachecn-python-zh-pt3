# 2.高级基础

像任何其他关于编程的书一样，这本书的其余部分依赖于读者可能会或可能不会认为很平常的一些特性。读者应该对 Python 和编程有很好的了解，但是有许多很少使用的特性在整本书展示的许多技术的操作中非常有用。

因此，尽管看起来不同寻常，这一章还是集中在高级基础的概念上。本章中的工具和技术不一定是常识，但它们为后续更高级的实现奠定了坚实的基础。让我们从 Python 开发中经常出现的一些通用概念开始。

## 一般概念

在进入更具体的细节之前，重要的是先了解一下隐藏在本章后面的细节背后的概念。这些不同于第 [1](01.html) 章中讨论的原则和哲学，因为它们更关注实际的编程技术，而之前讨论的是更通用的设计目标。

将第 [1](01.html) 章视为设计指南，而本章介绍的概念更像是实现指南。当然，像这样具体的描述不会陷入太多的细节中，所以这一节将遵从本书其余章节中更详细的信息。

### 循环

尽管 Python 代码中可能会出现几乎无限多种不同类型的序列——在本章后面和第 [5](05.html) 章中会有更多介绍——但大多数使用它们的代码都可以归为两类:实际使用整个序列的代码和只需要序列中的项目的代码。大多数函数以不同的方式使用这两种方法，但是为了理解 Python 提供了什么工具以及应该如何使用它们，这种区别是很重要的。

从纯面向对象的角度来看，与函数式编程的角度相反，很容易理解如何处理代码实际需要使用的序列。您将拥有一个具体的条目，比如一个列表、集合或字典，它不仅拥有与之相关联的数据，还拥有允许访问和修改这些数据的方法。您可能需要多次迭代它，无序地访问单个项，或者从其他方法返回它以供其他代码使用，所有这些都适用于更传统的对象用法。

同样，你可能实际上不需要把整个序列作为一个整体来处理；你可能只对其中的每一项感兴趣。例如，当在一系列数字上循环时，经常会出现这种情况，因为重要的是让循环中的每个数字都可用，而不是让整个数字列表都可用。

这两种方法的区别主要在于意图，但也有技术上的影响。并不是所有的序列都需要加载到内存中，很多甚至根本不需要有一个有限的上限，比如网络流。这一类别包括正奇数集、整数平方和斐波纳契数列，所有这些都是无限长的，很容易计算。因此，它们最适合纯迭代，不需要预先填充列表，这也节省了一点内存。

这样做的主要好处是内存分配。设计用来打印斐波纳契数列的整个范围的程序，在任何给定的时间只需要在内存中保存几个变量，因为数列中的每个值都可以通过前面两个值计算出来。填充一个值列表，即使长度有限，也需要在迭代之前将所有包含的值加载到内存中。如果整个列表永远不会作为一个整体来执行，那么简单地在需要时生成每个项目，并在不再需要时丢弃它，以便生成新的项目，这样效率会高得多。

Python 作为一种语言，提供了几种不同的实现方式来迭代一个序列，而不需要一次将所有的值都放入内存。在其标准库中，Python 在其提供的许多特性中使用了这些技术，这有时可能会导致混淆。Python 允许您毫无问题地编写一个`for`循环，但是许多序列没有您可能期望在列表中看到的方法和属性。要查看两种类型的循环，请尝试以下操作:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figa_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figa_HTML.jpg)

```
last_name='Smith'
count=0
for letter in last_name:
    print(letter,' ' ,count) # note a space between ' '
    count += 1

print('---and the second loop----')
count = 0
while (count<5):
    print(last_name[count], ' ', count)
    count += 1

```

本章后面关于迭代的部分介绍了创建可迭代序列的一些更常见的方法，以及当您确实需要将序列作为一个整体来操作时，将这些序列转换成列表的一种简单方法。然而，有时拥有一个在这两方面都起作用的对象是有用的，这就需要使用缓存。

### 贮藏

在计算之外，缓存是一个隐藏的集合，通常是太危险或太有价值而不能直接访问的项目。计算中的定义是相关的，缓存以不影响面向公众的接口的方式存储数据。也许现实世界中最常见的例子是 Web 浏览器，它在第一次被请求时从 Web 上下载文档，但保留该文档的副本。当用户稍后再次请求相同的文档时(如果文档没有改变)，浏览器加载私有副本并将其显示给用户，而不是再次点击远程服务器。

在浏览器示例中，公共界面可以是地址栏、用户收藏夹中的条目或来自另一个网站的链接，其中用户永远不必指示文档是应该远程检索还是应该从本地缓存中访问。相反，只要文档不会快速更改，软件就会使用缓存来减少需要发出的远程请求的数量。Web 文档缓存的细节超出了本书的范围，但是它是缓存一般如何工作的一个很好的例子:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figb_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figb_HTML.jpg)

```
import webbrowser
webbrowser.open_new('http://www.python.org/')
#more info at:  https://docs.python.org/3.4/library/webbrowser.html

```

更具体地说，缓存应该被视为一种节省时间或提高性能的实用工具，它不需要明确地存在才能使某个功能正常工作。如果缓存被删除或不可用，使用它的函数应该可以继续正常工作，也许性能会下降，因为它需要重新获取丢失的项目。这也意味着利用缓存的代码必须总是接受足够的信息，以便在不使用缓存的情况下生成有效的结果。

缓存的本质也意味着您需要小心确保缓存是最新的，以满足您的需求。在 Web 浏览器示例中，服务器可以指定浏览器在向服务器请求新文档之前应该保留文档的缓存副本多长时间。在简单的数学示例中，理论上可以永远缓存结果，因为给定相同的输入，结果应该总是相同的。第 [3](03.html) 章介绍了一种叫做*记忆*的技术，它就是这样做的。

一个有用的折衷办法是无限期地缓存一个值，但在值更新时立即更新它。这并不总是一个选项，特别是如果值是从外部源检索的，但是当值在应用程序中更新时，更新缓存是一个很容易包含的步骤，这样就省去了以后必须使缓存无效并从头开始检索值的麻烦。然而，这样做可能会导致性能下降，所以您必须权衡实时更新的优点和这样做可能会损失的时间。

### 透明度

无论是描述建筑材料，图像格式，还是政府行为，透明都是指看穿或看到事物内部的能力，它在编程中的使用也是如此。出于我们的目的，透明性指的是你的代码能够看到——在很多情况下，甚至能够编辑——计算机可以访问的几乎所有东西。

Python 不支持私有变量的概念，这种概念在许多其他编程语言中很常见，因此所有属性都可以被任何请求者访问。一些语言认为这种类型的开放性对可维护性是一种风险，而是允许实现一个对象的代码单独对该对象的数据负责。尽管这确实防止了一些偶然的内部数据结构滥用，但是 Python 并没有采取任何措施来限制对这些数据的访问。

尽管透明访问最明显的用途是在类实例属性中——这是许多其他语言允许更多隐私的地方——Python 允许您检查对象和实现它们的代码的许多方面。事实上，您甚至可以访问 Python 用来执行函数的已编译字节码。以下是运行时可用信息的几个例子:

*   对象的属性

*   对象可用属性的名称

*   对象的类型

*   定义类或函数的模块

*   模块加载的位置(通常是文件名)

*   函数对象的字节码

这些信息的大部分只在内部使用，但它是可用的，因为有一些潜在的用途在首次编写代码时没有考虑到。在运行时访问或检查这些信息被称为*自省*，这是实现 DRY(不要重复自己)等原则的系统中的常用策略。Hunt 和 Thomas 对 DRY 的定义是“每一项知识在一个系统中必须有一个单一的、明确的、权威的表示”(*《实用主义程序员*，2000，作者 A. Hunt 和 D. Thomas)。

本书的其余部分包含了许多不同的内省技术，在这些信息可用的地方。对于那些数据确实应该受到保护的罕见情况，第 3 章和第 4 章[展示了数据如何显示隐私意图或被完全隐藏。](04.html)

## 控制流

一般来说，程序的控制流就是程序在执行过程中所走的路径。控制流更常见的例子，当然包括*序列*结构，是`if`、`for,`和`while`块，它们用于管理你的代码可能需要的最基本的分支。这些块也是 Python 程序员首先要学习的一些东西，因此本节将关注一些较少使用和利用不足的控制流机制。

### 捕捉异常

第 [1](01.html) 章解释了 Python 哲学是如何鼓励在违背预期的情况下使用异常的，但是预期在不同的使用中会有所不同。当一个应用程序或模块依赖于另一个时，这种情况尤其常见，但在单个应用程序中也很常见。本质上，每当一个函数调用另一个函数时，它可以在被调用函数已经处理的异常之上添加自己的期望。

使用关键字`raise`用简单的语法引发异常，但是捕获它们稍微复杂一些，因为它使用了关键字的组合。`try`关键字在您认为可能会发生异常的地方开始一个块，而`except`关键字标记一个在出现异常时要执行的块。第一部分很简单，因为`try`没有任何附加信息，最简单的`except`也不需要任何附加信息:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figc_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figc_HTML.jpg)

```
def count_lines(filename):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    try:
        return len(open(filename, 'r').readlines())
    except:
         print('exception error reading the file or calculating lines!')
        # Something went wrong reading the file
        # or calculating the number of lines.
        return 0
myfile=input('Enter a file to open:  ')
print(count_lines(myfile))

```

任何时候在`try`块中出现异常，就会执行`except`块中的代码。就目前的情况而言，这并没有对可能出现的许多不同的异常做出任何区分；无论发生什么，函数总是返回一个数字。然而，实际上您很少想这样做，因为许多异常实际上应该传播到调用者——错误不应该无声无息地传递。一些著名的例子是`SystemExit`和`KeyboardInterrupt`，这两者通常都会导致程序停止运行。

为了考虑那些你的代码不应该干涉的异常，关键字`except`可以接受一个或多个应该被显式捕获的异常类型。任何其他的牌都会被简单地加注，就好像你根本没有`try`牌一样。这使得`except`块只关注那些应该明确处理的情况，所以你的代码只需要处理它应该管理的事情。对您刚才尝试的内容做一些小的更改，如下所示，看看效果如何:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figd_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figd_HTML.jpg)

```
def count_lines(file_name):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    try:
        return len(open(file_name, 'r').readlines())
    except IOError:
        # Something went wrong reading the file.
        return 0
my_file=input('Enter a file to open:  ')
print(count_lines(my_file))

```

通过更改代码来显式接受`IOError`，只有在从文件系统访问文件时出现问题时，`except`块才会执行。任何其他错误，比如甚至不是字符串的`filename`，都将在这个函数之外被引发，由调用堆栈中的其他代码处理。

如果您需要捕获多种异常类型，有两种方法。第一个也是最简单的方法是简单地捕获一些基类，所有必需的异常都是从这个基类派生出来的。因为异常处理与指定的类及其所有子类相匹配，所以当您需要捕捉的所有类型都有一个公共基类时，这种方法非常有效。在行计数的例子中，您可能会遇到`IOError`或`OSError`，它们都是`EnvironmentError`的后代:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Fige_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Fige_HTML.jpg)

```
def count_lines(file_name):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    try:
        return len(open(file_name, 'r').readlines())
    except EnvironmentError:
        # Something went wrong reading the file.
        return 0

```

### 注意

尽管我们只对`IOError`和`OSError`感兴趣，但是`EnvironmentError`的所有子类也会被捕获。在这种情况下，这很好，因为它们是`EnvironmentError`的唯一子类，但是一般来说，您会希望确保没有捕捉到太多的异常。

其他时候，您可能希望捕获不共享公共基类的多个异常类型，或者可能将其限制在较小的类型列表中。在这些情况下，您需要单独指定每种类型，用逗号分隔。在`count_lines()`的情况下，如果传入的文件名不是有效的字符串，也有可能引发`TypeError`:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figf_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figf_HTML.jpg)

```
def count_lines(file_name):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    try:
        return len(open(file_name, 'r').readlines())
    except (EnvironmentError, TypeError):
        # Something went wrong reading the file.
        return 0

```

如果您需要访问异常对象本身，也许是为了以后记录消息，您可以通过添加一个带有名称的 ***作为*** 子句(在下一个示例中为 ***作为 e*** )来实现，该子句将被绑定到异常对象:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figg_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figg_HTML.jpg)

```
import logging

def count_lines(file_name):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    try:
        return len(open(file_name, 'r').readlines())
    except (EnvironmentError, TypeError) as e:
        # Something went wrong reading the file.
        logging.error(e)
        return 0

```

### 兼容性:3.0 之前

在 Python 3.0 中，捕捉异常的语法变得更加明确，减少了一些常见错误。在旧版本中，用逗号将异常类型与用于存储异常对象的变量分开。为了捕获多个异常类型，您需要显式地将这些类型用括号括起来，形成一个元组。

因此，当试图捕捉两个异常类型但不在任何地方存储值时，很容易不小心忘记括号。这不是语法错误，而是只捕捉第一类异常，将其值存储在第二类异常的名称下。使用`except TypeError, ValueError`实际上存储了一个名为`ValueError`的`TypeError`对象！

为了解决这种情况，添加了关键字`as`,并成为存储异常对象的唯一方式。尽管这消除了模糊性，但为了清晰起见，多个异常仍然必须包装在元组中。

可以使用多个`except`子句，允许您以不同的方式处理不同的异常类型。例如，`EnvironmentError` OSError 的构造函数可选地接受两个参数，一个错误代码和一个错误消息，它们组合起来形成完整的字符串表示。为了只记录这种情况下的错误消息，但仍然正确处理`TypeError`的情况，可以使用两个`except`子句:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figh_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figh_HTML.jpg)

```
import logging

def count_lines(file_name):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    try:
        return len(open(file_name, 'r').readlines())
    except TypeError as e:
        # The filename wasn't valid for use with the filesystem.
        logging.error(e)
        return 0
    except EnvironmentError as e:
        # Something went wrong reading the file.
        logging.error(e.args[1])
        return 0

```

### 异常链

有时，在处理一个异常时，可能会引发另一个异常。这可以通过关键字`raise`显式实现，也可以通过作为处理的一部分执行的其他代码隐式实现。无论哪种方式，这种情况都带来了一个问题，即哪个异常足够重要，足以将其自身呈现给应用程序的其余部分。这个问题的确切答案取决于代码的布局，所以让我们看一个简单的例子，其中异常处理代码打开并写入一个日志文件:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figi_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figi_HTML.jpg)

```
def get_value(dictionary, name):
    try:
        return dictionary[name]
    except Exception as e:
        print("exception hit..writing to file")
        log = open('logfile.txt', 'w')
        log.write('%s\n' % e)
        log.close()
names={"Jack":113, "Jill":32,"Yoda":395}
print(get_value(names,"Jackz"))#change to Jack and it runs fine

```

如果在写入日志时出现任何问题，将会引发一个单独的异常。尽管这个新的异常很重要，但是已经有了一个不应该被忘记的异常。为了保留原始信息，文件异常获得了一个新属性，称为`__context__`，它保存原始异常对象。每个异常都可能相互引用，形成一个链，依次代表所有出错的地方。考虑当`get_value()`失败时会发生什么，但是`logfile.txt`是一个只读文件:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figj_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figj_HTML.jpg)

```
 get_value({}, 'test')
Traceback (most recent call last):

KeyError: 'test'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):

IOError: [Errno 13] Permission denied: 'logfile.txt'

```

这是一个隐含的链，因为异常只是通过在执行过程中遇到它们的方式联系起来的。有时您将自己生成一个异常，并且您可能需要包含一个在其他地方生成的异常。一个常见的例子是使用传入的函数来验证值。如第 [3](03.html) 和第 [4](04.html) 章所述，验证功能通常会产生一个`ValueError`，而不管错误是什么。

这是一个形成显式链的好机会，因此我们可以直接引发一个`ValueError`，同时在幕后保留实际的异常。Python 允许在`raise`语句的末尾包含`from`关键字:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figk_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figk_HTML.jpg)

```
 def validate(value, validator):
     try:
         return validator(value)
     except Exception as e:
         raise ValueError('Invalid value: %s' % value) from e

 def validator(value):
     if len(value) > 10:
         raise ValueError("Value can't exceed 10 characters")

 validate('test', validator)
 validate(False, validator)
Traceback (most recent call last):

TypeError: object of type 'bool' has no len()

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  ValueError: invalid value: False

```

因为这将多个异常封装到一个对象中，所以对于哪个异常真正被传递似乎是不明确的。要记住的一个简单规则是，最近的异常是被引发的异常，其他任何异常都可以通过`__context__`属性获得。通过将这些函数中的一个封装在一个新的`try`块中并检查异常的类型，这很容易测试:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figl_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figl_HTML.jpg)

```
 try:
     validate(False, validator)
 except Exception as e:
     print(type(e))

<class 'ValueError'>

```

### 当一切顺利的时候

另一方面，您可能会发现您有一个复杂的代码块，您需要捕捉其中一部分可能突然出现的异常，但是该部分之后的代码应该不进行任何错误处理。显而易见的方法是简单地将代码添加到`try` / `except`块之外。下面是我们如何调整`count_lines()`函数，将产生错误的代码包含在`try`块中，同时在处理完异常后进行行计数:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figm_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figm_HTML.jpg)

```
import logging

def count_lines(file_name):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    try:
        file = open(file_name, 'r')
    except TypeError as e:
        # The filename wasn't valid for use with the filesystem.
        logging.error(e)
        return 0
    except EnvironmentError as e:
        # Something went wrong reading the file.
        logging.error(e.args[1])
        return 0
    return len(file.readlines())

```

在这种特殊情况下，函数将按预期工作，所以一切似乎都很好。不幸的是，由于这一特定案例的性质，它具有误导性。因为每个`except`块都显式地从函数返回一个值，所以只有在没有引发异常的情况下，才会到达错误处理后的代码。

### 注意

我们可以在文件打开后直接放置文件读取代码，但是如果在那里出现任何异常，它们将使用与文件打开相同的错误处理被捕获。将它们分开是更好地控制异常整体处理方式的一种方式。您可能还注意到，该文件在这里的任何地方都没有关闭。随着这个函数的不断扩展，我们将在后面的章节中处理这个问题。

然而，如果`except`块只是记录了错误并继续前进，Python 会尝试计算文件中的行数，即使没有打开任何文件。相反，我们需要一种方法来指定一个代码块应该只在根本没有出现异常的情况下运行，所以你的`except`块如何执行并不重要。Python 通过`else`关键字提供了这个特性，它定义了一个单独的块:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Fign_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Fign_HTML.jpg)

```
import logging

def count_lines(filename):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    try:
        file = open(filename, 'r')
    except TypeError as e:
        # The filename wasn't valid for use with the filesystem.
        logging.error(e)
        return 0
    except EnvironmentError as e:
        # Something went wrong reading the file.
        logging.error(e.args[1])
        return 0
    else:
        return len(file.readlines())

```

### 警告

引发异常并不是告诉 Python 避免`else`块的唯一方法。如果函数在任何时候在`try`块中返回值，Python 将简单地按照指示返回值，完全跳过`else`块。

### 不考虑例外情况继续进行

许多函数执行某种类型的设置或资源分配，在将控制返回给外部代码之前，必须清理这些设置或资源分配。面对异常，清理代码可能不会总是被执行，这可能会使文件或套接字保持打开状态，或者在不再需要大对象时将它们留在内存中。

为了方便起见，Python 还允许使用一个`finally`块，每当相关的`try`、`except`和`else`块完成时，就会执行这个块。因为`count_lines()`打开了一个文件，最佳实践建议它也显式地关闭该文件，而不是等待垃圾回收来处理它。使用`finally`提供了一种确保文件总是被关闭的方法。

还有一点要考虑。到目前为止，`count_lines()`只预测了在试图打开文件时可能发生的异常，尽管在读取文件时会出现一个常见的异常:`UnicodeDecodeError`。第 7 章介绍了一点 Unicode 以及 Python 如何处理它，但是现在，只需要知道它经常出现。为了捕捉这个新的异常，有必要将`readlines ()`调用移回到`try`块中，但是我们仍然可以将行计数留在`else`块中:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figo_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figo_HTML.jpg)

```
import logging

def count_lines(file_name):
    """
    Count the number of lines in a file. If the file can't be
    opened, it should be treated the same as if it was empty.
    """
    file = None  # file must always have a value
    try:
        file = open(file_name, 'r')
        lines = file.readlines()
    except TypeError as e:
        # The filename wasn't valid for use with the filesystem.
        logging.error(e)
        return 0
    except EnvironmentError as e:
        # Something went wrong reading the file.
        logging.error(e.args[1])
        return 0
    except UnicodeDecodeError as e:
        # The contents of the file were in an unknown encoding.
        logging.error(e)
        return 0
    else:
        return len(lines)
    finally:
        if file:
            file.close()

```

当然，在一个简单的行计数函数中不太可能有这么多的错误处理。毕竟，它的存在只是因为我们想在出错时返回 0。在现实世界中，您更有可能让异常在`count_lines()`之外运行，让其他代码负责如何处理它。

### 小费

使用一个`with`块可以使这种处理变得简单一点，这将在本章后面描述。

### 优化循环

因为某种循环在大多数类型的代码中非常常见，所以确保它们尽可能高效地运行是很重要的。本章后面的迭代部分涵盖了优化任何循环设计的各种方法，而第 [5](05.html) 章解释了如何控制`for`循环的行为。相反，本节将重点介绍`while`循环的优化。

典型地，`while`用于检查在循环过程中可能改变的条件，以便一旦条件评估为假，循环可以结束执行。当条件太复杂而无法提取到单个表达式中时，或者当循环预计会由于异常而中断时，保持`while`表达式始终为真并在适当的时候使用`break`语句结束循环更有意义。

尽管任何计算结果为 true 的表达式都会产生预期的功能，但是有一个特定的值可以让它变得更好。Python 知道`True`总会计算为 true，所以它在幕后做了一些额外的优化来加速循环。本质上，它甚至不需要每次都检查条件；它只是无限期地运行循环中的代码，直到遇到异常、`break`语句或`return`语句:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figp_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figp_HTML.jpg)

```
def echo():
    """Returns everything you type until you press Ctrl-C"""

    while True:
        try:
            print(input'Type Something or CTRL C to exit: ')
        except KeyboardInterrupt:
            print()  # Make sure the prompt appears on a new line.
            print('bye for now...:')
            break
echo()

```

### 带有语句的

 *本章前面的异常处理一节中提到的`finally`块是一种在函数之后进行清理的便捷方式，但有时这是首先使用`try`块的唯一原因。有时你不想让任何异常沉默，但是你仍然想确保清理代码执行，不管发生什么。单独处理异常，一个简单版本的`count_lines()`可能看起来像这样:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figq_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figq_HTML.jpg)

```
def count_lines(file_name):
    """Count the number of lines in a file."""

    file = open(file_name, 'r')
    try:
        return len(file.readlines())
    finally:
        file.close()

```

如果文件无法打开，它甚至会在进入`try`块之前引发一个异常，而其他可能出错的事情会在 try 块中发生，这将导致`finally`块清理文件。不幸的是，仅仅为了这个而使用异常处理系统的能力是一种浪费。相反，Python 提供了另一种选择，这种选择也比异常处理有一些优势。

关键字`with`可以用来开始一个新的代码块，很像`try`，但是有一个非常不同的目的。通过使用`with`块，您定义了一个特定的上下文，块的内容应该在这个上下文中执行。然而，它的美妙之处在于，您在`with`语句中提供的对象决定了上下文的含义。

例如，您可以在`with`语句中使用`open()`来在该文件的上下文中运行一些代码。在这种情况下，`with`还提供了一个`as`子句，它允许一个对象在当前上下文中执行时被返回使用。下面是如何重写新版`count_lines()`来利用这一切的方法:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figr_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figr_HTML.jpg)

```
def count_lines(file_name):
    """Count the number of lines in a file."""

    with open(file_name, 'r') as file:
        return len(file.readlines())

```

在切换到使用`with`语句之后，`count_lines()`就只剩下这些了。异常处理由管理`with`语句的代码完成，而文件关闭行为实际上是由文件本身通过上下文管理器提供的。上下文管理器是一些特殊的对象，它们知道`with`语句，并且能够准确地定义在它们的上下文中执行代码意味着什么。

简而言之，在`with`块执行之前，上下文管理器有机会运行自己的代码；完成后，它会运行更多的清理代码。在这些阶段中的每一个阶段究竟发生了什么会有所不同。在`open()`的情况下，它打开文件，并在块执行完毕时自动关闭文件。

对于文件，上下文显然总是围绕一个打开的文件对象，使用在`as`子句中给定的名称使其对块可用。然而，有时上下文完全是环境的，所以在执行期间没有这样的对象可以使用。为了支持这些情况，`as`子句是可选的。

事实上，在`open()`的情况下，您甚至可以省略`as`子句，而不会导致任何错误。当然，您的代码也无法使用该文件，所以它没什么用，但是 Python 中没有任何东西阻止您这样做。如果在使用不提供对象的上下文管理器时包含了一个`as`子句，那么您定义的变量将简单地用`None`填充，因为如果没有指定其他值，所有函数都返回`None`。

Python 中有几个可用的上下文管理器，其中一些将在本书的其余部分详细介绍。此外，第 5 章展示了如何编写自己的上下文管理器，以便定制上下文行为来满足自己代码的需求。

### 条件表达式

通常，您可能会发现自己需要访问两个值中的一个，而使用哪个值取决于表达式的求值。例如，如果值超过特定值，则向用户显示一个字符串，否则显示另一个字符串，这是很常见的。通常，这将使用`if` / `else`组合来完成，如下所示:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figs_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figs_HTML.jpg)

```
def test_value(value):
    if value < 100:
        return 'The value is just right.'
    else:
        return 'The value is too big!'
print(test_value(55))

```

不要把它写成四行，可以用一个条件表达式把它压缩成一行。通过将`if`和`else`块转换成表达式中的子句，Python 更简洁地实现了同样的效果:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figt_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figt_HTML.jpg)

```
def test_value(value):
    return 'The value is ' + ('just right.' if value < 100 else 'too big!')
print(test_value(55))

```

### 可读性计数

如果您已经习惯了其他编程语言的这种行为，Python 的排序初看起来可能不太寻常。其他语言，比如 C++，实现了类似于`expression ? value_1 : value_2`的形式。也就是说，首先是要测试的表达式，然后是表达式为真时要使用的值，最后是表达式为假时要使用的值。

相反，Python 试图使用一种更明确地描述实际情况的形式。预期是表达式在大多数情况下为真，所以首先是关联值，然后是表达式，最后是表达式为假时要使用的值。这将整个语句考虑在内，将更常见的值放在没有表达式的地方。例如，你最终会得到类似于`return value ...`和`x = value ...`的东西。

因为表达式是随后添加的，所以它强调了表达式只是第一个值的限定的概念。"只要表达式为真，就使用该值；否则，使用另一个。”如果你习惯了另一种语言，这可能看起来有点奇怪，但是当你想到用简单的英语表达的时候，这是有意义的。

还有另一种方法，有时用于模拟本节中描述的条件表达式的行为。这经常在早期的 Python 安装中使用，那时还没有`if` / `else`表达式。取而代之的是，许多程序员依赖于`and`和`or`操作符的行为，可以让它们做一些非常类似的事情。下面是如何仅使用这些运算符来重写前面的示例:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figu_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figu_HTML.jpg)

```
def test_value(value):
    return 'The value is ' + (value < 100 and 'just right.' or 'too big!')

```

这使得组件的顺序更符合其他编程语言中使用的形式。这一事实可能会让习惯于使用这些语言的程序员感到更舒服，而且它肯定会保持与甚至更老版本的 Python 的兼容性。不幸的是，它伴随着一个隐藏的危险，这种危险通常不为人知，直到它在没有任何解释的情况下破坏了一个正常工作的程序。要了解原因，让我们来看看发生了什么。

在许多语言中，`and`操作符的工作方式类似于`&&`操作符，检查操作符左边的值是否为真。如果没有，`and`返回它左边的值；否则，计算并返回左侧的值。因此，如果值 50 被传入`test_value()`，左边的计算结果为真，`and`子句计算结果为字符串，`'just right.'`在这个过程中，代码如下所示:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figv_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figv_HTML.jpg)

```
    return 'The value is ' + ('just right.' or 'too big!')

```

从这里开始，`or`操作符的工作方式类似于`and`，检查它左边的值，看它的计算结果是否为真。不同之处在于，如果值为 true，则返回该值，甚至根本不计算运算符右侧的值。看看这里的压缩代码，很明显，`or`会返回字符串，`'just right.'`

相比之下，如果传递给`test_value()`函数的值是 150，行为就会改变。因为`150 < 100`的计算结果为假，所以`and`操作符返回该值，而不计算右边的值。在这种情况下，结果表达式如下:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figw_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figw_HTML.jpg)

```
    return 'The value is ' + (False or 'too big!')

```

因为`False`明显为假，`or`运算符反而将值返回到它右边，`'too big!'`这种行为导致很多人依赖`and` / `or`组合进行条件表达式。但是你注意到问题了吗？这里做的一个假设在很多情况下会导致整个事情失败。

当`and`子句的左侧为真时，问题出在`or`子句中。在这种情况下，`or`子句的行为完全取决于操作符左边的值。在这里显示的例子中，它是一个非空的字符串，其值总是为 true，但是如果您向它提供一个空字符串，数字 0，或者最糟糕的是，一个包含在代码执行之前无法确定的值的变量，会发生什么呢？

本质上发生的是,`and`子句的左边计算为 true，但是右边计算为 false，所以该子句的最终结果是 false 值。然后，当`or`子句求值时，它的左边为 false，所以它将值返回到它的右边。最后，不管表达式开头的值是多少，表达式总是将项目返回到`or`操作符*的右边。*

因为没有引发异常，所以看起来代码中并没有出现任何问题。相反，它只是看起来像表达式中的第一个值是假的，因为在这种情况下，它将返回您所期望的值。这可能会导致您尝试调试定义*和*值的任何代码，而不是查看真正的问题，即两个运算符之间的值。

最终，使它如此难以确定的是，你必须不信任你自己的代码，消除你对它应该如何工作的任何假设。你必须真正用 Python 的眼光看待它，而不是人类的眼光。

## 循环

通常有两种看待序列的方式:作为一个项目集合，或者作为一次访问一个项目的方式。这两者并不相互排斥，但是为了理解每种情况下可用的不同特性，将它们分开是有用的。将集合作为一个整体来处理要求所有的条目都在内存中，但是一次访问一个条目通常会更有效。

迭代指的是这种更有效的遍历集合的形式，一次只处理一个项目，然后继续处理下一个项目。对于任何类型的序列来说，迭代都是一个选项，但是真正的优势在于特殊类型的对象，它们不需要一次将所有内容都加载到内存中。这方面的典型例子是 Python 的内置`range()`函数，它似乎可以迭代给定范围内的整数:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figx_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figx_HTML.jpg)

```
>>>for x in range(5):
    print(x)
0
1
2
3
4

```

乍一看，`range()`似乎返回了一个包含适当值的列表，但事实并非如此。如果您单独检查它的返回值，而不对它进行迭代，就会显示:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figy_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figy_HTML.jpg)

```
>>>range(5)
>>>range(0, 5)
>>>list(range(5))
[0, 1, 2, 3, 4]

```

`range`对象本身不包含序列中的任何值。相反，它在迭代过程中按需一次生成一个。如果你真的想要一个可以添加或删除条目的列表，你可以通过将`range`对象传递给一个新的`list`对象来转换它。这就像一个`for`循环一样进行内部迭代，所以生成的列表使用与迭代`range`本身时相同的值。

第 5 章[展示了如何编写自己的可迭代对象，其工作方式类似于`range()`。除了提供可迭代对象之外，在不同的情况下，出于不同的目的，有许多方法可以迭代这些对象。`for`循环是最明显的技术，但是 Python 也提供了其他形式的语法，这将在本节中概述。](05.html)

### 序列解包

一般来说，你可以一次给一个变量赋一个值，所以当你有一个序列时，你可以把整个序列赋给一个变量。当序列很小时，并且您知道序列中有多少项以及每项将是什么，这是相当有限的，因为您通常最终只是单独访问每项，而不是作为序列来处理它们。

这在处理元组时尤其常见，其中序列通常具有固定的长度，并且序列中的每一项都具有预定的含义。这种类型的元组也是从一个函数返回多个值的首选方式，这使得必须将它们作为一个序列来处理更加麻烦。理想情况下，在获取函数的返回值时，您应该能够直接将它们作为单独的项进行检索。

为此，Python 支持一种称为序列解包的特殊语法。您可以在`=`操作符的左侧指定多个名称作为元组，而不是指定一个名称来赋值。这将导致 Python 解包操作符右侧的序列，将每个值分配给左侧的相关名称:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figz_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figz_HTML.jpg)

```
>>> 'propython.com'.split('.')
['propython', 'com']
>>> components = 'propython.com'.split('.')
>>> components
['propython', 'com']
>>> domain, tld = 'propython.com'.split('.')
>>> domain
'propython'
>>> tld
'com'
>>> domain, tld = 'www.propython.com'.split('.')
Traceback (most recent call last):
  ...
ValueError: too many values to unpack

```

本例末尾显示的错误说明了这种方法的唯一重大限制:要分配的变量数量必须与序列中的项目数量相匹配。如果它们不匹配，Python 就不能正确地赋值。但是，如果您将元组视为类似于参数列表，那么还有另一个选项可用。

如果您在变量列表的最后一个名称前添加一个星号，Python 将保留一个列表，其中包含无法放入其他变量的任何值。结果列表存储在 final 变量中，因此您仍然可以分配一个序列，该序列包含的项比您拥有的显式变量要多。只有当序列中的项目多于要分配的变量时，这种方法才有效。如果情况相反，您仍然会遇到前面显示的`TypeError`:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figaa_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figaa_HTML.jpg)

```
>>> domain, *path = 'propython.com/example/url'.split('/')
>>> domain
'propython.com'
>>> path
['example', 'url']

```

### 注意

第 3 章展示了类似的语法如何应用于函数参数。

### 列表理解

当序列中的项目多于实际需要的项目时，生成一个新列表并只添加那些符合特定标准的项目通常会很有用。有几种方法可以做到这一点，最明显的是使用一个简单的`for`循环，依次添加每个项目:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figab_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figab_HTML.jpg)

```
>>> output = []
>>> for value in range(10):
...     if value > 5:
...         output.append(str(value))
...
>>> output
['6', '7', '8', '9']

```

不幸的是，这给代码增加了四行和两级缩进，尽管这是一种非常常用的模式。相反，Python 为这种情况提供了更简洁的语法，允许您将代码的三个主要方面表达在一行中:

*   要从中检索值的序列

*   用于确定是否应包含某个值的表达式

*   用于为新列表提供值的表达式

这些都被组合成一种叫做列表理解的语法。下面是前面的例子在使用这个结构重写后的样子。为清晰起见，突出显示了该表单的三个基本部分:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figac_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figac_HTML.jpg)

```
>>> output = [str(value) for value in range(10) if value > 5]
>>> output
['6', '7', '8', '9']

```

正如您所看到的，整个表单的三个部分已经稍微进行了重新安排，首先是最终值的表达式，然后是迭代，最后是决定包含哪些项的条件。你也可以把包含新列表的变量看作是表单的第四部分，但是因为理解实际上只是一个表达式，所以不需要给它赋值。它可以很容易地用于将一个列表输入到一个函数中:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figad_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figad_HTML.jpg)

```
>>> min([value for value in range(10) if value > 5])
6

```

当然，这似乎违背了之前指出的迭代的全部要点。毕竟，理解返回一个完整的列表，只是在`min()`处理这些值时被丢弃。对于这些情况，Python 提供了不同的选项:生成器表达式。

### 生成器表达式

与其根据特定的标准创建一个完整的列表，还不如利用迭代的力量来完成这个过程。不要将压缩放在括号中，这表示创建了一个合适的列表，而是可以将它放在括号中，这将创建一个生成器。下面是它的实际效果:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figae_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figae_HTML.jpg)

```
>>> gen = (value for value in range(10) if value > 5)
>>> gen
<generator object <genexpr> at 0x...>
>>> min(gen)
6
>>> min(gen)
Traceback (most recent call last):
  ...
ValueError: min() arg is an empty sequence
>>> min(value for value in range(10) if value > 5)
6

```

这里发生了一些事情，但是一旦你看到了输出，就更容易理解了，这样你就有了一个参考框架。首先，生成器实际上只是一个可迭代的对象，您不必使用显式接口来创建它。第 [5](05.html) 章展示了如何手动创建迭代器，甚至如何更灵活地创建生成器，但是生成器表达式是处理它们最简单的方法。

当您创建一个发生器(无论是发生器表达式还是其他形式)时，您不能立即访问序列。生成器对象还不知道它需要迭代哪些值；它不会知道，直到它真正开始产生它们。因此，如果您没有对生成器进行迭代就查看或检查它，您将无法访问全部的值。

为了检索这些值，您需要做的就是像平常一样遍历生成器，它会很高兴地根据需要输出值。这一步在很多内置函数中隐式执行，比如`min()`。如果这些函数能够在不构建完整列表的情况下运行，那么您可以使用生成器来显著提高性能。如果他们不得不创建一个新的列表，延迟到函数真正需要创建它的时候，你也不会失去任何东西。

但是请注意，如果对生成器迭代两次会发生什么。第二次通过时，您得到一个错误，您试图在一个空序列中传递它。记住，一个生成器并不包含所有的值；当被要求这样做时，它只是迭代它们。一旦迭代完成并且不再有值需要迭代；发电机无法重启。相反，它只是在此后每次调用时返回一个空列表。

这种行为背后有两个主要原因。首先，如何重新开始这个序列并不总是显而易见的。一些可迭代的对象，比如`range()`，确实有一个明显的方法来重新启动它们自己，所以当迭代多次时它们会重新启动。不幸的是，因为有许多方法可以创建生成器——通常还有迭代器——所以由 iterable 本身来决定何时以及如何重置序列。第 [5 章](05.html)更详细地解释了这种行为，以及你如何根据自己的需要定制它。

第二，不是所有的序列一旦完成就应该被重置。例如，您可以实现一个接口，用于在一组活动用户之间循环，这些用户可能会随时间而变化。一旦您的代码完成了对可用用户的迭代，它就不应该简单地一次又一次地重置为相同的序列。不断变化的用户群意味着 Python 本身不可能猜测如何控制它。相反，这种行为由更复杂的迭代器控制。

关于生成器表达式，最后要指出的一点是:尽管它们必须总是用括号括起来，但是这些括号并不总是需要对表达式是唯一的。本节示例中的最后一个表达式简单地使用函数调用中的括号来括住生成器表达式，这也很好。

这种形式乍一看可能有点奇怪，但是在这个简单的例子中，它可以省去一组额外的括号。但是，如果生成器表达式只是多个参数中的一个，或者是更复杂的表达式的一部分，您仍然需要在生成器表达式本身周围包含显式括号，以确保 Python 知道您的意图。

### 集合理解

集合——在“集合”一节中有更详细的描述——在结构上与列表非常相似，所以你可以用与列表基本相同的方式使用理解来构建集合。两者之间唯一的显著区别是使用了花括号，而不是表达式两边的括号:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figaf_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figaf_HTML.jpg)

```
>>> {str(value) for value in range(10) if value > 5}
{'6', '7', '8', '9'}

```

### 注意

与序列不同，集合是无序的，因此不同的平台可能以不同的顺序显示项目。唯一的保证是相同的项目将出现在集合中，而不管平台如何。

### 词典释义

当然有一个主题随着不同类型的理解的构建而发展，而且仅限于一维序列。字典也可以是序列的一种形式，但是每个条目实际上是一对键和它的值。这反映在文字形式中，通过使用冒号将每个键与其值分开。

因为冒号是区分字典和集合的语法的因素，所以同一个冒号也是区分字典理解和集合理解的因素。在通常包含单个值的地方，只需提供一个键/值对，用冒号分隔。其余的理解遵循与其他类型相同的规则:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figag_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figag_HTML.jpg)

```
>>> {value: str(value) for value in range(10) if value > 5}
{8: '8', 9: '9', 6: '6', 7: '7'}

```

### 注意

记住，字典是无序的，所以它们的键很像集合。如果您需要一个具有可靠排序键的字典，请参阅本章后面的“有序字典”一节。

### 将可重复项链接在一起

在大多数情况下，使用一个 iterable 就足够了，但是有时您需要一个接一个地访问一个 iterable，对每个 iterable 执行相同的操作。简单的方法是只使用两个独立的循环，为每个循环复制代码块。合乎逻辑的下一步是将代码重构为一个函数，但是现在您在混合中有了一个额外的函数调用，它实际上只需要在循环内部完成。

相反，Python 提供了`chain()`函数，作为其`itertools`模块的一部分。`itertools`模块包括许多不同的实用程序，其中一些将在下面的章节中介绍。特别是`chain()`函数，它接受任意数量的 iterabless 并返回一个新的生成器，该生成器将依次迭代每个 iterable:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figah_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figah_HTML.jpg)

```
>>> import itertools
>>> list(itertools.chain(range(3), range(4), range(5)))
[0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4]

```

### 将可重复项压缩在一起

另一个涉及多个可重复项的常见操作是将它们并排放在一起。来自每个 iterable 的第一个项目将组合在一起形成一个元组，作为新生成器返回的第一个值。所有第二个项目都成为生成器中第二个元组的一部分，依此类推。内置的`zip()`函数在需要时提供该功能:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figai_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figai_HTML.jpg)

```
>>> list(zip(range(3), reversed(range(5))))
[(0, 4), (1, 3), (2, 2)]

```

请注意，尽管第二个 iterable 有五个值，但结果序列只包含三个值。当给定不同长度的迭代器时，`zip()`可以说是最小公分母。本质上，`zip()`确保结果序列中的每个元组的值正好与要连接在一起的迭代器的数量一样多。一旦最小的序列被用尽，`zip()`简单地停止寻找其他的。

这个功能在创建字典时特别有用，因为一个序列可以用来提供键，而另一个序列提供值。使用`zip()`可以将这些连接到正确的配对中，然后可以直接传递给新的`dict()`。在下一个例子中，ASCII 表中的 97 是小写的“a”，98 是“b”，直到(但不包括)指定的最后一个数字(102)，所以 101 是“e”。`map()`函数迭代一组值；然后将它与来自`values`的索引值 zip 配对，以构建字典:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figaj_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figaj_HTML.jpg)

```
>>> keys = map(chr, range(97, 102))
>>> values = range(1, 6)
>>> dict(zip(keys, values))
{'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4}

```

## 收集

Python 发行版中有许多众所周知的标准对象，既可以作为所有模块的内置对象，也可以作为标准包库的一部分。诸如整数、字符串、列表、元组和字典之类的对象在几乎所有 Python 程序中都是常用的，但是其他对象，包括命名元组的集合和一些特殊类型的字典，使用得不太频繁，对于那些还没有需要发现它们的人来说可能并不熟悉。

其中一些是内置类型，总是可用于每个模块，而另一些是每个 Python 安装中包含的标准库的一部分。还有更多是由第三方应用程序提供的，其中一些已经相当普遍地安装了，但是本节将只讨论 Python 本身包含的那些。

### 设置

通常，对象集合在 Python 中由元组和列表表示，但是集合提供了另一种处理相同数据的方式。本质上，集合的工作方式很像列表，但是不允许有任何重复，这使得它对于识别集合中的唯一对象很有用。例如，下面是一个简单函数如何使用集合来确定给定字符串中使用的字母:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figak_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figak_HTML.jpg)

```
>>> def unique_letters(word):
...     return set(word.lower())
...
>>> unique_letters('spam')
{'a', 'p', 's', 'm'}
>>> unique_letters('eggs')
{'s', 'e', 'g'}

```

请注意以下几点:

*   首先，内置的`set`类型将一个序列作为它的参数，用在该序列中找到的所有唯一元素填充集合。这对于任何序列都是有效的，例如示例中所示的字符串以及列表、元组、字典键或自定义可迭代对象。

*   第二，集合中的项并没有按照它们在原始字符串中出现的方式排序。集合只关心成员资格。他们跟踪集合中的项目，没有任何排序的概念。这似乎是一个限制，但如果你需要订购，你可能需要一个清单。当您只需要知道一个项目是否是集合的成员，而不考虑它在集合中的位置或者它出现了多少次时，集合是非常有效的。

*   第三，在交互式外壳中显示集合时显示的表示。因为这些表示的格式与您在源文件中输入的格式相同，所以这表明了在代码中将集合声明为文本的语法。它看起来非常类似于字典，但是没有任何与键相关联的值。这实际上是一个相当准确的类比，因为集合的工作方式非常类似于字典中键的集合。

因为集合是为不同于序列和字典的目的而设计的，所以可用的操作和方法与您可能习惯的稍有不同。然而，首先让我们看看集合相对于其他类型的行为方式。也许集合最常见的用途是确定成员资格，这是列表和字典经常需要完成的任务。本着符合期望的精神，这里使用了其他类型中常见的`in`关键字:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figal_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figal_HTML.jpg)

```
>>> example = {1, 2, 3, 4, 5}
>>> 4 in  example
True
>>> 6 in  example
False

```

此外，以后还可以在器械包中添加或删除物品。list 的`append()`方法不适用于集合，因为追加一个项目就是将它添加到末尾，这意味着集合中项目的顺序很重要。因为集合根本不关心排序，而是使用`add()`方法，它只是确保指定的项目出现在集合中。如果它已经存在，`add()`什么也不做；否则，它会将项目添加到集合中，这样就不会有任何重复项:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figam_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figam_HTML.jpg)

```
>>> example.add(6)
>>> example
{1, 2, 3, 4, 5, 6}
>>>
>>> example
{1, 2, 3, 4, 5, 6}

```

字典有一个有用的`update()`方法，它将新字典的内容添加到已经存在的字典中。集合也有一个`update()`方法，执行相同的任务:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figan_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figan_HTML.jpg)

```
>>> example.update({6, 7, 8, 9})
>>> example
{1, 2, 3, 4, 5, 6, 7, 8, 9}

```

从器械包中移除物品有几种不同的方式，每种方式都有不同的需求。对`add()`最直接的补充是`remove()`方法，它从集合中删除一个特定的项目。如果该项目一开始就不在集合中，它会引发一个`KeyError`:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figao_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figao_HTML.jpg)

```
>>> example.remove(9)
>>> example.remove(9)
Traceback (most recent call last):
  ...
KeyError: 9
>>> example
{1, 2, 3, 4, 5, 6, 7, 8}

```

然而，很多时候，该项目是否已经在集合中并不重要；你可能只关心当你用完它的时候它不在布景里。为此，集合也有一个`discard()`方法，它的工作方式类似于`remove()`，但是如果指定的项目不在集合中，它不会引发异常:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figap_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figap_HTML.jpg)

```
>>> example.discard(8)
>>> example.discard(8)
>>> example
{1, 2, 3, 4, 5, 6, 7}

```

当然，`remove()`和`discard()`都是假设你已经知道要从集合中移除什么对象。要简单地从集合中删除任何项目，可以使用`pop()`方法，该方法也是从 list API 中借用的，但略有不同。因为集合没有明确地排序，所以对于要弹出的项目来说，集合没有真正的结尾。相反，集合的`pop()`方法选择一个，不可预测地返回它供集合外使用:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figaq_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figaq_HTML.jpg)

```
>>> example.pop()
1
>>> example
{2, 3, 4, 5, 6, 7}

```

最后，集合还提供了一种一次性移除所有项目的方法，可以将其重置为空状态。`clear()`方法用于此目的:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figar_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figar_HTML.jpg)

```
>>> example.clear()
>>> example
set()

```

### 注意

空集的表示是`set()`，而不是`{}`，因为 Python 需要保持集合和字典之间的区别。为了保持与引入集合文字之前编写的旧代码的兼容性，空花括号仍然专用于字典，因此集合使用它们的名称。

除了就地修改内容的方法之外，集合还提供了两个集合以某种方式组合返回一个新集合的操作。其中最常见的是联合，在这种联合中，两个集合的内容被结合在一起，因此产生的新集合包含了两个原始集合中的所有项目。这与使用`update()`方法本质上是一样的，只是没有改变任何原始设置。

两个集合的并集很像是按位的 or 运算，所以 Python 用管道字符(`|`)来表示它，这与按位的 OR(比较每个字节)的用法相同。此外，集合使用`union()`方法提供相同的功能，可以从涉及的任一集合调用该方法:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figas_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figas_HTML.jpg)

```
>>> {1, 2, 3} | {4, 5, 6}
{1, 2, 3, 4, 5, 6}
>>> {1, 2, 3}.union({4, 5, 6})
{1, 2, 3, 4, 5, 6}

```

该操作的逻辑补充是交集，其结果是原始集合共有的所有项目的集合。同样，这类似于逐位操作，但这一次是逐位的，Python 使用&符号(`&`)来表示与集合相关的操作。集合也有一个`intersection()`方法，它执行相同的任务:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figat_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figat_HTML.jpg)

```
>>> {1, 2, 3, 4, 5} & {4, 5, 6, 7, 8}
{4, 5}
>>> {1, 2, 3, 4, 5}.intersection({4, 5, 6, 7, 8})
{4, 5}

```

您还可以确定两个集合之间的差异，从而产生一个集合，其中包含存在于其中一个集合中但不存在于另一个集合中的所有项目。通过从一个集合中删除另一个集合的内容，这很像减法，所以 Python 使用减法运算符(`–`)和`difference()`方法来执行这个操作:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figau_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figau_HTML.jpg)

```
>>> {1, 2, 3, 4, 5} – {2, 4, 6}
{1, 3, 5}
>>> {1, 2, 3, 4, 5}.difference({2, 4, 6})
{1, 3, 5}

```

除了这一基本差异，Python sets 使用`symmetric_difference()`方法提供了一种称为*对称差异*的变体。使用这种方法，得到的集合包含*在任一集合中的所有项目，但不同时包含在*中。这相当于逐位异或运算，通常称为 XOR。因为 Python 在别处使用插入符号(`^`)来表示 XOR 运算，所以集合使用相同的运算符和方法:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figav_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figav_HTML.jpg)

```
>>> {1, 2, 3, 4, 5} ^ {4, 5, 6}
{1, 2, 3, 6}
>>> {1, 2, 3, 4, 5}.symmetric_difference({4, 5, 6})
{1, 2, 3, 6}

```

最后，可以确定一个集合中的所有项目是否也存在于另一个集合中。如果一个集合包含另一个集合的所有项目，则第一个集合被视为另一个集合的超集，即使第一个集合包含第二个集合中不存在的其他项目。相反，第一个集合中的所有项目都包含在第二个集合中，即使第二个集合包含更多项目，这意味着第一个集合是第二个集合的子集。

分别通过两种方法`issubset()`和`issuperset()`来测试一个集合是另一个集合的子集还是超集。通过从一组中减去另一组并检查是否有任何项目剩余，可以手动执行相同的测试。如果没有留下任何项目，集合的计算结果为`False`，第一个项目肯定是第二个项目的子集，测试超集就像交换操作中的两个集合一样简单。使用这些方法可以避免创建一个新的集合，只是将它简化为一个布尔值:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figaw_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figaw_HTML.jpg)

```
>>> {1, 2, 3}.issubset({1, 2, 3, 4, 5})
True
>>> {1, 2, 3, 4, 5}.issubset({1, 2, 3})
False
>>> {1, 2, 3}.issuperset({1, 2, 3, 4, 5})
False
>>> {1, 2, 3, 4, 5}.issuperset({1, 2, 3})
True

>>> not ({1, 2, 3} – {1, 2, 3, 4, 5})
True
>>> not ({1, 2, 3, 4, 5} – {1, 2, 3})
False

```

### 注意

看看如何使用减法来确定子集和超集，您可能会注意到，两个相同的集合总是会减去一个空集，并且这两个集合的顺序是无关紧要的。这是正确的，因为`{1, 2, 3} – {1, 2, 3}`总是空的，所以每个集合都是另一个集合的子集和超集。

### 命名元组

字典非常有用，但是有时你可能有一组固定的可用键，所以你不需要那么大的灵活性。相反，Python 使用命名元组，它提供了一些相同的功能，但它们更有效，因为实例不需要包含任何键，只需要包含与它们相关的值。

命名元组是使用来自模块`collections`的工厂函数创建的，称为`namedtuple()`。`namedtuple()`不是返回一个单独的对象，而是返回一个新的类，它是为一组给定的名字定制的。第一个参数是 tuple 类本身的名称，但不幸的是，第二个参数没有这么简单。它接受一个属性名字符串，由空格或逗号分隔:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figax_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figax_HTML.jpg)

```
>>> from collections import namedtuple
>>> Point = namedtuple('Point', 'x y')
>>> point = Point(13, 25)
>>> point
Point(x=13, y=25)
>>> point.x, point.y
(13, 25)
>>> point[0], point[1]
(13, 25)

```

作为元组和字典之间的有效权衡，许多需要返回多个值的函数可以使用命名元组来尽可能地有用。不需要填充一个完整的字典，但是值仍然可以通过有用的名称而不是整数索引来引用。

### 有序词典

如果你曾经遍历过一个字典的键或者把它的内容打印到交互提示符下，就像本章前面所做的那样，你会注意到它的键并不总是遵循一个可预测的顺序。有时它们看起来像是按数字或字母顺序排序的，但有时看起来完全是随机的。

字典键和集合一样，被认为是无序的。尽管偶尔可能会出现模式，但这些只是实现的副产品，并没有正式定义。不仅不同字典之间的排序不一致，当使用不同的 Python 实现(如 Jython 或 IronPython)时，差异甚至更大。

大多数时候，您真正从字典中寻找的是一种将特定键映射到相关值的方法，因此键的顺序无关紧要。不过，有时以可靠的方式迭代这些键也是有用的。为了两全其美，Python 通过其`collections`模块提供了`OrderedDict`类。这提供了字典的所有功能，但具有可靠的键排序:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figay_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figay_HTML.jpg)

```
>>> from collections import OrderedDict
>>> d = OrderedDict((value, str(value)) for value in range(10) if value > 5)
>>> d
OrderedDict([(6, '6'), (7, '7'), (8, '8'), (9, '9')])
>>> d[10] = '10'
>>> d
OrderedDict([(6, '6'), (7, '7'), (8, '8'), (9, '9'), (10, '10')])
>>> del d[7]
>>> d
OrderedDict([(6, '6'), (8, '8'), (9, '9'), (10, '10')])

```

如您所见，以前使用的相同结构现在产生了一个有序的字典，即使在添加和删除条目时也能做正确的事情。

### 警告

在这里给出的例子中，注意字典的值是使用生成器表达式提供的。如果您提供了一个标准字典，这意味着您提供的值在进入有序数据库之前是无序的，然后有序数据库将假设该顺序是有意的并保留它。如果您将值作为关键字参数提供，也会发生这种情况，因为这些值是作为常规字典在内部传递的。向`OrderedDict()`提供排序的唯一可靠方法是使用标准序列，比如列表或生成器表达式。

### 带有默认值的词典

使用字典的另一个常见模式是，如果在映射中找不到某个键，总是假设某个默认值。这种行为可以通过显式捕获访问键时引发的`KeyError`或者使用可用的`get()`方法来实现，如果没有找到键，该方法可以返回合适的默认值。这种模式的一个例子是使用字典来跟踪每个单词在一些文本中出现的次数:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figaz_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figaz_HTML.jpg)

```
def count_words(text):
    count = {}
    for word in text.split(' '):
        current = count.get(word, 0) # Make sure we always have a number
        count[word] = current + 1
    return count

```

不需要处理额外的`get()`调用，`collections`模块提供了一个`defaultdict`类，可以为您处理这一步。创建它时，可以将一个 callable 作为单个参数传入，当请求的键不存在时，它将用于创建一个新值。在大多数情况下，您可以只提供一个内置类型，这将提供一个有用的基本值。在`count_words()`的情况下，我们可以用`int`:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figba_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figba_HTML.jpg)

```
from collections import defaultdict

def count_words(text):
    count = defaultdict(int)
    for word in text.split(' '):
        count[word] += 1
    return count

```

基本上任何可调用的都可以使用，但是内置类型倾向于为您需要处理的任何内容提供最佳默认值。使用`list`将给出一个空列表，`str`返回一个空字符串，`int`返回 0，`dict`返回一个空字典。如果您有更特殊的需求，任何可以不带任何参数使用的 callable 都可以。第 [3 章](03.html)介绍了 lambda 函数，对于这种情况很方便。

## 导入代码

复杂的 Python 应用程序通常由许多不同的模块组成，通常被分成包以提供更细粒度的名称空间。将代码从一个模块导入到另一个模块是一件简单的事情，但这只是事情的一部分。对于您可能遇到的更具体的情况，还有几个额外的功能。

### 后备导入

到目前为止，您已经看到了 Python 随时间变化的几个方面，有时是以向后不兼容的方式。偶尔会出现的一个特殊变化是当一个模块被移动或重命名时，但本质上仍然和以前做同样的事情。使您的代码使用它所需的唯一更新是更改到导入位置，但是您通常需要保持与更改前后版本的兼容性。

这个问题的解决方案利用 Python 的异常处理来确定模块是否存在于新位置。因为导入是在运行时处理的，所以像任何其他语句一样，您可以将它们包装在一个`try`块中，并捕捉一个`ImportError`，如果导入失败，就会引发这个事件。以下是在 Python 2.5 更改前后导入通用哈希算法的方法，Python 2.5 更改了其导入位置:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbb_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbb_HTML.jpg)

```
try:
    # Use the new library if available. Added in Python 2.5
    from hashlib import md5
except ImportError:
    # Compatible functionality provided prior to Python 2.5
    from md5 import new as md5

```

请注意，这里的导入优先选择较新的库。这是因为像这样的更改通常有一个宽限期，在此期间旧位置仍然可用，但已被废弃。如果您首先检查旧模块，您会在新模块可用后很久才发现它。通过首先检查新的功能，您可以利用任何更新的功能或添加的行为，只要它们可用，只在必要时回退到旧的功能。使用关键字`as`允许模块的其余部分简单地引用名字`md5`。

这种技术适用于第三方模块，就像适用于 Python 自己的标准库一样，但是第三方应用程序通常需要不同的处理。通常需要区分应用程序是否可用，而不是决定使用哪个模块。这与前面的例子一样，通过将 import 语句包装在一个`try`块中来确定。

然而，接下来会发生什么取决于在模块不可用的情况下应用程序应该如何表现。有些模块是严格必需的，所以如果它丢失了，您应该直接在`except ImportError`块中引发一个异常，或者干脆完全放弃异常处理。其他时候，缺少第三方模块仅仅意味着功能的减少。在这种情况下，最常见的方法是将`None`赋给包含导入模块的变量:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbc_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbc_HTML.jpg)

```
try:
    import docutils  # Common Python-based documentation tools
except ImportError:
    docutils = None

```

然后，当您的代码需要利用导入模块中的特性时，它可以使用类似于`if docutils`的东西来查看该模块是否可用，而不必重新导入它。

### 从未来导入

Python 的发布时间表经常包含新的特性，但是凭空引入它们并不总是一个好主意。特别是，语法的增加和行为的改变可能会破坏现有的代码，所以通常有必要提供一点宽限期。在转换过程中，这些新特性通过一种特殊的导入方式变得可用，允许您选择为每个模块更新哪些特性。

特殊的`__future__`模块允许你命名你想在给定模块中使用的特定特性。这为您的模块提供了一个简单的兼容性路径，因为一些模块可以依赖新的特性，而其他模块可以使用现有的特性。通常，在特性被添加到`__future__`之后的下一个版本，它成为所有模块可用的标准特性。

举个简单的例子，Python 3.0 改变了整数除法的工作方式。在早期版本中，将一个整数除以另一个整数总会得到一个整数，如果结果通常会产生余数，这通常会导致精度损失。这对熟悉底层 C 实现的程序员来说是有意义的，但这与在标准计算器上执行相同的计算是不同的，所以这造成了很多混乱。

如果除法运算包含余数，则除法运算的行为将改为返回浮点值，从而与标准计算器的工作方式相匹配。然而，在对整个 Python 进行更改之前，`division`选项被添加到了`__future__`模块中，允许在必要时提前更改行为。下面是 Python 2.5 中交互式解释器会话的样子。然而，Python 3.x 在默认情况下会像在> > > 5 / 2.0 中将 1 提升为浮点值一样处理它:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbd_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbd_HTML.jpg)

```
>>> 5 / 2  # Python 2.5 uses integer-only division by default
2
>>> from __future__ import division  # This updates the behavior of division
>>> 5 / 2
2.5

```

`__future__`模块支持许多这样的特性，Python 的每个版本都添加了新的选项。在本书的其余部分，我将在所描述的特性足够新以至于需要在 Python 的旧版本(回到 Python 2.5)中进行`__future__`导入时提到它们，而不是试图在这里列出它们。关于这些特性变化的完整细节可以在 Python 文档的“新特性”页面上找到。 <sup>[1](#Fn1)</sup>

### 注意

如果你试图从`__future__`导入一个已经存在于你正在使用的 Python 版本中的特性，它不会做任何事情。这个特性已经可用了，所以不需要做任何修改，但是它也不会引发任何异常。

### 使用 __all__ 自定义导入

Python 导入的一个很少使用的特性是能够将名称空间从一个模块导入到另一个模块。这是通过使用星号作为要导入的模块部分来实现的:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbe_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbe_HTML.jpg)

```
>>> from itertools import *
>>> list(chain([1, 2, 3], [4, 5, 6]))
[1, 2, 3, 4, 5, 6]

```

一般来说，这只是获取导入模块的名称空间中不以下划线开头的所有条目，并将它们转储到当前模块的名称空间中。它可以节省大量使用导入模块的模块中的一些输入，因为它使您不必在每次访问它的一个属性时都包含模块名。

然而，有时以这种方式使每个对象都可用是没有意义的。特别是，框架通常包括许多在框架模块中有用的实用函数和类，但是当导出到外部代码时就没什么意义了。为了控制像这样导入模块时导出什么对象，您可以在模块中的某个地方指定`__all__`。

您所需要做的就是提供一个列表——或者其他序列——其中包含在使用星号导入模块时应该导入的对象的名称。额外的对象仍然可以通过直接导入名称或者只导入模块本身而不是模块内部的任何东西来导入。下面是一个示例模块如何提供它的`__all__`选项:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbf_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbf_HTML.jpg)

```
__all__ = ['public_func']

def public_func():
    pass

def utility_func():
    pass

```

当然，在现实世界中，这两个函数都会有有用的代码。不过，为了便于说明，这里有一个导入该模块的不同方法的简要介绍，我们称之为`example`:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbg_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbg_HTML.jpg)

```
>>> import example

>>> example.public_func
<function public_func at 0x...>
>>> example.utility_func
<function utility_func at 0x...>

>>> from example import *

>>> public_func
<function public_func at 0x...>
>>> utility_func
Traceback (most recent call last):
  ...
NameError: name 'utility_func' is not defined

>>> from example import utility_func

>>> utility_func
<function utility_func at 0x...>

```

注意，在最后一种情况下，只要显式指定，您仍然可以使用`from`语法直接导入它。只有当你使用星号时`__all__`才会起作用。因此，根据您是希望所有功能都可用，还是只希望一个功能可用，您有多种选择。

### 显性比隐性好

首先使用星号符号导入通常被认为是不好的形式；Python 风格指南 PEP 8 明确建议不要这么做。它的主要问题是，模块的内容来自哪里并不明显。如果你看到一个函数在没有模块命名空间的情况下被使用，你通常可以看看模块的顶部，看看它是否被导入；如果没有，您可以放心地假设它是在模块中定义的。如果它是用星号符号导入的，您必须扫描整个模块以查看它是否被定义，或者打开相关模块的源代码以查看它是否被定义。

有时，使用星号导入仍然有用，但是最好只在将它包装在另一个名称空间中时才这样做。如第 [11](11.html) 章所示，你可以允许你的用户导入一个单一的根名称空间，这个名称空间包含了来自几个不同模块的对象。不必在每次添加新内容时都更新导入，您可以在主模块中使用星号导入，而不会在用户模块中引入任何模糊性。

### 相对进口

当开始一个项目时，你将花费大部分时间从外部包导入，所以每次导入都是绝对的；它的路径根植于你系统的`PYTHONPATH`。一旦您的项目开始增长到几个模块，您将定期从另一个模块导入。一旦建立了层次结构，您可能会意识到，当在树的相似部分的两个模块之间共享代码时，您不希望包含完整的导入路径。

Python 允许您指定想要导入的模块的相对路径，因此如果需要的话，您可以在整个包中移动，只需做最少的修改。这种方法的首选语法是用一个或多个句点指定模块路径的一部分，以指示在路径上要查找模块的位置。例如，如果`acme.shopping.cart`模块需要从`acme.billing`导入，那么下面两种导入模式是相同的:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbh_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbh_HTML.jpg)

```
from acme import billing
from .. import billing

```

单个句点允许您从当前包导入，因此`acme.shopping.gallery`可以作为`from.import gallery`导入。或者，如果您只是想从那个模块中导入一些东西，您可以简单地在模块路径前面加上必要的句点，然后像往常一样指定要导入的名称:`from.gallery import Image`。

### __import__()函数

您不必总是将导入放在模块的顶部。事实上，有时您可能根本无法提前编写一些导入。您可能会根据用户提供的设置来决定导入哪个模块，或者甚至允许用户直接指定模块。这些用户提供的设置是一种方便的方式，可以在不诉诸自动发现的情况下实现可扩展性。

为了支持这一功能，Python 允许您使用`__import__()`函数手动导入代码。它是一个内置函数，因此随处可用，但使用它需要一些解释，因为它不像 Python 提供的其他一些功能那样简单。您可以从五个参数中进行选择，以自定义模块的导入方式和检索内容:

*   `name`:唯一一个总是需要的参数，它接受应该加载的模块的名称。如果它是包的一部分，就用句点分隔路径的各个部分，就像使用`import path.to.module`时一样。

*   `globals`:命名空间字典，用于定义解析模块名的上下文。在标准的`import`情况下，内置`globals()`函数的返回值用于填充该参数。

*   `locals`:另一个名称空间字典，理想情况下用于帮助定义解析模块名称的上下文。然而，实际上，Python 的当前实现完全忽略了这一点。在未来支持的情况下，标准导入为该参数提供内置`locals()`函数的返回值。

*   `fromlist`:应该从模块导入的单个名称的列表，而不是导入整个模块。

*   `level`:一个整数，表示相对于调用`__import__()`的模块应该如何解析路径。值-1 允许绝对和隐式相对导入；0 只允许绝对导入；正值表示用于显式相对导入的路径级别。

尽管这看起来很简单，但返回值包含一些陷阱，可能会引起一些混乱。它总是返回一个模块对象，但是看到返回的是哪个模块以及该模块上有哪些可用的属性可能会令人惊讶。因为有许多不同的方式来导入模块，所以这些变化值得理解。首先，让我们看看不同类型的模块名如何影响返回值。

在最简单的情况下，您可以向`__import__()`传递一个模块名，返回值正是您所期望的:由所提供的名称引用的模块。该模块对象上可用的属性与您在代码中直接导入该名称时可用的属性相同:该模块代码中声明的整个名称空间。

但是，当您传入更复杂的模块路径时，返回值可能与预期不符。复杂的路径是使用源文件中使用的相同的点分隔语法提供的，所以例如，导入`os.path`可以通过传入"`os.path"`来实现。在这种情况下返回值是`os`，但是`path`属性允许您访问您真正寻找的模块。

这种变化的原因是`__import__()`模仿了 Python 源文件的行为，其中导入`os.path`使得`os`模块在那个名称下可用。您仍然可以访问`os.path`，但是进入主名称空间的模块是`os`。因为`__import__()`的工作方式本质上与标准导入相同，所以您在返回值中得到的就是您通常在主模块名称空间中得到的。

为了在模块路径的末端获得模块，可以采用几种不同的方法。最明显的，尽管不一定是直接的，是在句点上分割给定的模块名，使用路径的每个部分从由`__import__()`返回的模块中获得每个属性层。这里有一个简单的函数可以完成这项工作:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbi_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbi_HTML.jpg)

```
>>> def import_child(module_name):
...     module = __import__(module_name)
...     for layer in module_name.split('.')[1:]:
...         module = getattr(module, layer)
...     return module
...
>>> import_child('os.path')
<module 'ntpath' from 'C:\Python31\lib\ntpath.py'>
>>> import_child('os')
<module 'os' from 'C:\Python31\lib\os.py'>

```

### 注意

由`os.path`引用的模块的确切名称将根据它被导入的操作系统而有所不同。例如，它在 Windows 上被称为`ntpath`，而大多数 Linux 系统使用`posixpath`。大多数内容都是相同的，但是根据操作系统的需要，它们的行为可能会稍有不同，并且每种内容都可能具有该环境特有的附加属性。

正如您所看到的，它适用于简单的情况，也适用于更复杂的情况，但是它仍然要完成比实际需要更多的工作。当然，与导入本身相比，花费在循环上的时间是微不足道的，但是如果模块已经被导入，那么我们的`import_path()`函数包含了大部分的过程。另一种方法是利用 Python 自己的模块缓存机制来消除额外的处理:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbj_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbj_HTML.jpg)

```
>>> import sys
>>> def import_child(module_name):
...     __import__(module_name)
...     return sys.modules[module_name]
...
>>> import_child('os.path')
<module 'ntpath' from 'C:\Python31\lib\ntpath.py'>
>>> import_child('os')
<module 'os' from 'C:\Python31\lib\os.py'>

```

`sys.modules`字典将导入路径映射到导入时生成的模块对象。通过在字典中查找模块，就没有必要再纠结于模块名称的细节了。

当然，这真的只适用于绝对进口。相对导入，不管它们是如何被引用的，都是相对于导入语句所在的模块进行解析的——或者在本例中，是相对于`__import__()`函数调用所在的模块进行解析的。因为最常见的情况是将`import_path()`放在一个公共位置，所以相对导入将相对于该位置进行解析，而不是调用`import_path()`的模块。这可能意味着导入完全错误的模块。

### importlib 模块

为了解决直接使用`__import__()`带来的问题，Python 还包含了`importlib`模块，它提供了一个更直观的接口来导入模块。`import_module()`函数是实现与`__import__()`相同效果的一种简单得多的方法，但在某种程度上更符合预期。

对于绝对导入，`import_module()`接受模块路径，就像`__import__()`一样。然而，不同之处在于，`import_module()`总是返回路径中的最后一个模块，而`__import__()`返回第一个模块。由于这一功能，上一节中添加的额外处理变得完全没有必要，因此这是一种更好的使用方法:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbk_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbk_HTML.jpg)

```
>>> from importlib import import_module
>>> import_module('os.path')
<module 'ntpath' from 'C:\Python31\lib\ntpath.py'>
>>> import_module('os')
<module 'os' from 'C:\Python31\lib\os.py'>

```

此外，`import_module()`还通过接受一个`package`属性来考虑相对导入，该属性定义了应该从其解析相对路径的参考点。这在调用函数时很容易做到，只需传入一个始终全局的`__name__`变量，它保存了最初用于导入当前模块的模块路径:

![../images/330715_3_En_2_Chapter/330715_3_En_2_Figbl_HTML.jpg](../images/330715_3_En_2_Chapter/330715_3_En_2_Figbl_HTML.jpg)

```
import_module('.utils', package=__name__)

```

### 警告

相对导入不能直接在交互式解释器中工作。解释器运行的模块实际上不在文件系统中，所以没有相对路径可以使用。

## 令人兴奋的 Python 扩展:NIST 的随机数信标

大多数编程语言都实现了某种形式的随机数和伪随机数生成器。Python 也是如此；然而，生成这些随机数的基本算法没有其他地方的算法健壮。因此，国家标准和技术研究所(NIST)实施了一种随机信标，它每 60 秒向连接的用户发送一个真正的随机数。

从 2018 年 5 月开始，NIST 指出:“NIST 正在实施公共随机性的来源。该服务(在 [`https://beacon.nist.gov/home`](https://beacon.nist.gov/home) )使用两个独立的商用随机源，每个都有独立的硬件熵源和 SP 800-90 认可的组件。信标旨在提供*不可预测性、自主性和一致性。不可预测性*意味着用户无法在信息来源提供之前通过算法预测信息。*自主性*意味着信源可以抵抗外界改变随机比特分布的企图。*一致性*意味着一组用户可以以这样的方式访问源，他们确信他们都收到了相同的随机字符串。 <sup>[2](#Fn2)</sup>

对于需要随机值的应用程序(如游戏),您可以将随机性信标视为每 60 秒获得某种程度上可靠的随机性的好方法。这里使用了“某种程度上”一词，以说明 NIST 说不要将他们的服务用于加密需求，当然，许多人断言，由于 NIST 和国家安全局之间的连接，以及在 60 秒窗口内“随机性”可能会受到损害的事实，信标并不真正安全。然而，尽管如此，它仍然是一个有趣的，而且作者认为，有效的服务。要使用该服务，您需要先安装库所需的 [`https://www.nist.gov/programs-projects/nist-randomness-beacon`](https://www.nist.gov/programs-projects/nist-randomness-beacon) 进行访问。

### 如何安装 NIST 灯塔图书馆

无论您使用什么平台，您都可以将 NIST 信标与 Python 一起使用。有关版本和更新的信息可以在 NIST 或 [`https://pypi.org/project/nistbeacon/0.9.2`](https://pypi.org/project/nistbeacon/0.9.2) 找到。假设您使用的是 MS Windows，并且安装了 pip 并处于在线状态，安装起来就像下面这样简单:

```
pip install nistbeacon  (press enter)

```

假设您在安装过程中没有收到任何错误，尝试下面的几个例子来感受一下信标是如何工作的。

### 获取值的简单示例

在下面的例子中，从信标中获得 512 十六进制(基数 16)值，显示并转换为十进制。还获得并显示一个随机值，范围从 1 到 10。键入 ***记录。*** 在使用空闲或其他全功能 ide 时会显示许多其他功能选项。

```
#Get a 512 hex value from the beacon and display it
from nistbeacon import NistBeacon

record = NistBeacon.get_last_record()
v = record.output_value # 512 hex
r = record.pseudo_random # pick a pseudo random number
print ('Your random follows: ')
print (r.randint(1,10))  #print 1 - 10 random  #random())for floats .0 to 1.0
print()
print ('Hex original value:\n', v, '\n')
d=int(v,16) #convert to decimal
print ('Hex value converted to decimal:\n', d)

```

### 模拟滚动硬币翻转一定次数并显示正面或反面的示例

在这个例子中，每 66 秒获得一个记录，转换成十进制，然后与模数(整数除法的余数)进行比较，看它对于“偶数”是否是“奇数”，以模拟“正面”或“反面”:

```
#Coin flip-O-matic
from nistbeacon import NistBeacon
import time
print()
print ('Coin flip 0 or 1 tails or heads')
print()
print ('Run five times')
for count in range (5):
    time.sleep(66)  #wait for new beacon every 66 seconds
    h = NistBeacon.get_last_record()
    v = h.output_value #512 hex
    d=int(v,16) #convert to decimal
    coin = d% 2 #modulus of record (0 or 1)
    if coin == 0:
        print ('tails')
    else:
        print ('heads')

```

## 带着它

如果你愿意花时间学习这门语言，本章列出的特性只是 Python 所能提供的一点皮毛。本书的其余部分将在很大程度上依赖于这里所展示的内容，但是每一章都将为以后的章节增加一层内容。本着这种精神，让我们继续讨论您认为是 Python 最基本、最谦逊的特性之一:*函数*。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

参见 [`http://propython.com/whats-new`](http://propython.com/whats-new) 的“最新消息”页面。

  [2](#Fn2_source)

NIST，《NIST 随机性灯塔》， [`https://www.nist.gov/programs-projects/nist-randomness-beacon`](https://www.nist.gov/programs-projects/nist-randomness-beacon) ，2018 年 5 月 22 日访问。

 </aside>*