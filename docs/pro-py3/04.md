# 四、类

在第 [3](03.html) 章中，你回顾了*函数*如何允许你定义可重用的代码。这允许通过不必重新键入代码的“块”来简化一般的代码。然而，将这些相同的功能组合成定义特定类型对象的行为和属性的逻辑组通常更有用。这是标准的面向对象(OO)编程，在 Python 中通过*类型*和*类*来实现。这些就像函数一样，表面上看起来很简单，但是在它们背后有相当大的力量可以利用。

类最基本的想法是它封装了对象的行为，而类*的*实例*代表了对象*的数据。因此，即使数据可能会从一个实例变化到另一个实例，由底层类决定的行为在这些实例之间将保持不变。定义、扩展和改变该行为是本章的重点。

## 遗产

使用类的最简单的方法是为单一类型的对象定义一个单一的类。这对于许多简单的应用来说很好，但是您可能会发现需要对对象的行为进行更细粒度的控制。特别是，对于一个大的对象集合，通常只有一组通用的行为，但是您需要修改它们，或者为一个更小的更具体的对象集合添加新的行为。

为了方便起见，Python 允许每个类指定一个或多个提供基本行为的基类。然后，正在定义的新类可以添加新的行为或覆盖任何现有的行为。默认情况下，所有对象都继承自内置的`object`类型，尽管这本身并没有真正做任何有用的事情。它实际上只是一个支撑整个系统的基础类型，因为其他所有东西都是从它继承的。

像大多数面向对象的语言一样，Python 允许您为给定的类定义尽可能多的子类，并且您也可以对这些子类化，根据需要深入到尽可能多的层次。这种垂直的继承方法适用于大多数应用，因为它最大化了基类的有用性。当一个单独的、通常很大的行为集需要跨各种其他类重用时，垂直继承被证明非常有用。尝试一个带有显式构造函数的非常简单的 Python 类:

![img/330715_3_En_4_Figa_HTML.jpg](img/330715_3_En_4_Figa_HTML.jpg)

```py
class Contact:
    def __init__(self, lName, fName): # explicit constructor for class
        self.lastName = lName
        self.firstName = fName

worker1 = Contact("Smith", "James")
print(worker1.lastName, worker1.firstName)

```

Python 也有一些内置函数来修改你的类..这是对本章“属性”部分的前瞻，但是这些函数是 *getattr(obj，name)* 来访问对象的属性； *setattr(obj，name，value)* 设置一个对象的属性； *hasattr(obj，name)* 检查是否存在；最后， *delattr(obj，name)* 删除对象中的属性。当然，一旦创建了对象，就可以访问公共属性:

![img/330715_3_En_4_Figb_HTML.jpg](img/330715_3_En_4_Figb_HTML.jpg)

```py
class Contact:
    def __init__(self, lName, fName): # explicit constructor for class
        self.lastName = lName
        self.firstName = fName
worker1 = Contact('Smith', 'James')
print(worker1.lastName, worker1.firstName) # object.public_property
newLast=raw_input('Enter new last name: ')
setattr(worker1,'lastName',newLast) # set attribute with new value
print(worker1.lastName, worker1.firstName)
print(getattr(worker1, 'lastName')) # get existing attribute

```

作为又一示例，考虑涉及联系人管理应用的常见场景。在所有其他东西的基础上，你会有一个`Contact`类，因为，根据定义，应用中的所有东西都是一个联系人。它将有一组与之相关的字段和行为，根据应用的需要，这些字段和行为仅涵盖与所有联系人相关的内容:

![img/330715_3_En_4_Figc_HTML.jpg](img/330715_3_En_4_Figc_HTML.jpg)

```py
class Contact:
    name = TextField()
    email = EmailAddressField()
    phone = PhoneNumberField()

    def send_mail(self, message):
        # Email sending code would go here

```

现在，不要担心每个字段类来自哪里或它们在应用中如何工作的细节。如果你感兴趣，第 11 章展示了一个可能的框架来编写这样的类。现在的关键是，每个字段都代表与手头的类相关的一个数据片段。值可能由用户输入、数据库查询的结果甚至随机值生成器提供；重要的是类的结构以及子类如何使用它。

即使只有一个联系人，您也可以基于这些核心字段和行为创建一个有用的应用。提供附加功能意味着增加对不同类型联系人的支持。例如，真实的人有名字、姓氏，也许还有手机，而公司通常只有一个名字和电话号码。同样，公司会在特定行业开展业务，这对于个人来说没有任何意义:

![img/330715_3_En_4_Figd_HTML.jpg](img/330715_3_En_4_Figd_HTML.jpg)

```py
class Person(Contact):
    first_name = TextField()
    last_name = TextField()
    name = ComputedString('%(last_name)s, %(first_name)s')
    cell_phone = PhoneNumberField()

class Company(Contact):
    industry = TextField()

```

现在我们已经有了一个基本的层次结构。人和公司不一样，每个人都有适合每个案例的不同领域。Python 的继承系统自动从`Contact`类中提取字段，并使它们在`Person`和`Company`类中可用。您也可以对它们进行子类化，提供诸如`Employee`、`Friend`和`FamilyMember`这样的`Person`类型:

![img/330715_3_En_4_Fige_HTML.jpg](img/330715_3_En_4_Fige_HTML.jpg)

```py
class Employee(Person):
    employer = RelatedContact(Company)
    job_title = TextField()
    office_email = EmailAddressField()
    office_phone = PhoneNumberField()
    extension = ExtensionField()

class Friend(Person):
    relationship = TextField()

class FamilyMember(Person):
    relationship = TextField()
    birthday = DateField()

```

注意，尽管`Friend`和`FamilyMember`都有彼此相同的关系字段，`FamilyMember`并不从`Friend`继承。家庭成员不一定会成为朋友，所以阶级结构反映了这一点。每个新的子类都被自动认为是它所扩展的类的一个更具体的例子，所以继承方案反映被编码的实际关系是很重要的。

这看起来像是哲学上的细节，但它在代码中也有实际的分支。正如在本章的“自省”一节中将要展示的，Python 代码可以查看类的继承结构，所以任何不匹配都会导致你的代码将一种类型的类与另一种类型的类混淆。避免这些问题的最好方法是考虑你所表示的对象实际上是如何相互关联的，并尝试在代码中重新创建这些关系。

### 多重继承

Python 也支持类继承的水平方法，允许一个子类一次定义多个基类。这样，一个类可以从许多不同的类中获得行为，而不必深入几个层次。当然，这意味着采用不同的逻辑方法，因为您不再通过增加特异性来定义类。相反，在多重继承的一些应用中，您实际上是将每个类构建成一组组件。

像这样构建类特别适合于这样的应用，在这些应用中，您的类共享一些共同的行为，但在其他方面没有以分层的方式相互关联。为了有意义，这通常需要从相当多的组件中构建大量的类。因为这不是大多数应用的组合方式，所以在野外很少使用这种方式。

相反，多重继承经常被调用来应用支持类，称为 mixins。Mixin 类本身不提供完整的功能；相反，它们只提供了一个很小的附加特性，这个特性在很多不同的类上都很有用。一个例子可能是 mixin，当您试图访问对象上不可用的任何属性时，它返回`None`，而不是引发`AttributeError`:

![img/330715_3_En_4_Figf_HTML.jpg](img/330715_3_En_4_Figf_HTML.jpg)

```py
class NoneAttributes:
    def __getattr__(self, name):
        return None

```

`__getattr__()`方法将在本章后面的“神奇方法”一节中详细介绍，每当请求对象上不可用的属性时，就会调用该方法。因为它作为一个后备，所以它是 mixin 的一个显而易见的选择；real 类提供了自己的功能，mixin 在适当的地方添加了这些功能:

![img/330715_3_En_4_Figg_HTML.jpg](img/330715_3_En_4_Figg_HTML.jpg)

```py
class Example(BaseClass, NoneAttributes):
      pass

e = Example()
e.does_not_exist

```

在典型的应用中，垂直层次将提供大部分功能，mixins 在必要的地方添加一些额外的功能。由于在访问属性时涉及到的类的潜在数量，完全理解 Python 如何决定每个被访问的属性和方法使用哪个类变得更加重要。换句话说，你需要知道 Python 解析使用哪个方法的顺序。

### 方法解析顺序

给定一个类层次结构，Python 需要确定在试图通过名称访问属性时使用哪个类。为了做到这一点，Python 有一些规则来管理在定义新类时如何对一组基类进行排序。对于类的大多数基本用法，你不需要知道它是如何工作的，但是如果你使用多级或多重继承，本节的细节将帮助你理解真正发生了什么。

在简单的仅垂直场景中，很容易想象如何创建方法分辨率顺序(MRO)。您实际使用的类将是第一个，接下来是它的基类，然后是基类的基类，依此类推，直到您返回到根`object`类型。

在这个链的每一步，Python 都会检查这个类是否有一个带有所请求名称的属性，如果有，那就是你得到的。如果没有，它会移动到下一个。用一个简单的例子就可以很容易看出这一点。在提示符下键入并尝试:

![img/330715_3_En_4_Figh_HTML.jpg](img/330715_3_En_4_Figh_HTML.jpg)

```py
>>> class Book:
...     def __init__(self, title):
...         self.title = title
...         self.page = 1
...     def read(self):
...         return 'There sure are a lot of words on page %s.' % self.page
...     def bookmark(self, page):
...         self.page = page
...
>>> class Novel(Book):
...     pass
...
>>> class Mystery(Novel):
...     def read(self):
...         return "Page %s and I still don't know who did it!" % self.page
...
>>> book1 = Book('Pro Python')
>>> book1.read()
'There sure are a lot of words on page 1.'
>>> book1.bookmark(page=52)
>>> book1.read()
'There sure are a lot of words on page 52.'
>>> book2 = Novel('Pride and Prejudice')
>>> book2.read()
'There sure are a lot of words on page 1.'
>>> book3 = Mystery('Murder on the Orient Express')
>>> book3.read()
"Page 1 and I still don't know who did it!"
>>> book3.bookmark(page=352)
>>> book3.read()
"Page 352 and I still don't know who did it!"

```

正如你所看到的，当在一个`Mystery`对象上调用`read()`时，你得到了直接在那个类上定义的方法，而在同一个类上使用`bookmark()`使用了来自`Book`的实现。同样，`Novel`本身并没有定义任何东西——它只是为了建立一个更有意义的层次结构——所以你可以访问的所有方法实际上都来自`Book`。说得更直接一点，`Mystery`的 MRO 就是`[Mystery, Novel, Book]`，而`Novel`的 MRO 就是简单的`[Novel, Book]`。

那么，当你采用使用多重继承的水平方法时会发生什么呢？为了简单起见，我们将从提供的每个基类的单一继承层开始，这样它就是一个纯粹的水平方法。在这种情况下，Python 从左到右，按照类被定义为基类的顺序。一旦我们添加了一个`purchase() method`，这将允许用户购买这本书的副本，这就是上一个例子的样子。如果您仍然打开先前的终端会话，请尝试在我们所做的基础上添加下一部分内容:

![img/330715_3_En_4_Figi_HTML.jpg](img/330715_3_En_4_Figi_HTML.jpg)

```py
>>> class Product:
...     def purchase(self):
...         return 'Wow, you must really like it!'
...
>>> class BookProduct(Book, Product):
...     pass
...
>>> class MysteryProduct(Mystery, Product):
...     def purchase(self):
...         return 'Whodunnit?'
...
>>> product1 = BookProduct('Pro Python')
>>> product1.purchase()
'Wow, you must really like it!'
>>> product2 = MysteryProduct('Murder on the Orient Express')
>>> product2.purchase()
'Whodunnit?'

```

到目前为止，每部 MRO 都非常简单易懂，即使你不知道幕后发生了什么。不幸的是，当你开始结合两种形式的继承时，事情变得更加复杂。它甚至没有举一个非常复杂的例子来说明问题；考虑一下，当您从一个拥有自己的基类和独立 mixin 的类继承时会发生什么:

![img/330715_3_En_4_Figj_HTML.jpg](img/330715_3_En_4_Figj_HTML.jpg)

```py
class A:
    def test(self):
        return 'A'

class B(A):
    pass

class C:
    def test(self):
        return 'C'

```

这很简单，但是如果你创建一个新的类，`D`，它同时继承了`B`和`C`，如果你调用它的`test() method`，会发生什么呢？和往常一样，在交互式解释器中测试这一点很容易，你会发现答案取决于你先放哪一个。确保您在同一个会话中，并且键入了上述代码，然后尝试以下操作来查看结果:

![img/330715_3_En_4_Figk_HTML.jpg](img/330715_3_En_4_Figk_HTML.jpg)

```py
>>> class D(B, C):
...     pass
...
>>> D().test()
'A'
>>> class D(C, B):
...     pass
...
>>> D().test()
'C'

```

从表面上看，似乎很容易假设 Python 只是深度优先；它会查看第一个基类，并一直跟踪下去，寻找所请求的属性，只有在找不到所需的属性时，才会移动到下一个基类。这个观察对于这个和许多其他的例子来说当然是正确的，但是它仍然不是故事的全部。真正发生的事情会将整个继承方案考虑在内。

然而，在阐明完整的算法之前，让我们先弄清楚一件事。Python 关注的第一个名称空间总是实例对象。如果在那里找不到该属性，它将转到提供该对象行为的实际类。这两个名称空间总是首先被检查的两个名称空间，不管任何可能正在使用的继承结构。只有在没有找到属性的情况下，Python 才会尝试通过类继承来定位它。

Python 并没有把整个继承结构看作一棵树，而是试图把它展平成一个列表，每个类只出现一次。这是一个重要的区别，因为两个基类在链的更深处继承同一个类是可能的，但是查看那个类两次只会导致以后的混乱。为了解决这个和其他潜在的问题，需要一个单一的、平面的列表。

第一步是确定从一个类到它的最基本类的所有不同路径。因为两个原因，即使没有基类，也总会有至少一个路径。首先，给定类的 MRO 总是将类本身放在第一位。从前面的描述来看，这似乎是显而易见的，但是算法的其余部分将清楚地说明为什么明确地陈述这一点是重要的。此外，每个类都隐式继承自`object`，所以这是在每个 MRO 的末尾。

所以，对于一个简单的类，`A`，它不继承任何东西，它的 MRO 只是一个简单的两元素列表:`[A, object]`。如果你有另一个类，`B`，它的子类是`A`，它的 MRO 也变得相当明显，是`[B, A, object]`。一旦引入了一点多重继承，同一个类就有可能在整个树中出现不止一次，所以我们需要做一些额外的工作来整理 MRO。

考虑一个新的类，`C`，它继承自`B`和`A`。现在`A`出现在两个不同的分支下，离新类`C`有两个不同的距离。

### 注意

这样做可能没有意义，因为`B`已经继承了`A`。但是，请记住，您可能并不总是预先知道基类在幕后做什么。你可以扩展从其他地方传入你的代码的类或者动态生成的类，就像本章后面将要展示的那样。Python 不知道你的类是如何布局的，所以它必须能够考虑所有的可能性。

![img/330715_3_En_4_Figl_HTML.jpg](img/330715_3_En_4_Figl_HTML.jpg)

```py
>>> class A:
...     pass
...
>>> class B(A):
...     pass
...
>>> class C(B, A):
...     pass
...

```

对象的 MRO 显然只是`[object]`，正如你所料，A 已经显示为`[A, object]`。`B`明明是`[B, A, object]`，那`C`呢？首先看它的深度，一旦删除了重复的 A，你可能会猜到`[C, B, A, object]`。采用广度优先(先水平后垂直)的方法，您会想到`[C, A, B, object]`。

那么 Python 到底走哪条路呢？事实是，这两种说法都不准确；Python 使用一种叫做 C3 的算法。这个算法考虑了所有的继承，一次减少一层，直到只剩下一个列表。在每个级别，C3 处理为该级别的所有父类别创建的类别列表。因此，它从最普通的类`object`开始，并从那里继续向外扩展。

有了`C`,我们终于可以详细了解算法是如何工作的了。到 Python 遇到`C`的时候，`A`和`B`都已经被处理了，所以它们的 mro 是已知的。为了将它们结合起来，C3 查看每个父 MRO 中的第一个类，看它是否能找到一个候选项，以包含在`C`的 MRO 中。当然，这回避了一个问题，即什么才是有效的候选人。

用于识别候选类别的唯一标准是它是否仅存在于所考虑的任何 MRO 列表的第一位。不一定要全部都有，但是如果有，一定是列表中的第一个。如果它在任何列表中的任何其他位置，C3 将跳过它，直到它的下一次传递。一旦找到一个有效的条目，它就把它拉入新的 MRO，并使用相同的过程寻找下一个。

### 例如:C3 算法

因为算法实际上只是代码，所以让我们构建一个简单的 C3 函数来执行必要的线性化——将继承树简化为一个列表。然而，在深入完整的实现之前，让我们先看看函数调用是什么样子的，这样我们就知道它将处理什么数据。对于`C`，它看起来像这样:

```py
C3(C, [B, A, object], [A, object], [B, A])

```

第一个参数是类本身，后面是其父类的已知 MRO 列表，按照它们在类中定义的顺序。然而，最后一个参数只是父类本身的列表，没有它们的完整 mro。正如稍后对`C`稍加修改后所显示的，这个额外的参数对于解决一些歧义是必要的。

与任何功能一样，在完成真正的繁重工作之前，有一些令人厌烦的细节需要落实到位。在 C3 的例子中，会有一些对 MRO 列表的修改，我们不希望这些修改影响到调用 C3 函数的代码，所以我们必须复制它们来使用。此外，我们需要建立一个新的列表来包含算法生成的最终 MRO:

![img/330715_3_En_4_Figm_HTML.jpg](img/330715_3_En_4_Figm_HTML.jpg)

```py
def C3(cls, *mro_lists):
    # Make a copy so we don't change existing content
    mro_lists = [list(mro_list[:]) for mro_list in mro_lists]

    # Set up the new MRO with the class itself
    mro = [cls]

    # The real algorithm goes here.

    return mro

```

我们不能在这里使用`mro_list[:]`,因为它只是复制了外部列表。该列表中包含的所有其他列表都将保留，因此对它们的任何修改在函数外部都是可见的。通过使用列表理解并复制每个内部列表，我们得到了所有相关列表的副本，因此它们可以被安全地修改。

### 稳健性原则

如果你已经知道 Python 的复制模块——或者你已经跳到第六章[了——你可能想知道为什么我们不用`copy.` d `eepcopy(mro_list)`来代替。至少，你可能想知道这个额外的列表(mro_list[:])是干什么用的，因为我们已经在传入列表了。通过将每个内部序列显式地转换为列表，并将其全部包装在一个列表理解中，我们可以允许函数接受任何有效的序列类型，包括元组，这些元组在创建后不能被修改(就像常量一样)。这使得 C3 函数在接受的内容上更加自由。](06.html)

内务处理结束后，我们可以继续讨论主算法。因为我们事先不知道每个 MRO 中有多少个类，所以最好将主工作负载包装在一个简单的`while True`循环中，该循环将无限期执行，这样我们就可以使用`break`和`continue`来控制它的流程。当然，这意味着您不应该尝试执行这段代码，直到稍后，直到我们有了必要的控制代码。

该循环中的第一个任务是遍历每个 MRO 列表，获取它的第一个类，并查看它是否在任何其他列表中除了第一个之外的任何位置。如果是，那么这个类还不是一个有效的候选类，我们需要移动到下一个列表中的第一个类。下面是执行这些最初步骤所必需的循环:

![img/330715_3_En_4_Fign_HTML.jpg](img/330715_3_En_4_Fign_HTML.jpg)

```py
import itertools

def C3(cls, *mro_lists):
    # Make a copy so we don't change existing content
    mro_lists = [list(mro_list[:]) for mro_list in mro_lists]

    # Set up the new MRO with the class itself
    mro = [cls]

    while True:
        for mro_list in mro_lists:
            # Get the first item as a potential candidate for the MRO.
            candidate = mro_list[0]

            if candidate in itertools.chain(*(x[1:] for x in mro_lists)) :
                # The candidate was found in an invalid position, so we
                # move on to the next MRO list to get a new candidate.
                continue

    return mro

```

这里使用的链将所有 MRO 列表中的所有非第一类减少到一个列表中，因此更容易测试当前候选项是否有效。当然，当前代码只在候选无效时才响应。如果在那个链中没有找到，它就是一个有效的候选，可以马上提升到最终的 MRO。

此外，我们需要从发现该候选人的 MRO 名单中删除该候选人，以及可能发现该候选人的任何其他名单。由于我们知道它只能是任何列表中的第一项，并且不会出现在这一轮已经处理过的任何列表中，所以这变得稍微容易了一点。因此，我们可以只查看每个剩余的候选项，并删除被提升的类。无论如何，这一次不应该为新的候选人处理其他 MRO 列表，所以我们还需要添加一个`continue`:

![img/330715_3_En_4_Figo_HTML.jpg](img/330715_3_En_4_Figo_HTML.jpg)

```py
    while True:
    # Reset for the next round of tests
        candidate_found = False

        for mro_list in mro_lists:
            if not len(mro_list):
                # Any empty lists are of no use to the algorithm.
                continue

            # Get the first item as a potential candidate for the MRO.
            candidate = mro_list[0]

            if candidate_found:
                # Candidates promoted to the MRO are no longer of use.
                if candidate in mro:
                    mro_list.pop(0)
                # Don't bother checking any more candidates if one was found.
                continue

            if candidate in itertools.chain(*(x[1:] for x in mro_lists)) :
                # The candidate was found in an invalid position, so we
                # move on to the next MRO list to get a new candidate.
                continue

            else:
                # The candidate is valid and should be promoted to the MRO.
                mro.append(candidate)
                mro_list.pop(0)
                candidate_found = True

```

### 注意

既然我们要从 MRO 列表中删除项目，我们还必须添加额外的代码来处理其中一个列表被完全清空的情况。因为空列表中没有任何有价值的东西，所以循环会继续到下一个。

现在候选选择已经完成，剩下的事情就是告诉算法它的工作什么时候完成，它应该退出循环。按照现在的情况，它会完全清空列表，但是会一直循环下去，永远不会返回新的 MRO。识别这种情况的关键是它确实会清空所有的列表。因此，我们可以检查剩余的 MRO 列表，看看是否还有任何类。如果没有，就完成了，可以结束循环:

![img/330715_3_En_4_Figp_HTML.jpg](img/330715_3_En_4_Figp_HTML.jpg)

```py
    while True:
        # Reset for the next round of tests
        candidate_found = False

        for mro_list in mro_lists:
            if not len(mro_list):
                # Any empty lists are of no use to the algorithm.
                continue

            # Get the first item as a potential candidate for the MRO.
            candidate = mro_list[0]

            if candidate_found:
                # Candidates promoted to the MRO are no longer of use.
                if candidate in mro:
                    mro_list.pop(0)
                # Don't bother checking any more candidates if one was found.
                continue

            if candidate in itertools.chain(*(x[1:] for x in mro_lists)) :
                # The candidate was found in an invalid position, so we
                # move on to the next MRO list to get a new candidate.
                continue

            else:
                # The candidate is valid and should be promoted to the MRO.
                mro.append(candidate)
                mro_list.pop(0)
                candidate_found = True

        if not sum(len(mro_list) for mro_list in mro_lists):
            # There are no MROs to cycle through, so we're all done.
            # note any() returns false if no items so it could replace sum(len)
            break

```

这个循环，在已经提到的 C3 函数中，可以成功地为任何有效的 Python 继承模式创建一个 MRO。回到前面提到的对`C`类的函数调用，我们会得到下面的结果。请注意，我们在这里使用的是字符串而不是实际的类，以便于说明。无论如何，C3 算法实际上与类无关；这只是为了消除可能包含重复项的层次结构:

```py
>>> C3('C', ['B', 'A', 'object'], ['A', 'object'], ['B', 'A'])
['C', 'B', 'A', 'object']

```

这很好，但是还有另一个相关的情况需要注意:当`C`在`B`之前继承`A`时会发生什么？人们会从逻辑上假设在`A`上找到的任何属性都会在`B`上的属性之前使用，即使`B`的 MRO 将`B`放在`A`之前。这将违反类继承中的一个重要的一致性:MRO 中项目的顺序应该在它未来的所有子类中保持。

这些子类可以在它们的 MRO 中添加新的物件，甚至可以将它们插入到基类 MRO 中的物件之间，但是所有相关的 mro 仍然应该保持原来的顺序。所以当做类似于`C(A, B)`的事情时，正确的结果实际上会与用户的期望不一致。

这就是为什么 C3 算法要求将基类本身添加到传入的 mro 列表中。如果没有它们，我们可以用这个新的结构调用 C3 算法，得到与原始排序相同的结果:

```py
>>> C3('C', ['B', 'A', 'object'], ['A', 'object'])
['C', 'B', 'A', 'object']
>>> C3('C', ['A', 'object'], ['B', 'A', 'object'])
['C', 'B', 'A', 'object']

```

尽管看起来这两个人应该做不同的事情，但实际上他们最终会做同样的事情。然而，通过在末尾添加额外的类列表，C3 的行为发生了一点变化。第一个候选人是`A`，在`B`的 MRO 的第二个位置，所以本轮跳过`A`。下一个候选项是`B`，它在最后一个参数中添加的列表中，所以也被跳过。当检查最终列表时，再次跳过 A。

这意味着 C3 完成了一个完整的循环，而没有找到任何有效的候选，这就是它如何检测像`C(A, B)`这样的不适当的构造。如果没有有效的候选项，则不会从任何列表中删除任何项目，并且主循环将使用完全相同的数据再次运行。没有对无效情况的任何额外处理，我们当前的 Python 实现将简单地无限期继续下去。最好提出一个例外。然而，首先让我们通过用`C(A, B)`检查 Python 自身的行为来验证这个假设。假设您键入了前面的示例，请尝试以下操作:

![img/330715_3_En_4_Figq_HTML.jpg](img/330715_3_En_4_Figq_HTML.jpg)

```py
>>> class A:
...     pass
...
>>> class B(A):
...     pass
...
>>> class C(A, B):
...     pass
...
Traceback (most recent call last):
  ...
TypeError:  Cannot create a consistent method resolution
order (MRO)  for bases B, A

```

果然，Python 的类系统不允许这种构造，以迫使开发人员只创建有意义的类。在我们自己的 C3 类中复制这个功能是相当容易的，因为我们知道如何识别无效的情况。我们所要做的就是在循环结束时进行检查，看看是否找到了有效的候选对象。如果没有，我们可以提出一个`TypeError`:

![img/330715_3_En_4_Figr_HTML.jpg](img/330715_3_En_4_Figr_HTML.jpg)

```py
import itertools

def C3(cls, *mro_lists):
    # Make a copy so we don't change existing content
    mro_lists = [list(mro_list[:]) for mro_list in mro_lists]

    # Set up the new MRO with the class itself
    mro = [cls]

    while True:
        # Reset for the next round of tests
        candidate_found = False

        for mro_list in mro_lists:
            if not len(mro_list):
                # Any empty lists are of no use to the algorithm.
                continue

            # Get the first item as a potential candidate for the MRO.
            candidate = mro_list[0]

            if candidate_found:
                # Candidates promoted to the MRO are no longer of use.
                if candidate in mro:
                    mro_list.pop(0)
                # Don't bother checking any more candidates if one was found.
                continue

            if candidate in itertools.chain(*(x[1:] for x in mro_lists)) :
                # The candidate was found in an invalid position, so we
                # move on to the next MRO list to get a new candidate.
                continue

            else:
                # The candidate is valid and should be promoted to the MRO.
                mro.append(candidate)
                mro_list.pop(0)
                candidate_found = True

        if not sum(len(mro_list) for mro_list in mro_lists):
            # There are no MROs to cycle through, so we're all done.
            break

        if not candidate_found:
            # No valid candidate was available, so we have to bail out.
            break
            raise TypeError("Inconsistent MRO")

    return mro

```

有了这最后一部分，我们的 C3 实现与 Python 自身的行为相匹配，涵盖了所有的基础。大多数任意的类继承结构都可以简化为一个有效的 MRO，所以你通常不需要太担心算法是如何工作的。然而，类有一个特性——`super() function`—广泛依赖于 MRO。

### 使用 super()将控制传递给其他类

创建子类的一个最常见的原因是覆盖一些现有方法的行为。这可能像每次调用方法时记录日志一样简单，也可能像用不同的实现完全替换其行为一样复杂。在前一种情况下，您只是简单地调整现有的行为，能够直接使用原始的实现是非常有用的，这样您就不必为了做一些小的更改而重新发明轮子。

为了实现这一点，Python 提供了内置的`super() function`，这一点经常被误解。对`super()`的常见解释是，它允许您在子类的被覆盖方法中调用基类的方法。这种描述在一定程度上是可行的，但在更全面地解释它之前，让我们先看看它在简单情况下的表现，看看这到底意味着什么:

![img/330715_3_En_4_Figs_HTML.jpg](img/330715_3_En_4_Figs_HTML.jpg)

```py
class A(object):
    def afunction(self):
        print('afunction from Class A')
class B(A):
    def __init__(self):
        print('B is constructed!!!') # constructor for B
    def afunction(self):
        return super(B, self).afunction()
sample1=B()
print(sample1.afunction())

```

在这个简单的例子中，`super()`返回方法的基类。基于我们刚刚读到的内容，`super()`查看 MRO 中的下一个类，在本例中是类 a。注意，我们说“被覆盖”，因为我们有两个名为 *afunction* 的函数。

接下来，考虑一个应用，该应用需要创建一个字典，为任何还没有关联值的键自动返回`None`。这与`defaultdict`相当类似，但它不必每次都创建一个新值；它刚刚返回`None`:

![img/330715_3_En_4_Figt_HTML.jpg](img/330715_3_En_4_Figt_HTML.jpg)

```py
>>> class NoneDictionary(dict):
...     def __getitem__(self, name):
...         try:
...             return super(NoneDictionary, self). __getitem__(name)
...         except KeyError:
...             return None
...
>>> d = NoneDictionary()
>>> d['example']
>>> d['example'] = True
>>> d['example']
True

```

在进一步深入之前，重要的是要认识到`super()`在这里真正在做什么。在一些语言中，`super()`仅仅是一种语言特性，被编译成一些特殊的代码来访问其他类的方法。然而，在 Python 中，`super()`返回一个实际的对象，该对象具有一组基于其使用位置的属性和方法。

从这个简单的例子来看，`super()`似乎只是提供了对基类上的一个方法的访问，但是请记住，可以包含任意数量的基类，在每个类上指定不止一个。鉴于某些继承结构的复杂性，现在应该很清楚 Python 将使用 MRO 来决定使用哪种方法。然而，可能不明显的是在查找方法时使用哪个 MRO。

仅仅看一下，你可能会认为 Python 使用了使用了`super()`的类的 MRO，在这里给出的例子中是`NoneDictionary`。因为大多数情况看起来非常像那个例子，所以这个假设足够准确，可以解释大多数情况。然而，更复杂的类层次结构提出了一个问题，当子类中的 MRO 发生变化时会发生什么。考虑下面的一组类；但是，开始一个新的 Python 会话，因为这些类定义与我们的第一个示例略有不同:

![img/330715_3_En_4_Figu_HTML.jpg](img/330715_3_En_4_Figu_HTML.jpg)

```py
>>> class A:
...     def test(self):
...         return 'A'
...
>>> class B(A):
...     def test(self):
...         return 'B->' + super(B, self). test()
...
>>> B().test()
'B->A'

```

在这个例子中，在`B`中使用`super()`指的是它的基类`A`，正如所料。它的`test()`方法包含一个对自身的引用，所以如果事情发生变化，我们将能够一路看到。除了`B`，我们可以定义另一个类`C`，它也是`subclasses A`。为了更好地说明未来的事情，`C`将实现它自己的`test()`方法，而不使用`super()`:

![img/330715_3_En_4_Figv_HTML.jpg](img/330715_3_En_4_Figv_HTML.jpg)

```py
>>> class C(A):
...     def test(self):
...         return 'C'
...
>>> C().test()
'C'

```

当然，到目前为止，这没有什么不寻常或有问题的，因为它没有以任何方式与`A`或`B`交互。当我们创建一个新类`D`时，事情变得有趣起来，这个新类又包含了`B`和`C`两个子类。它不需要一个`test() method`，所以我们只是把它的主体留白，让它尽可能的简单。现在让我们看看`test()`会发生什么:

![img/330715_3_En_4_Figw_HTML.jpg](img/330715_3_En_4_Figw_HTML.jpg)

```py
>>> class D(B, C):
...     pass
...
>>> D().test()
'B->C'

```

现在我们终于可以看到发生了什么。我们可以看到`test()`在`B`上被调用，导致其在输出中引用，但是当它调用`super().test()`时，引用的是`C`的方法，而不是`A`上的方法。如果 Python 只是使用了定义方法的类的 MRO，它将引用`A`，而不是`C`。相反，因为它使用了`C`，我们可以深入了解`super()`的实际工作原理。

在最常见的情况下，包括这里显示的用法，`super()`接受两个参数:一个类和该类的一个实例。正如我们的示例所示，实例对象决定了哪个 MRO 将用于解析结果对象的任何属性。所提供的类确定了 MRO 的子集，因为`super()`只使用 MRO 中出现在所提供的类之后的那些条目。

推荐的用法是提供将`super()`用作第一个参数的类，将标准 self 用作第二个参数。产生的对象将保留`self`的实例`namespace`字典，但是它只检索在 MRO 中比提供的类更晚的类上定义的属性。然而，从技术上讲，您可以传入不同的类并得到不同的结果:

![img/330715_3_En_4_Figx_HTML.jpg](img/330715_3_En_4_Figx_HTML.jpg)

```py
>>> class B(A):
...     def test(self):
...         return 'B->' + super(C, self). test()
...
>>> class D(B, C):
...     pass
...
>>> D().test()
'B->A'

```

在这个例子中，当`B`在对`super()`的调用中实际引用了`C`时，产生的 MRO 跳过`C`，直接移动到`A`，这通过再次调用`test()`来显示。然而，在通常的实践中，这是一件危险的事情，正如试图单独使用`B`时所示:

![img/330715_3_En_4_Figy_HTML.jpg](img/330715_3_En_4_Figy_HTML.jpg)

```py
>>> B().test()
Traceback (most recent call last):
  ...
TypeError:  super(type, obj):  obj must be an instance or subtype of type

```

因为在这种情况下 self 不是`C`的子类，`C`不在 MRO 的任何地方，所以`super()`不能确定它应该从哪里开始寻找属性。与其创建一个无用的对象，只为每件事抛出一个`AttributeError`，`super()`在第一次被调用时会失败，提供一个更好的错误消息。

### 警告:小心你的论点

使用`super()`时一个常见的错误是在一个方法上使用它，这个方法在所有不同的类中不会总是有相同的签名。在我们这里的例子中，test()方法不接受任何参数，所以很容易确保它是一致的。许多其他情况，比如前面提到的`__getitem__()`，都是标准协议，它们的函数签名不应该被任何子类显著改变。第 5 章更详细地展示了这些案例。

不幸的是，你不能总是知道另一个类会做什么，所以使用 super()有时会给给定的类提供错误的参数，从而导致问题。当然，这与传入一个与另一个函数所期望的协议不同的对象并没有什么不同。

使用 super()值得注意的原因是，很容易假设您知道实际调用的是什么函数。如果没有对 mro 如何工作以及`super()`如何决定使用哪些属性的深刻理解，问题似乎会突然出现。然而，即使对这些主题有透彻的了解，对这类问题唯一真正的防御是所有涉及的类之间达成不改变方法签名的协议。

### 反省

考虑到所有可用的不同继承选项，Python 提供了许多工具来识别一个类使用什么结构是合适的。与类一起使用的最明显的自省任务是确定一个对象是否是给定类的实例。这个行为是使用内置的`isinstance() function`提供的，它将任意对象作为第一个参数，将一个 Python 类作为第二个参数。只有当给定的类在对象类的继承链中的任何位置时，才会`isinstance() return True`:

![img/330715_3_En_4_Figz_HTML.jpg](img/330715_3_En_4_Figz_HTML.jpg)

```py
>>> isinstance(10, int)
True
>>> isinstance('test', tuple)
False

```

对`isinstance()`的一个自然补充是确定一个类在其继承链中是否有另一个类的能力。这个特性是由内置的`subclass() function`提供的，工作方式和`isinstance()`一样，除了它操作的是一个类而不是它的一个实例。如果第一个类在其继承链中包含第二个类，`issubclass()`返回`True`:

![img/330715_3_En_4_Figaa_HTML.jpg](img/330715_3_En_4_Figaa_HTML.jpg)

```py
>>> issubclass(int, object)
True
>>> class A:
...     pass
...
>>> class B(A):
...     pass
...
>>> issubclass(B, A)
True
>>> issubclass(B, B)
True

```

最后一个例子可能看起来很奇怪，因为`B`显然不能成为自身的子类，但是这种行为是为了与`isinstance()`保持一致，如果所提供的对象的类型与所提供的类完全相同，那么它将返回`True`。简而言之，这两者之间的关系可以用一个简单的表达式来描述，这个表达式总是正确的:

```py
isinstance(obj, cls) == issubclass(type(obj), cls)

```

如果您想了解特定类的继承结构的更多信息，有一些不同的工具可供您使用。如果您想知道为一个特定的类定义了哪些基类，只需访问它的`__bases__`属性，该属性将在一个元组中包含这些基类。但是，它只提供了直接基类，而没有任何比它扩展得更深的类:

![img/330715_3_En_4_Figab_HTML.jpg](img/330715_3_En_4_Figab_HTML.jpg)

```py
>>> B.__bases__
(<class '__main__.A'>,)

```

另一方面，每个类也有一个`__subclasses__()`方法，它返回你正在处理的类的所有子类的列表。像`__bases__`一样，这与你正在处理的类只差一级。任何进一步的子类都需要使用一些其他机制来跟踪子类，其中一些将在本书的后面讨论:

![img/330715_3_En_4_Figac_HTML.jpg](img/330715_3_En_4_Figac_HTML.jpg)

```py
>>> A.__subclasses__()
[<class '__main__.B'>]

```

如果您想要更多的信息和控制，每个类还有一个`__mro__`属性，它在一个元组中包含该类的完整 MRO。如前所述，这还包括您传入的实际类及其任何父类。您甚至可以在第一个例子中尝试使用前面使用的`super()`:

![img/330715_3_En_4_Figad_HTML.jpg](img/330715_3_En_4_Figad_HTML.jpg)

```py
>>> B.__mro__
(<class '__main__.B'>, <class '__main__.A'>, <class 'object'>)

```

## 如何创建类

在 Python 中定义一个类的工作方式与在许多其他语言中不同，尽管差异并不总是显而易见的。这看起来很简单:你提供一个名字，可能是一个继承的基类，一些属性和一些方法。但是当 Python 遇到这种声明时，所发生的过程实际上与函数有着比您可能意识到的更多的共同点。

首先，类声明的主体是一个代码块。就像`if`、`for,`和`while`一样，一个类块的主体可以包含任何有效的 Python 代码，这些代码将自顶向下执行。它将跟随函数调用，执行错误处理，读取文件，或者你要求它做的任何事情。事实上，`if`块在类声明中非常有用:

![img/330715_3_En_4_Figae_HTML.jpg](img/330715_3_En_4_Figae_HTML.jpg)

```py
>>> try:
...     import custom_library
... except ImportError:
...     custom_library = None
...
>>> class Custom:
...     if custom_library is not None:
...         has_library = True
...     else:
...         has_library = False
...
>>> Custom.has_library
False

```

### 小费

此示例仅用于演示目的。如果您希望获得这里显示的确切效果，那么简单地将表达式`custom_library is not None`直接分配给`has_library`属性要实用得多。不管怎样，它都会返回一个布尔值，所以最终结果是相同的，但这是一种更常见的处理手头任务的方法。

Python 执行完内部代码后，您会注意到`has_library`变成了类对象的一个属性，可供代码的其余部分使用。这是可能的，因为 Python 的类声明有点像函数。当发现一个新类时，Python 首先为其中的代码块创建一个新的名称空间。执行代码块时，任何赋值都是在新的命名空间中进行的。然后，创建的名称空间用于填充一个新的对象，该对象实现了新的类。

### 在运行时创建类

前一节提到了 Python 在执行代码、编译和解释时创建类型`objects`的事实。与运行时发生的几乎所有其他事情一样，您可以自己挂钩到该流程中，并利用它来获得优势。这样做利用了 Python 在遇到类时在幕后所做的事情。

真正重要的事情发生在类的内容被处理之后。此时，Python 获取类名称空间，并将其与其他一些信息一起传递给内置的`type()`，后者创建或“实例化”新的类对象。这意味着所有的类实际上都是`type()`的子类，它是所有类的基础。具体来说，`type()`使用三条信息来实例化一个类:

*   声明的类的名称

*   定义的类应该继承的基类

*   执行类主体时填充的命名空间字典

这些信息是表示整个类所必需的，即使 Python 通过检查类声明自动获得这些信息，您也可以通过直接传入这些值来创建类型。

名字是最简单的，因为它只是一个带有类名的字符串。基类稍微复杂一些，但是它们仍然相当简单:只需提供一个包含新类应该继承的现有类对象的序列。名称空间字典就是这样:一个字典，恰好包含了应该通过名称附加到新类的所有内容。下面的例子说明了如何用两种不同的方法创建同一个类:

![img/330715_3_En_4_Figaf_HTML.jpg](img/330715_3_En_4_Figaf_HTML.jpg)

```py
>>> class Example(int):
...     spam = 'eggs'
...
>>> Example
<class '__main__.Example'>

>>> Example = type('Example', (int,), {'spam': 'eggs'})

>>> Example
<class '__main__.Example'>

```

### 不要重复你自己

你会注意到这个例子最后不得不写名字`Example`两次，这似乎违反了 DRY 原则。但是，请记住，这里实际上有两件事情在进行，而且这两件事情并不相互关联。首先，正在创建类，这需要我们提供一个名称。其次，新类被绑定到名称空间中的一个名称。

这个示例对两个操作使用了相同的名称，部分是为了方便，部分是为了与上面的本机类声明兼容。然而，命名空间的分配与类的创建是完全分开的，因此可以使用任何名称。事实上，大多数时候你甚至不知道这个类的名字，所以在实践中你总是会使用不同的名字。

像大多数时候一样，您对一个通用特性`type()`的访问权限很低，这给了您很多制造问题的机会。`type()`的三个参数之一是要创建的类的名称，因此可以用相同的名称创建多个类。

此外，通过传递属性名称空间，您可以提供一个新的`__module__`属性来模拟它在不同模块中的存在。它实际上不会把类放在指定的模块中，但是它会欺骗任何稍后自省该模块的代码。拥有两个具有相同名称和模块的类可能会导致自省模块以确定其结构和层次的工具出现问题。

当然，即使不直接使用`type()`也有可能遇到这些问题。如果您创建一个类，给它指定一个不同的名称，然后创建一个与原始类同名的新类，您可能会遇到完全相同的命名问题。此外，Python 允许您在标准的类声明中提供一个`__module__`属性，因此您甚至可以在不受您控制的代码中创建冲突。

尽管不直接求助于`type()`也有可能遇到这些问题，但这里的警告是`type()`使得意外遇到问题变得更加容易。如果没有它，您将不得不编写专门利用上述要点的代码，以便产生命名冲突。然而，使用`type()`，提供的值可能来自用户输入、定制设置或任何其他地方，代码看起来不会有任何这种性质的问题。

不幸的是，对于这类问题没有真正的保障措施，但是你可以做一些事情来帮助降低风险。一种方法是将所有自定义类的创建封装在一个函数中，该函数跟踪哪些名称已被赋值，并在创建副本时做出适当的反应。一个更实用的选择是简单地确保任何自省代码能够处理遇到重复的情况。使用哪种方法将取决于代码的需求。

### 元类

到目前为止，类被定义为由内置类型处理，内置类型接受类名、基类和名称空间字典。但是`type`就像其他任何东西一样只是一个类；它的特殊之处在于它是一个用于创建类的类——一个`metaclass`。但是，像任何其他类一样，它可以被子类化，以便为我们的应用提供定制的行为。因为 Python 一遇到元类就接收完整的类声明，所以您可以解锁一些非常强大的特性。

通过子类化`type`,你可以创建自己的元类，它可以定制新类的创建，以更好地满足你的应用的需求。像任何基于类的定制一样，这是通过创建一个类型的子类并覆盖任何对手边的任务有意义的方法来完成的。在大多数情况下，这不是`__new__()`就是`__init__()`。本章后面的“魔术方法”一节将解释这两者之间的区别，但是对于这次讨论，我们将只使用`__init__()`，因为它更容易使用。

如前所述，`type()`有三个参数，所有这些参数都必须包含在子类中。从简单开始，考虑下面的元类，它打印出它遇到的每个类的名称:

![img/330715_3_En_4_Figag_HTML.jpg](img/330715_3_En_4_Figag_HTML.jpg)

```py
>>> class SimpleMetaclass(type):
...     def __init__(cls, name, bases, attrs):
...         print(name)
...         super(SimpleMetaclass, cls).__init__(name, bases, attrs)
...

```

仅此一点就足以捕获一个类声明。在这里使用`super()`确保任何其他必要的初始化也发生。即使`type`在它自己的`__init__()`中不做任何事情，记住在本章的前面，这个类可能是一个更大的继承结构的一部分。使用`super()`确保类被正确初始化，而不管在给定的上下文中“正确”的真正含义是什么。

为了将这个元类应用于一个新类并打印出它的名称，Python 允许类定义在父类旁边指定一个元类。它看起来像一个关键字参数，但这不是一个函数调用，所以它实际上是类声明语法的一部分。下面是我们的`SimpleMetaclass`如何工作的一个例子:

![img/330715_3_En_4_Figah_HTML.jpg](img/330715_3_En_4_Figah_HTML.jpg)

```py
>>> class Example(metaclass=SimpleMetaclass):
...     pass
...
>>> Example

```

这里所需要的只是在类定义中提供元类，Python 自动将该定义发送给元类进行处理。这与标准类定义的唯一区别是它使用了`SimpleMetaclass`而不是`standard`类型。

### 注意

元类上的`__init__()`方法的第一个参数通常称为 cls，尽管您可能认为它应该是 self，因为`__init__()`操作的是实例对象，而不是类。一般都是这样，这个案例其实也不例外。这里唯一的区别是实例本身是一个类对象，它是`type`的一个实例，所以使用 self 仍然是准确的。然而，由于类和对象之间的差异，我们仍然称类对象为`cls`，而不是`self`，所以它们保持很好的分离。

如果没有真实世界的例子来说明它们的用处，元类可能很难理解。让我们看看如何使用一个简单的元类来为注册和使用插件提供一个强大的框架。

### 示例:插件框架

随着应用的增长，灵活性变得越来越重要，所以注意力经常转向插件以及应用是否能适应这种模块化水平。实现插件系统和单个插件的方法有很多，但它们都有三个共同的核心特性。

首先，你需要一种方法来定义插件可以使用的地方。为了插上东西，需要有一个插座供插头插入。另外，一路上如何实现单个插件应该是非常明显的。最后，框架需要提供一个简单的方法来访问所有找到的插件，这样它们都可以被使用。其他功能可能会添加到上面，但这些是插件框架。

有几种方法可以满足这些需求，但是因为插件实际上是一种扩展形式，所以让它们扩展基类是有意义的。这使得第一个需求定义起来相当简单:插件可以连接自己的点是一个类。作为一个类，它利用了 Python 自身的扩展特性，不仅通过内置的子类语法，还通过允许基类提供一些方法来构成默认功能或为常见的插件需求提供帮助。下面是这样一个插件挂载点如何寻找一个验证用户输入的应用:

![img/330715_3_En_4_Figai_HTML.jpg](img/330715_3_En_4_Figai_HTML.jpg)

```py
class InputValidator:
    """
    A plugin mount for input validation.

    Supported plugins must provide a validate(self, input) method, which receives
    input as a string and raises a ValueError if the input was invalid. If the
    input was properly valid, it should just return without error. Any return
    value will be ignored.
    """

    def validate(self, input):
        # The default implementation raises a NotImplementedError
        # to ensure that any subclasses must override this method.
        raise NotImplementedError

```

即使没有任何使插件工作的框架级代码，这个例子也展示了可扩展系统的一个最重要的方面:文档。只有正确地记录插件安装，你才能期望插件作者正确地遵守它的期望。插件框架本身并不假设你的应用会有什么需求，所以由你来记录它们。

有了挂载点，只需编写已经存在的挂载点的子类，就可以很容易地创建单独的插件。通过提供新的或重写的方法来满足文档化的需求，他们可以将自己的一小部分功能添加到整个应用中。下面是一个示例验证器，它确保提供的输入只包含 ASCII 字符:

![img/330715_3_En_4_Figaj_HTML.jpg](img/330715_3_En_4_Figaj_HTML.jpg)

```py
class ASCIIValidator(InputValidator):
    """
    Validate that the input only consists of valid ASCII characters.

    >>> v = ASCIIValidator()
    >>> v.validate('sombrero')
    >>> v.validate('jalapeño')
    Traceback (most recent call last):
      ...
    UnicodeDecodeError: 'ascii' codec can't decode character '\xf1' in position
    6: ordinal not in range(128)
    """

    def validate(self, input):
        # If the encoding operation fails, str.enc  ode() raises a
        # UnicodeDecodeError, which is a subclass of ValueError.
        input.encode('ascii')

```

### 小费

请注意，它还提供了自己的文档。因为插件本身也是类，它们可以被更专业的插件子类化。这使得即使在这一级也包含完整的文档非常重要，以帮助确保以后的正确使用。

既然我们已经解决了三个组件中的两个，那么在把它们结合在一起之前，剩下的唯一一件事就是演示如何访问任何已定义的插件。因为我们的代码已经知道了插件的挂载点，这就为访问它们提供了一个显而易见的位置，而且由于插件的数量可能从零到数百个不等，所以最好是对它们进行迭代，而不用关心有多少个插件。下面是一个示例函数，它使用任何和所有可用的插件来确定用户提供的某些输入是否有效:

![img/330715_3_En_4_Figak_HTML.jpg](img/330715_3_En_4_Figak_HTML.jpg)

```py
def is_valid(input):
    for plugin in InputValidator.plugins:
        try:
            plugin().validate(input)
        except ValueError:
            # A ValueError means invalidate input
            return False
    # All validators succeeded
    return True

```

拥有插件意味着你可以扩展这样一个简单函数的功能，而不需要再修改它的代码。简单地添加一个新插件，确保它被导入，剩下的工作由框架来完成。至此，我们终于开始解释这个框架，以及它是如何将所有这些部分联系在一起的。因为我们使用的类的定义不仅仅指定了它们的行为，所以元类将是一种理想的技术。

元类真正需要做的是识别插件挂载类和插件子类之间的区别，并在插件挂载列表中注册任何插件，以后可以在那里访问它们。如果这听起来太简单，那真的不是。事实上，整个框架可以用几行代码来表达，并且只需要插件挂载上的一行额外代码就可以激活整个框架:

![img/330715_3_En_4_Figal_HTML.jpg](img/330715_3_En_4_Figal_HTML.jpg)

```py
class PluginMount(type):
    """
    Place this metaclass on any standard Python class to turn it into a plugin
    mount point. All subclasses will be automatically registered as plugins.
    """
    def __init__(cls, name, bases, attrs):
        if not hasattr(cls, 'plugins'):
            # The class has no plugins list, so it must be a mount point,
            # so we add one for plugins to be registered in later.
            cls.plugins = []
        else:
            # Since the plugins attribute already exists, this is an
            # individual plugin, and it needs to be registered.
            cls.plugins.append(cls)

```

这就是提供整个插件框架所需的全部内容。当元类在插件挂载上被激活时，`__init__()`方法识别出 plugins 属性还不存在，所以它创建一个并返回，不做任何其他事情。当遇到插件子类时，`plugins`属性由于其父类而可用，因此元类将新类添加到现有列表中，从而注册它以备后用。

将这个功能添加到前面描述的`inputValidator`挂载点就像将元类添加到它的类定义中一样简单。

```py
class InputValidator(metaclass=PluginMount):
    ...

```

单个插件仍然被定义为标准插件，不需要额外的努力。因为元类由所有子类继承，所以插件行为是自动添加的。

### 控制命名空间

元类也可以用来帮助控制 Python 如何处理类声明。另一种策略是在 Python 处理类的原始组件时处理它们，而不是等待类被创建后再处理。这是通过一个叫做`__prepare__()`的特殊元类实现的。

通过在元类上提供一个`__prepare__()`方法，您可以提前访问类声明。事实上，这发生得太早了，以至于类定义的主体还没有被处理。`__prepare__()`方法只接收类名及其基类的元组。`__prepare__()`负责返回字典本身，而不是获取名称空间字典作为参数。

当 Python 执行类定义的主体时，`__prepare__()`返回的字典被用作名称空间。这允许您在将每个属性分配给类时立即截取它，这样就可以立即处理它。通常，这用于返回一个有序字典，这样属性可以按照它们在类中声明的顺序存储。作为参考，看看元类如何在不使用`__prepare__()`的情况下工作:

![img/330715_3_En_4_Figam_HTML.jpg](img/330715_3_En_4_Figam_HTML.jpg)

```py
>>> from collections import OrderedDict
>>> class OrderedMeta(type):
...     def __init__(cls, name, bases, attrs):
...         print(attrs)
...
>>> class Example(metaclass=OrderedMeta):
...     b = 1
...     a = 2
...     c = 3
...
{'a': 2, '__module__': '__main__', 'b': 1, 'c': 3}

```

默认行为返回一个标准字典，它不跟踪键是如何添加的。添加一个简单的`__prepare__()`方法提供了在类被处理后保持顺序不变所需的一切:

![img/330715_3_En_4_Figan_HTML.jpg](img/330715_3_En_4_Figan_HTML.jpg)

```py
>>> class OrderedMeta(type):
...     @classmethod
...     def __prepare__(cls, name, bases):
...         return OrderedDict()
...     def __init__(cls, name, bases, attrs):
...         print(attrs)
...
>>> class Example(metaclass=OrderedMeta):
...     b = 1
...     a = 2
...     c = 3
...
OrderedDict([('__module__', '__main__'), ('B', 1), ('A', 2), ('c', 3)])

```

### 注意

属性位于属性列表的开头，因为它是在调用了`__prepare__()`之后，Python 开始处理类的主体之前添加的。

### 权力越大，责任越大

通过控制用于名称空间字典的对象，您可以对整个类声明的行为进行大量的控制。每当类中的一行引用一个变量或分配一个属性时，定制的名称空间可以调解并改变标准行为。一种可能性是提供在类中定义方法时可以使用的 decorators，而不需要单独的导入来使它们对类定义可用。同样，您可以通过更改属性的名称、将属性包装在辅助对象中或将其从名称空间中完全删除来控制属性的分配方式。

这种力量和灵活性很容易被滥用来提供一种在别处看不到的魔力。对于一个仅仅使用你的代码而没有完全理解它是如何实现的开发人员来说，这看起来就像 Python 本身是非常不一致的。更糟糕的是，您对类声明的行为所做的任何重大更改都可能会影响您的用户可能尝试与您的用户结合使用的其他工具的行为。第 [5](05.html) 章展示了如何通过扩展字典来启用这些特性，但是在这么做的时候要非常小心。

## 属性

一旦实例化了一个对象，与之相关的任何数据都保存在一个新的特定于该实例的名称空间字典中。对这个字典的访问由属性处理，这比使用字典键更容易访问。就像字典键一样，可以根据需要检索、设置和删除属性值。

通常，访问属性需要您事先知道属性的名称。在提供变量而不是文字方面，属性的语法不像字典键那样灵活，所以如果您需要用来自其他地方的名称来获取或设置属性，它看起来可能会受到限制。Python 没有提供以这种方式处理属性的特殊语法，而是提供了三个函数。

第一个是`getattr()`，在给定包含属性名称的变量的情况下，检索属性引用的值。下一个是`setattr()`，它接受属性的名称和它的值，并将该值附加到具有给定名称的属性上。最后，`delattr()`允许你删除一个给定名字作为参数的属性值。使用这些函数，您可以在编写代码时处理任何对象的任何属性，而无需知道属性名。

### 性能

属性不仅仅充当标准名称空间字典的代理，它还允许属性由能够访问 Python 全部功能的方法提供动力。通常，属性是使用内置的`@property`装饰函数定义的。应用于方法时，它会强制在将函数名作为属性名访问时调用该方法:

![img/330715_3_En_4_Figao_HTML.jpg](img/330715_3_En_4_Figao_HTML.jpg)

```py
>>> class Person:
...     def __init__(self, first_name, last_name):
...         self.first_name = first_name
...         self.last_name = last_name
...     @property
...     def name(self):
...         return '%s, %s' % (self.last_name, self.first_name)
...
>>> p = Person('Marty', 'Alchin')
>>> p.name
'Alchin, Marty'
>>> p.name = 'Alchin, Martin'  # Update it to be properly legal
Traceback (most recent call last):
  ...
AttributeError: can't set attribute

```

最后一个错误不是很好描述，但是基本上以这种方式定义的属性只检索属性值，而不是设置它们。函数调用只是一种方式，所以要设置值，我们需要添加另一种方法来处理这方面的事情。这个新方法将接受另一个变量:应该在属性上设置的值。

为了将新方法标记为属性的 setter，它被装饰得很像 getter 属性。不过，getter 没有使用内置的装饰器，而是获得了一个可以用来装饰新方法的`setter`属性。这符合 decorators 典型的基于名词的命名约定，同时也描述了哪个属性将被管理:

![img/330715_3_En_4_Figap_HTML.jpg](img/330715_3_En_4_Figap_HTML.jpg)

```py
>>> class Person:
...     def __init__(self, first_name, last_name):
...         self.first_name = first_name
...         self.last_name = last_name
...     @property
...     def name(self):
...         return '%s, %s' % (self.last_name, self.first_name)

...     @name.setter

...     def name(self, value):

...         return '%s, %s' % (self.last_name, self.first_name)

...
>>> p = Person('Marty', 'Alchin')
>>> p.name
'Alchin, Marty'
>>> p.name = 'Alchin, Martin'  # Update it to be properly legal

>>> p.name

'Alchin, Martin'

```

只要确保 setter 方法的名称与原始 getter 方法的名称相同，否则它将无法正常工作。原因是`name.setter`实际上并没有用 setter 方法更新原始属性。相反，它将 getter 复制到新的属性上，并将它们赋给 setter 方法的名称。这在幕后的确切含义将在下一节描述符中更好地解释。

除了获取和设置值，属性还可以使用类似于 setter 的装饰器删除当前值。通过将`name.deleter`应用到一个只接受通常自我的方法，您可以使用该方法从属性中删除值。对于这里显示的`Person`类，这意味着同时清除`first_name`和`last_name`:

![img/330715_3_En_4_Figaq_HTML.jpg](img/330715_3_En_4_Figaq_HTML.jpg)

```py
>>> class Person:
...     def __init__(self, first_name, last_name):
...         self.first_name = first_name
...         self.last_name = last_name
...     @property
...     def name(self):
...         return '%s, %s' % (self.last_name, self.first_name)
...     @name.setter
...     def name(self, value):
...         return '%s, %s' % (self.last_name, self.first_name)

...     @name.deleter

...     def name(self):

...         del self.first_name

...         del self.last_name

...
>>> p = Person('Marty', 'Alchin')
>>> p.name
'Alchin, Marty'
>>> p.name = 'Alchin, Martin' # Update it to be properly legal
>>> p.name
'Alchin, Martin'

>>> del p.name

>>> p.name

Traceback (most recent call last):
  ...
AttributeError: 'Person' object has no attribute 'last_name'

```

### 描述符

属性的一个潜在问题是，它们要求所有方法都被定义为类定义的一部分。如果您自己能够控制类，那么为类添加功能是非常好的，但是当构建一个包含在其他代码中的框架时，我们将需要另一种方法。描述符允许你定义一个对象，这个对象的行为方式可以和它所赋给的任何类上的属性一样。

事实上，属性是作为描述符在幕后实现的，方法也是如此，这将在下一节中解释。这使得描述符可能是高级类行为的最基本的方面之一。它们通过实现三种可能的方法来处理获取、设置和删除值。

第一个是`__get__()`，管理属性值的检索，但是与属性不同，描述符可以管理对类及其实例的属性访问。为了识别差异，`__get__()`接收对象实例和它的所有者类作为参数。所有者类将总是被提供，但是如果描述符是直接在类上而不是在实例上被访问的，那么实例参数将是`None`。

仅使用`__get__()`方法的简单描述符可用于在请求时始终提供最新值。一个明显的例子是返回当前日期和时间的对象，而不需要单独的方法调用:

![img/330715_3_En_4_Figar_HTML.jpg](img/330715_3_En_4_Figar_HTML.jpg)

```py
>>> import datetime
>>> class CurrentTime:
...     def __get__(self, instance, owner):
...         return datetime.datetime.now()
...
>>> class Example:
...     time = CurrentTime()
...
>>> Example().time
datetime.datetime(2009, 10, 31, 21, 27, 5, 236000)
>>> import time
>>> time.sleep(5 * 60) # Wait five minutes
>>> Example().time
datetime.datetime(2009, 10, 31, 21, 32, 15, 375000)

```

相关的`__set__()`方法管理在描述符管理的属性上设置一个值。与`__get__()`不同，该操作只能在实例对象上执行。如果您为类的给定名称赋值，实际上会用新值覆盖描述符，从类中删除它的所有功能。这是有意的，因为没有它，一旦描述符被分配给一个类，就没有办法修改或删除它。

因为不需要接受 owner 类，`__set__()`只接收实例对象和被赋值的值。不过，仍然可以通过访问所提供的实例对象上的`__class__`属性来确定该类，因此不会丢失任何信息。在描述符上定义了`__get__()`和`__set__()`之后，我们可以做一些更有用的事情。例如，下面是一个基本描述符，它的行为就像一个属性，只是它会在每次值发生变化时进行记录:

![img/330715_3_En_4_Figas_HTML.jpg](img/330715_3_En_4_Figas_HTML.jpg)

```py
>>> import datetime
>>> class LoggedAttribute:
...     def __init__(self):
...         self.log = []
...         self.value_map = {}
...     def __set__(self, instance, value):
...         self.value_map[instance] = value
...         log_value = (datetime.datetime.now(), instance, value)
...         self.log.append(log_value)
...     def __get__(self, instance, owner):
...         if not instance:
...             return self # This way, the log is accessible
...         return self.value_map[instance]
...
>>> class Example:
...     value = LoggedAttribute()
...
>>> e = Example()
>>> e.value = 'testing'
>>> e.value
'testing'
>>> Example.value.log
[(datetime.datetime(2009, 10, 31, 21, 49, 59, 933000), <__main__.Example object a
t 0x...>, 'testing')]

```

在继续之前，这里有一些重要的事情需要注意。首先，当在描述符上设置一个值时，`__set__()`使用实例作为键，将它添加到自身的字典中。这样做的原因是描述符对象在它所附加的类的所有实例之间共享。如果您将该值设置为描述符自身的值，那么该值也将在所有这些实例之间共享。

### 注意

使用字典只是确保实例得到处理的一种方式，但这不是最好的方式。这里使用它是因为首选的方法是直接分配给实例的名称空间字典，这只是在您知道属性名称后的一个选项。描述符本身不能访问这个名称，所以这里使用字典。第 11 章展示了一种基于元类解决这个问题的方法。

另外，请注意，如果没有传入实例，`__get__()`将返回 self。因为描述符基于设置值工作，所以当在类上调用它时，它没有额外的贡献值。大多数时候，当描述符处于这种情况时，更有意义的做法是抛出一个`AttributeError`来防止用户尝试一些没有意义的东西。在这里这样做意味着值日志永远不可用，所以描述符返回它自己。

除了获取和设置值，描述符还可以从属性或属性本身删除值。`__delete__()`方法管理这个行为，因为它只对实例起作用，不关心值，所以它接收实例对象作为它唯一的参数。

除了管理属性，描述符还用于实现面向对象编程的一个最重要的方面:方法。

## 方法

当一个函数被定义在一个类中时，它被认为是一个方法。尽管它总体上仍然像函数一样工作，但它有可用的类信息，因为函数实际上也是描述符。然而，在方法类别中，有两种截然不同的类型:绑定方法和未绑定方法。

### 未绑定方法

因为可以从类及其实例中访问描述符，所以也可以从这两者中访问方法。当访问一个类的函数时，它成为一个未绑定的方法。描述符接收类，但是方法通常需要实例，所以在没有实例的情况下访问时，它们被称为未绑定的。

将其称为非绑定方法实际上更像是一种命名约定，而不是任何正式声明。当访问类的方法时，您得到的只是函数对象本身:

![img/330715_3_En_4_Figat_HTML.jpg](img/330715_3_En_4_Figat_HTML.jpg)

```py
>>> class Example:
...     def method(self):
...         return 'done!'
...
>>> type(Example.method)
<class 'function'>
>>> Example.method
<function method at 0x...>

# self isn't passed automatically

>>> Example.method()
Traceback (most recent call last):
  ...
TypeError: method() takes exactly 1 position argument (0 given)

```

它仍然是可调用的，就像任何其他标准函数一样，但是它也携带关于它附加到什么类的信息。注意，未绑定方法中的`self`参数不是自动传递的，因为没有实例对象可以绑定到它。

### 绑定方法

一旦类被实例化，每个方法描述符返回一个绑定到该实例的函数。它仍然由相同的函数支持，并且原始的未绑定方法仍然在该类上可用，但是绑定方法现在自动接收实例对象作为它的第一个参数:

![img/330715_3_En_4_Figau_HTML.jpg](img/330715_3_En_4_Figau_HTML.jpg)

```py
>>> ex = Example()
>>> type(ex.method)
<class 'method'>
>>> ex.method
<bound method Example.method of <__main__.Example object at 0x...>>

# self gets passed automatically now

>>> ex.method()
'done!'

# And the underlying function is still the same

>>> Example.method is ex.method.__func__
True

# is and == have related yet different functionality and == could have replaced is in this instance, yet since is checks to see if two arguments refer to the same object versus == checks to see if two object have same value, is works better for our needs.

```

如您所见，绑定方法仍然由与未绑定方法相同的函数支持。唯一真正的区别是绑定方法有一个实例作为第一个参数接收。同样重要的是要认识到实例对象是作为位置参数传递的，所以参数名不需要为`self`才能正常工作，但是这是一个已经建立的标准，您应该尽可能地遵循。

### 小费

因为绑定方法接受实例作为第一个参数，所以可以通过显式提供实例作为未绑定方法的第一个参数来伪造方法绑定。对于该方法来说，这一切看起来都是一样的，并且在将函数作为回调传递时，这可能是一种有用的方法。

然而，有时方法不需要访问实例对象，不管类是否已经被实例化。这些方法分为两种不同的类型。

### 类方法

当一个方法只需要访问它所附加的类时，它被认为是一个类方法，Python 通过使用内置的`@classmethod` decorator 来支持它。这确保了该方法将总是接收类对象作为它的第一个位置参数，而不管它是作为类的属性还是它的实例之一被调用:

![img/330715_3_En_4_Figav_HTML.jpg](img/330715_3_En_4_Figav_HTML.jpg)

```py
>>> class Example:
...     @classmethod
...     def method(cls):
...         return cls
...
>>> Example.method()
<class __main__.Example at 0x...>
>>> Example().method()
<class __main__.Example at 0x...>

```

一旦应用了`@classmethod`decorator——参见本章后面关于 decorator 的信息——`method() method`将永远不会收到一个`Example`的实例作为它的第一个参数，而将永远是类本身或它的一个子类。`cls`参数总是用来调用方法的类，而不仅仅是定义方法的类。

尽管从前面的例子中可能看不清楚，但类方法实际上是绑定的实例方法，就像前面几节中描述的那些方法一样。因为所有类实际上都是内置类型的实例，所以类方法被绑定到类本身:

![img/330715_3_En_4_Figaw_HTML.jpg](img/330715_3_En_4_Figaw_HTML.jpg)

```py
>>> Example.method
<bound method type.method of <class '__main__.Example'>>

```

类方法也可以用另一种稍微间接的方式创建。因为所有的类实际上都只是元类的实例，所以可以在元类上定义一个方法。然后，所有实例类都可以将该方法作为标准绑定方法进行访问。不需要使用`@classmethod`装饰器，因为该方法已经使用前面描述的标准行为绑定到了类。它是这样工作的:

![img/330715_3_En_4_Figax_HTML.jpg](img/330715_3_En_4_Figax_HTML.jpg)

```py
>>> class ExampleMeta(type):
...     def method(cls):
...         return cls
...
>>> class Example(metaclass=ExampleMeta):
...     pass
...
>>> Example.method
<bound method ExampleMeta.method of <class '__main__.Example'>>
>>> Example.method()
<class __main__.Example at 0x...>

```

以这种方式构造的方法的实际行为在大多数方面与常规的类方法相同，因为它们在内部是以相同的方式构建的。它们可以从类本身调用，而不需要实例，并且它们总是接收类对象作为隐式的第一个参数。然而，不同之处在于类方法仍然可以从实例中调用，而绑定类方法只能从类本身调用。

这种行为的原因是该方法是在元类名称空间中定义的，这只能将其放在该元类实例的 MRO 中。所有引用该元类的类都可以访问该方法，但实际上并不在它们的定义中。用`@classmethod`修饰的方法被直接放在定义它们的类的名称空间中，这使得它们对于该类的实例也是可用的。

尽管这种可见性上的差异看起来像是基于元类的类方法只是标准修饰类方法的一个低级版本，但是有两个原因可以解释为什么它们对应用有益。首先，类方法通常被期望作为类的属性来调用，很少从实例对象中调用。这不是一个通用的规则，当然也不足以证明元类本身的使用，但这是值得注意的。

也许更重要的是，许多已经使用元类的应用还需要向使用该元类的任何类添加类方法。在这种情况下，只在现有元类上定义方法是有意义的，而不是使用单独的类来保存类方法。当额外的类本身没有任何有价值的东西可添加时，这尤其有用；如果元类是重要的部分，最好把所有东西都放在那里。

### 静态方法

有时，即使是类也比方法完成工作所需的信息多。静态方法就是这种情况，实现静态方法通常是为了给本来可以在模块级实现的函数建立一个名称空间。使用`staticmethod`装饰器，该方法在任何时候都不会接收任何隐式参数:

![img/330715_3_En_4_Figay_HTML.jpg](img/330715_3_En_4_Figay_HTML.jpg)

```py
>>> class Example:
...     @staticmethod
...     def method():
...         print('static!')
...
>>> Example.method
<function method at 0x...>
>>> Example.method()
static!

```

如您所见，静态方法看起来一点也不像方法。它们只是碰巧出现在一个类中的标准函数。下一节将展示如何利用 Python 的动态特性在实例上实现类似的效果。

### 将函数分配给类和实例

Python 允许简单地通过分配一个新值来覆盖大多数属性，这为方法提供了一个有趣的机会:

![img/330715_3_En_4_Figaz_HTML.jpg](img/330715_3_En_4_Figaz_HTML.jpg)

```py
>>> def dynamic(obj):
...     return obj
...
>>> Example.method = dynamic
>>> Example.method()
Traceback (most recent call last):
  ...
TypeError: dynamic() takes exactly 1 positional argument (0 given)
>>> ex = Example()
>>> ex.method()
<__main__.Example object at 0x...>

```

请注意，分配给该类的函数仍然需要编写成接受一个实例作为它的第一个参数。一旦赋值，它就像一个常规的实例方法一样工作，所以参数需求根本不会改变。赋值给实例在语法上类似，但是因为函数永远不会被赋值给类，所以根本不涉及绑定。直接分配给实例属性的函数就像附加到类的静态方法一样工作:

![img/330715_3_En_4_Figba_HTML.jpg](img/330715_3_En_4_Figba_HTML.jpg)

```py
>>> def dynamic():
...     print('dynamic!')
...
>>> ex.method = dynamic
>>> ex.method()
dynamic!
>>> ex.method
<function dynamic at 0x...>

```

## 神奇的方法

Python 中的对象可以用许多不同的方式来创建、操作和销毁，并且大多数可用的行为可以通过在您自己的定制类上实现一些额外的方法来修改。一些更特殊的定制可以在第 5 章中找到，但是有一些特殊的方法对于所有类型的类都是通用的。这些方法可以根据它们处理的类的方面来分类，因此下面的章节将分别介绍一些不同的方法。

### 创建实例

从类到对象的转换称为实例化。实例只不过是对提供行为和名称空间字典的类的引用，该字典对于正在创建的实例是唯一的。当创建一个新对象而不覆盖任何特殊方法时，实例名称空间只是一个空字典，等待数据。

因此，大多数类实现的第一个方法是`__init__()`，目的是用一些有用的值初始化名称空间。有时这些只是占位符，直到更多有趣的数据到来，而在其他时候，有趣的数据以参数的形式直接进入方法。发生这种情况是因为传递给类实例化的任何参数都会一直传递给`__init__()`:

![img/330715_3_En_4_Figbb_HTML.jpg](img/330715_3_En_4_Figbb_HTML.jpg)

```py
>>> class Example:
...     def __init__(self):
...         self.initialized = True
...
>>> e = Example()
>>> e.initialized = True
>>> class Example2:
...     def __init__(self, name, value=“):
...         self.name = name
...         self.value = value
...
>>> e = Example2()
Traceback (most recent call last):
  ...
TypeError: __init__() takes at least 2 positional arguments (1 given)
>>> e = Example2('testing')
>>> e.name
'testing'
>>> e.value
"

```

像任何 Python 函数一样，您可以在`__init__()`中自由地做任何您想做的事情，但是请记住，这只是为了初始化对象，仅此而已。一旦`__init__()`完成执行，对象应该准备好用于更实际的目的，但是任何超出基本设置的事情应该被推迟到其他更明确的方法。

当然，初始化的真正定义可能对不同的对象有不同的含义。对于大多数对象，您只需要将一些属性设置为一些默认值或传递给`__init__()`的值，如前面的例子所示。其他时候，这些初始值可能需要计算，比如将不同的时间单位转换成秒，所以一切都是正常的。

在一些不太常见的情况下，初始化可能包括更复杂的任务，如数据验证、文件检索，甚至网络流量。例如，一个使用 web 服务的类可能将一个 API 令牌作为它对`__init__()`的唯一参数。然后，它可能会调用 web 服务，将该令牌转换为经过身份验证的会话，这将允许进行其他操作。所有其他操作都需要单独的方法调用，但是所有这些操作背后的认证可能发生在`__init__()`中。

在`__init__()`中做得太多的主要问题是，除了文档之外，没有任何迹象表明发生了任何事情。不幸的是，无论你如何努力，有些用户就是不愿意阅读你的文档；他们可能仍然期望初始化是一个简单的操作，例如，如果他们没有有效的网络连接，他们可能会惊讶地看到错误。关于解决这个问题的一种方法，请参见下一节中的示例。

尽管`__init__()`可能是所有方法中最广为人知的魔法方法，但它并不是创建新对象时第一个被执行的方法。毕竟，记住`__init__()`是关于初始化一个对象，而不是创建它。对于后者，Python 提供了`__new__()`方法，该方法获得大部分相同的参数，但负责在初始化之前实际创建新对象。

与典型的实例对象`self`不同，`__new__()`的第一个参数实际上是被创建对象的类。这使它看起来很像一个类方法，但是你不需要使用任何装饰器来使它这样工作——这是 Python 中的一个特例。然而，从技术上讲，它是一个静态方法，所以如果你试图直接调用它，你总是需要提供类；它永远不会被隐式发送，就像它是一个真正的类方法一样。

在类参数之后——通常命名为 cls，就像常规的类方法一样——`__new__()`方法接收所有与`__init__()`相同的参数。当试图创建对象时，你传递给类的任何东西都将被传递给`__new__()`来帮助定义它。这些参数在根据当前需求定制新对象时通常很有用。

这通常不同于初始化，因为`__new__()`通常用于改变被创建对象的本质，而不仅仅是设置一些初始值。举例来说，考虑一个例子，其中对象的类可以根据创建它时传入的值而改变。

### 示例:自动子类

有些库由大量不同的类组成，其中大多数共享一组公共数据，但可能具有不同的行为或其他数据定制。这通常需要库的用户跟踪所有不同的类，并确定他们的数据的哪些特征对应于适当的类。

相反，提供一个用户可以实例化的类会更有帮助，该类实际上返回一个对象，该对象可以是不同的类，这取决于参数。使用`__new__()`定制新对象的创建，这可以相当简单地实现。确切的行为将取决于手边的应用，但是基本的技术很容易用一个通用的例子来说明。

考虑一个类，每当它被实例化为一个对象时，它随机选择一个子类。当然，这不是最实际的用途，但是它说明了这个过程是如何工作的。使用`random.choice()`从使用`__subclasses__()`得到的值中选择，然后实例化它找到的子类，而不是定义的子类:

![img/330715_3_En_4_Figbc_HTML.jpg](img/330715_3_En_4_Figbc_HTML.jpg)

```py
>>> import random
>>> class Example:
...     def __new__(cls, *args, **kwargs):
...         cls = random.choice(cls.__subclasses__())
...         return super(Example, cls).__new__(cls, *args, **kwargs)
...
>>> class Spam(Example):
...     pass
...
>>> class Eggs(Example):
...     pass
...
>>> Example()
<__main__.Eggs object at 0x...>
>>> Example()
<__main__.Eggs object at 0x...>
>>> Example()
<__main__.Spam object at 0x...>
>>> Example()
<__main__.Eggs object at 0x...>
>>> Example()
<__main__.Spam object at 0x...>
>>> Example()
<__main__.Spam object at 0x...>

```

在另一个真实的例子中，您可以将文件的内容传递给一个单独的`File`类，并让它自动实例化一个子类，该子类的属性和方法是为所提供的文件格式构建的。这对于大类文件(如音乐或图像)尤其有用，这些文件表面上在大多数方面表现相似，但却有可以抽象掉的潜在差异。

### 处理属性

使用一个对象时，最常见的需求之一是与其属性进行交互。一般来说，这很简单，只要给定属性的名称，比如`instance.attribute`，就可以直接分配和访问属性。在少数情况下，这种类型的访问本身是不够的，因此您需要更多的控制。

如果您在编写应用时不知道属性的名称，那么如果您使用内置的`getattr()`函数，您可以为名称提供一个变量。例如，`instance.attribute`将变成`getattr(instance`，`attribute_name)`，其中`attribute_name`的值可以从任何地方提供，只要它是一个字符串。

这种方法只处理给定一个字符串形式的名称，并且需要查找该名称引用的实例属性的情况。另一方面，你也可以告诉一个类如何处理它没有明确管理的属性。这种行为由`__getattr__()`方法控制。

如果您定义了这个方法，Python 将在您请求尚未定义的属性时调用它。它接收所请求的属性的名称，因此您的类可以决定应该如何处理它。一个常见的例子是字典，它允许您按属性检索值，而不只是使用标准的字典语法:

![img/330715_3_En_4_Figbd_HTML.jpg](img/330715_3_En_4_Figbd_HTML.jpg)

```py
>>> class AttributeDict(dict):
...     def __getattr__(self, name):
...         return self[name]
...
>>> d = AttributeDict(spam='eggs')
>>> d['spam']
'eggs'
>>> d.spam
'eggs'

```

### 注意

`__getattr__()`的一个不太明显的特性是，它只被实际上不存在的属性调用。如果您直接设置属性，引用该属性将检索它而不调用`__getattr__()`。如果你需要捕捉每个属性，使用`__getattribute__()`代替。它采用与`__getattr__()`相同的参数和函数，除了即使属性已经在实例上，它也会被调用。

当然，如果属性是只读的，那么允许属性访问的字典就没什么用了。为了使画面完整，我们还应该支持在属性中存储值。除了这个简单的字典示例之外，当您为一个属性设置值时，还需要定制发生的事情。正如所料，Python 以`__setattr__()`方法的形式提供了一个并行。

这个新方法需要一个额外的参数，因为还有一个值需要管理。通过定义`__setattr__()`，您可以截取这些赋值，并根据您的应用的需要来处理它们。将这个应用到`AttributeDict`就像前面的例子一样简单:

![img/330715_3_En_4_Figbe_HTML.jpg](img/330715_3_En_4_Figbe_HTML.jpg)

```py
>>> class AttributeDict(dict):
...     def __getattr__(self, name):
...         return self[name]

...     def __setattr__(self, name, value):

...         self[name] = value

...
>>> d = AttributeDict(spam='eggs')
>>> d['spam']
'eggs'
>>> d.spam
'eggs'
>>> d.spam = 'ham'

>>> d.spam

'ham'

```

### 小费

就像`getattr()`提供用变量代替硬编码名称来访问属性一样，Python 提供了`setattr()`来设置属性。它的参数与`__setattr__()`的参数相匹配，因为它接受对象、属性名和值。

尽管这看起来像是属性访问的完整画面，但仍然缺少一个组件。当您不再需要某个属性，并希望将其从对象中完全移除时，Python 提供了`del`语句。然而，当您使用由这些特殊方法管理的假属性时，`del`本身不起作用。

为了处理这种情况，Python 会挂钩到`__delattr__()`方法(如果有的话)。因为这个值不再相关，所以这个方法只接受属性名和标准的`self`。将它添加到现有的`AttributeDict`很容易:

![img/330715_3_En_4_Figbf_HTML.jpg](img/330715_3_En_4_Figbf_HTML.jpg)

```py
>>> class AttributeDict(dict):
...     def __getattr__(self, name):
...         return self[name]
...     def __setattr__(self, name, value):
...         self[name] = value

...     def __delattr__(self, name):

...         del self[name]

...
>>> d = AttributeDict(spam='eggs')
>>> d['spam']
'eggs'
>>> d.spam
'eggs'
>>> d.spam = 'ham'
>>> d.spam
'ham'

>>> del d.spam

>>> d.spam

Traceback (most recent call last):

  ...

KeyError: 'spam'

```

### 警告:引发正确的异常

该错误消息提出了使用这些类型的被覆盖属性的重要一点。很容易忽略异常在函数内部是如何处理的，所以你最终可能会抛出一个没有任何意义的异常；如果一个属性不存在，你会合理地期望看到一个`AttributeError`，而不是一个`KeyError`。

这似乎是一个随意的细节，但是请记住，大多数代码都显式地捕捉特定类型的异常，因此，如果您引发了错误的类型，您可能会导致其他代码采取错误的路径。因此，当遇到相当于丢失属性的东西时，一定要确保显式地抛出`AttributeError`。根据假属性的作用，它可能是一个`KeyError`、`IOError,`或者甚至是一个`UnicodeDecodeError`。

这将在本书和现实世界中的不同地方出现。第 [5](05.html) 章涵盖了各种协议，在这些协议中，获得正确的异常和参数一样重要。

### 字符串表示

在 Python 中所有可能的不同对象类型中，最常见的无疑是字符串。从读写文件到与 web 服务交互和打印文档，字符串支配着软件执行的许多方面。尽管我们的大部分数据以其他形式存在，但迟早大部分数据会被转换成字符串。

为了使这个过程尽可能简单，Python 提供了一个额外的钩子来将对象转换成它的字符串表示。当在一个类上实现时，`__str__()`方法允许使用内置的`str() function`将它的实例转换成一个字符串，当使用`print()`或字符串格式化时也会用到这个方法。关于这些特性和更多的细节可以在第 7 章[中找到，但是现在，看看`__str__()`在一个简单的类中是如何工作的:](07.html)

![img/330715_3_En_4_Figbg_HTML.jpg](img/330715_3_En_4_Figbg_HTML.jpg)

```py
# First, without __str__()

>>> class Book:
...     def __init__(self, title):
...         self.title = title
...
>>> Book('Pro Python')
<__main__.Book object at 0x...>
>>> str(Book('Pro Python'))
'<__main__.Book object at 0x...>'

# And again, this time with __str__()

>>> class Book:
...     def __init__(self, title):
...         self.title = title

...     def __str__(self):

...         return self.title

...
>>> Book('Pro Python')
<__main__.Book object at 0x...>
>>> str(Book('Pro Python'))

'Pro Python'

```

添加的`__str__()`允许该类指定在将对象表示为字符串时应该显示对象的哪些方面。在这个例子中，它是一本书的标题，但是它也可以是一个人的名字、地理位置的纬度和经度，或者在一组同类对象中简洁地标识该对象的任何其他东西。它不必包含关于对象的所有内容，但需要足够的内容来区分不同的对象。

还要注意，当交互式解释器中的表达式不包含对`str()`的调用时，它不使用由`__str__()`返回的值。相反，解释器使用对象的不同表示，这是为了更准确地表示对象的代码性质。对于自定义类来说，这种表示是相当无用的，只显示了对象的类的名称和模块以及它在内存中的地址。

然而，对于其他类型，您会注意到这些表示在确定对象是什么时非常有用。事实上，这种表示的理想目标是呈现一个字符串，如果将该字符串键入控制台，将会重新创建该对象。这对于了解交互式控制台中的对象非常有用:

![img/330715_3_En_4_Figbh_HTML.jpg](img/330715_3_En_4_Figbh_HTML.jpg)

```py
>>> dict(spam='eggs')
{'spam': 'eggs'}
>>> list(range(5))
[0, 1, 2, 3, 4]
>>> set(range(5))
{0, 1, 2, 3, 4}

>>> import datetime
>>> datetime.date.today()
datetime.date(2009, 10, 31)
>>> datetime.time(12 + 6, 30)
datetime.time(18, 30)

```

这种替代表示由`__repr__()`方法控制，主要用于这种情况，描述交互控制台中的对象。当在解释器中单独引用一个对象时，它被自动触发，有时在日志应用中使用，在那里`__str__()`通常不能提供足够的细节。

对于列表和字典这样的内置对象，表示是一个文字表达式，可以很容易地再现对象。对于其他不包含太多数据的简单对象，日期和时间示例表明，只需提供一个实例化调用就可以了。当然，`datetime`必须首先被导入，但是它完成了工作。

如果对象表示的数据太多，无法压缩成这样一个简单的表示，那么下一个最好的方法是提供一个用尖括号括起来的字符串，它以更合理的细节描述对象。这通常是显示类名和一些标识类名的数据。对于`Book`示例，它在现实世界中有更多的属性，看起来可能是这样的:

![img/330715_3_En_4_Figbi_HTML.jpg](img/330715_3_En_4_Figbi_HTML.jpg)

```py
>>> class Book:
...     def __init__(self, title, author=None):
...         self.title = title
...         self.author = author
...     def __str__(self):
...         return self.title
...     def __repr__(self):
...         return '<%s by %s>' % (self.title, self.author or '<Unknown Author>')
...
>>> Book('Pro Python', author='Marty Alchin')
<Book: Pro Python by Marty Alchin>
>>> str(Book('Pro Python', author='Marty Alchin'))
'Pro Python'

```

## 令人兴奋的 Python 扩展:迭代器

迭代器是可以被迭代的对象；换句话说，你可以说它是一个“可迭代”或“可循环”的项目。列表、元组和字符串是可迭代的；它们容纳不止一个项目，因此是可迭代的容器。Python 中有两个迭代器对象。第一个是序列迭代器，适用于任意序列。第二个对象遍历可调用对象项，并带有结束该过程的 sentinel 值。让我们看看他们的行动，以便更好地理解这一点。

一个非常简单的例子是增强的 ***for 循环*** ，它遍历容器中的所有条目(你必须有不止一个)。请考虑以下几点:

```py
my_string=('Hello Python!')
for item in my_string:
            print(item)
my_list=[1,2,3,4]
for item in my_list:
            print (item, end=' ')
#Note newline after printing is replaced with space
print()
my_tuple='Fred','Wilma', 1, 3
for item in my_tuple:
            print (item)

```

现在，如果在 Python 脚本所在的同一文件夹中有一个文本文件，例如一个包含数据的 CSV 文件，您可以执行如下操作:

```py
for the_line in open("file.csv”):
                   print (the_line)

```

使用 Python 迭代器，您还可以组合结构来增强功能。一定要保持可读性。请注意，我们正在遍历一个字符串，并对字母“b”的实例进行计数

```py
#Combine control structures
my_string=('ababaaaabbbbaaaabb')
counter=0
for character in [char for char in my_string if char == 'b']:
            counter +=1
print('There were ', counter, ' letter b')

```

另一个例子可能是凯撒密码加密:

```py
#Secret message Ceasar cipher!
my_string = input('Type secret message:  ')
print (my_string)
new_string = ' '
z=input('How much to Ceasar shift by?  ')
for letter in my_string:
            x=ord(letter)
            t=x+int(z)
            print (chr(t),)

```

现在我们来看看**迭代协议**。 ***下一个*** 函数从第一项开始迭代，一直到最后一项，但是当它试图打印列表中没有的第四项时，返回一个 *StopIteration* 错误:

```py
# Simple iteration over a list
simple_list = [1, 3, 2]
simple_iter = iter(simple_list)
counter = 1
while counter <=4:
          print(next(simple_iter))
          counter +=1

```

现在，您可以添加 try 和 except 来保持运行，但这显示了一般情况下的工作方式。花时间使用迭代器会有很好的回报。

## 带着它

对类的透彻理解为您的应用打开了一个可能性的世界，无论它们是简单的个人项目还是为大规模分发而构建的大型框架。除了所有这些自由之外，还有一组已建立的协议，允许您的类像 Python 中一些最著名的类型一样工作。