# 一、即时黑魔法：基础知识

是时候开始黑了。在这一章中，你将学习如何通过说一种电脑能理解的语言来控制你的电脑:Python。这里没有什么特别难的，所以如果你知道你的计算机如何工作的基本原理，你应该能够跟随例子并自己尝试。我将介绍一些基础知识，从极其简单的开始，但是因为 Python 是一种如此强大的语言，所以您很快就能做相当高级的事情。

首先，您需要安装 Python，或者验证您已经安装了 Python。如果你运行的是 macOS 或者 Linux/UNIX，打开一个终端(Mac 上的终端应用)，输入`python`，然后回车。您应该会收到一条欢迎消息，以下面的提示结束:

```py
>>>

```

如果这样做了，您可以立即开始输入 Python 命令。但是，请注意，您可能有旧版本的 Python。如果第一行以`Python 2`而不是`Python 3`开头，您可能还是想安装一个更新的版本，因为 Python 3 引入了几个突破性的变化。

安装过程的细节当然会因您的操作系统和首选安装机制而异，但最直接的方法是访问 [`www.python.org`](http://www.python.org) ，在那里您应该可以找到下载页面的链接。这一切都是不言自明的——只需通过链接找到您的平台的最新版本，无论是 Windows、macOS、Linux/UNIX 还是其他平台。对于 Windows 和 Mac，您将下载一个安装程序，您可以运行它来实际安装 Python。对于 Linux/UNIX，您需要按照附带的说明自己编译源代码。如果你正在使用一个包管理器，比如 Homebrew 或者 APT，你可以用它来简化这个过程。

一旦你安装了 Python，试着启动交互式解释器。如果您使用命令行，您可以简单地使用`python`命令，或者如果您已经安装了旧版本，也可以使用`python3`。如果您更喜欢使用图形界面，可以启动 Python 安装附带的空闲应用程序。

## 交互式解释器

当您启动 Python 时，您会得到类似如下的提示:

```py
Python 3.5.0 (default, Dec 5 2015, 15:03:35)
[GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.1.76)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>>

```

解释器的确切外观及其错误消息将取决于您使用的版本。这可能看起来不太有趣，但是相信我，它很有趣。这是你通往黑魔法世界的大门，是你控制电脑的第一步。用更实际的术语来说，它是一个交互式 Python 解释器。为了看看它是否有效，请尝试以下方法:

```py
>>> print("Hello, world!")

```

当您按下 Enter 键时，会出现以下输出:

```py
Hello, world!
>>>

```

如果你熟悉其他计算机语言，你可能习惯于用分号结束每一行。在 Python 中不需要这样做。一条线就是一条线，或多或少。如果你愿意，你可以添加一个分号，但它不会有任何效果(除非在同一行上有更多的代码)，而且它不是一个常见的事情。

这里发生了什么？那个东西就是提示。你可以在这个空间写点东西，比如`print "Hello, world!"`。如果您按 Enter 键，Python 解释器会打印出字符串“Hello，world！”你会在下面看到一个新的提示。

如果你写的是完全不同的东西呢？尝试一下:

```py
>>> The Spanish Inquisition
SyntaxError: invalid syntax
>>>

```

显然，翻译不明白这一点。 [<sup>2</sup>](#Fn2) (如果运行的是 IDLE 以外的解释器，比如 Linux 的命令行版本，错误信息会略有不同。)解释器还指出了错误:它将通过给西班牙语一个红色背景来强调这个单词(或者，在命令行版本中，通过使用一个脱字符号，`^`)。

如果你喜欢，多和翻译玩玩。为了获得一些指导，尝试在提示符下输入命令`help()`并按 Enter 键。您可以按 F1 键获取有关空闲的帮助。否则，让我们继续努力。毕竟，当你不知道告诉它什么的时候，解释器就没什么意思了。

## 有什么事吗？。。怎么了？

在我们开始认真编程之前，我会试着给你一个什么是计算机编程的概念。简单地说，它告诉计算机做什么。电脑可以做很多事情，但是它们不太擅长独立思考。他们真的需要被灌输细节。你需要用计算机能理解的语言输入一个算法。算法只是一个程序或配方的花哨词汇——对如何做某事的详细描述。请考虑以下几点:

```py
SPAM with SPAM, SPAM, Eggs, and SPAM:  First, take some SPAM.
Then add some SPAM, SPAM, and eggs.
If a particularly spicy SPAM is desired, add some SPAM.
Cook until done -- Check every 10 minutes.

```

这不是最奇特的食谱，但它的结构很有启发性。它由一系列要按顺序执行的指令组成。有些指示可以直接完成(“吃一些垃圾邮件”)，而有些则需要一些深思熟虑(“如果想要一份特别辣的垃圾邮件”)，而有些则必须重复几次(“每 10 分钟检查一次。”)

配方和算法由配料(对象、事物)和指令(语句)组成。在这个例子中，垃圾邮件和鸡蛋是配料，而指令包括添加垃圾邮件，烹饪给定的时间长度，等等。让我们从一些相当简单的 Python 成分开始，看看可以用它们做些什么。

## 数字和表达式

交互式 Python 解释器可以用作强大的计算器。尝试以下方法:

```py
>>> 2 + 2

```

这应该会给你答案 4。这并不难。好吧，那这个呢:

```py
>>> 53672 + 235253
288925

```

还是没印象？诚然，这是相当标准的东西。(我假设你已经用了足够多的计算器，知道`1 + 2 * 3`和`(1 + 2) * 3`之间的区别。)所有常用的算术运算符都按预期工作。除法产生十进制数，称为浮点数(或浮点数)。

```py
>>> 1 / 2
0.5
>>> 1 / 1
1.0

```

如果你宁愿舍弃小数部分而做整数除法，你可以用双斜线。

```py
>>> 1 // 2
0
>>> 1 // 1
1
>>> 5.0 // 2.4
2.0

```

在 Python 的旧版本中，整数的普通除法曾经像这个双斜线一样工作。如果您正在使用 Python 2.x，您可以通过将以下语句添加到程序的开头(编写完整的程序将在后面描述)或在交互式解释器中简单地执行它来获得适当的划分:

```py
>>> from __future__ import division

```

Note

如果不完全清楚，指令中的`future`两边用两个下划线包围:`_ _future_ _`。

另一种方法是，如果您从命令行运行旧的 Python，提供命令行开关`-Qnew`。在本章后面的“回到 __ 未来 _ _”一节中有关于`__future__`的更详细的解释。

现在你已经看到了基本的算术运算符(加、减、乘、除)，但是我没有提到整数除法的近亲。

```py
>>> 1 % 2
1

```

这是余数(模数)运算符。`x % y`给出`x`除以`y`的余数。换句话说，就是用整数除法时剩下的部分。也就是说，`x % y`和`x - ((x // y) * y)`是一样的。

```py
>>> 10 // 3
3
>>> 10 % 3
1
>>> 9 // 3
3
>>> 9 % 3
0
>>> 2.75 % 0.5
0.25

```

这里的`10 // 3`是`3`，因为结果是向下舍入的。但是 3 × 3 是 9，所以你得到 1 的余数。当你用 9 除以 3 时，结果正好是 3，没有四舍五入。因此，余数为 0。如果你想像本章前面的食谱那样“每 10 分钟”检查一次，这可能是有用的。你可以简单地检查`minute % 10`是否为 0。(有关如何操作的描述，请参阅本章后面的边栏“预览:if 语句”。)正如您在最后一个例子中看到的，余数操作符同样适用于浮点数。它甚至适用于负数，这可能会有点混乱。

```py
>>> 10 % 3
1
>>> 10 % -3
-2
>>> -10 % 3
2
>>> -10 % -3
-1

```

看着这些例子，它的工作原理可能不是很明显。如果看看整数除法的伴生运算，大概就更容易理解了。

```py
>>> 10 // 3
3
>>> 10 // -3
-4
>>> -10 // 3
-4
>>> -10 // -3
3

```

考虑到除法是如何工作的，就不难理解余数是多少了。关于整数除法，需要理解的重要一点是，它是向下舍入的，对于负数来说是远离零的。这意味着`-10 // 3`被向下舍入到`-4`，而不是向上舍入到`-3`。

我们要看的最后一个运算符是幂运算符。

```py
>>> 2 ** 3
8
>>> -3 ** 2
-9
>>> (-3) ** 2
9

```

请注意，求幂运算符比求反运算符(一元减号)绑定得更紧，因此`-3**2`实际上与`-(3**2)`相同。如果你想计算`(-3)**2`，你必须明确地说出来。

### 十六进制八进制和二进制

为了结束这一节，我应该提到十六进制、八进制和二进制数是这样写的:

```py
>>> 0xAF
175
>>> 010
8
>>> 0b1011010010
722

```

这两个数字的第一个数字都是零。(如果你不知道这是怎么回事，你可能还不需要这个。把它归档以备后用。)

## 变量

另一个你可能很熟悉的概念是变量。如果代数只是遥远的记忆，不要担心:Python 中的变量很容易理解。变量是代表(或引用)某个值的名称。例如，您可能希望名称`x`代表`3`。为此，只需执行以下命令:

```py
>>> x = 3

```

这就是所谓的任务。我们将值`3`赋给变量`x`。换句话说，我们将变量`x`绑定到值(或对象)`3`。给变量赋值后，可以在表达式中使用该变量。

```py
>>> x * 2
6

```

与其他一些语言不同，在将变量绑定到某个东西之前，不能使用它。没有“默认值”

Note

简单来说，Python 中的名称或标识符由字母、数字和下划线字符(`_`)组成。它们不能以数字开头，所以`Plan9`是有效的变量名，而`9Plan`不是。 [<sup>3</sup>](#Fn3)

## 声明

到目前为止，我们一直(几乎)专门研究表情，也就是食谱的成分。但是陈述——指令呢？

事实上，我作弊了。我已经介绍了两种类型的语句:`print`语句和赋值语句。语句和表达式有什么区别？你可以这样想:一个表达式是一些东西，而一个语句做一些事情。例如，`2 * 2`是`4`，而`print(2 * 2)`打印的是`4`。这两者的行为非常相似，所以它们之间的区别可能不是那么明显。

```py
>>> 2 * 2
4
>>> print(2 * 2)
4

```

只要在交互式解释器中执行，就没有区别，但那只是因为解释器总是打印出所有表达式的值(使用与`repr`相同的表示——见本章后面的“字符串表示，str 和 repr”一节)。一般来说，Python 不是这样的。在本章的后面，你将会看到如何让程序在没有这个交互提示的情况下运行；简单地在你的程序中放一个像`2 * 2`这样的表达式不会有任何有趣的效果。 [<sup>4</sup>](#Fn4) 然而把`print(2 * 2)`放在那里，仍然会打印出`4`。

Note

实际上，`print`是一个函数(这一章后面会详细介绍)，所以我所说的`print`语句只是一个函数调用。在 Python 2.x 中，`print`有自己的语句类型，并且不在参数周围使用括号。

在处理赋值的时候，语句和表达式的区别更加明显。因为它们不是表达式，所以它们没有可以由交互式解释器打印出来的值。

```py
>>> x = 3
>>>

```

您只是立即得到一个新的提示。然而，有些事情已经改变了。我们现在有了一个新的变量`x`，它现在被绑定到值`3`。从某种程度上来说，这是一种定义性的陈述:它们改变事物。例如，赋值改变变量，而`print`语句改变你的屏幕外观。

赋值可能是任何编程语言中最重要的语句类型，尽管现在可能很难理解它们的重要性。变量可能看起来只是临时的“存储”(就像烹饪食谱中的锅碗瓢盆)，但变量的真正力量在于，你不需要知道它们持有什么值才能操纵它们。 [<sup>5</sup>](#Fn5)

例如，你知道`x * y`等于`x`和`y`的乘积，即使你可能不知道`x`和`y`是什么。所以，你可能会编写以不同方式使用变量的程序，而不知道程序运行时它们最终会保存(或引用)的值。

## 从用户那里获得输入

您已经看到，您可以在不知道变量的值的情况下编写带有变量的程序。当然，解释者最终必须知道这些值。所以我们怎么可能不知道呢？翻译只知道我们告诉它的东西，对吗？不一定。

你可能写了一个程序，别人可能会用。您无法预测用户将为程序提供什么样的价值。我们来看看有用的函数`input`。(一会儿我会对函数有更多的说明。)

```py
>>> input("The meaning of life: ")
The meaning of life: 42
'42'

```

这里发生的是在交互式解释器中执行第一行(`input(...)`)。它打印出字符串`"The meaning of life: "`作为新的提示。我输入`42`，然后按回车键。`input`的结果值就是那个数字(作为一段文本或字符串)，它自动打印在最后一行。使用`int`将字符串转换成整数，我们可以构造一个稍微有趣一点的例子:

```py
>>> x = input("x: ")
x: 34
>>> y = input("y: ")
y: 42
>>> print(int(x) * int(y))
1428

```

这里，Python 提示符处的语句(`>>>`)可能是一个已完成程序的一部分，输入的值(`34`和`42`)将由某个用户提供。然后你的程序会打印出值`1428`，它是两者的乘积。当你写程序的时候，你不需要知道这些值，对吗？

Note

当您将程序保存在一个单独的文件中以便其他用户可以执行它们时，像这样获得输入会有用得多。在本章后面的“保存和执行程序”一节中，你会学到如何做到这一点

Sneak Peek: The if Statement

为了增加一点趣味，我将让你先睹为快一些你在第五章[之前不应该了解的东西:语句。如果给定的条件为真，那么`if`语句允许您执行一个动作(另一个语句)。一种类型的条件是相等测试，使用相等运算符==。是的，这是一个双等号。(单人的是用来做作业的，记得吗？)](05.html)

您将这个条件放在单词`if`之后，然后用冒号将其与下面的语句分开。

```py
>>> if 1 == 2: print('One equals two')
...
>>> if 1 == 1: print('One equals one')
...
One equals one
>>>

```

当条件为假时，什么都不会发生。然而，当它为真时，冒号后面的语句(在本例中是一个`print`语句)被执行。还要注意，在交互式解释器中使用`if`语句时，需要在执行之前按两次 Enter 键。(原因将在第 [5](05.html) 章中变得清楚。)

因此，如果变量`time`被绑定到以分钟为单位的当前时间，您可以使用下面的语句来检查您是否“在整点”:

```py
if time % 60 == 0: print('On the hour!')

```

## 功能

在“数字和表达式”一节中，我使用了指数运算符(`**`)来计算幂。事实上，您可以使用一个名为`pow`的函数来代替。

```py
>>> 2 ** 3
8
>>> pow(2, 3)
8

```

函数就像一个小程序，你可以用它来执行一个特定的动作。Python 有很多函数，可以做很多奇妙的事情。事实上，您也可以创建自己的函数(稍后会详细介绍)；所以我们经常把`pow`等标准函数称为内置函数。

像我在前面的例子中所做的那样使用一个函数叫做调用函数。您向它提供参数(在本例中是`2`和`3`)，它向您返回值。因为它返回一个值，函数调用只是另一种类型的表达式，就像本章前面讨论的算术表达式一样。 [<sup>6</sup>](#Fn6) 事实上，你可以结合函数调用和运算符来创建更复杂的表达式(就像我之前对`int`所做的那样)。

```py
>>> 10 + pow(2, 3 * 5) / 3.0
10932.666666666666

```

像这样的数字表达式中可以使用几个内置函数。例如，`abs`给出一个数的绝对值，`round`将浮点数舍入到最接近的整数。

```py
>>> abs(-10)
10
>>> 2 // 3
0
>>> round(2 / 3)
1.0

```

注意最后两个表达式的区别。整数除法总是向下舍入，而`round`舍入到最接近的整数，平局则舍入到偶数。但是如果你想把一个给定的数字四舍五入呢？例如，您可能知道一个人 32.9 岁，但您想将其四舍五入到 32 岁，因为她实际上还没有 33 岁。Python 为此提供了一个函数(称为`floor`)——只是不能直接使用。和许多有用的函数一样，它可以在一个模块中找到。

## 模块

您可能认为模块是可以导入 Python 来扩展其功能的扩展。您可以用一个名为(很自然)`import`的特殊命令导入模块。上一节提到的函数`floor`位于一个名为`math`的模块中。

```py
>>> import math
>>> math.floor(32.9)
32

```

注意这是如何工作的:我们用`import`导入一个模块，然后通过编写`module.function`来使用该模块中的函数。特别是对于这个操作，你实际上可以把这个数字转换成一个整数，就像我之前做的那样，使用来自`input`的结果。

```py
>>> int(32.9)
32

```

Note

还有类似的函数可以转换成其他类型(例如，`str`和`float`)。事实上，这些并不是真正的函数——它们是类。稍后我会有更多关于课程的内容。

然而,`math`模块还有其他几个有用的功能。比如`floor`的反义词是`ceil`(“天花板”的简称)，求大于等于给定数的最小整数值。

```py
>>> math.ceil(32.3)
33
>>> math.ceil(32)
32

```

如果您确定不会用给定的名称(从不同的模块)导入多个函数，您可能不想在每次调用函数时都写模块名。然后，您可以使用`import`命令的变体。

```py
>>> from math import sqrt
>>> sqrt(9)
3.0

```

使用`from module import function`后，可以使用不带模块前缀的功能。

Tip

事实上，您可以使用变量来引用函数(以及 Python 中的大多数其他东西)。通过执行赋值`foo = math.sqrt`，可以开始使用`foo`计算平方根；例如，`foo(4)`产出`2.0`。

### cmath 和复数

`sqrt`函数用于计算一个数的平方根。让我们看看如果给它提供一个负数会发生什么:

```py
>>> from math import sqrt
>>> sqrt(-1)
Traceback (most recent call last):    ...
ValueError: math domain error

```

或者，在某些平台上:

```py
>>> sqrt(-1)
nan

```

Note

`nan`只是一个特殊值，意思是“不是数字”

如果我们把自己限制在实数及其浮点数形式的近似实现上，我们就不能求负数的平方根。负数的平方根是所谓的虚数，实数和虚数之和称为复数。Python 标准库有一个单独的处理复数的模块。

```py
>>> import cmath
>>> cmath.sqrt(-1)
1j

```

注意，我在这里没有使用`from ... import ...`。如果我有，我就失去了我普通的`sqrt`。像这样的名字冲突可能是偷偷摸摸的，所以除非你真的想使用`from`版本，否则你可能应该坚持使用普通的`import`。

值`1j`是虚数的一个例子。这些数字后面有一个`j`(或`J`)。复杂的算术基本上是根据定义`1j`为`-1`的平方根得出的。在不深入探讨这个话题的情况下，让我来展示最后一个例子:

```py
>>> (1 + 3j) * (9 + 4j)
(-3 + 31j)

```

如您所见，这种语言内置了对复数的支持。

Note

Python 中没有单独的虚数类型。它们被视为实部为零的复数。

### 回到 __ 未来 _ _ _

有传言说吉多·范·罗苏姆(Python 的创造者)有一台时间机器——不止一次，当人们请求该语言的特性时，他们发现这些特性已经被实现了。当然，我们并不都被允许进入这个时间机器，但是 Guido 已经很好地将它的一部分以魔法模块`__future__`的形式构建到 Python 中。从中，我们可以导入将来会成为 Python 标准的特性，但这些特性还不是该语言的一部分。你在“数字和表达式”部分看到了这一点，在本书中你会不时碰到它。

## 保存和执行您的程序

交互式解释器是 Python 的一大优势。它使得实时测试解决方案和语言实验成为可能。如果你想知道某样东西是如何工作的，试一试就知道了！但是，当您退出时，您在交互式解释器中写的所有内容都将丢失。你真正想做的是编写你和其他人都能运行的程序。在本节中，您将学习如何做到这一点。

首先，你需要一个文本编辑器，最好是用于编程的。(如果你用的是微软 Word 之类的东西，我真的不太推荐，一定要把你的代码存成纯文本。)如果你已经在用 IDLE 了，那你就走运了。使用 IDLE，您可以简单地用文件新建文件创建一个新的编辑器窗口。将出现另一个窗口，但没有交互式提示。咻！首先输入以下内容:

```py
print("Hello, world!")

```

现在选择 File Save 保存您的程序(实际上，它是一个纯文本文件)。一定要把它放在以后可以找到的地方，并给你的文件取一个合理的名字，比如`hello.py`。(`.py`结局意义重大。)

明白了吗？不要关闭有你的程序的窗口。如果有，只需再次打开它(文件打开)。现在，您可以使用运行模块来运行它。(如果您没有使用 IDLE，请参见下一节关于从命令提示符运行程序的内容。)

会发生什么？`Hello, world!`被打印在解释器窗口中，这正是我们想要的。解释器提示符可能消失了(取决于您使用的版本)，但您可以通过按 Enter 键(在解释器窗口中)恢复它。

让我们将脚本扩展如下:

```py
name = input("What is your name? ")
print("Hello, " + name  + "!")

```

如果您运行这个命令(记得首先保存它)，您应该在解释器窗口中看到以下提示:

```py
What is your name?

```

输入您的姓名(例如，`Gumby`)并按回车键。您应该得到这样的结果:

```py
Hello, Gumby!

```

Turtle Power!

`print`语句对于基本示例很有用，因为它几乎在任何地方都有效。如果你想尝试视觉上更有趣的输出，你应该看看`turtle`模块，它实现了所谓的海龟图形。如果你有空闲和运行，`turtle`模块应该工作得很好，它让你画数字，而不是打印文本。虽然这是一种通常应该小心的做法，但是在玩海龟图形的时候，简单地从模块中导入所有的名字会很方便。

```py
from turtle import *

```

一旦你弄清楚了你需要哪些函数，你就可以回到只导入那些函数的状态。

海龟图形的想法源于真正的海龟机器人，它们可以前后移动，并向左或向右转动给定的角度。此外，他们还携带一支笔，可以上下移动来确定笔是否接触到他们正在移动的纸张。`turtle`模块给你这样一个机器人的模拟。例如，你可以这样画一个三角形:

```py
forward(100)
left(120)
forward(100)
left(120)
forward(100)

```

如果你运行这个，应该会出现一个新的窗口，有一个小箭头形状的“海龟”在移动，后面拖着一条线。要让它提起笔，你用`penup()`，再放下笔，`pendown()`。更多命令，请参考 Python 库参考( [`https://docs.python.org/3/library/turtle.html`](https://docs.python.org/3/library/turtle.html) )的相关章节，对于绘图想法，请尝试在网上搜索海龟图形。当你学习更多的概念时，你可能想用海龟来代替更普通的`print`例子。玩海龟图形很快证明了我将向您展示的一些基本编程结构的必要性。(例如，你如何避免重复前面例子中的`forward`和`left`命令？比如说，你会怎么画一个八边形而不是三角形？或者几个边数不同的正多边形，代码行尽量少？)

### 从命令提示符运行 Python 脚本

实际上，有几种方法可以运行你的程序。首先，让我们假设您面前有一个 DOS 窗口或 UNIX shell 提示符，并且包含 Python 可执行文件的目录(在 Windows 中称为`python.exe`，在 UNIX 中称为`python`)或包含可执行文件的目录(在 Windows 中)已经放在您的`PATH`环境变量中。 [<sup>7</sup>](#Fn7) 同样，让我们假设上一节的脚本(`hello.py`)在当前目录中。然后，您可以在 Windows 中使用以下命令执行您的脚本:

```py
C:\>python hello.py

```

或 UNIX:

```py
$ python hello.py

```

如您所见，命令是相同的。只有系统提示改变。

### 让你的脚本像普通程序一样运行

有时，您希望像执行其他程序(如 web 浏览器或文本编辑器)一样执行 Python 程序(也称为脚本)，而不是显式使用 Python 解释器。在 UNIX 中，有一种标准的方法:让脚本的第一行以字符序列`#!`(称为 pound bang 或 shebang)开始，后跟解释脚本的程序的绝对路径(在我们的例子中是 Python)。即使您不太明白这一点，如果您想让它在 UNIX 上轻松运行，只需在脚本的第一行中输入以下内容:

```py
#!/usr/bin/env python

```

无论 Python 二进制文件位于何处，这都应该运行脚本。如果您安装了不止一个版本的 Python，您可以使用更具体的可执行文件名称，比如`python3`，而不是简单的`python`。

在实际运行脚本之前，您必须使其可执行。

```py
$ chmod a+x hello.py

```

现在它可以这样运行(假设您的路径中有当前目录):

```py
$ hello.py

```

如果这不起作用，请尝试使用`./hello.py`来代替，即使当前目录(`.`)不在您的执行路径中(一个负责任的系统管理员可能会告诉您这不应该)，这也会起作用。

如果你愿意，你可以重命名你的文件，去掉后缀`py`，让它看起来更像一个普通的程序。

#### 双击呢？

在 Windows 中，后缀(`.py`)是让你的脚本像程序一样运行的关键。尝试双击您在上一节中保存的文件`hello.py`。如果 Python 安装正确，会出现一个 DOS 窗口，提示“你叫什么名字？”然而，这样运行你的程序有一个问题。一旦你输入了你的名字，程序窗口会在你阅读结果之前关闭。程序完成时，窗口关闭。尝试通过在末尾添加以下行来更改脚本:

```py
input("Press <enter>")

```

现在，在运行程序并输入您的名字后，您应该有一个包含以下内容的 DOS 窗口:

```py
What is your name? Gumby
Hello, Gumby!
Press <enter>

```

一旦你按下回车键，窗口关闭(因为程序已经完成)。

### 评论

散列符号(`#`)在 Python 中有点特殊。当你把它放入你的代码时，它右边的所有东西都被忽略了(这就是为什么 Python 解释器没有被之前使用的`/usr/bin/env`卡住)。这里有一个例子:

```py
# Print the circumference of the circle:
print(2 * pi * radius)

```

这里的第一行被称为注释，它有助于让程序更容易理解——当你回到旧代码时，对其他人和你自己都是如此。据说程序员的第一条戒律是“你应该评论”(尽管一些不太仁慈的程序员发誓说“如果很难写，就应该很难读”)。确保你的评论是有意义的，不要简单地重复代码中已经很明显的内容。无用的、多余的评论可能比没有更糟糕。例如，在下面的例子中，并不真正需要注释:

```py
# Get the user's name:
user_name = input("What is your name?")

```

即使没有注释，让代码本身也是可读的，这总是一个好主意。幸运的是，Python 是编写可读程序的优秀语言。

## 用线串

那些东西是怎么回事？本章的第一个程序很简单

```py
print("Hello, world!")

```

在编程教程中，习惯上是从这样的程序开始。问题是我还没有真正解释它是如何工作的。你知道`print`语句的基本知识(我稍后会对此进行更多的说明)，但是什么是`"Hello, world!"`？它被称为字符串(如“一串字符”)。几乎每一个有用的、真实世界的 Python 程序中都有字符串，并且有许多用途。它们的主要用途是表示文本，例如感叹词“你好，世界！”

### 单引号字符串和转义引号

字符串是值，就像数字一样:

```py
>>> "Hello, world!"
'Hello, world!'

```

不过，这个例子中有一点可能有点令人惊讶:当 Python 打印出我们的字符串时，它使用了单引号，而我们使用了双引号。有什么区别？其实没什么区别。

```py
>>> 'Hello, world!'
'Hello, world!'

```

这里我们用单引号，结果是一样的。那么，为什么两者都允许呢？因为在某些情况下可能有用。

```py
>>> "Let's go!"
"Let's go!"
>>> '"Hello, world!" she said'
'"Hello, world!" she said'

```

在前面的代码中，第一个字符串包含一个单引号(或者一个撇号，在这个上下文中我们应该这样称呼它)，因此我们不能用单引号将字符串括起来。如果我们这样做了，翻译会抱怨(这是理所当然的)。

```py
>>> 'Let's go!'
SyntaxError: invalid syntax

```

在这里，字符串是`'Let'`，Python 不太知道如何处理后面的`s`(或者说，该行的其余部分)。

在第二个字符串中，我们使用双引号作为句子的一部分。因此，我们必须用单引号将字符串括起来，原因与前面所述相同。或者，实际上我们不必。只是方便而已。另一种方法是使用反斜杠字符(`\`)来转义字符串中的引号，如下所示:

```py
>>> 'Let\'s go!'
"Let's go!"

```

Python 知道中间的单引号是字符串中的一个字符，而不是字符串的结尾。(尽管如此，Python 还是选择在打印字符串时使用双引号。)如你所料，双引号也是如此。

```py
>>> "\"Hello, world!\" she said"
'"Hello, world!" she said'

```

像这样的转义引用可能是有用的，有时也是必要的。例如，如果您的字符串既包含单引号又包含双引号，就像在字符串`'Let\'s say "Hello, world!"'`中一样，如果没有反斜杠，您会怎么做？

Note

厌倦了反斜杠？正如你将在本章后面看到的，你可以通过使用长字符串和原始字符串(可以组合)来避免它们中的大多数。

### 串联字符串

只是为了继续鞭笞这个有点折磨人的例子，让我给你看另一种写同样字符串的方法:

```py
>>> "Let's say " '"Hello, world!"'
'Let\'s say "Hello, world!"'

```

我简单地写了两个字符串，一个接一个，Python 自动将它们连接起来(使它们成为一个字符串)。这种机制不常使用，但有时会很有用。然而，只有当你实际上同时写两个字符串，直接一个接一个的时候，它才起作用。

```py
>>> x = "Hello, "
>>> y = "world!"
>>> x y
SyntaxError: invalid syntax

```

换句话说，这只是编写字符串的一种特殊方式，而不是连接字符串的通用方法。那么，如何连接字符串呢？就像你添加数字一样:

```py
>>> "Hello, " + "world!"
'Hello, world!'
>>> x = "Hello, "
>>> y = "world!"
>>> x + y
'Hello, world!'

```

### 字符串表示，str 和 repr

在这些例子中，您可能已经注意到 Python 打印出的所有字符串仍然是带引号的。这是因为它打印出的值可能是用 Python 代码编写的，而不是用户希望的样子。但是，如果使用`print`，结果就不同了。

```py
>>> "Hello, world!"
'Hello, world!'
>>> print("Hello, world!")
Hello, world!

```

如果我们加入特殊的换行符代码`\n`，这种差异会更加明显。

```py
>>> "Hello,\nworld!"
'Hello,\nworld!'
>>> print("Hello,\nworld!")
Hello,
world!

```

值通过两种不同的机制转换为字符串。您可以通过使用函数`str`和`repr`来访问这两种机制。 [<sup>9</sup>](#Fn9) 使用`str`，你可以以某种用户可能理解的合理方式将一个值转换成一个字符串，例如，在可能的情况下，将任何特殊的字符代码转换成相应的字符。但是，如果使用`repr`，通常会得到合法 Python 表达式形式的值表示。

```py
>>> print(repr("Hello,\nworld!"))
'Hello,\nworld!'
>>> print(str("Hello,\nworld!"))
Hello,
world!

```

### 长字符串、原始字符串和字节

有一些有用的、稍微专门化的编写字符串的方法。例如，有一个自定义的语法用于编写包含换行符(长字符串)或反斜杠(原始字符串)的字符串。在 Python 2 中，也有一个单独的语法来编写带有不同种类的特殊符号的字符串，产生`unicode`类型的对象。语法仍然有效，但现在是多余的，因为 Python 3 中的所有字符串都是 Unicode 字符串。相反，引入了一种新的语法来指定一个`bytes`对象，大致相当于老式的字符串。正如我们将看到的，这些在 Unicode 编码的处理中仍然扮演着重要的角色。

#### 采油套管

如果你想写一个很长的字符串，跨越几行，你可以用三重引号代替普通引号。

```py
print('''This is a very long string.  It continues here.
And it's not over yet.  "Hello, world!"
Still here.''')

```

也可以用三重双引号，`"""like this"""`。请注意，由于独特的括起的引号，单引号和双引号都允许包含在内，而不会被反斜杠转义。

Tip

普通的字符串也可以跨几行。如果一行的最后一个字符是反斜杠，换行符本身会被“转义”并被忽略。例如:

```py
print("Hello, \ world!")

```

会打印出`Hello, world!`。一般来说，表达式和语句也是如此。

```py
>>> 1 + 2 + \
    4 + 5
12
>>> print \
    ('Hello, world')
Hello, world

```

#### 原始字符串

Raw strings 对反斜杠不太挑剔，有时候会非常有用。 [<sup>10</sup>](#Fn10) 在普通的字符串中，反斜杠有一个特殊的作用:它转义东西，让你把平时不能直接写的东西放到你的字符串中。例如，正如我们所见，一个换行符被写成`\n`并可以被放入一个字符串中，如下所示:

```py
>>> print('Hello,\nworld!')
Hello,
world!

```

这通常很好，但在某些情况下，这不是你想要的。如果您希望字符串包含一个反斜杠，后跟一个`n`会怎么样？你可能想把 DOS 路径名`C:\nowhere`放到一个字符串中。

```py
>>> path = 'C:\nowhere'
>>> path
'C:\nowhere'

```

这看起来是正确的，直到你打印出来并发现它的缺陷。

```py
>>> print(path)
C:
owhere

```

这不是我们想要的，对吧？那我们该怎么办？我们可以对反斜杠本身进行转义。

```py
>>> print('C:\\nowhere')
C:\nowhere

```

这很好。但是对于长路径，你会有很多反斜线。

```py
path = 'C:\\Program Files\\fnord\\foo\\bar\\baz\\frozz\\bozz'

```

在这种情况下，原始字符串非常有用。他们根本不把反斜杠当作特殊字符。你放入原始字符串的每个字符都保持你写的样子。

```py
>>> print(r'C:\nowhere')
C:\nowhere
>>> print(r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz')
C:\Program Files\fnord\foo\bar\baz\frozz\bozz

```

如您所见，原始字符串带有前缀`r`。看起来你可以在一个原始字符串中放入任何东西，这几乎是真的。引号必须照常转义，尽管这意味着在最后的字符串中也会有一个反斜杠。

```py
>>> print(r'Let\'s go!')
Let\'s go!

```

原始字符串中唯一不能有的是一个单独的最后一个反斜杠。换句话说，原始字符串中的最后一个字符不能是反斜杠，除非您对它进行转义(然后您用来转义它的反斜杠也将是字符串的一部分)。鉴于前面的例子，这应该是显而易见的。如果最后一个字符(在最后一个引号之前)是一个未转义的反斜杠，Python 不知道是否结束字符串。

```py
>>> print(r"This is illegal\")
SyntaxError: EOL while scanning string literal

```

好的，这是合理的，但是如果你希望原始字符串的最后一个字符是反斜杠呢？(例如，这可能是 DOS 路径的结尾。)好了，在这一节中我已经给了你一整套技巧，应该可以帮助你解决那个问题，但是基本上你需要把反斜杠放在一个单独的字符串中。下面是一个简单的方法:

```py
>>> print(r'C:\Program Files\foo\bar' '\\')
C:\Program Files\foo\bar\

```

请注意，您可以对原始字符串使用单引号和双引号。甚至三重引号字符串也可能是原始的。

#### Unicode、bytes 和 bytearray

Python 字符串使用一种称为 Unicode 的方案来表示文本。对于大多数 basic 程序来说，这种工作方式是相当透明的，所以如果你愿意，你现在可以跳过这一节，根据需要阅读这个主题。然而，由于字符串和文本文件处理是 Python 代码的主要用途之一，所以至少浏览一下这一部分可能不会有什么坏处。

抽象地说，每个 Unicode 字符都由一个所谓的码位表示，码位就是它在 Unicode 标准中的编号。这使你能够以任何现代软件都可以识别的方式引用 129 种书写系统中的 120，000 多个字符。当然，您的键盘不会有成千上万个键，所以有一些通用的机制来指定 Unicode 字符，要么通过 16 位或 32 位十六进制文字(分别以`\u`或`\U`作为前缀)，要么通过它们的 Unicode 名称(使用`\N{` `name` `}`)。

`>>> "\u00C6"`

`'Æ'`

`>>> "\U0001F60A"`

`'☺'`

`>>> "This is a cat: \N{Cat}"`

`'This is a cat:`![A326949_3_En_1_Figa_HTML.jpg](img/A326949_3_En_1_Figa_HTML.jpg)T1】

你可以通过搜索网页找到各种代码点和名称，使用你需要的字符的描述，或者你可以使用一个特定的网站，如 [`http://unicode-table.com`](http://unicode-table.com) 。

Unicode 的概念非常简单，但是它带来了一些挑战，其中之一就是编码问题。所有对象在内存或磁盘上都表示为一系列二进制数字——0 和 1——以八个字节或字节为一组，字符串也不例外。在像 C 这样的编程语言中，这些字节是完全公开的。字符串只是字节序列。例如，为了与 C 互操作，以及将文本写入文件或通过网络套接字发送，Python 有两种类似的类型，不可变的`bytes`和可变的`bytearray`。如果你愿意，你可以使用前缀`b`直接产生一个字节对象，而不是一个字符串:

```py
>>> b'Hello, world!'
b'Hello, world!'

```

然而，一个字节只能容纳 256 个值，比 Unicode 标准所要求的要少得多。Python `bytes`文字只允许 ASCII 标准的 128 个字符，剩余的 128 个字节值需要转义序列，如十六进制值`0xf0`(即`240`)的`\xf0`。

似乎这里唯一的区别是我们可用的字母表的大小。然而，这并不准确。乍一看，ASCII 和 Unicode 似乎都指非负整数和字符之间的映射，但有一个微妙的区别:Unicode 码位被定义为整数，而 ASCII 字符是由数字和二进制编码定义的。这看起来完全不起眼的一个原因是，整数 0–255 和一个八位二进制数之间的映射是完全标准的，几乎没有回旋的余地。问题是，一旦我们超越了单字节，事情就没那么简单了。简单地将每个码位表示为相应的二进制数的直接概括可能不合适。不仅存在字节顺序的问题(即使在对整数值进行编码时也会遇到这一问题),还存在空间浪费的问题:如果我们对每个代码点使用相同数量的字节进行编码，那么所有的文本都必须适应这样一个事实，即您可能希望包含一些安纳托利亚象形文字或一点帝国阿拉姆语。这种 Unicode 编码有一个标准，称为 UTF-32(Unicode 转换格式 32 位)，但是如果您主要处理的是互联网上一种更常见语言的文本，这就相当浪费了。

然而，有一个绝对聪明的选择，主要是由计算机先驱肯·汤普逊设计的。它不使用完整的 32 位，而是使用可变编码，一些脚本的字节数比其他的少。假设你会更经常地使用这些脚本，这将节省你的空间，就像莫尔斯电码通过使用更少的点和破折号来节省你的精力一样。 [<sup>11</sup>](#Fn11) 特别是，ASCII 编码仍然用于单字节编码，保留了与旧系统的兼容性。但是，超出此范围的字符使用多个字节(最多六个)。让我们尝试使用 ASCII、UTF-8 和 UTF-32 编码将字符串编码成字节。

```py
>>> "Hello, world!".encode("ASCII")
b'Hello, world!'
>>> "Hello, world!".encode("UTF-8")
b'Hello, world!'
>>> "Hello, world!".encode("UTF-32")
b'\xff\xfe\x00\x00H\x00\x00\x00e\x00\x00\x00l\x00\x00\x00l\x00\x00\x00o\x00\x00\x00,\x00\x00\x00 \x00\x00\x00w\x00\x00\x00o\x00\x00\x00r\x00\x00\x00l\x00\x00\x00d\x00\x00\x00!\x00\x00\x00'

```

如你所见，前两个是相等的，而最后一个要长得多。这是另一个例子:

```py
>>> len("How long is this?".encode("UTF-8"))
17
>>> len("How long is this?".encode("UTF-32"))
72

```

一旦我们使用一些稍微奇特的字符，ASCII 和 UTF-8 之间的区别就显现出来了:

```py
>>> "Hællå, wørld!".encode("ASCII")
Traceback (most recent call last):
  ...
UnicodeEncodeError: 'ascii' codec can't encode character '\xe6' in position 1: ordinal not in range(128)

```

这里的斯堪的纳维亚字母在 ASCII 中没有编码。如果我们真的需要 ASCII 编码(这肯定会发生)，我们可以向`encode`提供另一个参数，告诉它如何处理错误。这里的正常模式是`'strict'`，但是您可以使用其他模式来忽略或替换违规字符。

```py
>>> "Hællå, wørld!".encode("ASCII", "ignore")
b'Hll, wrld!'
>>> "Hællå, wørld!".encode("ASCII", "replace")
b'H?ll?, w?rld!'
>>> "Hællå, wørld!".encode("ASCII", "backslashreplace")
b'H\\xe6ll\\xe5, w\\xf8rld!'
>>> "Hællå, wørld!".encode("ASCII", "xmlcharrefreplace")
b'Hællå, wørld!'

```

不过，在几乎所有情况下，使用 UTF-8 会更好，事实上这甚至是默认的编码。

```py
>>> "Hællå, wørld!".encode()
b'H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!'

```

这比`"Hello, world!"`示例稍长，而 UTF-32 编码在两种情况下长度完全相同。

就像字符串可以编码成字节一样，字节也可以解码成字符串。

```py
>>> b'H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!'.decode()
'Hællå, wørld!'

```

和以前一样，默认编码是 UTF-8。我们可以指定一个不同的编码，但是如果我们使用了错误的编码，我们要么得到一个错误消息，要么得到一个乱码字符串。对象本身不知道编码，所以你有责任跟踪你使用了哪一种编码。

与其使用`encode`和`decode`方法，不如简单地构造`bytes`和`str`(即字符串)对象，如下所示:

```py
>>> bytes("Hællå, wørld!", encoding="utf-8")
b'H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!'
>>> str(b'H\xc3\xa6ll\xc3\xa5, w\xc3\xb8rld!', encoding="utf-8")
'Hællå, wørld!'

```

如果您不确切知道您正在处理的类似字符串或类似字节的对象的类，那么使用这种方法会更通用一些，并且作为一般规则，您不应该对此太严格。

编码和解码最重要的用途之一是将文本存储在磁盘上的文件中。然而，Python 读写文件的机制通常会为您完成这项工作！只要你能接受 UTF-8 编码的文件，你就不需要担心这个问题。但是，如果您最终在应该是文本的地方看到了乱码，也许文件实际上是其他编码的，那么了解一下正在发生的事情会很有用。如果您想了解更多关于 Python 中 Unicode 的知识，请查看该主题的指南。 [<sup>12</sup>](#Fn12)

Note

你的源代码也是编码的，默认也是 UTF 8。如果您想使用其他编码(例如，如果您的文本编辑器坚持保存为除 UTF-8 以外的其他格式)，您可以用特殊的注释来指定编码。

```py
# -*- coding: encoding name -*-

```

将`encoding name`替换为您正在使用的任何编码(大写或小写)，例如`utf-8`或者更有可能是`latin-1`。

最后，我们有`bytearray`，它是`bytes`的可变版本。在某种意义上，它就像一个可以修改字符的字符串——这是普通字符串做不到的。然而，它实际上更多地被设计成在幕后使用，如果作为类似字符串使用，就不太用户友好。例如，要替换一个字符，你必须给它分配一个在 0…255 范围内的`int`。所以如果你想真正插入一个字符，你必须得到它的序数值，使用`ord`。

```py
>>> x = bytearray(b"Hello!")
>>> x[1] = ord(b"u")
>>> x
bytearray(b'Hullo!')

```

## 快速总结

这一章涵盖了相当多的材料。在继续之前，让我们看看你学到了什么。

*   算法:算法是告诉你如何执行一项任务的处方。当你给计算机编程时，你实际上是在用计算机能理解的语言描述一种算法，比如 Python。这种机器友好的描述称为程序，它主要由表达式和语句组成。
*   表达式:表达式是代表一个值的计算机程序的一部分。例如，`2 + 2`是一个表达式，代表值`4`。简单表达式是通过使用运算符(如`+`或`%`)和函数(如`pow`)从文字值(如`2`或`"Hello"`)构建的。更复杂的表达式可以通过组合更简单的表达式来创建(例如`(2 + 2) * (3 - 1)`)。表达式也可能包含变量。
*   变量:变量是代表一个值的名称。可以通过`x = 2`之类的赋值将新值赋给变量。作业是一种陈述。
*   语句:语句是告诉计算机做某事的指令。这可能涉及到改变变量(通过赋值)，把东西打印到屏幕上(比如`print("Hello, world!")`)，导入模块，或者做许多其他的事情。
*   函数:Python 中的函数就像数学中的函数一样:它们可以接受一些参数，然后返回一个结果。(在返回之前，它们实际上可能会做很多有趣的事情，当你在第 [6](06.html) 章中学习编写自己的函数时，你会发现这一点。)
*   模块:模块是可以导入 Python 来扩展其功能的扩展。例如，`math`模块中有几个有用的数学函数。
*   程序:您已经看到了编写、保存和运行 Python 程序的实用性。
*   字符串:字符串非常简单——它们只是一些文本，用 Unicode 码表示字符。然而关于它们还有很多需要了解的。在这一章中，你已经看到了许多编写它们的方法，在第三章中，你将学到许多使用它们的方法。

### 本章的新功能

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `abs(number)` | 返回一个数字的绝对值。 |
| `bytes(string, encoding[, errors])` | 用指定的错误行为对给定的字符串进行编码。 |
| `cmath.sqrt(number)` | 返回平方根；适用于负数。 |
| `float(object)` | 将字符串或数字转换为浮点数。 |
| `help([object])` | 提供交互式帮助。 |
| `input(prompt)` | 以字符串形式从用户处获取输入。 |
| `int(object)` | 将字符串或数字转换为整数。 |
| `math.ceil(number)` | 以浮点数形式返回一个数的上限。 |
| `math.floor(number)` | 以浮点形式返回数字的下限。 |
| `math.sqrt(number)` | 返回平方根；对负数不起作用。 |
| `pow(x, y[, z])` | 返回 x 的 y 次方(以 z 为模)。 |
| `print(object, ...)` | 打印参数，用空格分隔。 |
| `repr(object)` | 返回值的字符串表示形式。 |
| `round(number[, ndigits])` | 将数字舍入到给定的精度，并舍入到偶数。 |
| `str(object)` | 将值转换为字符串。如果从`bytes`转换，您可以指定编码和错误行为。 |

方括号中的参数是可选的。

### 什么现在？

现在你已经知道了表达式的基础，让我们继续学习更高级的东西:数据结构。与处理简单的值(比如数字)不同，您将看到如何将它们组合成更复杂的结构，比如列表和字典。此外，您将进一步了解字符串。在第 [5](05.html) 章中，你会学到更多关于语句的知识，之后你就可以编写一些真正漂亮的程序了。

Footnotes [1](#Fn1_source)

黑魔法攻击不同于破解，破解是一个描述计算机犯罪的术语。两者经常混淆，用法也在逐渐变化。正如我在这里所使用的，黑魔法的基本意思是“一边编程一边享受乐趣”

  [2](#Fn2_source)

毕竟，没人指望西班牙宗教裁判所。。。

  [3](#Fn3_source)

稍微简单一点的是，标识符名称的规则部分基于 Unicode 标准，正如在 [`https://docs.python.org/3/reference/lexical_analysis.html`](https://docs.python.org/3/reference/lexical_analysis.html) 的 Python 语言参考中所记录的。

  [4](#Fn4_source)

如果你想知道——是的，它确实做了一些事情。它计算 2 和 2 的乘积。但是，结果不会保存在任何地方，也不会显示给用户；除了计算本身，它没有任何副作用。

  [5](#Fn5_source)

请注意关于存储的报价。值不是存储在变量中的——它们存储在计算机内存的某个阴暗的深处，由变量引用。随着阅读的深入，你会发现不止一个变量可以引用同一个值。

  [6](#Fn6_source)

如果您只是忽略返回值，函数调用也可以用作语句。

  [7](#Fn7_source)

如果你不理解这句话，你也许应该跳过这一节。你其实不需要。

  [8](#Fn8_source)

这种行为取决于您的操作系统和安装的 Python 解释器。例如，如果你已经在 macOS 中使用 IDLE 保存了文件，双击该文件就可以在 IDLE 代码编辑器中打开它。

  [9](#Fn9_source)

其实，`str`是一个类，然而就像`int. repr`是一个函数一样。

  [10](#Fn10_source)

在编写正则表达式时，原始字符串可能特别有用。你可以在第 10 章中了解更多。

  [11](#Fn11_source)

这通常是一种重要的压缩方法，例如在霍夫曼编码中使用，霍夫曼编码是几种现代压缩工具的组成部分。

  [12](#Fn12_source)

[`https://docs.python.org/3/howto/unicode.html`见](https://docs.python.org/3/howto/unicode.html)。