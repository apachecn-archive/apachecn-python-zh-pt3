# 10.包括电池

您现在已经了解了大部分基本的 Python 语言。虽然核心语言本身就很强大，但是 Python 为您提供了更多的工具。标准安装包括一组称为标准库的模块。你已经看到了其中的一些(比如`math`和`cmath`，但是还有更多。这一章向你展示了模块是如何工作的，以及如何探索它们，学习它们所提供的东西。然后这一章提供了标准库的概述，集中在几个精选的有用模块上。

## 模块

你已经知道如何制作自己的程序(或脚本)并执行它们。您还看到了如何使用`import`从外部模块获取函数到您的程序中。

```py
>>> import math
>>> math.sin(0)
0.0

```

让我们来看看如何编写自己的模块。

### 模块是程序

任何 Python 程序都可以作为模块导入。假设您已经编写了清单 [10-1](#Par6) 中的程序，并将其存储在一个名为`hello.py`的文件中。除了扩展名`.py`之外，文件的名称将成为模块的名称。

```py
# hello.py
print("Hello, world!")
Listing 10-1.A Simple Module

```

你把它保存在哪里也很重要；在下一节中，您将了解到更多这方面的内容，但现在我们假设您将它保存在目录`C:\python` (Windows)或`∼/python` (UNIX/macOS)中。

然后，您可以通过执行以下命令(使用 Windows 目录)告诉您的解释器在哪里查找该模块:

```py
>>> import sys
>>> sys.path.append('C:/python')

```

Tip

在 UNIX 中，不能简单地将字符串`'∼/python'`附加到`sys.path`上。你必须使用完整的路径(比如`'/home/yourusername/python'`，或者，如果你想自动化它，使用`sys.path.expanduser('∼/python')`。

这只是告诉解释器，除了正常查找的位置之外，还应该在目录`C:\python`中查找模块。完成这些之后，您就可以导入您的模块(它存储在文件`C:\python\hello.py`中，还记得吗？).

```py
>>> import hello
Hello, world!

```

Note

当您导入一个模块时，您可能会注意到在您的源文件旁边出现了一个名为`__` `pycache__`的新目录。(在旧版本中，你会看到带有后缀`.pyc`的文件。)这个目录包含的文件带有 Python 可以更高效处理的已处理文件。如果你以后导入同一个模块，Python 会导入这些文件，然后是你的`.py`文件，除非`.py`文件发生了变化；在这种情况下，会生成一个新的已处理文件。删除`__pycache__`目录没有坏处——会根据需要创建一个新目录。

如您所见，模块中的代码在您导入它时被执行。但是，如果您尝试再次导入它，什么也不会发生。

```py
>>> import hello
>>>

```

为什么这次不管用？因为模块在导入时并不是真的要做什么(比如打印文本)。它们主要是用来定义事物，比如变量、函数、类等等。因为你只需要定义一次，所以多次导入一个模块和导入一次效果是一样的。

Why Only Once?

在大多数情况下，只导入一次的行为是一种实质性的优化，在一种特殊的情况下，它可能非常重要:如果两个模块相互导入。

在许多情况下，您可能会编写两个需要相互访问函数和类才能正常工作的模块。例如，您可能已经创建了两个模块——`clientdb`和`billing`——分别包含客户端数据库和计费系统的代码。您的客户端数据库可能包含对您的计费系统的调用(例如，每月自动向客户端发送账单)，而计费系统可能需要从您的客户端数据库访问功能以正确计费。

如果每个模块都可以多次导入，那么这里就会出现问题。模块`clientdb`会导入`billing`，T1 又会导入`clientdb`，这……你明白了。你最终会得到一个导入的无限循环(无限递归，还记得吗？).但是，因为第二次导入模块时什么也没有发生，所以循环被中断了。

如果你坚持重载你的模块，你可以使用`importlib`模块中的`reload`函数。它采用单个参数(您想要重新加载的模块)并返回重新加载的模块。如果您对模块进行了更改，并希望这些更改在程序运行时反映在程序中，这可能会很有用。为了重新加载简单的`hello`模块(只包含一个`print`语句)，我将使用以下代码:

```py
>>> import importlib
>>> hello = importlib.reload(hello)
Hello, world!

```

在这里，我假设`hello`已经被导入(一次)。通过将`reload`的结果赋给`hello`，我已经用重新加载的版本替换了之前的版本。正如您可以从打印的问候中看到的，我确实在这里导入了模块。

如果你已经通过实例化模块`bar`中的类`Foo`创建了一个对象`x`，然后你重新加载`bar`，那么`x`引用的对象将不会以任何方式被重新创建。`x`仍将是旧版本`Foo`的实例(来自旧版本`bar`)。相反，如果您希望`x`基于重新加载模块中的新`Foo`，您将需要重新创建它。

### 模块是用来定义事物的

所以模块在第一次被导入程序时就被执行了。这似乎有点用，但不是很有用。使它们有价值的是它们(就像类一样)在之后保持它们的作用域。这意味着您定义的任何类或函数，以及您赋值的任何变量，都将成为模块的属性。这看似复杂，但实际上非常简单。

#### 在模块中定义函数

假设您已经编写了一个类似清单 [10-2](#Par27) 中的模块，并将它存储在一个名为`hello2.py`的文件中。还假设您已经将它放在 Python 解释器可以找到的地方，或者使用前一节中的`sys.path`技巧，或者使用后一节“使您的模块可用”中的更传统的方法

Tip

如果您使一个程序(它是用来执行的，而不是真正作为一个模块使用)以与其他模块相同的方式可用，那么您实际上可以使用 Python 解释器的`-m`开关来执行它。运行命令`python -m progname args`将运行带有命令行参数`args`的程序`progname`，前提是文件`progname.py`(注意后缀)与您的其他模块一起安装(也就是说，前提是您已经导入了`progname`)。

```py
# hello2.py
def hello():
    print("Hello, world!")
Listing 10-2.A Simple Module Containing a Function

```

然后您可以像这样导入它:

```py
>>> import hello2

```

然后执行模块，这意味着函数`hello`是在模块的作用域中定义的，所以可以像这样访问函数:

```py
>>> hello2.hello()
Hello, world!

```

在模块的全局作用域中定义的任何名称都可以以同样的方式使用。你为什么想这么做？为什么不在主程序中定义所有的东西呢？

主要原因是代码重用。如果你把你的代码放在一个模块中，你可以在不止一个程序中使用它，这意味着如果你写了一个好的客户端数据库，并把它放在一个叫做`clientdb`的模块中，你可以在计费时，在发送垃圾邮件时(虽然我希望你不会)，以及在任何需要访问你的客户端数据的程序中使用它。如果你没有把它放在一个单独的模块中，你将需要重写每一个程序的代码。所以，记住，要使你的代码可重用，就要模块化！(而且，没错，这肯定和抽象有关。)

#### 在模块中添加测试代码

模块用于定义诸如函数和类之类的东西，但是每隔一段时间(实际上非常频繁)，添加一些测试代码来检查事情是否如它们应该的那样工作是有用的。例如，如果你想确保`hello`函数正常工作，你可以将模块`hello2`重写为一个新的模块`hello3`，在清单 [10-3](#Par35) 中定义。

```py
# hello3.py
def hello():
    print("Hello, world!")

# A test:
hello()

Listing 10-3.A Simple Module with Some Problematic Test Code

```

这似乎是合理的——如果你把它作为一个普通的程序运行，你会发现它是有效的。然而，如果你把它作为一个模块导入，为了在另一个程序中使用`hello`函数，测试代码被执行，就像在本章的第一个`hello`模块中一样。

```py
>>> import hello3
Hello, world!
>>> hello3.hello()
Hello, world!

```

这不是你想要的。避免这种行为的关键是检查模块是作为一个程序单独运行还是导入到另一个程序中。为此，您需要变量 __ `name` __。

```py
>>> __name__
'__main__'
>>> hello3.__name__
'hello3'

```

可以看到，在“主程序”(包括解释器的交互提示)中，变量`__name__`的值为`'` __ `main` __ `'`。在导入的模块中，它被设置为该模块的名称。因此，通过加入一个`if`语句，你可以让你的模块的测试代码表现得更好，如清单 [10-4](#Par41) 所示。

```py
# hello4.py

def hello():
    print("Hello, world!")

def test():
    hello()

if __name__ == '__main__': test()

Listing 10-4.A Module with Conditional Test Code

```

如果将此作为程序运行，则执行`hello`函数；如果导入它，它的行为就像一个普通的模块。

```py
>>> import hello4
>>> hello4.hello()
Hello, world!

```

如您所见，我已经将测试代码包装在一个名为`test`的函数中。我可以将代码直接放入`if`语句中；但是，通过将它放在一个单独的测试函数中，即使您已经将它导入到另一个程序中，您也可以测试该模块。

```py
>>> hello4.test()
Hello, world!

```

Note

如果你写更彻底的测试代码，把它放在一个单独的程序中可能是个好主意。参见第 [16](16.html) 章了解更多关于编写测试的信息。

### 使您的模块可用

在前面的例子中，我修改了`sys.path`，它包含一个目录列表(字符串形式),解释器应该在其中查找模块。但是，你一般不会想这么做。理想的情况是`sys.path`包含正确的目录(包含您的模块的目录)。有两种方法可以做到这一点:把你的模块放在正确的位置或者告诉解释器去哪里找。以下部分讨论了这两种解决方案。如果你想让你的模块容易被其他人使用，那就是另一回事了。Python 打包经历了一个日益复杂和多样化的阶段；现在，Python 打包权威机构正在对其进行控制和精简，但仍有许多内容需要消化。与其深入这个具有挑战性的主题，我建议您参考 Python 打包用户指南，可从`packaging.python.org`获得。

#### 将您的模块放在正确的位置

将您的模块放在正确的位置——或者说，一个正确的位置——是非常容易的。只需要找出 Python 解释器在哪里寻找模块，然后把你的文件放在那里。如果您正在使用的机器上的 Python 解释器是由管理员安装的，并且您没有管理员权限，则您可能无法将您的模块保存在 Python 使用的任何目录中。然后，您将需要使用下一节中描述的替代解决方案:告诉解释器在哪里查找。

您可能还记得，目录列表(所谓的搜索路径)可以在`sys`模块的`path`变量中找到。

```py
>>> import sys, pprint
>>> pprint.pprint(sys.path)
['C:\\Python35\\Lib\\idlelib',
 'C:\\Python35',
 'C:\\Python35\\DLLs',
 'C:\\Python35\\lib',
 'C:\\Python35\\lib\\plat-win',
 'C:\\Python35\\lib\\lib-tk',
 'C:\\Python35\\lib\\site-packages']

```

Tip

如果你的数据结构太大，无法在一行中显示，你可以使用`pprint`模块中的`pprint`函数，而不是普通的`print`语句。`pprint`是一个漂亮的打印功能，使打印输出更加智能。

当然，你可能得不到完全相同的结果。关键是，如果您希望您的解释器找到模块，这些字符串中的每一个都提供了放置模块的位置。尽管所有这些都可以工作，`site-packages`目录是最好的选择，因为它就是为这类事情准备的。浏览您的`sys.path`并找到您的`site-packages`目录，并将清单 [10-4](#Par41) 中的模块保存在其中，但给它另起一个名字，比如`another_hello.py`。然后尝试以下方法:

```py
>>> import another_hello
>>> another_hello.hello()
Hello, world!

```

只要你的模块位于`site-packages`这样的地方，你所有的程序都能够导入它。

#### 告诉翻译往哪里看

出于多种原因，将模块放在正确的位置可能不是您的正确解决方案。

*   您不希望 Python 解释器的目录与您自己的模块混杂在一起。
*   您没有权限在 Python 解释器的目录中保存文件。
*   你想把你的模块放在别的地方。

底线是，如果你把你的模块放在别的地方，你必须告诉解释器去哪里找。正如您之前看到的，一种方法是直接修改`sys.path`，但这并不是一种常见的方法。标准方法是将您的模块目录包含在环境变量`PYTHONPATH`中。

根据您使用的操作系统的不同，`PYTHONPATH`的内容会有所不同(参见侧栏“环境变量”)，但基本上它就像`sys.path`——一个目录列表。

Environment Variables

环境变量不是 Python 解释器的一部分，而是操作系统的一部分。基本上，它们就像 Python 变量，但是它们是在 Python 解释器之外设置的。假设您使用的是`bash` shell，它可以在大多数类 UNIX 系统、macOS 和最新版本的 Windows 上使用。然后，您可以执行下面的语句将`∼/python`追加到您的`PYTHONPATH`环境变量中:

```py
export PYTHONPATH=$PYTHONPATH:∼/python

```

如果您想让这个语句在您启动的所有 shells 中执行，那么您可以将它添加到主目录中的`.bashrc`文件中。有关以其他方式编辑环境变量的说明，您应该查阅系统文档。

作为使用 PYTHONPATH 环境变量的替代方法，您可能希望考虑所谓的路径配置文件。这些是扩展名为`.pth`的文件，位于某些特定的目录中，包含应该添加到`sys.path`中的目录名。有关详细信息，请参考`site`模块的标准库文档。

### 包装

要构建模块，您可以将它们分组到包中。包基本上就是另一种类型的模块。有趣的是，它们可以包含其他模块。模块存储在一个文件中(文件扩展名为`.py`)，而包是一个目录。要让 Python 把它当作一个包，它必须包含一个名为`__init__.py`的文件。如果您像导入一个普通模块一样导入它，那么这个文件的内容将是包的内容。例如，如果您有一个名为`constants`的包，并且文件`constants/__init__.py`包含语句`PI = 3.14`，您将能够执行以下操作:

```py
import constants
print(constants.PI)

```

要将模块放入包中，只需将模块文件放入包目录中。您也可以将包嵌套在其他包中。例如，如果你想要一个名为`drawing`的包，其中包含一个名为`shapes`的模块和一个名为`colors`的模块，你需要表 [10-1](#Tab1) 中显示的文件和目录(UNIX 路径名)。

表 10-1。

A Simple Package Layout

<colgroup><col> <col></colgroup> 
| 文件/目录 | 描述 |
| --- | --- |
| `∼/python/` | `PYTHONPATH`中的目录 |
| `∼/python/drawing/` | 包目录(`drawing`包) |
| `∼/python/drawing/__init__.py` | 包装代码(`drawing`模块) |
| `∼/python/drawing/colors.py` | `colors`模块 |
| `∼/python/drawing/shapes.py` | `shapes`模块 |

在这种设置下，以下语句都是合法的:

```py
import drawing             # (1) Imports the drawing package
import drawing.colors      # (2) Imports the colors module
from drawing import shapes # (3) Imports the shapes module

```

在第一条语句之后，`drawing`中的`__init__.py`文件的内容将是可用的；然而，`shapes`号和`colors`号模块就不是了。在第二条语句之后，`colors`模块将是可用的，但是只能使用它的全名`drawing.colors`。在第三条语句之后，`shapes`模块就可用了，它的名字很短(也就是简单的`shapes`)。请注意，这些陈述只是示例。例如，不需要像我在这里所做的那样，在导入一个模块之前导入包本身。第二个声明很可能会自行执行，第三个也是如此。

## 探索模块

在我描述一些标准库模块之前，我将向您展示如何自己探索模块。这是一项很有价值的技能，因为在 Python 程序员的职业生涯中，您会遇到许多有用的模块，我不可能在这里一一介绍。当前的标准图书馆足够大，可以保证所有的书都是自己的(这样的书已经被写出来了)——而且它还在增长。每个版本都添加了新的模块，通常有些模块会有细微的变化和改进。此外，你肯定会在网上找到几个有用的模块，能够快速而容易地理解它们会使你的编程更加有趣。

### 模块里有什么？

探测模块最直接的方法是在 Python 解释器中研究它。当然，您需要做的第一件事是导入它。假设你听说了一个叫做`copy`的标准模块的传闻。

```py
>>> import copy

```

没有引发异常——所以它存在。但是它有什么用呢？它包含什么？

#### 使用目录

要找出一个模块包含什么，您可以使用`dir`函数，它列出一个对象的所有属性(以及模块的所有函数、类、变量等等)。如果你打印出`dir(copy)`，你会得到一长串名字。(去吧，试试看。)这些名称中有几个以下划线开头——暗示(按照惯例)它们不应该在模块外使用。所以让我们用一点列表理解来过滤掉它们(如果你不记得这是如何工作的，查看第 [5](05.html) 章中关于列表理解的部分)。

```py
>>> [n for n in dir(copy) if not n.startswith('_')]
['Error', 'PyStringMap', 'copy', 'deepcopy', 'dispatch_table', 'error', 'name', 't', 'weakref']

```

结果由来自`dir(copy)`的所有名字组成，这些名字的第一个字母没有下划线，应该比完整的列表更容易混淆。

#### __all__ 变量

我在上一节中对小列表理解所做的是猜测我应该在`copy`模块中看到什么。但是，你可以直接从模块本身得到正确答案。在完整的`dir(copy)`列表中，你可能已经注意到了`__all__`这个名字。这是一个包含列表的变量，类似于我用 list comprehension 创建的列表，只是这个列表是在模块本身中设置的。让我们看看它包含了什么:

```py
>>> copy.__all__
['Error', 'copy', 'deepcopy']

```

我的猜测没那么糟。我只得到几个不打算给我用的额外的名字。但是这个`__all__`列表是从哪里来的，为什么它真的在那里？第一个问题很容易回答。它是在`copy`模块中设置的，像这样(直接从`copy.py`复制过来的):

```py
__all__ = ["Error", "copy", "deepcopy"]

```

那它为什么会在那里？它定义了模块的公共接口。更具体地说，它告诉解释器从这个模块导入所有名字意味着什么。所以如果你用这个:

```py
from copy import *

```

您只能获得在`__all__`变量中列出的四个函数。例如，要导入`PyStringMap`，您需要显式地导入`copy`并使用`copy.PyStringMap`，或者使用`from copy import PyStringMap`。

这样设置`__all__`在编写模块时也是一种有用的技术。因为您的模块中可能有许多其他程序可能不需要或不想要的变量、函数和类，所以出于礼貌将它们过滤掉。如果不设置`__all__`，带星号的导入中导出的名称默认为模块中不以下划线开头的所有全局名称。

### 获得帮助

到目前为止，您一直在利用自己的聪明才智和对各种 Python 函数和特殊属性的了解来探索`copy`模块。对于这种探索，交互式解释器是一个强大的工具，因为对语言的掌握是您能够深入探索一个模块的唯一限制。但是，有一个标准函数可以提供您通常需要的所有信息。那个函数叫做`help`。让我们在`copy`功能上试试:

```py
>>> help(copy.copy)
Help on function copy in module copy:

copy(x)
    Shallow copy operation on arbitrary Python objects.

    See the module's __doc__ string for more info.

```

这告诉您,`__copy__`接受单个参数`x`,这是一个“浅层复制操作”但是它也提到了模块的`__doc__`字符串。那是什么？你可能还记得我在第六章[中提到了文档字符串。docstring 只是一个写在函数开头的字符串，用来记录函数。然后，该字符串可以被函数属性`__doc__`引用。正如您从前面的帮助文本中所理解的，模块也可能有文档字符串(它们写在模块的开头)，类也可能有文档字符串(它们写在类的开头)。](06.html)

实际上，前面的帮助文本是从 copy 函数的 docstring 中提取的:

```py
>>> print(copy.copy.__doc__)
Shallow copy operation on arbitrary Python objects.

    See the module's __doc__ string for more info.

```

与像这样直接检查 docstring 相比，使用`help`的优点是可以获得更多的信息，比如函数签名(也就是它所采用的参数)。尝试在模块本身上调用`help`,看看会得到什么。它打印出了很多信息，包括对`copy`和`deepcopy`之间的差异的彻底讨论(本质上是`deepcopy(x)`将在`x`中找到的值复制为属性等等，而`copy(x)`只是复制`x`，将副本的属性绑定到与`x`相同的值)。

### 文件

当然，模块信息的一个自然来源是它的文档。我推迟了对文档的讨论，因为自己先检查一下模块通常会快得多。例如，你可能想知道，“再问一次`range`的参数是什么？”不用在 Python 书籍或标准 Python 文档中搜索关于`range`的描述，您可以直接查看。

```py
>>> print(range.__doc__)
range(stop) -> range object
range(start, stop[, step]) -> range object

Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).

```

现在您已经对`range`函数有了一个精确的描述，并且因为您可能已经运行了 Python 解释器(在您编程时经常会对这样的函数感到疑惑)，访问这些信息只需要几秒钟。

然而，并不是每个模块和每个函数都有一个好的 docstring(尽管它们应该有)，有时您可能需要对事情如何工作进行更全面的描述。你从网上下载的大多数模块都有一些相关的文档。学习 Python 编程的一些最有用的文档是 Python 库参考，它描述了标准库中的所有模块。如果我想查找关于 Python 的一些事实，十有八九，我会在那里找到它。该库参考可在线浏览(在 [`https://docs.python.org/library`](https://docs.python.org/library) )或下载，其他几个标准文档也是如此(如 Python 教程和 Python 语言参考)。所有的文档都可以从 Python 网站 [`https://docs.python.org`](https://docs.python.org) 获得。

### 使用源

到目前为止，我讨论的探索技术对于大多数情况来说可能已经足够了。但是那些希望真正理解 Python 语言的人可能想知道关于一个模块的事情，如果不真正阅读源代码，这些事情是无法回答的。事实上，阅读源代码是学习 Python 的最好方法之一——除了自己编码。

做实际的阅读应该不是什么大问题，但是来源在哪里呢？假设您想阅读标准模块`copy`的源代码。你会在哪里找到它？一种解决方案是再次检查`sys.path`,并像解释器一样自己寻找它。一种更快的方法是检查模块的`__file__`属性。

```py
>>> print(copy.__file__)
C:\Python35\lib\copy.py

```

在那里！您可以在代码编辑器(例如 IDLE)中打开`copy.py`文件，并开始检查它是如何工作的。如果文件名以`.pyc`结尾，就使用对应的以`.py`结尾的文件。

Caution

当在文本编辑器中打开一个标准库文件时，您会有意外修改它的风险。这样做可能会破坏该文件，所以当您关闭该文件时，请确保您没有保存任何可能已做的更改。

请注意，有些模块没有任何可供阅读的 Python 源代码。它们可能内置在解释器中(如`sys`模块)，也可能用 C 编程语言编写。 [<sup>1</sup>](#Fn1) (参见第 [17 章](17.html)了解更多关于使用 c 扩展 Python 的信息)

## 标准图书馆:几个最爱

关于 Python 的短语“包括电池”最初是由 Frank Stajano 创造的，指的是 Python 丰富的标准库。当您安装 Python 时，您可以“免费”获得许多有用的模块(“电池”)因为有很多方法可以获得关于这些模块的更多信息(如本章第一部分所解释的)，所以我在这里不包括完整的参考资料(这将占用太多的空间)；相反，我将描述几个我最喜欢的标准模块，以激起您的探索欲望。你会在项目章节中遇到更多的标准模块(章节 [20](20.html) 到 [29](29.html) )。模块描述并不完整，但强调了每个模块的一些有趣的功能。

### [计]系统复制命令（system 的简写）

`sys`模块让您可以访问与 Python 解释器密切相关的变量和函数。其中一些如表 [10-2](#Tab2) 所示。

表 10-2。

Some Important Functions and Variables in the sys Module

<colgroup><col> <col></colgroup> 
| 函数/变量 | 描述 |
| --- | --- |
| `argv` | 命令行参数，包括脚本名称 |
| `exit([arg])` | 退出当前程序，可以选择返回给定的返回值或错误信息 |
| `modules` | 将模块名映射到加载的模块的字典 |
| `path` | 可以找到模块的目录名列表 |
| `platform` | 平台标识符，如`sunos5`或`win32` |
| `stdin` | 标准输入流—类似文件的对象 |
| `stdout` | 标准输出流—类似文件的对象 |
| `stderr` | 标准错误流—类似文件的对象 |

变量`sys.argv`包含传递给 Python 解释器的参数，包括脚本名。

功能`sys.` `exit`退出当前程序。(如果在第 [8](08.html) 章中讨论的`try` / `finally`块内调用，`finally`子句仍然执行。)您可以提供一个整数来表示程序是否成功，这是一个 UNIX 约定。如果您依赖默认值(零，表示成功)，那么在大多数情况下您可能不会有问题。或者，您可以提供一个字符串，它用作错误消息，对于试图找出程序停止原因的用户非常有用；然后，程序退出，并显示错误消息和指示失败的代码。

映射`sys.modules`将模块名映射到实际的模块。它仅适用于当前导入的模块。

模块变量`sys.path`在本章前面已经讨论过了。这是一个字符串列表，其中每个字符串都是一个目录名，当执行一个`import`语句时，解释器将在这个目录中寻找模块。

模块变量`sys.platform`(一个字符串)仅仅是解释器运行的“平台”的名称。这可能是一个表示操作系统的名称(例如`sunos5`或`win32`，或者它可能表示某种其他类型的平台，例如 Java 虚拟机(例如`java1.4.0`),如果您运行的是 Jython 的话。

模块变量`sys.stdin`、`sys.stdout`和`sys.stderr`是类似文件的流对象。它们代表了标准输入、标准输出和标准错误的标准 UNIX 概念。简单来说，`sys.stdin`是 Python 获取输入的地方(例如在`input`中使用的)，而`sys.stdout`是它打印的地方。在第 [11](11.html) 章你会学到更多关于文件(和这三个流)的知识。

例如，考虑以相反顺序使用打印参数的问题。当您从命令行调用 Python 脚本时，您可以在它后面添加一些参数，即所谓的命令行参数。这些将被放入列表`sys.argv`，Python 脚本的名称为`sys.argv[0]`。按照相反的顺序打印这些内容非常简单，如清单 [10-5](#Par112) 所示。

```py
# reverseargs.py
import sys
args = sys.argv[1:]
args.reverse()
print(' '.join(args))
Listing 10-5.Reversing and Printing Command-Line Arguments

```

如你所见，我复制了一份`sys.argv`。您可以修改原始参数，但是一般来说，不这样做更安全，因为程序的其他部分也可能依赖于包含原始参数的`sys.argv`。还注意到我跳过了`sys.argv`的第一个元素——剧本的名字。我用`args.reverse()`反转列表，但是我不能打印那个操作的结果。它是一个返回`None`的原地修改。另一种方法如下:

```py
print(' '.join(reversed(sys.argv[1:])))

```

最后，为了让输出更漂亮，我使用了`join`字符串方法。我们来试试结果(假设其他某个 shell 的`bash`)。

```py
$ python reverseargs.py this is a test
test a is this

```

### 骨

`os`模块可以让你访问几个操作系统服务。`os`模块广泛；表 [10-3](#Tab3) 中只描述了几个最有用的函数和变量。除了这些，`os`及其子模块`os.path`包含了几个检查、构造和删除目录和文件的函数，以及操纵路径的函数(例如，`os.path.split`和`os.path.join`让你大部分时间忽略`os.pathsep`)。有关此功能的更多信息，请参见标准库文档。在那里你还可以找到对`pathlib`模块的描述，它提供了一个面向对象的路径操作接口。

表 10-3。

Some Important Functions and Variables in the os Module

<colgroup><col> <col></colgroup> 
| 函数/变量 | 描述 |
| --- | --- |
| `environ` | 使用环境变量映射 |
| `system(command)` | 在子外壳中执行操作系统命令 |
| `sep` | 路径中使用的分隔符 |
| `pathsep` | 分隔路径的分隔符 |
| `linesep` | 行分隔符(`'\n'`、`'\r'`或`'\r\n'`) |
| `urandom(n)` | 返回`n`字节的强加密随机数据 |

映射`os.environ`包含本章前面描述的环境变量。例如，要访问环境变量`PYTHONPATH`，可以使用表达式`os.environ['PYTHONPATH']`。这种映射也可以用来改变环境变量，尽管不是所有的平台都支持。

功能`os.system`用于运行外部程序。还有其他用于执行外部程序的函数，包括`execv`，它退出 Python 解释器，将控制权交给执行的程序，以及`popen`，它创建一个类似文件的程序连接。

有关这些函数的更多信息，请参考标准库文档。

Tip

检查`subprocess`模块。它收集了`os.system`、`execv`和`popen`函数的功能。

模块变量`os.sep`是路径名中使用的分隔符。UNIX(以及 Python 的 macOS 命令行版本)中的标准分隔符是`/`。Windows 中的标准是`\\`(单个反斜杠的 Python 语法)，在旧的 macOS 中是`:`。(在某些平台上，`os.altsep`包含一个替代路径分隔符，比如 Windows 中的`/`。)

当对几个路径进行分组时，使用`os.pathsep`，就像在`PYTHONPATH`中一样。`pathsep`用于分隔路径名:UNIX/macOS 中的`:`和 Windows 中的`;`。

模块变量`os.linesep`是文本文件中使用的行分隔符字符串。在 UNIX/OS X 中，这是一个单独的换行符(`\n`)，而在 Windows 中，它是回车符和换行符的组合(`\r\n`)。

`urandom`函数使用一个依赖于系统的“真实的”(或者至少是加密的)随机性来源。如果你的平台不支持，你会得到一个`NotImplementedError`。

例如，考虑启动 web 浏览器的问题。`system`命令可用于执行任何外部程序，这在 UNIX 等环境中非常有用，在这些环境中，您可以从命令行执行程序(或命令)来列出目录内容、发送电子邮件等等。但是它也可以用于启动带有图形用户界面的程序——比如网络浏览器。在 UNIX 中，您可以执行以下操作(假设您在`/usr/bin/firefox`有浏览器):

```py
os.system('/usr/bin/firefox')

```

以下是 Windows 版本(再次使用您已安装的浏览器的路径):

```py
os.system(r'C:\"Program Files (x86)"\"Mozilla Firefox"\firefox.exe')

```

注意，我很小心地将`Program Files`和`Mozilla Firefox`用引号括起来；否则，底层 shell 会避开空白。(这对你的`PYTHONPATH`中的目录也很重要。)还要注意，这里必须使用反斜杠，因为 shell 会被正斜杠搞混。如果您运行这个程序，您会注意到浏览器试图打开一个名为`Files"\Mozilla…`的网站，这是命令中空格后面的部分。此外，如果您试图从空闲状态运行它，会出现一个 DOS 窗口，但浏览器不会启动，直到您关闭该 DOS 窗口。总而言之，这不完全是理想的行为。

另一个更适合这项工作的功能是 Windows 特有的功能`os.startfile`。

```py
os.startfile(r'C:\Program Files (x86)\Mozilla Firefox\firefox.exe')

```

正如您所看到的，`os.startfile`接受一个普通的路径，即使它包含空白(也就是说，不要像在`os.system`的例子中那样用引号将`Program Files`括起来)。

注意，在 Windows 中，你的 Python 程序在`os.system`(或`os.startfile`)启动了外部程序后，还在继续运行；在 UNIX 中，您的 Python 程序等待`os.system`命令完成。

A Better Solution: Webbrowser

`os.system`函数对很多事情都很有用，但是对于启动 web 浏览器的特定任务，有一个更好的解决方案:`webbrowser`模块。它包含一个名为`open`的功能，可以让你自动启动网络浏览器打开给定的网址。例如，如果您希望您的程序在 web 浏览器中打开 Python 网站(启动一个新的浏览器或使用一个已经运行的浏览器)，您只需使用:

```py
import webbrowser
webbrowser.open('http://www.python.org')

```

页面应该会弹出。

### fileinput

在第 [11 章](11.html)中你会学到很多关于读写文件的知识，但是这里有一个预览。`fileinput`模块使您能够轻松地遍历一系列文本文件中的所有行。如果像这样调用脚本(假设是 UNIX 命令行):

```py
$ python some_script.py file1.txt file2.txt file3.txt

```

您将能够依次迭代`file1.txt`到`file3.txt`的行。还可以迭代提供给标准输入(`sys.stdin`)的行，还记得吗？)，例如在 UNIX 管道中，使用标准的 UNIX 命令`cat`。

```py
$ cat file.txt | python some_script.py

```

如果您使用`fileinput`，在 UNIX 管道中用`cat`调用您的脚本就像将文件名作为命令行参数提供给脚本一样有效。表 [10-4](#Tab4) 中描述了`fileinput`模块最重要的功能。

表 10-4。

Some Important Functions in the fileinput Module

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `input([files[, inplace[, backup]])` | 促进多个输入流中的行的迭代 |
| `filename()` | 返回当前文件的名称 |
| `lineno()` | 返回当前(累计)行号 |
| `filelineno()` | 返回当前文件中的行号 |
| `isfirstline()` | 检查当前行是否是文件中的第一行 |
| `isstdin()` | 检查最后一行是否来自`sys.stdin` |
| `nextfile()` | 关闭当前文件并移动到下一个文件 |
| `close()` | 关闭序列 |

`fileinput.input`是最重要的功能。它返回一个对象，您可以在一个`for`循环中迭代这个对象。如果您不想要默认的行为(其中`fileinput`找出要迭代的文件)，您可以向该函数提供一个或多个文件名(作为一个序列)。您也可以将`inplace`参数设置为真值(`inplace=True`)来启用就地处理。对于您访问的每一行，您需要打印出一个替换行，它将被放回到当前的输入文件中。当您进行就地处理时，可选的`backup`参数为从原始文件创建的备份文件提供一个文件扩展名。

函数`fileinput.filename`返回当前所在文件的文件名(即包含当前正在处理的行的文件)。

函数`fileinput.lineno`返回当前行的编号。此计数是累积的，因此当您处理完一个文件并开始处理下一个文件时，行号不会被重置，而是从比前一个文件的最后一个行号多 1 的位置开始。

函数`fileinput.filelineno`返回当前文件中当前行的编号。每当您处理完一个文件并开始处理下一个文件时，文件行号将被重置并从 1 重新开始。

如果当前行是当前文件的第一行，函数`fileinput.isfirstline`返回真值；否则，它将返回一个假值。

如果当前文件为`sys.stdin`，函数`fileinput.isstdin`返回真值；否则，它返回 false。

函数`fileinput.nextfile`关闭当前文件并跳到下一个文件。跳过的行数不计入行数。如果您知道已经完成了当前文件，这可能会很有用，例如，如果每个文件都包含排序的单词，并且您正在查找特定的单词。如果您已经通过了单词在排序顺序中的位置，您可以安全地跳到下一个文件。

函数`fileinput.close`关闭整个文件链并完成迭代。

作为使用`fileinput`的一个例子，假设你写了一个 Python 脚本，你想给这些行编号。因为您希望程序在您完成这些后继续工作，所以您必须在每行的右边添加注释中的行号。要将它们对齐，可以使用字符串格式。让我们允许每个程序行最多 40 个字符，并在其后添加注释。清单 [10-6](#Par152) 中的程序用`fileinput`和`inplace`参数展示了一种简单的方法。

```py
# numberlines.py

import fileinput

for line in fileinput.input(inplace=True):
    line = line.rstrip()
    num = fileinput.lineno()
    print('{:<50} # {:2d}'.format(line, num))

Listing 10-6.Adding Line Numbers to a Python Script

```

如果你自己运行这个程序，像这样:

```py
$ python numberlines.py numberlines.py

```

您最终得到清单 [10-7](#Par156) 中的程序。注意程序本身已经被修改，如果你像这样运行几次，你会在每一行有多个数字。回想一下，`rstrip`是一个字符串方法，它返回一个字符串的副本，其中右边的所有空格都被删除了(参见第 [3 章](03.html)中的“字符串方法”一节和附录 B 中的表 B-6)。

```py
# numberlines.py                                   #  1
                                                   #  2
import fileinput                                   #  3
                                                   #  4
for line in fileinput.input(inplace=True):         #  5
    line = line.rstrip()                           #  6
    num = fileinput.lineno()                       #  7
    print('{:<50} # {:2d}'.format(line, num))      #  8
Listing 10-7.The Line Numbering Program with Line Numbers Added

```

Caution

小心使用`inplace`参数——这是破坏文件的一个简单方法。你应该仔细地测试你的程序，不要原地设置(这只是打印出结果)，在你让它修改你的文件之前，确保程序工作。

关于使用`fileinput`的另一个例子，参见本章后面关于`random`模块的章节。

### 集合、堆和 Deques

有许多有用的数据结构，Python 支持一些更常见的数据结构。其中一些，如字典(或哈希表)和列表(或动态数组)，是语言不可或缺的一部分。其他的，虽然有点外围，有时仍然可以派上用场。

#### 设置

很久以前，集合是由`sets`模块中的`Set`类实现的。尽管您可能会在现有代码中遇到`Set`实例，但是您自己没有理由使用它们，除非您想向后兼容。在最近的版本中，集合由内置的`set`类实现。这意味着您不需要导入`sets`模块——您可以直接创建集合。

```py
>>> set(range(10))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

```

集合由一个序列(或其他一些可迭代的对象)构成，或者用花括号明确指定。请注意，您不能用大括号指定空集，因为您最终会得到一个空字典。

```py
>>> type({})
<class 'dict'>

```

相反，你需要不带参数地调用`set`。集合的主要用途是确定成员资格，因此重复项会被忽略:

```py
>>> {0, 1, 2, 3, 0, 1, 2, 3, 4, 5}
{0, 1, 2, 3, 4, 5}

```

就像字典一样，集合元素的排序是非常随意的，不应该依赖它。

```py
>>> {'fee', 'fie', 'foe'}
{'foe', 'fee', 'fie'}

```

除了检查成员资格之外，您还可以执行各种标准的集合运算(您可能从数学中已经知道了)，例如并集和交集，方法是使用方法，或者使用与整数上的位运算相同的运算(请参见附录 B)。例如，您可以使用其中一个集合的`union`方法或按位 or 运算符`|`找到两个集合的并集。

```py
>>> a = {1, 2, 3}
>>> b = {2, 3, 4}
>>> a.union(b)
{1, 2, 3, 4}
>>> a | b
{1, 2, 3, 4}

```

下面是一些其他的方法和它们对应的操作符；这些名称应该清楚地表明它们的含义:

```py
>>> c = a & b
>>> c.issubset(a)
True
>>> c <= a
True
>>> c.issuperset(a)
False
>>> c >= a
False
>>> a.intersection(b)
{2, 3}
>>> a & b
{2, 3}
>>> a.difference(b)
{1}
>>> a - b
{1}
>>> a.symmetric_difference(b)
{1, 4}
>>> a ^ b
{1, 4}
>>> a.copy()
{1, 2, 3}
>>> a.copy() is a
False

```

还有各种到位操作，有相应的方法，还有基本方法`add`和`remove`。有关详细信息，请参阅《Python 库参考》中关于集合类型的部分。

Tip

如果你需要一个函数来寻找，比如说，两个集合的并集，你可以简单地使用`set`类型的`union`方法的未绑定版本。这可能是有用的，例如，与`reduce`合作。

```py
>>> my_sets = []
>>> for i in range(10):
...     my_sets.append(set(range(i, i+5)))
...
>>> reduce(set.union, my_sets)
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}

```

集合是可变的，因此不能用作字典中的键。另一个问题是集合本身可能只包含不可变的(可散列的)值，因此可能不包含其他集合。因为集合的集合经常在实践中出现，这可能是一个问题。幸运的是，有`frozenset`类型，它代表不可变的(因此是可散列的)集合。

```py
>>> a = set()
>>> b = set()
>>> a.add(b)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: set objects are unhashable
>>> a.add(frozenset(b))

```

`frozenset`构造函数创建给定集合的副本。每当您想要将一个集合用作另一个集合的成员或者作为字典的关键字时，它都是有用的。

#### 很

另一个众所周知的数据结构是堆，一种优先级队列。优先级队列允许您以任意顺序添加对象，并在任何时候(可能在添加之间)找到(并可能删除)最小的元素。这比在列表中使用`min`要有效得多。

事实上，Python 中没有单独的堆类型——只有一个具有一些堆操作功能的模块。该模块名为`heapq`(`q`代表队列)，包含六个函数(见表 [10-5](#Tab5) )，其中前四个与堆操作直接相关。您必须使用列表作为堆对象本身。

表 10-5。

Some Important Functions in the fileinput Module

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `heappush(heap, x)` | 将`x`推到堆上 |
| `heappop(heap)` | 弹出堆中最小的元素 |
| `heapify(heap)` | 在任意列表上强制执行`heap`属性 |
| `heapreplace(heap, x)` | 弹出最小的元素并推动 |
| `x nlargest(n, iter)` | 返回`iter`的`n`个最大元素 |
| `nsmallest(n, iter)` | 返回`iter`的`n`个最小元素 |

`heappush`函数用于向堆中添加一个项目。注意，您不应该在任何旧的列表中使用它——只能在通过使用各种堆函数构建的列表中使用。这样做的原因是元素的顺序很重要(即使它看起来有点杂乱无章；元素没有完全排序)。

```py
>>> from heapq import *
>>> from random import shuffle
>>> data = list(range(10))
>>> shuffle(data)
>>> heap = []
>>> for n in data:
...     heappush(heap, n)
...
>>> heap
[0, 1, 3, 6, 2, 8, 4, 7, 9, 5]
>>> heappush(heap, 0.5)
>>> heap
[0, 0.5, 3, 6, 1, 8, 4, 7, 9, 5, 2]

```

元素的顺序并不像看起来那样随意。它们没有严格的排序顺序，但是有一个保证:位置`i`的元素总是大于位置`i // 2`的元素(或者相反，它小于位置`2 * i`和`2 * i + 1`的元素)。这是底层堆算法的基础。这称为堆属性。

`heappop`函数弹出最小的元素，该元素总是在索引 0 处找到，并确保剩余元素中最小的元素接管这个位置(同时保留堆属性)。尽管弹出列表的第一个元素通常效率不是很高，但这在这里不是问题，因为`heappop`在幕后做了一些漂亮的洗牌。

```py
>>> heappop(heap)
0
>>> heappop(heap)
0.5
>>> heappop(heap)
1
>>> heap
[2, 5, 3, 6, 9, 8, 4, 7]

```

`heapify`函数接受一个任意的列表，并通过最少的洗牌使其成为合法的堆(也就是说，它施加了堆属性)。如果你没有用`heappush`从头开始构建你的堆，这是在开始使用`heappush`和`heappop`之前要使用的函数。

```py
>>> heap = [5, 8, 0, 3, 6, 7, 9, 1, 4, 2]
>>> heapify(heap)
>>> heap
[0, 1, 5, 3, 2, 7, 9, 8, 4, 6]

```

`heapreplace`函数不像其他函数那样常用。它从堆中取出最小的元素，然后将一个新元素放入其中。这比一个`heappop`后面跟着一个`heappush`要高效一点。

```py
>>> heapreplace(heap, 0.5)
0
>>> heap
[0.5, 1, 5, 3, 2, 7, 9, 8, 4, 6]
>>> heapreplace(heap, 10)
0.5
>>> heap
[1, 2, 5, 3, 6, 7, 9, 8, 4, 10]

```

`heapq`模块剩下的两个函数，`nlargest(n, iter)`和`nsmallest(n, iter)`，分别用于查找任何可迭代对象`iter`的`n`最大或最小元素。您可以通过使用排序(例如，使用`sorted`函数)和切片来做到这一点，但是堆算法更快，更节省内存(更不用说，更容易使用)。

#### 德克(和其他收藏品)

当您需要按照添加元素的顺序删除元素时，双端队列会很有用。在`collections`模块中可以找到 deque 类型以及其他几种集合类型。

deque 是从一个 iterable 对象(就像集合一样)创建的，有几个有用的方法。

```py
>>> from collections import deque
>>> q = deque(range(5))
>>> q.append(5)
>>> q.appendleft(6)
>>> q
deque([6, 0, 1, 2, 3, 4, 5])
>>> q.pop()
5
>>> q.popleft()
6
>>> q.rotate(3)
>>> q
deque([2, 3, 4, 0, 1])
>>> q.rotate(-1)
>>> q
deque([3, 4, 0, 1, 2])

```

deque 很有用，因为它允许在开始时(向左)有效地追加和弹出，这是列表所不能做到的。作为一个不错的副作用，您还可以有效地旋转元素(也就是说，将它们向左或向右移动，环绕两端)。Deque 对象也有`extend`和`extendleft`方法，`extend`的工作方式类似于相应的 list 方法，`extendleft`的工作方式类似于`appendleft`。注意在`extendleft`中使用的 iterable 对象中的元素将以相反的顺序出现在队列中。

### 时间

`time`模块包含获取当前时间、操作时间和日期、从字符串中读取日期以及将日期格式化为字符串等功能。日期可以表示为一个实数(从“纪元”中的 1 月 1 日 0 点开始的秒数，这是一个依赖于平台的年份；对于 UNIX，它是 1970)或包含九个整数的元组。这些整数在表 [10-6](#Tab6) 中解释。例如，元组

表 10-6。

The Fields of Python Date Tuples

<colgroup><col> <col> <col></colgroup> 
| 索引 | 田 | 价值 |
| --- | --- | --- |
| Zero | 年 | 例如，2000 年、2001 年等等 |
| one | 月 | 在 1-12 的范围内 |
| Two | 一天 | 在 1–31 的范围内 |
| three | 小时 | 在 0–23 的范围内 |
| four | 分钟 | 在 0–59 的范围内 |
| five | 第二 | 在 0–61 的范围内 |
| six | 工作日 | 在 0 到 6 的范围内，其中星期一为 0 |
| seven | 儒略日 | 在 1–366 的范围内 |
| eight | 日光节约时间 | 0、1 或–1 |

```py
(2008, 1, 21, 12, 2, 56, 0, 21, 0)

```

表示 2008 年 1 月 21 日 12:02:56，这是一个星期一，也是一年中的第 21 天(没有夏令时)。

秒的范围是 0–61，表示闰秒和双闰秒。夏令时数字是一个布尔值(真或假)，但如果使用–1，`mktime`(一个将这样的元组转换为自纪元以来以秒为单位测量的时间戳的函数)可能会得到正确的结果。表 [10-7](#Tab7) 中描述了`time`模块中一些最重要的功能。

表 10-7。

Some Important Functions in the time Module

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `asctime([tuple])` | 将时间元组转换为字符串 |
| `localtime([secs])` | 将秒转换为本地时间的日期元组 |
| `mktime(tuple)` | 将时间元组调整为本地时间 |
| `sleep(secs)` | 休眠`secs`秒(不做任何事情) |
| `strptime(string[, format])` | 将字符串解析为时间元组 |
| `time()` | 当前时间(自纪元以来的秒数，UTC) |

函数`time.asctime`将当前时间格式化为字符串，如下所示:

```py
>>> time.asctime()
'Mon Jul 18 14:06:07 2016'

```

如果不想要当前时间，也可以提供一个日期元组(比如那些由`localtime`创建的元组)。(对于更详细的格式化，您可以使用标准文档中描述的`strftime`函数。)

函数`time.localtime`将一个实数(从 epoch 开始的秒数)转换为一个日期元组，即本地时间。如果你想要世界时，用`gmtime`代替。

函数`time.mktime`将日期元组转换为从 epoch 开始的时间(以秒为单位);是`localtime`的逆。

函数`time.sleep`使解释器等待给定的秒数。

函数`time.strptime`将由`asctime`返回的格式的字符串转换为日期元组。(可选格式参数遵循与`strftime`相同的规则；请参见标准文档。)

函数`time.time`返回当前(世界)时间，以秒为单位。尽管历元可能因平台而异，但是您可以通过保存事件(比如函数调用)前后的`time`结果，然后计算差值，来可靠地确定某件事情的时间。关于这些函数的例子，请参见下一节，这一节将介绍`random`模块。

表 [10-7](#Tab7) 中显示的功能只是从`time`模块中选择的功能。本模块中的大多数功能执行的任务与本节中描述的任务相似或相关。如果您需要这里描述的函数没有涵盖的内容，可以看看 Python 库参考中关于`time`模块的部分；很有可能你会找到你想要的东西。

此外，还有两个与时间相关的模块可用:`datetime`(支持日期和时间算法)和`timeit`(帮助您对代码片段计时)。你可以在 Python 库参考中找到更多关于这两者的信息，并且`timeit`也在第 [16](16.html) 章中有简要讨论。

### 随意

`random`模块包含返回伪随机数的函数，这对模拟或任何生成随机输出的程序都很有用。请注意，尽管这些数字看起来完全是随机的，但它们背后有一个可预测的系统。如果你需要真正的随机性(例如，对于密码术或任何与安全相关的东西)，你应该检查一下`os`模块的`urandom`函数。在`random`模块中的`SystemRandom`类基于同样的功能，给你接近真实随机性的数据。

该模块中的一些重要功能如表 [10-8](#Tab8) 所示。

表 10-8。

Some Important Functions in the random Module

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `random()` | 返回一个随机实数 n，使得 0 ≤ n ≤ 1 |
| `getrandbits(n)` | 以长整数的形式返回 n 个随机位 |
| `uniform(a, b)` | 返回一个随机实数 n，使得`a` ≤ n ≤ `b` |
| `randrange([start], stop, [step])` | 从`range(start, stop, step)`返回一个随机数 |
| `choice(seq)` | 从序列`seq`中返回一个随机元素 |
| `shuffle(seq[, random])` | 将序列`seq`打乱到位 |
| `sample(seq, n)` | 从序列`seq`中选择`n`个随机的、唯一的元素 |

函数`random.random`是最基本的随机函数之一；它只是返回一个伪随机数 n，使得 0 ≤ n ≤ 1。除非这正是您所需要的，否则您可能应该使用提供额外功能的其他函数之一。函数`random.getrandbits`以整数的形式返回给定数量的位(二进制数字)。

当提供两个数值参数`a`和`b`时，函数`random.uniform`返回一个随机的(均匀分布的)实数 n，使得`a` n ≤ `b`。例如，如果你想要一个随机的角度，你可以使用`uniform(0, 360)`。

函数`random.randrange`是标准函数，用于生成一个范围内的随机整数，该范围是通过使用相同的参数调用`range`得到的。例如，要获得 1 到 10(包括 1 和 10)范围内的随机数，您可以使用`randrange(1, 11)`(或者，`randrange(10) + 1`)，如果您想要一个小于 20 的随机奇数正整数，您可以使用`randrange(1, 20, 2)`。

函数`random.choice`从给定的序列中(一致地)选择一个随机元素。

函数`random.shuffle`随机打乱一个(可变的)序列的元素，这样每一个可能的排序都是一样的。

函数`random.sample`从给定的序列中(一致地)选择给定数量的元素，确保它们都是不同的。

Note

对于统计倾向，有类似于`uniform`的其他函数返回根据各种其他分布采样的随机数，如贝塔变量、指数、高斯和其他几种分布。

让我们看一些使用`random`模块的例子。在这些例子中，我使用了前面描述的`time`模块中的几个函数。首先，让我们得到代表时间间隔极限的实数(2016 年)。您可以通过将日期表示为时间元组(使用`-1`表示一周中的某一天、一年中的某一天和夏令时，让 Python 自己计算)并对这些元组调用`mktime`来实现这一点:

```py
from random import *
from time import *
date1 = (2016, 1, 1, 0, 0, 0, -1, -1, -1)
time1 = mktime(date1)
date2 = (2017, 1, 1, 0, 0, 0, -1, -1, -1)
time2 = mktime(date2)

```

然后你在这个范围内统一生成一个随机数(不包括上限):

```py
>>> random_time = uniform(time1, time2)

```

然后你只需将这个数字转换回一个清晰的日期。

```py
>>> print(asctime(localtime(random_time)))
Tue Aug 16 10:11:04 2016

```

对于下一个例子，让我们问用户要扔多少个骰子，每个骰子应该有多少面。抛模机构由`randrange`和`for`回路实现。

```py
from random import randrange
num   = int(input('How many dice? '))
sides = int(input('How many sides per die? '))
sum = 0
for i in range(num): sum += randrange(sides) + 1
print('The result is', sum)

```

如果您将它放在脚本文件中并运行它，您会得到如下所示的交互:

```py
How many dice? 3
How many sides per die? 6
The result is 10

```

现在假设你做了一个文本文件，其中每行文本包含一笔财富。然后，您可以使用前面描述的`fileinput`模块将运气放入一个列表中，然后随机选择一个。

```py
# fortune.py
import fileinput, random
fortunes = list(fileinput.input())
print random.choice(fortunes)

```

在 UNIX 或 macOS 中，您可以在标准字典文件`/usr/share/dict/words`上测试这个，以获得一个随机单词。

```py
$ python fortune.py /usr/share/dict/words
dodge

```

作为最后一个例子，假设您希望您的程序在每次按键盘上的 Enter 键时向您发牌，一次一张。此外，你要确保你不会得到同一张卡不止一次。首先，你做一副“卡片”——一串字符串。

```py
>>> values = list(range(1, 11)) + 'Jack Queen King'.split()
>>> suits = 'diamonds clubs hearts spades'.split()
>>> deck = ['{} of {}'.format(v, s) for v in values for s in suits]

```

我们刚刚创建的这副牌不太适合玩纸牌游戏。让我们先看一些卡片:

```py
>>> from pprint import pprint
>>> pprint(deck[:12])
['1 of diamonds',
 '1 of clubs',
 '1 of hearts',
 '1 of spades',
 '2 of diamonds',
 '2 of clubs',
 '2 of hearts',
 '2 of spades',
 '3 of diamonds',
 '3 of clubs',
 '3 of hearts',
 '3 of spades']

```

有点太有秩序了，不是吗？这很容易解决。

```py
>>> from random import shuffle
>>> shuffle(deck)
>>> pprint(deck[:12])
['3 of spades',
 '2 of diamonds',
 '5 of diamonds',
 '6 of spades',
 '8 of diamonds',
 '1 of clubs',
 '5 of hearts',
 'Queen of diamonds',
 'Queen of hearts',
 'King of hearts',
 'Jack of diamonds',
 'Queen of clubs']

```

注意，为了节省空间，我只在这里打印了前 12 张卡片。你可以自己随意看一下整副牌。

最后，为了让 Python 在每次按下键盘上的 Enter 键时给你发一张牌，直到没有更多的牌，你只需创建一个小的`while`循环。假设您将创建卡片组所需的代码放入一个程序文件中，您只需在末尾添加以下内容:

```py
while deck: input(deck.pop())

```

注意，如果您在交互式解释器中尝试这个`while`循环，您将在每次按 Enter 时得到一个空字符串。这是因为`input`返回你写的东西(其实什么都不是)并且会被打印出来。在一个正常的程序中，这个来自`input`的返回值被简单地忽略。要交互地“忽略”它，只需将`input`的结果赋给某个你不会再看到的变量，并将其命名为类似于`ignore`的东西。

### 搁置和 json

在下一章中，您将学习如何在文件中存储数据，但是如果您想要一个真正简单的存储解决方案，`shelve`模块可以为您完成大部分工作。你只需要给它提供一个文件名。在`shelve`中唯一感兴趣的功能是`open`。当被调用时(用一个文件名)，它返回一个`Shelf`对象，你可以用它来存储东西。只要把它当作普通的字典(除了键必须是字符串)，当你完成时(并希望东西保存到磁盘)，调用它的`close`方法。

#### 潜在的陷阱

重要的是要认识到由`shelve.open`返回的对象不是一个普通的映射，如下例所示:

```py
>>> import shelve
>>> s = shelve.open('test.dat')
>>> s['x'] = ['a', 'b', 'c']
>>> s['x'].append('d')
>>> s['x']
['a', 'b', 'c']

```

`'d'`去哪里了？

解释很简单:当你在一个`shelf`对象中查找一个元素时，这个对象是从它的存储版本中重建的；当你给一个键分配一个元素时，它被存储。上例中发生的情况如下:

*   列表`['a', 'b', 'c']`存储在`s`中的关键字`'x'`下。
*   检索存储的表示，从中构造一个新的列表，并将`'d'`附加到副本中。此修改版本未被存储！
*   最后，再次检索原始文件—没有`'d'`。

要正确修改使用`shelve`模块存储的对象，您必须将一个临时变量绑定到检索到的副本，然后在副本被修改后再次存储该副本 [<sup>2</sup>](#Fn2) :

```py
>>> temp = s['x']
>>> temp.append('d')
>>> s['x'] = temp
>>> s['x']
['a', 'b', 'c', 'd']

```

还有一种方法可以解决这个问题:将`open`函数的`writeback`参数设置为`true`。如果这样做，您从工具架读取或分配给工具架的所有数据结构都将保留在内存中(缓存),只有在您关闭工具架时才会写回磁盘。如果您没有处理大量数据，并且不想担心这些事情，将`writeback`设置为 true 可能是个好主意。完成后，你必须确保关上架子；一种方法是将工具架用作上下文管理器，就像打开文件一样，这将在下一章中解释。

#### 一个简单的数据库示例

清单 [10-8](#Par254) 展示了一个使用`shelve`模块的简单数据库应用程序。

```py
# database.py
import sys, shelve

def store_person(db):
    """
    Query user for data and store it in the shelf object
    """
    pid = input('Enter unique ID number: ')
    person = {}
    person['name'] = input('Enter name: ')
    person['age'] = input('Enter age: ')
    person['phone'] = input('Enter phone number: ')
    db[pid] = person

def lookup_person(db):
    """
    Query user for ID and desired field, and fetch the corresponding data from     the shelf object
    """
    pid = input('Enter ID number: ')
    field = input('What would you like to know? (name, age, phone) ')
    field = field.strip().lower()

    print(field.capitalize() + ':', db[pid][field])

def print_help():
    print('The available commands are:')
    print('store  : Stores information about a person')
    print('lookup : Looks up a person from ID number')
    print('quit   : Save changes and exit')
    print('?      : Prints this message')

def enter_command():
    cmd = input('Enter command (? for help): ')
    cmd = cmd.strip().lower()
    return cmd

def main():
    database = shelve.open('C:\\database.dat') # You may want to change this name
    try:
        while True:
            cmd = enter_command()
            if  cmd == 'store':
                store_person(database)
            elif cmd == 'lookup':
                lookup_person(database)
            elif cmd == '?':
                print_help()
            elif cmd == 'quit':
                return
    finally:
        database.close()

if name == '__main__': main()

Listing 10-8.A Simple Database Application

```

清单 [10-8](#Par254) 中显示的程序有几个有趣的特性:

*   一切都包装在函数中，使程序更加结构化。(一个可能的改进是将这些函数组合成一个类的方法。)
*   主程序在`main`函数中，只有在`__name__ == '__main__'`时才会被调用。这意味着你可以将它作为一个模块导入，然后从另一个程序中调用`main`函数。
*   我在`main`函数中打开一个数据库(shelf ),然后将它作为参数传递给需要它的其他函数。我也可以使用全局变量，因为这个程序很小，但是在大多数情况下最好避免使用全局变量，除非你有理由使用它们。
*   在读入一些值后，我通过对它们调用`strip`和`lower`来修改版本，因为如果提供的键要与数据库中存储的键匹配，这两个键必须完全相同。如果你总是在用户输入的内容上使用`strip`和`lower`，你可以允许他们随意使用大写或小写字母以及额外的空格。另外，请注意，我在打印字段名称时使用了`capitalize`。
*   我已经使用了`try`和`finally`来确保数据库正确关闭。您永远不知道什么时候可能会出错(并且您会得到一个异常)，如果程序在没有正确关闭数据库的情况下终止，您可能会得到一个损坏的数据库文件，该文件实际上是无用的。通过使用`try`和`finally`，你可以避免这种情况。我也可以使用书架作为上下文管理器，正如在第 [11 章](11.html)中解释的那样。

所以，让我们把这个数据库拿出来兜一圈。下面是一个交互示例:

```py
Enter command (? for help): ?
The available commands are:
store  : Stores information about a person
lookup : Looks up a person from ID number
quit   : Save changes and exit
?      : Prints this message
Enter command (? for help): store
Enter unique ID number: 001
Enter name: Mr. Gumby
Enter age: 42
Enter phone number: 555-1234
Enter command (? for help): lookup
Enter ID number: 001
What would you like to know? (name, age, phone) phone
Phone: 555-1234
Enter command (? for help): quit

```

这种互动并不十分有趣。我可以用一个普通的字典而不是`shelf`对象做完全相同的事情。但是现在我已经退出了这个程序，让我们看看当我重新启动它时会发生什么——也许是第二天？

```py
Enter command (? for help): lookup
Enter ID number: 001
What would you like to know? (name, age, phone) name
Name: Mr. Gumby
Enter command (? for help): quit

```

如你所见，程序读入了我第一次创建的文件，Gumby 先生还在！

请随意试验这个程序，看看是否可以扩展它的功能并提高它的用户友好性。也许你能想出一个对你自己有用的版本？

Tip

如果您希望以一种其他语言编写的程序可以轻松阅读的形式保存数据，您可能希望研究 JSON 格式。Python 标准库提供了`json`模块来处理 JSON 字符串，在它们和 Python 值之间进行转换。

### 是

有些人在遇到问题时会想:“我知道，我会使用正则表达式。”现在他们有两个问题。——杰米·扎温斯基

`re`模块包含对正则表达式的支持。如果你听说过正则表达式，你可能知道它们有多强大；如果你没有，准备好大吃一惊吧。

但是，您应该注意，一开始掌握正则表达式可能有点棘手。关键是一次了解一点点——只需查找特定任务所需的部件。事先把它都记住是没有意义的。本节描述了`re`模块和正则表达式的主要特性，使您能够开始使用。

Tip

除了标准文档，Andrew Kuchling 的“正则表达式如何”( [`https://docs.python.org/3/howto/regex.html`](https://docs.python.org/3/howto/regex.html) )是关于 Python 中正则表达式的有用信息来源。

#### 什么是正则表达式？

正则表达式(也称为 regex 或 regexp)是可以匹配一段文本的模式。正则表达式最简单的形式就是一个普通的字符串，它匹配自身。换句话说，正则表达式`'python'`匹配字符串`'python'`。您可以将这种匹配行为用于诸如搜索文本中的模式、用一些计算值替换某些模式或者将文本拆分成片段之类的事情。

##### 通配符

正则表达式可以匹配多个字符串，您可以通过使用一些特殊字符来创建这样的模式。例如，句点字符(点)匹配任何字符(换行符除外)，因此正则表达式`'.ython'`将匹配字符串`'python'`和字符串`'jython'`。它还会匹配诸如`'qython'`、`'+ython'`或`' ython'`之类的字符串(其中第一个字母是单个空格)，但不会匹配诸如`'cpython'`或`'ython'`之类的字符串，因为句点匹配单个字母，既不是两个也不是零。

因为它匹配“任何内容”(除换行符之外的任何单个字符)，所以句点被称为通配符。

##### 转义特殊字符

普通角色匹配自己，不匹配其他。然而，特殊字符是一个不同的故事。例如，假设您想要匹配字符串`'python.org'`。是不是简单的用模式`'python.org'`？你可以，但那也会匹配`'pythonzorg'`，例如，你可能不想要的。(点匹配除换行符以外的任何字符，记得吗？)为了让一个特殊字符表现得像正常字符一样，你要对它进行转义，就像我在第 [1](01.html) 章中演示的如何对字符串中的引号进行转义一样。你在它前面放一个反斜杠。因此，在这个例子中，您将使用`'python\\.org'`，它将匹配`'python.org'`而不是其他。

注意，要得到一个反斜杠，这是`re`模块所需要的，你需要在字符串中写两个反斜杠——以避开解释器。因此，这里有两个级别的转义:(1)从解释器和(2)从`re`模块。(实际上，在某些情况下，您可以使用单个反斜杠并让解释器自动为您转义，但不要依赖它。)如果你厌倦了对折反斜杠，就用一个原始字符串，比如`r'python\.org'`。

##### 字符集

匹配任何字符都是有用的，但有时您需要更多的控制。您可以通过将子字符串括在括号中来创建所谓的字符集。这样的字符集将匹配它包含的任何字符。例如，`'[pj]ython'`将同时匹配`'python'`和`'jython'`，但不匹配其他任何内容。还可以使用范围，比如`'[a-z]'`匹配从 a 到 z(按字母顺序)的任何字符，并且可以通过一个接一个地放置来组合这样的范围，比如`'[a-zA-Z0-9]'`匹配大小写字母和数字。(请注意，字符集将只匹配一个这样的字符。)

要反转字符集，首先放置字符`^`，如在`'[^abc]'`中匹配除 a、b 或 c 之外的任何字符。

Special Characters in Character Sets

通常，如果您希望特殊字符(如点、星号和问号)在模式中显示为文字字符，而不是作为正则表达式操作符，则必须用反斜杠对它们进行转义。在字符集内部，转义这些字符通常是不必要的(尽管完全合法)。但是，您应该记住以下规则:

*   如果脱字符(`^`)出现在字符集的开头，您确实需要对它进行转义，除非您希望它充当求反运算符。(换句话说，除非是真心的，否则不要放在开头。)
*   同样，右括号(`]`)和破折号(`-`)必须放在字符集的开头，或者用反斜杠转义。(其实破折号也可能放在最后，如果你愿意的话。)

##### 替代和子模式

当您让每个字母独立变化时，字符集很好，但是如果您只想匹配字符串`'python'`和`'perl'`呢？您不能用字符集或通配符来指定这样一个特定的模式。取而代之的是，您可以使用特殊的替代字符:竖线字符(`|`)。所以，你的模式应该是`'python|perl'`。

然而，有时您不想在整个模式上使用选择操作符——只是它的一部分。要做到这一点，您需要用括号将部件或子模式括起来。前面的例子可以重写为`'p(ython|erl)'`。(注意术语子模式也可以应用于单个字符。)

##### 可选和重复的子模式

通过在子模式后添加一个问号，可以使它成为可选的。它可能出现在匹配的字符串中，但不是严格要求的。例如，这个(有点不可读)模式:

```py
r'(http://)?(www\.)?python\.org'

```

将匹配以下所有字符串(除此之外):

```py
'http://www.python.org'
'http://python.org'
'www.python.org'
'python.org'

```

这些东西在这里一文不值:

*   我对点进行了转义，以防止它们充当通配符。
*   我使用了一个原始字符串来减少反斜杠的数量。
*   每个可选子模式都用括号括起来。
*   可选的子模式可能会出现，也可能不会出现，彼此独立。

问号意味着子模式可以出现一次，也可以根本不出现。其他一些操作符允许多次重复一个子模式。

*   `(pattern)*` : `pattern`重复零次或多次。
*   `(pattern)+` : `pattern`重复一次或多次。
*   `(pattern){m,n}` : `pattern`从`m`到`n`重复多次。

所以，比如`r'w*\.python\.org'`配`'` [`www.python.org`](http://www.python.org) `'`还要配`'.python.org'``'ww.python.org'``'wwww`[`www.python.org`](http://www.python.org)`'`。同样，`r'w+\.python\.org'`匹配`'w.python.org'`但不匹配`'.python.org'`,`r'w{3,4}\.python\.org'`只匹配`'` [`www.python.org`](http://www.python.org) `'`和`'w` [`www.python.org`](http://www.python.org) `'`。

Note

这里不严格地使用术语“匹配”来表示模式匹配整个字符串。`match`函数(见表 [10-9](#Tab9) )只要求模式匹配字符串的开头。

表 10-9。

Some Important Functions in the re Module

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `compile(pattern[, flags])` | 用正则表达式从字符串创建模式对象 |
| `search(pattern, string[, flags])` | 在`string`中搜索`pattern` |
| `match(pattern, string[, flags])` | 匹配`string`开头的`pattern` |
| `split(pattern, string[, maxsplit=0])` | 按`pattern`的出现次数拆分一个`string` |
| `findall(pattern, string)` | 返回`string`中`pattern`的所有出现的列表 |
| `sub(pat, repl, string[, count=0])` | 用`repl`替换`string`中出现的`pat` |
| `escape(string)` | 转义`string`中的所有特殊正则表达式字符 |

##### 字符串的开头和结尾

到目前为止，您只查看匹配整个字符串的模式，但是您也可以尝试查找匹配该模式的子串，例如匹配模式`'w+'`的字符串`'` [`www.python.org`](http://www.python.org) `'`的子串`'www'`。当您搜索类似这样的子字符串时，有时将该子字符串锚定在整个字符串的开头或结尾会很有用。例如，您可能希望在字符串的开头匹配`'ht+p'`,而不是在其他任何地方。然后用一个脱字符号(`'^'`)来标记开头。例如，`'^ht+p'`会匹配`'` [`http://python.org`](http://python.org) `'`(就此而言还有`'htttttp://python.org'`)，但不会匹配`'` [`www.http.org`](http://www.http.org) `'`。类似地，字符串的结尾可以用美元符号(`$`)来表示。

Note

有关正则表达式运算符的完整列表，请参见 Python 库中的“正则表达式语法”一节。

#### re 模块的内容

如果你不能用正则表达式做任何事情，那么知道如何写正则表达式就没什么用了。`re`模块包含几个使用正则表达式的有用函数。表 [10-9](#Tab9) 中描述了一些最重要的方法。

函数`re.compile`将一个正则表达式(写成字符串)转换成一个模式对象，这可以用于更有效的匹配。如果在调用`search`或`match`等函数时使用表示为字符串的正则表达式，无论如何都必须在内部将其转换为正则表达式对象。通过使用`compile`功能，这样做一次，每次使用该模式时就不再需要这个步骤。模式对象作为方法具有搜索/匹配功能，所以`re.search(pat, string)`(其中`pat`是写成字符串的正则表达式)等价于`pat.search(string)`(其中`pat`是用`compile`创建的模式对象)。编译后的正则表达式对象也可以用在普通的`re`函数中。

函数`re.search`搜索一个给定的字符串，找到匹配给定正则表达式的第一个子字符串(如果有的话)。如果找到一个，则返回一个`MatchObject`(评估为真)；否则，返回`None`(评估为假)。由于返回值的性质，该函数可用于条件语句中，如下所示:

```py
if re.search(pat, string):
    print('Found it!')

```

但是，如果您需要关于匹配子串的更多信息，您可以检查返回的`MatchObject`。(您将在下一节了解更多关于`MatchObject`的信息。)

函数`re.match`试图匹配给定字符串开头的正则表达式。所以`re.match('p', 'python')`返回真(一个匹配对象)，而`re.match('p', '` [`www.python.org`](http://www.python.org) `')`返回假(`None`)。

Note

如果模式与字符串的`beginning`匹配，`match`函数将报告匹配；不要求模式匹配整个字符串。如果你想这样做，你需要在你的模式后面加一个美元符号。美元符号将匹配字符串的结尾，从而“延长”匹配。

函数`re.split`根据模式的出现次数分割字符串。这类似于 string 方法`split`，除了您允许完整的正则表达式，而不仅仅是一个固定的分隔符字符串。例如，使用字符串方法`split`，您可以根据字符串`', '`的出现次数来拆分字符串，但是使用`re.split`，您可以根据空格字符和逗号的任意序列来拆分。

```py
>>> some_text = 'alpha, beta,,,,gamma    delta'
>>> re.split('[, ]+', some_text)
['alpha', 'beta', 'gamma', 'delta']

```

Note

如果模式包含括号，则括号中的组分散在拆分的子字符串之间。例如，`re.split('o(o)', 'foobar')`将产生`['f', 'o', 'bar']`。

从这个例子中可以看出，返回值是一个子字符串列表。`maxsplit`参数表示允许的最大分割数。

```py
>>> re.split('[, ]+', some_text, maxsplit=2)
['alpha', 'beta', 'gamma    delta']
>>> re.split('[, ]+', some_text, maxsplit=1)
['alpha', 'beta,,,,gamma    delta']

```

函数`re.findall`返回给定模式的所有出现的列表。例如，要查找字符串中的所有单词，您可以执行以下操作:

```py
>>> pat = '[a-zA-Z]+'
>>> text = '"Hm... Err -- are you sure?" he said, sounding insecure.'
>>> re.findall(pat, text)
['Hm', 'Err', 'are', 'you', 'sure', 'he', 'said', 'sounding', 'insecure']

```

或者你可以找到标点符号:

```py
>>> pat = r'[.?\-",]+'
>>> re.findall(pat, text)
['"', '...', '--', '?"', ',', '.']

```

注意破折号(`-`)已经被转义，所以 Python 不会将其解释为字符范围的一部分(比如`a-z`)。

函数`re.sub`用于用给定的替换替换模式最左边的不重叠的出现。考虑以下示例:

```py
>>> pat = '{name}'
>>> text = 'Dear {name}...'
>>> re.sub(pat, 'Mr. Gumby', text)
'Dear Mr. Gumby...'

```

有关如何更有效地使用该功能的信息，请参阅本章后面的“替换中的组号和功能”一节。

函数`re.escape`是一个实用函数，用于转义字符串中可能被解释为正则表达式操作符的所有字符。如果您有一个包含许多这些特殊字符的长字符串，并且您想要避免键入大量反斜杠，或者如果您从用户处获得一个字符串(例如，通过`input`函数)并且想要将它用作正则表达式的一部分，请使用此选项。下面是它如何工作的一个例子:

```py
>>> re.escape('www.python.org')
'www\\.python\\.org'
>>> re.escape('But where is the ambiguity?')
'But\\ where\\ is\\ the\\ ambiguity\\?'

```

Note

在表 [10-9](#Tab9) 中，你会注意到一些函数有一个名为`flags`的可选参数。此参数可用于更改正则表达式的解释方式。有关这方面的更多信息，请参见 Python 库参考中关于`re`模块的部分。

#### 匹配对象和组

当找到匹配时，试图将模式与字符串的一部分匹配的`re`函数都返回`MatchObject`对象。这些对象包含与模式匹配的子字符串的信息。它们还包含关于模式的哪些部分与子串的哪些部分匹配的信息。这些部分被称为组。

组只是一个被括在括号中的子模式。各组用左括号编号。零组是整个模式。所以，在这个模式中:

```py
'There (was a (wee) (cooper)) who (lived in Fyfe)'

```

这些组如下:

```py
0 There was a wee cooper who lived in Fyfe
1 was a wee cooper
2 wee
3 cooper
4 lived in Fyfe

```

通常，这些组包含特殊字符，如通配符或重复操作符，因此您可能有兴趣了解给定组匹配了什么。例如，在此模式中:

```py
r'www\.(.+)\.com$'

```

组 0 将包含整个字符串，而组 1 将包含从`'www.'`到`'.com'`之间的所有内容。通过创建这样的模式，您可以提取字符串中您感兴趣的部分。

表 [10-10](#Tab10) 中描述了一些更重要的`re`匹配对象的方法。

表 10-10。

Some Important Methods of re Match Objects

<colgroup><col> <col></colgroup> 
| 方法 | 描述 |
| --- | --- |
| `group([group1, …])` | 检索给定子模式(组)的出现 |
| `start([group])` | 返回给定组出现的起始位置 |
| `end([group])` | 返回给定组出现的结束位置(独占限制，如在切片中) |
| `span([group])` | 返回一个组的开始和结束位置 |

方法`group`返回模式中给定组匹配的(子)字符串。如果没有给出组号，则假定组为 0。如果只给定了一个组号(或者只使用默认值 0)，则返回一个字符串。否则，返回对应于给定组号的字符串元组。

Note

除了整个比赛(第 0 组)之外，您只能有 99 个组，编号范围为 1-99。

方法`start`返回给定组出现的起始索引(默认为 0，整个模式)。

方法`end`类似于`start`，但是返回结束索引加 1。

方法`span`返回具有给定组的开始和结束索引的元组`(start, end)`(默认为 0，整个模式)。

以下示例演示了这些方法的工作原理:

```py
>>> m = re.match(r'www\.(.*)\..{3}', 'www.python.org')
>>> m.group(1)
'python'
>>> m.start(1)
4
>>> m.end(1)
10
>>> m.span(1)
(4, 10)

```

#### 替换中的组数和函数

在第一个使用`re.sub`的例子中，我简单地用另一个子串替换了一个子串——我可以很容易地用`replace`字符串方法完成这个任务(在第 [3](03.html) 章的“字符串方法”一节中有描述)。当然，正则表达式很有用，因为它允许您以更灵活的方式进行搜索，而且还允许您执行更强大的替换。

利用`re.sub`的最简单的方法是在替换字符串中使用组号。替换字符串中任何形式为`'\\n'`的转义序列都被模式中由组`n`匹配的字符串替换。例如，假设您想要将形式为`'*something*'`的单词替换为`'<em>something</em>'`，其中前者是在纯文本文档(如电子邮件)中表达强调的正常方式，后者是相应的 HTML 代码(如在网页中使用的)。让我们首先构造正则表达式。

```py
>>> emphasis_pattern = r'\*([^\*]+)\*'

```

注意正则表达式很容易变得难以阅读，所以使用有意义的变量名(可能还有一两个注释)是很重要的，如果有人(包括你！)将在某个时候查看代码。

Tip

让正则表达式更易读的一种方法是在`re`函数中使用`VERBOSE`标志。这允许你添加空白(空格字符、制表符、换行符等等)到你的模式中，这将被`re`忽略——除非你把它放在一个字符类中或者用反斜杠转义它。你也可以在这种冗长的正则表达式中加入注释。下面是一个等同于强调模式的模式对象，但是它使用了`VERBOSE`标志:

```py
>>> emphasis_pattern = re.compile(r'''
... \*               # Beginning emphasis tag -- an asterisk
... (                # Begin group for capturing phrase
... [^\*]+           # Capture anything except asterisks
... )                # End group
... \*               # Ending emphasis tag
...            ''', re.VERBOSE)
...

```

现在我有了我的模式，我可以使用`re.sub`进行替换。

```py
>>> re.sub(emphasis_pattern, r'<em>\1</em>', 'Hello, *world*!')
'Hello, <em>world</em>!'

```

如你所见，我已经成功地将文本从纯文本翻译成了 HTML。

但是，通过使用一个函数作为替换，您可以使您的替换更加强大。这个函数将被提供以`MatchObject`作为它唯一的参数，它返回的字符串将被用作替换。换句话说，您可以对匹配的子字符串做任何您想做的事情，并进行精心处理以生成它的替换。你会问，这种力量对你有什么用处？一旦您开始尝试正则表达式，您肯定会发现这种机制的无数用途。对于一个应用程序，请参阅本章后面的“样本模板系统”一节。

Greedy and Nongreedy Patterns

默认情况下，重复操作符是贪婪的，这意味着它们将尽可能地匹配。例如，假设我重写了强调程序以使用以下模式:

```py
>>> emphasis_pattern = r'\*(.+)\*'

```

这匹配一个星号，后跟一个或多个字符，然后是另一个星号。听起来很完美，不是吗？但事实并非如此。

```py
>>> re.sub(emphasis_pattern, r'<em>\1</em>', '*This* is *it*!')
'<em>This* is *it</em>!'

```

如您所见，该模式匹配了从第一个星号到最后一个星号的所有内容——包括中间的两个星号！这就是贪婪的含义:拿走你能拿走的一切。

在这种情况下，你显然不想要这种过分贪婪的行为。当您知道一个特定的字母是非法的时，前面文本中给出的解决方案(使用匹配除星号之外的任何字符的字符集)就可以了。但是让我们考虑另一种情况。如果你用形式`'**something**'`来表示强调会怎么样？现在，在强调短语中包含单个星号应该不成问题。但是如何避免太贪心呢？

实际上，这很简单——只需使用一个非 greedy 版本的重复操作符。所有的重复操作符都可以通过在它们后面加一个问号而变得不简洁。

```py
>>> emphasis_pattern = r'\*\*(.+?)\*\*'
>>> re.sub(emphasis_pattern, r'<em>\1</em>', '**This** is **it**!')
'<em>This</em> is <em>it</em>!'

```

这里我使用了运算符+？而不是+，这意味着模式将匹配通配符的一次或多次出现，如前所述。但是，它将尽可能少地匹配，因为它现在不是 greedy。因此，它将只匹配到达下一个出现的`'\*\*'`所需的最小值，这是模式的结尾。如你所见，它工作得很好。

#### 查找电子邮件的发件人

你曾经把电子邮件保存为文本文件吗？如果您看过，您可能已经看到它在顶部包含了许多基本上不可读的文本，类似于清单 [10-9](#Par362) 中所示。

```py
From foo@bar.baz Thu Dec 20 01:22:50 2008
Return-Path: <foo@bar.baz>
Received: from xyzzy42.bar.com (xyzzy.bar.baz [123.456.789.42])
        by frozz.bozz.floop (8.9.3/8.9.3) with ESMTP id BAA25436
        for <magnus@bozz.floop>; Thu, 20 Dec 2004 01:22:50 +0100 (MET)
Received: from [43.253.124.23] by bar.baz
        (InterMail vM.4.01.03.27 201-229-121-127-20010626) with ESMTP
        id <20041220002242.ADASD123.bar.baz@[43.253.124.23]>; Thu, 20 Dec 2004 00:22:42 +0000
User-Agent: Microsoft-Outlook-Express-Macintosh-Edition/5.02.2022
Date: Wed, 19 Dec 2008 17:22:42 -0700
Subject: Re: Spam
From: Foo Fie <foo@bar.baz>
To: Magnus Lie Hetland <magnus@bozz.floop>
CC: <Mr.Gumby@bar.baz>
Message-ID: <B8467D62.84F%foo@baz.com>
In-Reply-To: <20041219013308.A2655@bozz.floop> Mime- version: 1.0
Content-type: text/plain; charset="US-ASCII" Content-transfer-encoding: 7bit
Status: RO
Content-Length: 55
Lines: 6

So long, and thanks for all the spam!

Yours,
Foo Fie

Listing 10-9.A Set of (Fictitious) Email Headers

```

让我们试着找出这封邮件是谁发来的。如果您检查了文本，我相信您可以在这种情况下弄明白它(当然，特别是如果您查看邮件本身底部的签名)。但是你能看出一个大致的模式吗？如果没有电子邮件地址，如何提取发件人的姓名？或者你怎么能列出标题中提到的所有电子邮件地址呢？让我们先处理前一个任务。

包含发件人的行以字符串`'From: '`开始，以用尖括号(`<`和`>`)括起来的电子邮件地址结束。您希望在这些括号之间找到文本。如果你使用`fileinput`模块，这应该是一个简单的任务。清单 [10-10](#Par366) 给出了解决问题的程序。

Note

如果您愿意，可以不使用正则表达式来解决这个问题。您也可以使用`email`模块。

```py
# find_sender.py
import fileinput, re
pat = re.compile('From: (.*) <.*?>$')
for line in fileinput.input():
    m = pat.match(line)
    if m: print(m.group(1))
Listing 10-10.A Program for Finding the Sender of an Email

```

然后，您可以像这样运行程序(假设电子邮件在文本文件`message.eml`中):

```py
$ python find_sender.py message.eml
Foo Fie

```

关于该程序，您应该注意以下几点:

*   我编译正则表达式以使处理更有效。
*   我将想要提取的子模式放在括号中，使它成为一个组。
*   我使用了一个非 greedy 模式，所以电子邮件地址只匹配最后一对尖括号(以防名称包含一些括号)。
*   我使用一个美元符号来表示我希望模式匹配整行，一直到最后。
*   在我尝试提取特定组的匹配之前，我使用一个`if`语句来确保我确实匹配了一些东西。

要列出标题中提到的所有电子邮件地址，您需要构造一个正则表达式，该表达式只匹配一个电子邮件地址。然后，您可以使用方法`findall`在每一行中查找所有出现的内容。为了避免重复，您将地址保存在一个集合中(在本章前面有所描述)。最后，提取密钥，对它们进行排序，并打印出来。

```py
import fileinput, re
pat = re.compile(r'[a-z\-\.]+@[a-z\-\.]+', re.IGNORECASE)
addresses = set()

for line in fileinput.input():
    for address in pat.findall(line):
        addresses.add(address)
for address in sorted(addresses):
    print address

```

运行该程序时的结果输出(以清单 [10-9](#Par362) 中的电子邮件消息作为输入)如下:

```py
Mr.Gumby@bar.baz
foo@bar.baz
foo@baz.com
magnus@bozz.floop

```

注意，排序时，大写字母排在小写字母之前。

Note

我没有严格遵守这里的问题规范。问题是找到文件头中的地址，但在这种情况下，程序会找到整个文件中的所有地址。为了避免这种情况，如果发现空行，可以调用`fileinput.close()`，因为标题不能包含空行。或者，如果有多个文件，您可以使用`fileinput.nextfile()`开始处理下一个文件。

#### 一个样本模板系统

模板是一个文件，您可以将特定的值放入其中，以获得某种完整的文本。例如，您可能有一个只需要插入收件人姓名的邮件模板。Python 已经有了一个高级的模板机制:字符串格式化。然而，使用正则表达式，您可以使系统更加高级。假设您想用 Python 中的表达式对`something`求值的结果替换所有出现的`'[something]'`(“字段”)。因此，这个字符串:

```py
'The sum of 7 and 9 is [7 + 9].'

```

应该翻译成这样:

```py
'The sum of 7 and 9 is 16.'

```

此外，您希望能够在这些字段中执行赋值，以便该字符串:

```py
'[name="Mr. Gumby"]Hello, [name]'

```

应该翻译成这样:

```py
'Hello, Mr. Gumby'

```

这听起来可能是一项复杂的任务，但是让我们回顾一下可用的工具。

*   您可以使用正则表达式来匹配字段并提取它们的内容。
*   您可以用`eval`评估表达式字符串，提供包含范围的字典。你可以在一个`try` / `except`语句中做到这一点。如果出现了`SyntaxError`，你可能有一个陈述(比如一个任务)要做，应该用`exec`来代替。
*   您可以用`exec`执行赋值字符串(和其他语句)，将模板的作用域存储在一个字典中。
*   您可以使用`re.sub`将评估结果代入正在处理的字符串。突然，它看起来不那么令人生畏了，不是吗？

Tip

如果一项任务看起来令人生畏，把它分成小块总是有帮助的。此外，盘点一下你手头的工具，找出解决问题的方法。

参见清单 [10-11](#Par396) 中的示例实现。

```py
# templates.py

import fileinput, re

# Matches fields enclosed in square brackets:
field_pat = re.compile(r'\[(.+?)\]')

# We'll collect variables in this:
scope = {}

# This is used in re.sub:
def replacement(match):
    code = match.group(1)
    try:
        # If the field can be evaluated, return it:
        return str(eval(code, scope))
    except SyntaxError:
        # Otherwise, execute the assignment in the same scope ... exec code in scope
        # ... and return an empty string:
        return ''

# Get all the text as a single string:

# (There are other ways of doing this; see Chapter 11)
lines = []
for line in fileinput.input():
    lines.append(line)
text = ''.join(lines)

# Substitute all the occurrences of the field pattern:
print(field_pat.sub(replacement, text))

Listing 10-11.A Template System

```

简而言之，该程序执行以下操作:

*   定义匹配字段的模式。
*   创建一个字典作为模板的作用域。
*   定义执行以下操作的替换函数:
    *   从比赛中抓取组 1 并将其放入`code`。
    *   尝试使用作用域字典作为名称空间来评估`code`，将结果转换为字符串，并返回它。如果成功，那么这个字段就是一个表达式，一切正常。否则(即引发一个`SyntaxError`)，进入下一步。
    *   执行用于计算表达式的同一命名空间(作用域字典)中的字段，然后返回一个空字符串(因为赋值不计算任何值)。
*   使用`fileinput`读取所有可用的行，将它们放在一个列表中，并将其连接成一个大字符串。
*   使用`re.sub`中的替换功能替换所有出现的`field_pat`，并打印结果。

Note

在 Python 的早期版本中，将这些行放入一个列表中，然后在末尾将它们连接起来，比这样做要高效得多:

```py
text = ''
for line in fileinput.input():
    text += line

```

虽然这看起来很优雅，但是每个赋值都必须创建一个新的字符串，也就是旧的字符串加上新的字符串，这会导致资源的浪费并使你的程序变慢。在 Python 的旧版本中，这和使用`join`之间的差别可能是巨大的。在更新的版本中，使用+=操作符实际上可能会更快。如果性能对您很重要，您可以尝试这两种解决方案。如果你想要一种更优雅的方式来阅读一个文件的所有文本，看看第 11 章。

所以，我们只用了 15 行代码就创建了一个非常强大的模板系统(不包括空格和注释)。我希望当您使用标准库时，您开始看到 Python 变得多么强大。让我们通过测试模板系统来结束这个例子。尝试在清单 [10-12](#Par410) 所示的简单文件上运行它。

```py
[x = 2]
[y = 3]
The sum of [x] and [y] is [x + y].
Listing 10-12.A Simple Template Example

```

您应该看到这个:

```py
The sum of 2 and 3 is 5.

```

但是等等，还有更好的！因为我用过`fileinput`，所以可以依次处理几个文件。这意味着我可以用一个文件定义一些变量的值，然后用另一个文件作为插入这些值的模板。例如，我可能有一个定义如清单 [10-13](#Par414) 所示的文件，名为`magnus.txt`，还有一个模板文件如清单 [10-14](#Par415) 所示，名为`template.txt`。

```py
[name       = 'Magnus Lie Hetland' ]
[email      = 'magnus@foo.bar' ]
[language   = 'python' ]
Listing 10-13.Some Template Definitions

```

```py
[import time]
Dear [name],

I would like to learn how to program. I hear you
use the [language] language a lot -- is it something I
should consider?

And, by the way, is [email] your correct email address?

Fooville, [time.asctime()]

Oscar Frozzbozz

Listing 10-14.A Template

```

`import time`语句不是赋值语句(这是我要处理的语句类型)，但是因为我不挑剔，只使用简单的`try` / `except`语句，所以我的程序支持任何使用`eval`或`exec`的语句或表达式。您可以像这样运行程序(假设有一个 UNIX 命令行):

```py
$ python templates.py magnus.txt template.txt

```

您应该会得到类似如下的输出:

```py
Dear Magnus Lie Hetland,

I would like to learn how to program. I hear you use the python language a lot -- is it something I
should consider?

And, by the way, is magnus@foo.bar your correct email address?

Fooville, Mon Jul 18 15:24:10 2016

Oscar Frozzbozz

```

尽管这个模板系统能够进行一些非常强大的替换，但它仍然有一些缺陷。例如，如果能以更灵活的方式编写定义文件就好了。如果用`execfile`执行，您可以简单地使用普通的 Python 语法。这也将解决在输出顶部出现所有空行的问题。

你能想出改进这个项目的其他方法吗？你能想出这个程序中使用的概念的其他用途吗？真正精通任何一种编程语言的最好方法就是尝试——测试它的局限性并发现它的优势。看看你是否能重写这个程序，使它更好地工作，满足你的需要。

### 其他有趣的标准模块

尽管这一章已经涵盖了很多内容，但我仅仅触及了标准库的皮毛。为了吸引您的兴趣，我将快速介绍几个更酷的库。

*   在 UNIX 中，命令行程序通常使用各种选项或开关来运行。(Python 解释器就是一个典型的例子。)这些都会在`sys.argv`中找到，但是自己正确处理这些远非易事。`argparse`模块使得提供完整的命令行界面变得简单明了。
*   这个模块使你能够编写一个命令行解释器，有点像 Python 交互式解释器。您可以定义自己的命令，用户可以在提示符下执行这些命令。也许你可以用它作为你某个程序的用户界面？
*   CSV 是逗号分隔值的缩写，这是许多应用程序(例如，许多电子表格和数据库程序)用来存储表格数据的一种简单格式。它主要用于不同程序之间的数据交换。`csv`模块让您可以轻松地读写 CSV 文件，并且它非常透明地处理格式中一些比较棘手的部分。
*   `datetime`:如果`time`模块不足以满足你的时间追踪需求，那么`datetime`也很有可能。它支持特殊的日期和时间对象，并允许您以各种方式构建和组合这些对象。该界面在许多方面比`time`模块更加直观。
*   这个库可以让你计算两个序列有多相似。它还使您能够(从可能性列表中)找到与您提供的原始序列“最相似”的序列。例如，`difflib`可以用来创建一个简单的搜索程序。
*   枚举类型是一种具有固定的、少量可能值的类型。许多语言都内置了这样的类型，但是如果您在 Python 中需要这样的类型，`enum`模块是您的好朋友。
*   在这里，您可以找到这样的功能，它允许您只使用一个函数的一些参数(部分求值)，稍后再填充其余的参数。在 Python 3.0 中，这是你可以找到`filter`和`reduce.hashlib`的地方。有了这个模块，你可以从字符串中计算出小的“签名”(数字)。如果你计算两个不同字符串的签名，你几乎可以肯定这两个签名是不同的。您可以在大型文本文件中使用它。这些模块在加密和安全方面有多种用途。 [<sup>3</sup>](#Fn3)
*   在这里，你有很多工具来创建和组合迭代器(或者其他可迭代的对象)。有链接 iterable 的函数，有创建永远返回连续整数的迭代器的函数(类似于`range`，但是没有上限)，有重复遍历 iterable 的函数，还有其他有用的东西。
*   `logging`:简单地使用`print`语句来弄清楚你的程序中发生了什么是很有用的。如果您想在没有大量调试输出的情况下跟踪事情，您可以将这些信息写入日志文件。该模块为您提供了一套标准的工具，用于管理一个或多个中央日志，其中包括日志消息的多个优先级。
*   `statistics`:计算一组数字的平均值并不难，但是即使是偶数个元素，也要得到正确的中值，例如，实现总体和样本标准偏差的差异，就需要多一点小心。与其自己动手，不如使用`statistics`模块！`timeit`、`profile`和`trace`:`timeit`模块(及其附带的命令行脚本)是一个测量一段代码运行时间的工具。它有一些锦囊妙计，你可能应该使用它而不是`time`模块进行性能测量。`profile`模块(以及它的同伴模块`pstats`)可以用来对一段代码的效率进行更全面的分析。`trace`模块(和程序)可以给你一个覆盖率分析(也就是说，你的代码的哪些部分被执行了，哪些没有被执行)。例如，这在编写测试代码时会很有用。

## 快速总结

在本章中，你学习了模块:如何创建它们，如何探索它们，以及如何使用标准 Python 库中的一些模块。

*   模块:模块基本上是一个子程序，其主要功能是定义事物，如函数、类和变量。如果一个模块包含任何测试代码，它应该放在一个`if`语句中，该语句检查`name == '__main__'`是否。如果模块在`PYTHONPATH`中，它们可以被导入。您用语句`import foo`导入存储在文件`foo.py`中的模块。
*   包:包只是一个包含其他模块的模块。包被实现为包含名为`__init__.py`的文件的目录。
*   探索模块:将模块导入交互式解释器后，可以用多种方式探索它。其中包括使用`dir`，检查`__all__`变量，以及使用`help`函数。文档和源代码也是信息和洞察力的极好来源。
*   标准库:Python 附带了几个模块，统称为标准库。本章回顾了其中一些:
    *   `sys`:一个模块，可以让你访问与 Python 解释器紧密相连的几个变量和函数。
    *   `os`:一个模块，可以让你访问与操作系统紧密相连的几个变量和函数。
    *   `fileinput`:一个模块，它使得在几个文件或流的行上迭代变得容易。
    *   `sets`、`heapq`和`deque`:三个模块，提供三种有用的数据结构。还有内置类型`set`的套装。
    *   `time`:获取当前时间、操作和格式化时间和日期的模块。
    *   一个模块，具有生成随机数，从序列中选择随机元素，以及混洗列表元素的功能。
    *   `shelve`:创建持久映射的模块，用给定的文件名将其内容存储在数据库中。
    *   `re`:支持正则表达式的模块。

如果您想了解更多关于模块的信息，我再次建议您浏览 Python 库参考。读起来真的很有趣。

### 本章的新功能

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `dir(obj)` | 返回按字母顺序排列的属性名列表 |
| `help([obj])` | 提供交互式帮助或关于特定对象的帮助 |
| `imp.reload(module)` | 返回已经导入的模块的重新加载版本 |

### 现在怎么办？

如果您已经掌握了本章中的至少一些概念，那么您的 Python 能力可能已经向前迈进了一大步。有了唾手可得的标准库，Python 从强大变得极其强大。用你目前所学的知识，你可以编写程序来解决各种各样的问题。在下一章中，你将学到更多关于使用 Python 与外部世界的文件和网络进行交互，从而解决更大范围的问题。

Footnotes [1](#Fn1_source)

如果模块是用 C 语言编写的，C 源代码应该是可用的。

  [2](#Fn2_source)

感谢路德·比利塞特指出了这一点。

  [3](#Fn3_source)

另请参见`md5`和`sha`模块。