# 十六、测试，123

你怎么知道你的程序有效呢？你能一直依靠自己写出毫无瑕疵的代码吗？无意冒犯，我想这不太可能。当然，大多数时候用 Python 写正确的代码是很容易的，但是你的代码可能会有错误。

对于程序员来说，调试是生活的一部分，是编程工艺不可或缺的一部分。然而，开始调试的唯一方法是运行您的程序。正确仅仅运行你的程序可能还不够。例如，如果你写了一个以某种方式处理文件的程序，你将需要一些文件来运行它。或者，如果您已经编写了一个带有数学函数的实用程序库，您将需要为这些函数提供参数，以便运行您的代码。

程序员一直在做这种事情。在编译语言中，循环类似于“编辑、编译、运行”，周而复始。在某些情况下，甚至让程序编译都可能是一个问题，所以程序员只需在编辑和编译之间切换。在 Python 中，没有编译步骤——只需编辑和运行。运行你的程序是测试的全部。

在这一章中，我将讨论测试的基础。我给你一些关于如何让测试成为你的编程习惯之一的笔记，并向你展示一些编写测试的有用工具。除了标准库的测试和分析工具，我还向您展示了如何使用代码分析器 PyChecker 和 PyLint。

有关编程实践和理念的更多信息，请参见第 [19](19.html) 章。在那里，我还提到了日志记录，这与测试有些关系。

## 先测试，后编码

为了计划变更和灵活性(如果您的代码甚至在您自己的开发过程结束时仍然存在，这是至关重要的)，为程序的各个部分设置测试(所谓的单元测试)是很重要的。这也是设计应用的一个非常实用的部分。与直观的“一点点编码，一点点测试”实践不同，极限编程人群引入了非常有用但有点违反直觉的格言“一点点测试，一点点编码”

换句话说，先测试，后编码。这也被称为测试驱动编程。虽然这种方法一开始可能不熟悉，但它有很多优点，而且随着时间的推移，你会越来越喜欢它。最终，一旦你使用了测试驱动编程一段时间，在没有测试的情况下编写代码可能看起来真的很落后。

### 精确的需求规格

当开发一个软件时，你必须首先知道软件应该解决什么问题——它应该满足什么目标。你可以通过写一个需求规格说明，一个描述程序必须满足的需求的文档(或者只是一些快速注释)来阐明你的程序目标。然后很容易在以后的某个时间检查需求是否确实被满足。但是许多程序员不喜欢写报告，通常更喜欢让他们的计算机尽可能多地做他们的工作。这里有一个好消息:您可以用 Python 指定需求，并让解释器检查它们是否得到满足！

Note

有许多类型的需求，包括客户满意度这样的模糊概念。在这一节中，我将重点放在功能需求上——也就是说，程序的功能需要什么。

这个想法是从编写一个测试程序开始，然后编写一个通过测试的程序。测试程序是你的需求规格，帮助你在开发程序时坚持那些需求。

我们举一个简单的例子。假设您想编写一个模块，该模块具有一个计算给定高度和宽度的矩形面积的函数。在你开始编码之前，你写一个单元测试，用一些你知道答案的例子。您的测试程序可能看起来如清单 [16-1](#Par12) 所示。

```py
from area import rect_area
height = 3
width = 4
correct_answer = 12
answer = rect_area(height, width)
if answer == correct_answer:
    print('Test passed ')
else:
    print('Test failed ')
Listing 16-1.A Simple Test Program

```

在这个例子中，我对高度 3 和宽度 4 调用函数`rect_area`(我还没写)并将答案与正确答案进行比较，正确答案是 12。[<sup>1</sup>T4】](#Fn1)

如果您随后不小心如下实现了`rect_area`(在文件`area.py`中)并试图运行测试程序，您将会得到一个错误消息。

```py
def rect_area(height, width):
    return height * height # This is wrong ...

```

然后，您可以检查代码，看看哪里出错了，并用`height * width`替换返回的表达式。

在你写代码之前写一个测试不仅仅是为了找到 bug——也是为了看看你的代码是否工作。这有点像古老的禅宗公案:“如果没有人听到，森林中倒下的一棵树会发出声音吗？”嗯，当然有(抱歉，禅僧)，但是声音对你或者其他人没有任何影响。对于您的代码，问题是，“在您测试它之前，它实际上做什么了吗？”撇开哲学不谈，采取这样一种态度是有用的，即在你对一个特性进行测试之前，它并不真正存在(或者不是一个真正的特性)。然后你就可以清楚地证明它就在那里，并且正在做它应该做的事情。这不仅在最初开发程序时有用，而且在以后扩展和维护代码时也有用。

### 变革规划

除了在您编写程序时提供大量帮助之外，自动化测试还可以帮助您避免在引入变更时积累错误，这在您的程序变大时尤为重要。正如在第 19 章中所讨论的，你应该准备好改变你的代码，而不是疯狂地抓住现有的不放，但是改变是有危险的。当您更改代码的某个部分时，您经常会引入一两个无法预见的错误。如果你已经很好地设计了你的程序(通过适当的抽象和封装)，一个改变的影响应该是局部的，并且只影响一小部分代码。这意味着如果您发现了错误，调试会更容易。

Code Coverage

覆盖率的概念是测试知识的一个重要部分。当您运行您的测试时，您可能不会运行您代码的所有部分，即使那将是理想的情况。(实际上，最理想的情况是使用每一个可能的输入，遍历程序的每一个可能的状态，但是这真的不会发生。)一个好的测试套件的目标之一是获得良好的覆盖率，确保这一点的一种方法是使用覆盖率工具，它测量测试期间实际运行的代码的百分比。在撰写本文时，还没有真正标准化的 Python 覆盖工具，但是在网上搜索类似“test coverage python”的东西应该会出现一些选项。一个选项是 Python 发行版附带的程序`trace.py`。您可以在命令行上将它作为一个程序运行(可能使用`-m`开关，省去了您查找文件的麻烦)，或者您可以将它作为一个模块导入。关于如何使用它的帮助，你可以用`--help`开关运行程序，或者导入模块并在解释器中执行`help(trace)`。

有时，您可能会被广泛测试所有内容的要求压垮。别担心——你不必测试输入和状态变量的数百种组合，至少一开始不用。测试驱动编程最重要的部分是，你实际上在编码时反复运行你的方法(或函数或脚本),以获得关于你做得如何的持续反馈。如果您想增加对代码正确性(以及覆盖率)的信心，您总是可以在以后添加更多的测试。

关键是，如果你手头没有一套完整的测试，你甚至可能直到后来才发现你引入了一个错误，那时你不再知道错误是如何引入的。如果没有一套好的测试，就很难准确找出问题所在。你不能逆来顺受，除非你看到他们来了。获得良好测试覆盖率的一个方法是遵循测试驱动编程的原则。如果在编写函数之前确保已经编写了测试，就可以确定每个函数都经过了测试。

### 测试的 1-2-3(和 4)

在我们进入编写测试的本质之前，这里有一个测试驱动开发过程的分解(或者至少是它的一个版本):

1.  想出你想要的新功能。可能记录它，然后为它编写一个测试。
2.  为该特性编写一些框架代码，这样您的程序运行时不会出现任何语法错误或类似错误，但您的测试仍然会失败。看到你的测试失败是很重要的，所以你肯定它确实会失败。如果测试有问题，并且无论如何它总是成功(这已经发生在我身上很多次了)，你就没有真正测试任何东西。这一点值得重复:在你试图让测试成功之前，先看到它失败。
3.  为你的骨架写伪代码，只是为了安抚测试。这不需要精确地实现功能；它只需要通过测试。这样，在开发的时候，你可以让你所有的测试都通过(除了第一次运行测试的时候，记得吗？)，即使在最初实现功能时也是如此。
4.  重写(或重构)代码，使它真正做它应该做的事情，同时确保你的测试一直成功。

当你离开时，你应该保持你的代码处于一个健康的状态——不要留下任何失败的测试(或者，就此而言，在你的伪代码还在的情况下成功)。他们是这么说的。我发现我有时会留下一个失败的测试，这是我目前工作的点，作为我自己的一种“待办事项”或“继续这里”。但是，如果你和其他人一起开发，这是非常不好的形式。您不应该将失败的代码签入公共代码库中。

## 测试工具

你可能认为编写大量的测试来确保程序的每个细节都正常工作听起来像是一件苦差事。好吧，我有好消息告诉你:标准库中有帮助(不是一直都有吗？).有两个出色的模块可以自动完成测试过程。

*   通用测试框架
*   一个更简单的模块，设计用于检查文档，但也非常适合编写单元测试

我们先来看看`doctest`，这是一个很好的起点。

### doctest(测试)

在本书中，我使用了直接来自交互式解释器的例子。我发现这是一种展示事物如何工作的有效方式，当你有这样一个例子时，你很容易自己去测试它。事实上，交互式解释器会话是放入 docstrings 的一种有用的文档形式。例如，假设我编写了一个求数字平方的函数，并在它的 docstring 中添加了一个例子。

```py
def square(x):
    '''
    Squares a number and returns the result.

    >>> square(2)
    4
    >>> square(3)
    9
    '''
    return x * x

```

如您所见，我也在 docstring 中包含了一些文本。这和测试有什么关系？假设`square`函数定义在模块`my_math`(即一个名为`my_math.py`的文件)中。然后，您可以在底部添加以下代码:

```py
if name =='__main__':
    import doctest, my_math
    doctest.testmod(my_math)

```

这不是很多，是吗？您只需导入`doctest`和`my_math`模块本身，然后从`doctest`运行`testmod`(对于“测试模块”)函数。这是做什么的？让我们试试。

```py
$ python my_math.py
$

```

似乎什么都没发生，但这是件好事。`doctest.testmod`函数读取一个模块的所有文档字符串，并从交互式解释器中找出任何看起来像例子的文本。然后它检查这个例子是否代表现实。

Note

如果我在这里编写一个真正的函数，我将(或者应该，根据我之前制定的规则)首先编写 docstring，用 doctest 运行脚本以查看测试是否失败，添加一个虚拟版本(例如使用`if`语句来处理 docstring 中的特定输入)以使测试成功，然后开始进行正确的实现。另一方面，如果您打算进行全面的“先测试，后编码”编程，那么`unittest`框架(稍后讨论)可能更适合您的需求。

为了获得更多的输入，您可以给脚本添加`-v`(表示“详细”)开关。

```py
$ python my_math.py -v

```

该命令将产生以下输出:

```py
Running my_math.__doc__
0 of 0 examples failed in my_math.__doc__
Running my_math.square.__doc__
Trying: square(2)
Expecting: 4
Ok

Trying: square(3)
Expecting: 9
ok
0 of 2 examples failed in my_math.square.__doc__
1 items had no tests:
     test
1 items passed all tests:
2 tests in my_math.square
2 tests in 2 items.
2 passed and 0 failed.
Test passed.

```

如你所见，幕后发生了很多事情。`testmod`函数检查模块 docstring(如您所见，它不包含任何测试)和函数 docstring(它包含两个测试，两个测试都成功)。

有了测试，您就可以安全地更改代码了。假设您想使用 Python 取幂运算符而不是简单乘法，并使用`x ** 2`而不是`x * x`。你编辑了代码，但是不小心忘记输入数字 2，以`x ** x`结束。尝试一下，然后运行脚本来测试代码。会发生什么？这是您得到的输出:

```py
*****************************************************************
Failure in example: square(3)
from line #5 of my_math.square
Expected: 9
Got: 27
*****************************************************************
1 items had failures:
    1 of 2 in my_math.square
***Test Failed***
1 failures.

```

所以错误被发现了，你得到了一个非常清晰的错误描述。现在解决这个问题应该不难。

Caution

不要盲目相信自己的测试，一定要测试足够多的案例。正如你所看到的，使用`square(2)`的测试没有捕捉到错误，因为对于`x == 2`，`x ** 2`和`x ** x`是同一个东西！

要了解关于`doctest`模块的更多信息，您应该再次查阅库参考。

### 单元测试

虽然`doctest`非常容易使用，但是`unittest`(基于流行的测试框架 JUnit，for Java)更加灵活和强大。`unittest`可能比`doctest`有更陡峭的学习曲线，但是我建议你看一看这个模块，因为它允许你以更结构化的方式编写非常大和全面的测试集。

我将在这里给你一个简单的介绍。包含了一些您在大多数测试中可能不需要的特性。

Tip

标准库中单元测试工具的两个有趣的替代品是`pytest` ( `pytest.org`)和`nose` ( `nose.readthedocs.io`)。

同样，让我们看一个简单的例子。您将编写一个名为`my_math`的模块，其中包含一个名为`product`的计算乘积的函数。那么你从哪里开始呢？当然是通过测试(在一个名为`test_my_math.py`的文件中)，使用来自`unittest`模块的`TestCase`类(参见清单 [16-2](#Par55) )。

```py
import unittest, my_math

class ProductTestCase(unittest.TestCase):

    def test_integers(self):
        for x in range(-10, 10):
            for y in range(-10, 10):
                p = my_math.product(x, y)
                self.assertEqual(p, x * y, 'Integer multiplication failed')

    def test_floats(self):
        for x in range(-10, 10):
            for y in range(-10, 10):
                x = x / 10
                y = y / 10
                p = my_math.product(x, y)
                self.assertEqual(p, x * y, 'Float multiplication failed')

if __name__ == '__main__': unittest.main()

Listing 16-2.A Simple Test Using the unittest Framework

```

函数`unittest.main`负责为您运行测试。它将实例化`TestCase`的所有子类，并运行名称以`test`开头的所有方法。

Tip

如果您定义了名为`setUp`和`tearDown`的方法，它们将在每个测试方法之前和之后执行。您可以使用这些方法为所有的测试提供公共的初始化和清理代码，即所谓的测试夹具。

当然，运行这个测试脚本只会给出一个关于模块`my_math`不存在的异常。像`assertEqual`这样的方法检查一个条件，以确定给定的测试是成功还是失败。`TestCase`类还有许多其他类似的方法，比如`assertTrue`、`assertIsNotNone`和`assertAlmostEqual`。

`unittest`模块区分错误和失败，前者引发异常，后者由调用`failUnless`等导致。下一步是编写框架代码，这样我们就不会出错，只会失败。这仅仅意味着创建一个名为`my_math`的模块(即一个名为`my_math.py`的文件)，包含以下内容:

```py
def product(x, y):
    pass

```

全是填充物，没意思。如果您现在运行测试，您应该会得到两条`FAIL`消息，如下所示:

```py
FF
======================================================================
FAIL: test_floats (__main__.ProductTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test_my_math.py", line 17, in testFloats
    self.assertEqual(p, x * y, 'Float multiplication failed')
AssertionError: Float multiplication failed
======================================================================
FAIL: test_integers (__main__.ProductTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test_my_math.py", line 9, in testIntegers
     self.assertEqual(p, x * y, 'Integer multiplication failed')
AssertionError: Integer multiplication failed

----------------------------------------------------------------------
Ran 2 tests in 0.001s

FAILED (failures=2)

```

这都在意料之中，所以不要太担心。现在，至少，您知道测试确实与代码相关联——代码是错误的，测试失败了。太好了。

下一步是让它发挥作用。在这种情况下，当然没什么大不了的:

```py
def product(x, y):
    return x * y

```

现在输出简单如下:

```py
..
----------------------------------------------------------------------
Ran 2 tests in 0.015s
OK

```

顶部的两个点是测试。如果您仔细观察失败版本的混杂输出，您也会在顶部看到两个字符:两个`F`表示两次失败。

只是为了好玩，改变`product`函数，使其对于特定的参数 7 和 9 失效。

```py
def product(x, y):
    if x == 7 and y == 9:
        return 'An insidious bug has surfaced!'
    else:
        return x * y

```

如果您再次运行测试脚本，您应该会得到一个失败。

```py
.F
======================================================================
FAIL: test_integers (__main__.ProductTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test_my_math.py", line 9, in testIntegers
   self.assertEqual(p, x * y, 'Integer multiplication failed')
AssertionError: Integer multiplication failed
----------------------------------------------------------------------
Ran 2 tests in 0.005s

FAILED (failures=1)

```

Tip

对于面向对象代码的更高级测试，请查看模块`unittest.mock`。

## 超越单元测试

测试显然是重要的，对于任何有点复杂的项目来说，它们是绝对重要的。即使你不想为单元测试的结构化套件而烦恼，你也必须有某种方法来运行你的程序，看看它是否有效。在您进行任何大量的编码之前拥有这种能力可以为您以后节省大量的工作(和痛苦)。

还有其他方法来预测你的程序，在这里我将向你展示几个工具来做这件事:源代码检查和分析。源代码检查是寻找代码中常见错误或问题的一种方式(有点像编译器对静态类型语言所做的，但远不止于此)。剖析是一种发现你的程序到底有多快的方法。我按照这个顺序来讨论这些话题，以此来尊重这条古老的好规则:“让它工作，让它更好，让它更快。”单元测试帮助它工作；源代码检查可以帮助它变得更好；最后，剖析有助于加快速度。

### 用 PyChecker 和 PyLint 检查源代码

在相当长的一段时间里，PyChecker ( `pychecker.sf.net`)是检查 Python 源代码的唯一工具，用来寻找错误，比如提供不能用于给定函数的参数等等。(好吧，在标准库中有`tabnanny`，但是它并不那么强大，因为它只是检查你的缩进。)随后出现了 PyLint ( [`pylint.org`](http://www.logilab.org/projects/pylint) )，它支持 PyChecker 的大部分特性以及更多特性(比如你的变量名是否符合给定的命名约定，你是否遵守自己的编码标准，等等)。

安装工具很简单。它们都可以从几个包管理器系统(比如 Debian APT 和 Gentoo Portage)获得，也可以从它们各自的网站直接下载。您可以使用 Distutils 和标准命令进行安装。

```py
python setup.py install

```

也可以使用`pip`安装 PyLint。

一旦完成，这些工具应该可以作为命令行脚本(分别用于 PyChecker 和 PyLint 的`pychecker`和`pylint`)和 Python 模块(具有相同的名称)使用。

Note

在 Windows 中，这两个工具使用批处理文件`pychecker.bat`和`pylint.bat`作为命令行工具。您可能需要将这些添加到 PATH 环境变量中，以便在命令行中使用`pychecker`和`pylint`命令。

要使用 PyChecker 检查文件，您可以使用文件名作为参数运行脚本，如下所示:

```py
pychecker file1.py file2.py ...

```

使用 PyLint，您可以使用模块(或包)名称:

```py
pylint module

```

您可以通过使用`-h`命令行开关运行这两个工具来获得更多信息。当您运行这些命令中的任何一个时，您可能会得到相当多的输出(很可能来自`pylint`的输出比来自`pychecker`的输出多)。这两个工具都可以根据您想要获得(或抑制)的警告进行配置；有关更多信息，请参见各自的文档。

在离开检查器之前，让我们看看如何将它们与单元测试结合起来。毕竟，让它们(或者只是其中的一个)作为测试在您的测试套件中自动运行，并且在没有任何问题的情况下静静地成功，这将是非常令人愉快的。那么你实际上可以有一个测试套件，不仅测试功能，也测试代码质量。

PyChecker 和 PyLint 都可以作为模块导入(分别是`pychecker.checker`和`pylint.lint`)，但是它们并没有真正被设计成以编程方式使用。当你导入`pychecker.checker`时，它会检查后面的代码(包括导入的模块)，将警告打印到标准输出。`pylint.lint`模块有一个名为`Run`的未记录的函数，它在`pylint`脚本本身中使用。这也打印出警告，而不是以某种方式返回它们。与其纠结于这些问题，我建议使用 PyChecker 和 PyLint 的本来用途:作为命令行工具。而 Python 中使用命令行工具的方式就是`subprocess`模块。清单 [16-3](#Par89) 是早期测试脚本的一个例子，现在有两个代码检查测试。

```py
import unittest, my_math
from subprocess import Popen, PIPE

class ProductTestCase(unittest.TestCase):

    # Insert previous tests here

    def test_with_PyChecker(self):
        cmd = 'pychecker', '-Q', my_math.__file__.rstrip('c')
        pychecker = Popen(cmd, stdout=PIPE, stderr=PIPE)
        self.assertEqual(pychecker.stdout.read(), '')

    def test_with_PyLint(self):
        cmd = 'pylint', '-rn', 'my_math'
        pylint = Popen(cmd, stdout=PIPE, stderr=PIPE)
        self.assertEqual(pylint.stdout.read(), '')

if __name__ == '__main__': unittest.main()

Listing 16-3.Calling External Checkers Using the subprocess Module

```

我给了 checker 程序一些命令行开关，以避免干扰测试的无关输出。对于`pychecker`，我已经提供了`-Q`(静音)开关。对于`pylint`，我提供了`-rn`(其中`n`代表“否”)来关闭报告，这意味着它将只显示警告和错误。

`pylint`命令直接使用提供的模块名运行，因此非常简单。为了让`pychecker`正常工作，我们需要获得一个文件名。为了实现这一点，我使用了`my_math`模块的`__file__`属性，`rstrip`去除了可能在文件名末尾找到的任何`c`(因为该模块实际上可能来自于`.pyc`文件)。

为了安抚 PyLint(而不是将它配置为对短变量名、缺少的修订和文档字符串之类的事情闭口不谈)，我稍微重写了`my_math`模块。

```py
"""
A simple math module.
"""
__revision__ = '0.1'

def product(factor1, factor2):
    'The product of two numbers'
    return factor1 * factor2

```

如果您现在运行测试，您应该不会得到任何错误。试着摆弄一下代码，看看是否能让任何检查器在功能测试仍然工作的时候报告错误。(请随意删除 PyChecker 或 PyLint——一个可能就足够了。)比如试着把参数重新命名回`x`和`y`，PyLint 要抱怨变量名短。或者在`return`语句后添加`print('Hello, world!')`，两个检查者都会合理地抱怨(可能给出不同的抱怨理由)。

The Limits of Automatic Checking: Will it Ever End?

虽然像 PyChecker 或 PyLint 这样的自动检查器所能发现的东西令人惊讶，但是它们的能力是有限的。虽然他们能发现的错误和问题的广度令人印象深刻，但他们不知道你的程序最终要做什么；因此，总是需要定制的单元测试。但是除了这个明显的障碍，自动检查器还有其他限制。如果你喜欢稍微有点奇怪的理论，你可能会对计算理论世界的一个结果感兴趣，这个结果被称为停止定理。让我们考虑一个假设的检验程序，我们可以这样运行:

```py
halts.py myprog.py data.txt

```

正如您可能猜到的，当对输入`data.txt`运行时，检查器应该检查`myprog.py`的行为。我们只想检查一件事:无限循环(或任何等效的东西)。换句话说，程序`halts.py`应该决定`myprog.py`在`data.txt`上运行时是否会停止。鉴于现有的 checker 程序可以分析代码，并确定各种变量必须是哪种类型才能工作，检测像无限循环这样简单的事情似乎轻而易举，对吗？抱歉，但是没有，至少一般情况下没有。

不要相信我的话，道理其实很简单。假设我们有一个正在工作的暂停检查器，并假设(为了简单起见)它是作为 Python 模块编写的。现在，让我们假设我们编写了下面这个小小的阴险程序，名为`trouble.py`。

```py
import halts, sys
name = sys.argv[1]
if halts.check(name, name):
    while True: pass

```

它使用`halts`模块的功能来检查一个作为第一个命令行参数给出的程序，如果把它自己作为输入来提供，它是否会停止。它可以这样运行，例如:

```py
trouble.py myprog.py

```

这将决定如果以`myprog.py`(即其自身)作为输入，那么`myprog.py`是否会停止。如果确定它会停止运行，`trouble.py`将进入无限循环。否则，它将简单地结束(即，暂停)。

现在考虑以下场景:

```py
halts.py trouble.py trouble.py

```

我们正在检查`trouble.py`是否会以`trouble.py`(也就是它自己)作为输入而停止。本身并不那么令人费解。但是结果会是什么呢？如果`halts.py`说“是”——也就是说`trouble.py trouble.py`将停止——那么`trouble.py trouble.py`被定义为不停止。如果我们得到一个“不”，我们就会遇到同样的(逆向)问题。无论哪种方式，`halts.py`都注定会出错，而且没有办法修复。我们以假设检查器实际工作开始这个故事，现在我们达到了一个矛盾，这意味着我们的假设是错误的。

当然，这并不意味着我们不能检测任何类型的无限循环。例如，看到一个没有`break`、`raise`或`return`的`while True`将是一个强有力的线索。只是一般情况下检测不出来。可悲的是，许多其他类似的属性在一般情况下也无法自动分析。因此，即使有 PyChecker 和 PyLint 这样漂亮的工具，我们也需要依靠根植于我们对程序特殊环境的了解的手工调试。或许，我们应该尽量避免故意编写像`trouble.py`这样复杂的程序。

### 压型

现在你已经让你的代码工作了，并且可能比最初的版本更好，是时候让它更快了。那么，同样，它可能不会。正如 Donald Knuth 引用 C. A. R. Hoare 的话说:“过早优化是编程中所有罪恶(或者至少是大部分罪恶)的根源。”如果你真的不需要，不要担心聪明的优化技巧。如果程序足够快，干净、简单、可理解的代码的价值可能比稍快的程序高得多。毕竟，再过几个月，更快的硬件可能就会出现。

但是如果您确实需要优化您的程序，因为它对于您的需求来说根本不够快，您绝对应该在做任何事情之前对它进行概要分析。这是因为很难猜测瓶颈在哪里，除非你的程序非常简单。如果你不知道是什么让你的程序变慢，很可能你优化的是错误的东西。

标准库包括一个名为`profile`的漂亮的剖析器模块，以及一个更快的 C 版本，名为`cProfile`。使用分析器很简单。只需用一个字符串参数调用它的`run`方法。

```py
>>> import cProfile
>>> from my_math import product
>>> cProfile.run('product(1, 2)')

```

这将为您提供一份打印输出，其中包含各种函数和方法被调用的次数以及在各种函数中花费的时间。如果您提供一个文件名，例如，`'my_math.profile'`，作为要运行的第二个参数，`results`将被保存到一个文件中。然后，您可以使用`pstats`模块来检查配置文件。

```py
>>> import pstats
>>> p = pstats.Stats('my_math.profile')

```

使用这个`Stats`对象，您可以通过编程来检查结果。(有关 API 的详细信息，请参考标准库文档。)

Tip

标准库还包含一个名为`timeit`的模块，这是一种计时 Python 代码小片段的简单方法。`timeit`模块对于详细的概要分析来说并不真正有用，但是当您只想计算一段代码执行需要多少时间时，它会是一个很好的工具。自己尝试这样做经常会导致测量不准确(除非你知道自己在做什么)。使用`timeit`通常是更好的选择。

现在，如果你真的担心你的程序的速度，你可以添加一个单元测试来分析你的程序并强制执行某些约束(比如如果程序花费超过一秒钟就失败)。这可能是一件有趣的事情，但我不推荐这样做。过分的剖析很容易将你的注意力从真正重要的事情上转移开，比如干净、可理解的代码。如果程序真的很慢，你无论如何都会注意到，因为你的测试将永远无法完成。

## 快速总结

以下是本章涵盖的主要主题:

*   测试驱动编程:基本上，测试驱动编程意味着先测试，后编码。测试让您充满信心地重写代码，使您的开发和维护更加灵活。
*   doctest 和 unittest 模块:如果您想用 Python 进行单元测试，这些是必不可少的工具。`doctest`模块被设计用来检查文档串中的例子，但是也可以很容易地用来设计测试套件。为了让您的套件更加灵活和结构化，`unittest`框架非常有用。
*   PyChecker 和 PyLint:这两个工具读取源代码并指出潜在的(和实际的)问题。他们检查从短变量名到不可及的代码片段的一切。通过一点编码，你可以使它们(或其中之一)成为你的测试套件的一部分，以确保你所有的重写和重构都符合你的编码标准。
*   剖析:如果你真的关心速度，并且想要优化你的程序(只有在绝对必要的情况下才这么做)，你应该首先剖析它。使用`profile`或`cProfile`模块找到代码中的瓶颈。

### 本章的新功能

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `doctest.testmod(module)` | 检查文档字符串示例。(需要更多的参数。) |
| `unittest.main()` | 在当前模块中运行单元测试。 |
| `profile.run(stmt[, filename])` | 执行并分析`statement`。可选地，将结果保存到`filename`。 |

### 什么现在？

现在，您已经看到了使用 Python 语言和标准库可以做的各种事情。您已经看到了如何探测和调整您的代码，直到它尖叫起来(如果您认真对待剖析，不顾我的警告)。如果你仍然没有得到你需要的动力，是时候打开盖子，用一些低级工具调整引擎了。

Footnotes [1](#Fn1_source)

当然，像这样只测试一种情况不会给你对代码正确性的信心。一个真正的测试程序可能会更彻底。

  [2](#Fn2_source)

3.看看大卫·哈雷尔的《计算机有限公司:它们真的不能做什么》(牛津大学出版社，2000 年)中关于这个主题的许多有趣的材料。