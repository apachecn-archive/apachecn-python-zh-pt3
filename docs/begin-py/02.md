# 二、列表和元组

本章介绍了一个新概念:数据结构。数据结构是以某种方式构造的数据元素(例如数字或字符，甚至其他数据结构)的集合，例如通过对元素进行编号。Python 中最基本的数据结构是序列。序列中的每个元素都被分配了一个数字，即它的位置或索引。第一个索引是零，第二个索引是一，依此类推。一些编程语言从 1 开始给它们的序列元素编号，但是零索引约定有一个从序列开始的偏移的自然解释，负索引绕到结尾。如果你觉得这种编号有点奇怪，我可以保证你很快就会习惯。

本章从序列的概述开始，然后涵盖所有序列共有的一些操作，包括列表和元组。这些操作也适用于字符串，字符串将在一些例子中使用，尽管要完整地处理字符串操作，你必须等到下一章。处理完这些基础知识后，我们开始处理列表，看看它们有什么特别之处。在列表之后，我们来到元组，一种特殊用途的序列类型，类似于列表，除了你不能改变它们。

## 序列概述

Python 有几种内置的序列类型。本章集中讨论两个最常见的:列表和元组。字符串是另一种重要的类型，我将在下一章再次讨论。

列表和元组的主要区别在于，你可以改变列表，但不能改变元组。这意味着，如果您需要在进行过程中添加元素，列表可能是有用的，而如果出于某种原因，您不允许序列改变，元组可能是有用的。后者的原因通常是技术性的，与 Python 内部的工作方式有关。这就是为什么你可能会看到内置函数返回元组。对于你自己的程序，几乎在所有情况下你都可以用列表代替元组。(如第 4 章[所述，一个显著的例外是使用元组作为字典键。这些列表是不允许的，因为不允许你修改键。)](04.html)

当您想要处理值的集合时，序列非常有用。您可能有一个序列代表数据库中的一个人，第一个元素是他们的名字，第二个元素是他们的年龄。写成一个列表(列表中的项目用逗号分隔，并用方括号括起来)，如下所示:

```py
>>> edward = ['Edward Gumby', 42]

```

但是序列也可以包含其他序列，所以你可以列出这样的人，这就是你的数据库。

```py
>>> edward = ['Edward Gumby', 42]
>>> john = ['John Smith', 50]
>>> database = [edward,  john]
>>> database
[['Edward  Gumby', 42], ['John Smith', 50]]

```

Note

Python 有一种称为容器的数据结构的基本概念，容器基本上是可以包含其他对象的任何对象。两种主要的容器是序列(比如列表和元组)和映射(比如字典)。虽然序列的元素是编号的，但是映射中的每个元素都有一个名称(也称为键)。在第 4 章中你会学到更多关于映射的知识。关于既不是序列也不是映射的容器类型的例子，请参见第 [10](10.html) 章中对集合的讨论。

## 常见顺序操作

您可以对所有序列类型执行某些操作。这些操作包括索引、切片、加法、乘法和成员检查。此外，Python 具有用于查找序列长度以及查找其最大和最小元素的内置函数。

Note

这里没有提到的一个重要操作是迭代。迭代序列意味着重复执行某些操作，对序列中的每个元素重复一次。要了解更多信息，请参见第 [5](05.html) 章中的“循环”一节。

### 索引

序列中的所有元素都从零开始向上编号。您可以使用一个数字单独访问它们，如下所示:

```py
>>> greeting = 'Hello'
>>> greeting[0]
'H'

```

Note

字符串只是一系列字符。索引 0 指的是第一个元素，在本例中是字母 h。但是，与其他一些语言不同，它没有单独的字符类型。字符只是一个单元素字符串。

这就是所谓的索引。您使用索引来获取元素。所有的序列都可以用这种方式索引。当使用负索引时，Python 从右边开始计数，即从最后一个元素开始计数。最后一个元素位于位置–1。

```py
>>> greeting[-1]
'o'

```

字符串文字(和其他序列文字，就此而言)可以直接索引，而不使用变量来引用它们。效果完全一样。

```py
>>> 'Hello'[1]
'e'

```

如果函数调用返回一个序列，你可以直接索引它。例如，如果您只是对用户输入的年份的第四位数字感兴趣，您可以这样做:

```py
>>> fourth = input('Year: ')[3]
Year: 2005
>>> fourth
'5'

```

清单 [2-1](#Par22) 包含一个示例程序，它询问您年份、月份(从 1 到 12 的数字)和日期(1 到 31)，然后打印出带有正确月份名称的日期等等。

```py
# Print out a date, given year, month, and day as numbers

months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
]

# A list with one ending for each number from 1 to 31
endings = ['st', 'nd', 'rd'] + 17 * ['th'] \
        + ['st', 'nd', 'rd'] +  7 * ['th'] \
        + ['st']

year    = input('Year: ')
month   = input('Month  (1-12): ')
day     = input('Day (1-31): ')

month_number = int(month)
day_number = int(day)

# Remember to subtract 1 from month and day to get a correct index
month_name = months[month_number-1]
ordinal = day + endings[day_number-1]

print(month_name + ' ' + ordinal + ', ' + year)

Listing 2-1.Indexing Example

```

使用此程序的会话示例如下:

```py
Year: 1974
Month (1-12): 8
Day (1-31): 16
August 16th, 1974

```

最后一行是程序的输出。

### 限幅

正如您使用索引来访问单个元素一样，您也可以使用切片来访问一定范围的元素。您可以通过使用两个索引来实现，用冒号分隔。

```py
>>> tag = '<a href="http://www.python.org">Python web site</a>'
>>> tag[9:30]
'http://www.python.org'
>>> tag[32:-4]
'Python web site'

```

如您所见，切片对于提取部分序列非常有用。这里的编号非常重要。第一个索引是要包含的第一个元素的编号。但是，最后一个索引是切片后第一个元素的编号。请考虑以下几点:

```py
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[3:6] [4, 5, 6]
>>> numbers[0:1] [1]

```

简而言之，您提供两个指数作为切片的限制，其中第一个是包含性的，第二个是排他性的。

#### 一条漂亮的捷径

假设您想要访问数字的最后三个元素(来自前面的示例)。当然，你可以明确地这样做。

```py
>>> numbers[7:10]
[8, 9, 10]

```

现在，索引 10 引用了元素 11——它并不存在，但在您想要的最后一个元素之后一步。明白了吗？如果你想从末尾开始数，你可以使用负指数。

```py
>>> numbers[-3:-1]
[8, 9]

```

然而，看起来你不能这样访问最后一个元素。用 0 作为终点“一步之遥”的元素怎么样？

```py
>>> numbers[-3:0]
[]

```

这不完全是想要的结果。事实上，任何时候一个切片中最左边的索引在序列中比第二个晚(在这种情况下，倒数第三个比第一个晚)，结果总是一个空序列。幸运的是，您可以使用一个快捷方式:如果切片继续到序列的末尾，您可以简单地省略最后一个索引。

```py
>>> numbers[-3:]
[8, 9, 10]

```

同样的事情从一开始就起作用。

```py
>>> numbers[:3]
[1, 2, 3]

```

事实上，如果你想复制整个序列，你可以省去两个索引。

```py
>>> numbers[:]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

```

清单 [2-2](#Par44) 包含一个小程序，提示您输入一个 URL(假设它是相当有限的形式 [`http://www.somedomainname.com`](http://www.somedomainname.com) )并提取域名。

```py
# Split up a URL of the form http://www.something.com

url = input('Please enter the URL:')
domain = url[11:-4]

print("Domain name: " + domain)

Listing 2-2.Slicing Example

```

以下是该程序的运行示例:

```py
Please enter the URL: http://www.python.org
Domain name: python

```

#### 更长的台阶

切片时，可以指定(显式或隐式)切片的起点和终点。另一个参数通常是隐式的，就是步长。在常规切片中，步长为 1，这意味着切片从一个元素“移动”到下一个元素，返回开始和结束之间的所有元素。

```py
>>> numbers[0:10:1]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

```

在本例中，您可以看到切片包含另一个数字。正如你可能已经猜到的，这是明确的步长。如果步长设置为大于 1 的数，元素将被跳过。例如，步长为 2 将只包括开始和结束之间间隔的每隔一个元素。

```py
>>> numbers[0:10:2]
[1, 3, 5, 7, 9]
numbers[3:6:3]
[4]

```

您仍然可以使用前面提到的快捷方式。例如，如果您想要序列中的第四个元素，您只需要提供步长为 4 的元素。

```py
>>> numbers[::4]
[1, 5, 9]

```

自然地，步长不能为零——这不会让你去任何地方——但是它可以是负的，这意味着从右到左提取元素。

```py
>>> numbers[8:3:-1]
[9, 8, 7, 6, 5]
>>> numbers[10:0:-2]
[10, 8, 6, 4, 2]
>>> numbers[0:10:-2]
[]
>>> numbers[::-2]
[10, 8, 6, 4, 2]
>>> numbers[5::-2]
[6, 4, 2]
>>> numbers[:5:-2]
[10, 8]

```

把事情做好可能需要一点思考。可以看到，第一个限制(最左边的)仍然是包含性的，而第二个限制(最右边的)是排他性的。当使用负步长时，您需要有一个高于第二个的第一个限制(起始索引)。可能有点令人困惑的是，当您隐式保留开始和结束索引时，Python 会做“正确的事情”——对于正步长，它会从开始向结束移动，对于负步长，它会从结束向开始移动。

### 添加序列

序列可以用加法(加)运算符连接。

```py
>>> [1, 2, 3] + [4, 5,  6]
[1, 2, 3, 4, 5, 6]
>>> 'Hello,' + 'world!'
'Hello, world!'
>>> [1, 2, 3] + 'world!'
Traceback (innermost last):
 File "<pyshell>", line 1, in ?
    [1, 2, 3] + 'world!'
TypeError: can only concatenate list (not "string") to list

```

正如您在错误消息中看到的，您不能连接一个列表和一个字符串，尽管两者都是序列。一般来说，您不能连接不同类型的序列。

### 增加

将一个序列乘以数字 x 会创建一个新序列，其中原始序列重复 x 次:

```py
>>> 'python' * 5
'pythonpythonpythonpythonpython'
>>> [42] * 10
[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]

```

#### 无、空列表和初始化

空列表简单地写成两个括号(`[]`)——里面什么也没有。如果你想要一个有 10 个元素的列表，但是里面没有任何有用的东西，你可以像以前一样使用`[42]*10`，或者更实际的使用`[0]*10`。你现在有一个包含十个零的列表。然而，有时您可能想要一个表示“什么都没有”的值，比如“我们还没有在这里放任何东西。”这时你使用的`None. None`是一个 Python 值，意思就是“这里什么都没有”所以如果你想初始化一个长度为 10 的列表，你可以这样做:

```py
>>> sequence = [None] * 10
>>> sequence
[None, None, None, None, None, None, None, None, None, None]

```

清单 [2-3](#Par64) 包含一个程序，它打印(到屏幕上)一个由字符组成的“框”,这个框在屏幕上居中，并适应用户提供的句子的大小。代码可能看起来很复杂，但基本上只是算术——计算出需要多少空格、破折号等等，以便正确放置。

```py
# Prints a sentence in a centered "box" of correct width

sentence = input("Sentence: ")

screen_width = 80
text_width   = len(sentence)
box_width    = text_width + 6
left_margin  = (screen_width - box_width) // 2

print()
print(' ' * left_margin + '+'   + '-' * (box_width-2)  +   '+')
print(' ' * left_margin + '|  ' + ' ' * text_width     + '  |')
print(' ' * left_margin + '|  ' +       sentence       + '  |')
print(' ' * left_margin + '|  ' + ' ' * text_width     + '  |')
print(' ' * left_margin + '+'   + '-' * (box_width-2)  +   '+')
print()

Listing 2-3.Sequence (String) Multiplication Example

```

以下是运行示例:

```py
Sentence: He's a very  naughty boy!

                        +-----------------------------+
                        |                             |
                        |  He's a very  naughty boy!  |
                        |                             |
                        +-----------------------------+

```

### 成员资格

要检查一个值是否能在序列中找到，可以使用`in`操作符。这个运算符与目前讨论的有些不同(比如乘法或加法)。它检查某事是否为真，并相应地返回一个值:`True`为真，`False`为假。这样的运算符称为布尔运算符，真值称为布尔值。在第 5 章的条件语句一节中，你会学到更多关于布尔表达式的知识。

下面是一些使用`in`操作符的例子:

```py
>>> permissions = 'rw'
>>> 'w' in permissions
True
>>> 'x' in permissions
False
>>> users = ['mlh', 'foo', 'bar']
>>> input('Enter your user name: ') in users
Enter your user name: mlh
True
>>> subject = '$$$ Get rich now!!! $$$'
>>> '$$$' in subject
True

```

前两个例子使用成员测试来检查`'w'`和`'x'`是否分别出现在字符串`permissions`中。这可能是 UNIX 机器上的一个脚本，用于检查文件的写入和执行权限。下一个示例检查提供的用户名(`mlh`)是否在用户列表中。如果你的程序执行一些安全策略，这可能是有用的。(在这种情况下，您可能也想使用密码。)最后一个例子检查字符串`subject`是否包含字符串`'$$$'`。例如，这可以用作垃圾邮件过滤器的一部分。

Note

检查字符串是否包含' $$$ '的示例与其他示例略有不同。一般来说，`in`操作符检查一个对象是否是一个序列(或其他集合)的成员(即一个元素)。然而，字符串的唯一成员或元素是它的字符。所以，下面的话很有道理:

```py
>>> 'P' in 'Python'
True

```

事实上，在 Python 的早期版本中，这是唯一处理字符串的成员资格检查——找出一个字符是否在字符串中。现在，您可以使用`in`操作符来检查任何字符串是否是另一个字符串的子字符串。

清单 [2-4](#Par75) 显示了一个程序，它读入一个用户名，并对照一个数据库(实际上是一个列表)检查输入的 PIN 码，该数据库包含成对的(更多的列表)用户名和 PIN 码。如果在数据库中找到名称/PIN 对，则打印字符串`'Access granted'`。(在第 [1](01.html) 章中提到了`if`声明，并将在第 [5](05.html) 章中进行全面解释。)

```py
# Check a user name and PIN code

database = [
    ['albert',  '1234'],
    ['dilbert', '4242'],
    ['smith',   '7524'],
    ['jones',   '9843']
]

username = input('User name: ')
pin = input('PIN code: ')

if [username, pin] in database: print('Access granted')

Listing 2-4.Sequence Membership Example

```

### 长度、最小值和最大值

内置函数`len`、`min`和`max`可能非常有用。函数`len`返回一个序列包含的元素数量。`min`和`max`分别返回序列的最小和最大元素。(在第 [5](05.html) 章的“比较操作符”一节中，你会学到更多关于比较对象的知识)

```py
>>> numbers = [100, 34, 678]
>>> len(numbers)
3
>>> max(numbers)
678
>>> min(numbers)
34
>>> max(2, 3)
3
>>> min(9, 3, 2, 5)
2

```

除了可能的最后两个表达式之外，从前面的解释中应该清楚这是如何工作的。在这些函数中，`max`和`min`不是用序列参数调用的；这些数字直接作为参数提供。

## 列表:Python 的主力

在前面的例子中，我使用了很多列表。您已经看到了它们是多么有用，但是本节讨论的是它们与元组和字符串的不同之处:列表是可变的——也就是说，您可以更改它们的内容——并且它们有许多有用的专用方法。

### 列表功能

因为字符串不能像列表一样被修改，所以有时从字符串创建列表会很有用。您可以使用`list`功能来完成此操作。[<sup>1</sup>T4】](#Fn1)

```py
>>> list('Hello')
['H', 'e', 'l', 'l', 'o']

```

注意`list`适用于所有类型的序列，而不仅仅是字符串。

Tip

要将字符列表(如前面的代码)转换回字符串，可以使用以下表达式:

```py
''.join(somelist)

```

其中`somelist`是您的列表。关于这真正含义的解释，参见第 [3](03.html) 章中关于`join`的部分。

### 基本列表操作

您可以对列表执行所有标准的序列操作，如索引、切片、连接和乘法。但是列表的有趣之处在于它们可以被修改。在本节中，您将看到一些更改列表的方法:项目分配、项目删除、切片分配和列表方法。(注意，并不是所有的列表方法都会改变它们的列表。)

#### 更改列表:项目分配

更改列表很容易。你只需使用普通赋值，如第 [1](01.html) 章所述。但是，您不用编写类似于`x = 2`的代码，而是使用索引符号来指定一个特定的现有位置，比如`x[1] = 2`。

```py
>>> x = [1, 1, 1]
>>> x[1] = 2
>>> x
[1, 2, 1]

```

Note

您不能分配到不存在的职位；如果您的列表长度为 2，则不能为索引 100 赋值。为此，您必须创建一个长度为 101(或更长)的列表。请参阅本章前面的“无、空列表和初始化”一节。

#### 删除元素

从列表中删除元素也很容易。您可以简单地使用`del`语句。

```py
>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
>>> del names[2]
>>> names
['Alice', 'Beth', 'Dee-Dee', 'Earl']

```

请注意塞西尔是如何完全消失的，列表的长度从五个缩减到四个。`del`语句可以用来删除列表元素以外的东西。它可以用于字典(见第 [4 章](04.html))甚至变量。更多信息，请参见第 [5 章](05.html)。

#### 分配给切片

切片是一个非常强大的特性，而且您可以为切片赋值，这使得它更加强大。

```py
>>> name = list('Perl')
>>> name
['P', 'e', 'r', 'l']
>>> name[2:] = list('ar')
>>> name
['P', 'e', 'a', 'r']

```

所以你可以一次分配到几个位置。你可能想知道这有什么大不了的。你就不能一次分配一个给他们吗？当然，但是当您使用片段分配时，您也可以用长度不同于原始长度的序列替换片段。

```py
>>> name = list('Perl')
>>> name[1:] = list('ython')
>>> name
['P', 'y', 't', 'h', 'o', 'n']

```

切片分配甚至可以用于插入元素，而无需替换任何原始元素。

```py
>>> numbers = [1, 5]
>>> numbers[1:1] = [2, 3, 4]
>>> numbers
[1, 2, 3, 4, 5]

```

在这里，我基本上“替换”了一个空切片，从而真正插入了一个序列。您可以执行相反的操作来删除切片。

```py
>>> numbers
[1, 2, 3, 4, 5]
>>> numbers[1:4] = []
>>> numbers
[1, 5]

```

你可能已经猜到了，最后这个例子相当于`del numbers[1:4]`。(现在为什么不尝试步长不为 1 的切片赋值呢？甚至可能是负面的？)

### 列出方法

方法是一个与某个对象紧密耦合的函数，可以是一个列表、一个数字、一个字符串或其他任何东西。一般来说，方法是这样调用的:

```py
object.method(arguments)

```

一个方法调用看起来就像一个函数调用，除了对象放在方法名的前面，用一个点把它们分开。(在第 [7](07.html) 章中，你会得到关于什么是真正的方法的更详细的解释。)列表有几种方法允许您检查或修改其内容。

#### 附加

方法用于将一个对象附加到列表的末尾。

```py
>>> lst = [1, 2, 3]
>>> lst.append(4)
>>> lst
[1, 2, 3, 4]

```

你可能想知道为什么我选择了一个如此丑陋的名字作为我的名单。为什么不叫`list`？我可以这样做，但是您可能还记得，`list`是一个内置函数。如果我使用列表的名字，我就不能再调用这个函数了。对于给定的应用程序，您通常可以找到更好的名称。一个名字比如`lst`真的不能告诉你什么。例如，如果你的列表是一个价格列表，你可能应该称它为`prices`、`prices_of_eggs`或`pricesOfEggs`。

同样重要的是要注意到，`append`像几个类似的方法一样，就地改变列表。这意味着它不是简单地返回一个新的、修改过的列表；而是直接修改旧的。这通常是您想要的，但有时可能会带来麻烦。当我在本章后面描述`sort`时，我将回到这个讨论。

#### 清楚的

方法就地清除列表的内容。

```py
>>> lst = [1, 2, 3]
>>> lst.clear()
>>> lst
[]

```

类似于切片赋值`lst[:] = []`。

#### 复制

方法复制一个列表。回想一下，普通的赋值只是将另一个名字绑定到同一个列表。

```py
>>> a = [1, 2, 3]
>>> b = a
>>> b[1] = 4
>>> a
[1, 4, 3]

```

如果你想让`a`和`b`成为单独的列表，你必须将`b`绑定到`a`的副本上。

```py
>>> a = [1, 2, 3]
>>> b = a.copy()
>>> b[1] = 4
>>> a
[1, 2, 3]

```

这类似于使用`a[:]`或`list(a)`，两者都会复制`a`。

#### 数数

方法统计一个元素在列表中出现的次数。

```py
>>> ['to', 'be', 'or', 'not', 'to',  'be'].count('to')
2
>>> x = [[1, 2], 1,  1,  [2, 1,  [1, 2]]]
>>> x.count(1)
2
>>> x.count([1, 2])
1

```

#### 扩展

`extend`方法允许您通过提供一系列想要追加的值来一次追加几个值。换句话说，你原来的列表被另一个扩展了。

```py
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a.extend(b)
>>> a
[1, 2, 3, 4, 5, 6]

```

这看起来类似于串联，但重要的区别是扩展序列(在本例中为`a`)被修改了。这与普通的连接不同，在普通的连接中会返回一个全新的序列。

```py
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a + b
[1, 2, 3, 4, 5, 6]
>>> a
[1, 2, 3]

```

如您所见，连接列表看起来与上一个例子中的扩展列表完全相同，但是这次`a`没有改变。因为普通的连接必须创建一个包含`a`和`b`副本的新列表，如果您想要的是这样的内容，那么它就不如使用`extend`有效:

```py
>>> a = a + b

```

此外，这不是一个就地操作——它不会修改原始文件。`extend`的效果可以通过分配给切片来实现，如下所示:

```py
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a[len(a):] = b
>>> a
[1, 2, 3, 4, 5, 6]

```

虽然这种方法有效，但可读性不太好。

#### 指数

`index`方法用于搜索列表，以找到某个值第一次出现的索引。

```py
>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
>>> knights.index('who')
4
>>> knights.index('herring')
Traceback (innermost last):
  File "<pyshell>", line 1, in ?
    knights.index('herring')
ValueError: list.index(x): x not in list

```

当您搜索单词`'who'`时，您会发现它位于索引 4。

```py
>>> knights[4]
'who'

```

但是，当你搜索`'herring'`时，你会得到一个异常，因为根本找不到这个单词。

#### 插入

方法用于将一个对象插入到一个列表中。

```py
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers.insert(3, 'four')
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]

```

与`extend`一样，您可以用片分配来实现`insert`。

```py
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers[3:3] = ['four']
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]

```

这可能很奇特，但是它很难像使用`insert`那样易读。

#### 流行音乐

`pop`方法从列表中移除一个元素(默认情况下是最后一个)并返回它。

```py
>>> x = [1, 2, 3]
>>> x.pop()
3
>>> x
[1, 2]
>>> x.pop(0)
1
>>> x
[2]

```

Note

pop 方法是唯一一个既修改列表又返回值的列表方法(除了`None`)。

使用`pop`，您可以实现一个称为堆栈的公共数据结构。像这样的一堆工作起来就像一堆盘子。你可以把盘子放在上面，也可以把盘子从上面拿走。最后一个放入堆栈的是第一个被移除的。(这个原则叫做后进先出，或 LIFO。)

两种堆栈操作(放入和取出)通常被称为 push 和 pop。Python 没有 push，但是可以用`append`代替。`pop`和`append`方法反转彼此的结果，所以如果你压入(或追加)刚刚弹出的值，你会得到相同的堆栈。

```py
>>> x = [1, 2, 3]
>>> x.append(x.pop())
>>> x
[1, 2, 3]

```

Tip

如果你想要一个先进先出(FIFO)队列，你可以用`insert(0, ...)`代替`append`。或者，你可以继续使用`append`，但是用`pop(0)`代替`pop()`。更好的解决方案是使用集合模块中的`deque`。更多信息见第 [10](10.html) 章。

#### 移动

`remove`方法用于删除第一次出现的值。

```py
>>> x = ['to', 'be', 'or', 'not', 'to', 'be']
>>> x.remove('be')
>>> x
['to', 'or', 'not', 'to', 'be']
>>> x.remove('bee')
Traceback (innermost last):
 File "<pyshell>", line 1, in ?
  x.remove('bee')
ValueError: list.remove(x): x not in list

```

如您所见，只有第一个匹配项被删除，如果它不在列表中，您就不能删除它(在本例中是字符串`'bee'`)。

需要注意的是，这是一种“不返回原位更改”的方法。它修改列表，但不返回任何内容(与`pop`相反)。

#### 反面的

`reverse`方法反转列表中的元素。(我想这并不奇怪。)

```py
>>> x = [1, 2, 3]
>>> x.reverse()
>>> x
[3, 2, 1]

```

注意，`reverse`改变了列表并且不返回任何东西(例如，就像`remove`和`sort`)。

Tip

如果你想反向迭代一个序列，你可以使用`reversed`函数。不过，这个函数不返回列表；它返回一个迭代器。(你会在第九章[学到更多关于迭代器的知识。)可以用`list`转换返回的对象。](09.html)

```py
>>> x = [1, 2, 3]
>>> list(reversed(x))
[3, 2, 1]

```

#### 分类

`sort`方法用于就地排序列表。 [<sup>3</sup>](#Fn3) 排序“就地”意味着改变原始列表，使其元素按排序顺序排列，而不是简单地返回列表的排序副本。

```py
>>> x = [4, 6, 2, 1, 7, 9]
>>> x.sort()
>>> x
[1, 2, 4, 6, 7, 9]

```

您已经遇到了几个修改列表而不返回任何内容的方法，在大多数情况下，这种行为是很自然的(例如，`append`)。但是我想在`sort`的例子中强调一下这种行为，因为很多人似乎被它迷惑了。当用户想要一个列表的排序副本，而不去管原始列表时，通常会出现这种混乱。一种直观(但错误)的方法如下:

```py
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.sort() # Don't do this!
>>> print(y)
None

```

因为`sort`修改了`x`但没有返回任何内容，所以最终得到一个排序的`x`和一个包含`None`的`y`。一种正确的做法是首先将`y`绑定到`x`的副本，然后对`y`进行排序，如下所示:

```py
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.copy()
>>> y.sort()
>>> x
[4, 6, 2, 1, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]

```

简单地将`x`赋给`y`是行不通的，因为`x`和`y`会引用同一个列表。另一种获得列表排序副本的方法是使用`sorted`函数。

```py
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = sorted(x)
>>> x
[4, 6, 2, 1, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]

```

这个函数实际上可以用在任何序列上，但总是返回一个列表。 [<sup>4</sup>](#Fn4)

```py
>>> sorted('Python')
['P', 'h', 'n', 'o', 't', 'y']

```

如果您想对元素进行逆序排序，您可以使用`sort`(或`sorted`)，然后调用`reverse`方法，或者您可以使用`reverse`参数，如下一节所述。

#### 高级排序

`sort`方法有两个可选参数:`key`和`reverse`。如果您想使用它们，通常通过名称来指定它们(所谓的关键字参数；你会在第六章了解更多。`key`参数类似于`cmp`参数:你提供一个函数，它被用在排序过程中。但是，函数不是直接用于确定一个元素是否小于另一个元素，而是用于为每个元素创建一个键，并根据这些键对元素进行排序。因此，举例来说，如果您想根据元素的长度对它们进行排序，您可以使用`len`作为键函数。

```py
>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate']
>>> x.sort(key=len)
>>> x
['add', 'acme', 'aerate', 'abalone', 'aardvark']

```

另一个关键字参数`reverse`，仅仅是一个真值(`True`或`False`)；你将在第 [5](05.html) 章中了解更多关于这些的内容，指出列表是否应该反向排序。

```py
>>> x = [4, 6, 2, 1, 7, 9]
>>> x.sort(reverse=True)
>>> x
[9, 7, 6, 4, 2, 1]

```

在`sorted`函数中也有`key`和`reverse`参数。在许多情况下，为`key`使用自定义函数会很有用。你将在第六章[中学习如何定义你自己的函数。](06.html)

Tip

如果你想了解更多关于排序的内容，你可以看看 [`https://wiki.python.org/moin/HowTo/Sorting`](https://wiki.python.org/moin/HowTo/Sorting) 的“排序小指南”。

## 元组:不可变序列

元组是序列，就像列表一样。唯一的区别是元组不能改变。(您可能已经注意到了，字符串也是如此。)元组语法很简单——如果用逗号分隔一些值，就会自动得到一个元组。

```py
>>> 1, 2, 3
(1, 2, 3)

```

正如您所看到的，元组也可能(并且经常)包含在括号中。

```py
>>> (1, 2, 3)
(1, 2, 3)

```

空元组被写成两个不包含任何内容的括号。

```py
>>> ()
()

```

因此，您可能想知道如何编写包含单个值的元组。这有点奇怪——即使只有一个值，也必须包含一个逗号。

```py
>>> 42
42
>>> 42,
(42,)
>>> (42,)
(42,)

```

最后两个例子产生长度为 1 的元组，而第一个例子根本不是元组。逗号至关重要。单纯加括号也无济于事:`(42)`和`42`一模一样。然而，一个单独的逗号可以完全改变表达式的值。

```py
>>> 3 * (40 + 2)
126
>>> 3 * (40 + 2,)
(42, 42, 42)

```

`tuple`函数的工作方式与`list`非常相似:它接受一个序列参数并将其转换成一个元组。[T3】5T5】如果自变量已经是元组，则不变返回。](#Fn5)

```py
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> tuple('abc')
('a', 'b', 'c')
>>> tuple((1, 2, 3))
(1, 2, 3)

```

正如您可能已经收集到的，元组并不复杂——除了创建它们和访问它们的元素之外，您真的不能对它们做太多事情，您可以像对其他序列一样做这些事情。

```py
>>> x = 1, 2, 3
>>> x[1]
2
>>> x[0:2]
(1, 2)

```

元组的片也是元组，就像列表片本身是列表一样。

您需要了解元组有两个重要原因。

*   它们可以用作映射中的键(和集合的成员)；列表不能这样使用。你将在第 [4](04.html) 章学到更多的映射。
*   它们由一些内置的函数和方法返回，这意味着您必须处理它们。只要你不试图去改变它们，“处理”它们最常见的方式就是把它们当成列表一样对待(除非你需要像`index`和`count`这样的方法，而元组是没有的)。

一般来说，列表可能足以满足您的排序需求。

## 快速总结

让我们回顾一下本章中涉及的一些最重要的概念。

*   序列:序列是一种数据结构，其中的元素被编号(从零开始)。序列类型的例子有列表、字符串和元组。其中，列表是可变的(您可以更改它们)，而元组和字符串是不可变的(一旦创建，它们就是固定的)。可以通过切片来访问序列的各个部分，提供两个索引来指示切片的开始和结束位置。要更改列表，可以为其位置指定新值，或者使用赋值来覆盖整个切片。
*   成员资格:用操作符`in`检查一个值是否能在一个序列(或其他容器)中找到。对字符串使用`in`是一个特例——它将允许您查找子字符串。
*   方法:一些内置类型(比如列表和字符串，但不是元组)有许多有用的方法。这些有点像函数，除了它们与一个特定的值紧密相连。方法是面向对象编程的一个重要方面，我们在第 [7](07.html) 章中会讲到。

### 本章的新功能

<colgroup><col> <col></colgroup> 
| 功能 | 描述 |
| --- | --- |
| `len(seq)` | 返回序列的长度 |
| `list(seq)` | 将序列转换为列表 |
| `max(args)` | 返回一个序列或一组参数的最大值 |
| `min(args)` | 返回一个序列或一组参数的最小值 |
| `reversed(seq)` | 允许您反向迭代序列 |
| `sorted(seq)` | 返回`seq`元素的排序列表 |
| `tuple(seq)` | 将序列转换为元组 |

### 现在怎么办？

现在你已经熟悉了序列，让我们继续学习字符序列，也称为字符串。

Footnotes [1](#Fn1_source)

它实际上是一个类，而不是一个函数，但是区别现在并不重要。

  [2](#Fn2_source)

其实从 Python 2.2 版本开始，`list`就是一个类型，而不是一个函数。(这也是`tuple`和`str`的情况。)关于这个的完整故事，参见第 9 章[的“子类化列表、字典和字符串”一节。](09.html)

  [3](#Fn3_source)

如果您感兴趣，从 Python 2.3 开始，`sort`方法使用稳定的排序算法。

  [4](#Fn4_source)

实际上，`sorted`函数可以用在任何可迭代的对象上。在第 9 章中你会学到更多关于可迭代对象的知识。

  [5](#Fn5_source)

像`list`，`tuple`不是一个真正的函数——它是一种类型。和`list`一样，你现在可以放心地忽略这一点。