# 9.高级主题 II:复杂性

本周是高级 python 概念的继续，将涵盖开发人员在工作中必须了解的更多主题。

本周开始，我们将介绍一个你一直在使用的概念，**生成器和迭代器**。在接下来的几天里，我们将讨论**装饰者**和**模块**，它们将帮助我们构建更大规模的应用程序。这些概念将有助于理解如何使用框架，比如 *Flask* 和 *Django* 。

虽然我不喜欢在这本书里谈论理论，但理解时间复杂性如何与算法一起工作是很重要的。周四，我们将深入**大 O 符号**并进一步理解算法。本书中的所有课程都引导你能够继续深造，成为一名 Python 开发人员。这一切将我们带入周五的项目，即**面试准备**。因为这本书是作为改善或改变你职业生涯的工具而设立的，所以其中很重要的一部分就是面试过程。会有关于这个过程的信息，会有什么期待，以及如何处理一些你可能会被问到的面试问题。

**概述**

*   理解生成器和迭代器对象

*   使用和应用装饰器

*   创建和导入模块

*   什么是时间复杂度和大 O 记数法？

*   知道如何处理面试、问题等等

### 挑战问题

作为一名程序员，你必须考虑执行一个程序所花费的时间。即使是一个会给你 100%准确答案的程序，如果没有及时把答案给你，也可能毫无用处。不用查，你认为当需要检索和存储信息时，列表或字典更有效吗？

## 星期一:生成器和迭代器

在本书的前几节，你可能已经看到了提到的单词**生成器**或**迭代器**。在不知情的情况下，你一直在使用它们。今天，我们将深入了解这些概念是什么以及如何使用它们。

为了继续今天的内容，让我们从“ *python_bootcamp* ”文件夹中打开 Jupyter 笔记本。打开后，创建一个新文件，并将其重命名为“ *Week_09。*“接下来，制作第一个标题为:“**生成器和迭代器”的单元格。**“我们将开始在那个牢房下面工作。

### 迭代器与可迭代对象

一个**迭代器**是一个包含可以被迭代的条目的对象，这意味着你可以遍历所有的值。一个**可迭代**是一个集合，比如列表、字典、元组和集合。主要的区别是可迭代的不是迭代器；相反，它们是数据的容器。在 Python 中，迭代器对象实现了神奇的方法 *iter* 和 *next* ，允许你遍历它的值。

### 创建基本迭代器

我们可以很容易地从可迭代器中创建迭代器。您可以简单地使用 *iter()* 函数来实现:

```
 1| # creating a basic iterator from an iterable
 3| sports = [ "baseball", "soccer", "football", "hockey", "basketball" ]
 5| my_iter = iter(sports)
 7| print( next(my_iter) )     # outputs first item
 8| print( next(my_iter) )     # outputs second item
10| for item in my_iter:
11|   print(item)
13| print( next(my_iter) )     # will produce error

```

去查查手机。迭代器将永远记住它们返回的最后一项，这就是为什么我们在第 13 行得到一个错误。使用 *next()* 方法，我们能够输出迭代器中的下一项。然而，一旦迭代器中的所有项都被使用了，我们就不能再遍历迭代器了，因为没有剩余的项了。迭代器也非常适合循环，像列表和字典一样，我们可以简单地使用 in 关键字*(见第 10 行)*。你仍然可以像我们通常做的那样循环遍历列表，它总是从索引 0 开始，但是一旦我们的迭代器没有条目了，我们就不能再使用它了。

### 创建我们自己的迭代器

现在我们已经看到了如何从 Python iterable 创建迭代器，让我们创建自己的迭代器类，它将输出字母表中的每个字母。要创建一个迭代器，我们需要实现神奇的方法 *__iter__()* 和 *__next__():*

```
 1| # creating our own iterator
 3| class Alphabet( ):
 4|   def __iter__(self):
 5|           self.letters = "abcdefghijklmnopqrstuvwxyz"
 6|           self.index = 0
 7|           return self
 9|   def __next__(self):
10|           if self.index <= 25:
11|                   char = self.letters[ self.index ]
12|                   self.index += 1
13|                   return char
14|           else:
15|                   raise StopIteration
17| for char in Alphabet( ):
18|   print(char)

```

去查查手机。输出结果是一次打印一个字母的整个字母表。我们首先创建一个名为" *Alphabet 的迭代器。然后我们使用 *iter* 方法来声明与这个迭代器相关的属性。将 *iter* 方法视为迭代器的初始化方法。在 *iter* 方法结束时，必须始终返回 *self* 。声明了 *next* 方法，这样当被调用时，迭代器可以返回字母串中的下一个字符。我们存储了一个名为 *index* 的属性，以便跟踪接下来应该返回哪个条目。最后，我们在第 14 行添加了一个条件，这样如果已经输出了所有的字母，它就会产生一个 *StopIteration* 错误。当您需要以特定的方式遍历 Python 集合时，迭代器非常有用。*

### 什么是发电机？

**生成器**是产生反馈信息以产生一系列结果而不是单个值的函数。它们是简化迭代器创建的一种方式。通常，当函数完成任务并返回信息时，函数内部声明的变量将被删除。然而，对于生成器，它们使用“ **yield** ”关键字将信息发送回被调用的位置，而不会终止函数。生成器并不总是必须返回整数，尽管您可以生成您想要的任何信息。让我们看几个既有数字又有单个字符的例子。

### 注意

生成器是简化的迭代器。

### 创建范围生成器

虽然 *range* 函数不是一个生成器，但是我们可以使用 *yield* 关键字从生成器创建我们自己的版本。让我们试一试:

```
 1| # creating our own range generator with start, stop, and step parameters
 3| def myRange(stop, start=0, step=1):
 4|  while start < stop:
 5|          print( "Generator Start Value: { }".format(start) )
 6|          yield start
 7|          start += step       # increment start, otherwise infinite loop
 9| for x in myRange(5):
10|  print( "For Loop X Value: { }".format(x) )

```

去查查手机。这两个 print 语句用于显示发生器 *myRange* 何时被访问，与循环的*何时输出结果相比较。我们能够调用 *myRange* 就像我们调用一个普通的 Range 函数一样，因为发电机的工作方式。在第 3 行，我们像声明其他函数一样声明该函数，接受与 *range* 相同的参数。我们在第 4 行的函数中开始一个 while 循环，这个循环将使*返回到 *start* 值。一旦信息被返回给 for 循环，它就能够将该值用于当前的迭代。一旦 for 循环完成了它的代码块，它就返回到生成器，因为 while 循环条件没有得到满足。通常，一旦函数返回了信息，就不会再被调用；但是，生成器会继续返回并存储信息，直到它们的条件得到满足。如果我们没有用*步骤*增加*开始*值，我们将创建一个无限循环。与迭代器一样，当您需要特定的序列进行迭代时，生成器会很有用。当您需要知道内存时，生成器非常有用。尽管它们在性能方面没有那么高效，但在存储信息时它们是内存高效的。它们在需要创建数据管道的情况下很有用，这是指需要对数据片段执行一组执行。**

### 周一练习

1.  **反向迭代**:创建一个接受列表的迭代器，当迭代结束时，它以相反的顺序返回信息。**提示**:在迭代器中接受参数时，需要使用 *init* 方法，以及 *iter* 和 *next* 。下面的调用应该产生**“5，4，3，2，1”**。

    ```
    >>> for i in RevIter( [ 1, 2, 3, 4, 5 ] ):

    ```

2.  **Squares** :创建一个类似 range 函数的生成器，除了它每次都产生一个平方数。下面这个调用的结果应该是**“0，1，4，16”**。

    ```
    >>> for i in range(4):

    ```

今天，我们能够理解如何构建我们自己的 *range* 函数，以及如何迭代数据集合。生成器是迭代器的简化版本，但是使用 *yield* 关键字返回信息。迭代器必须总是通过使用 *iter* 和 next *方法*来创建，并且对于创建我们自己的迭代序列非常有用。

## 星期二:装修工

如果你想学习框架，或者了解如何改进 Python 中的功能，那么你需要理解什么是**装饰器**以及它是如何工作的。这将有助于简化我们的代码，同时减少改进程序所需的代码行。

为了跟上这一课，让我们从之前的笔记本文件“ *Week_09* ”继续，简单地在底部添加一个标有“ **Decorators”的 markdown 单元格。**

### 什么是装修工？

**装饰器**，也被称为*包装器*，是在不显式修改其他函数的情况下赋予它们额外能力的函数。它们由函数名前面的**“@”**符号表示，该符号写在函数声明的上方，如下所示:

```
>>> @decorator
>>> def normalFunc( ):

```

当您希望在函数执行之前或之后执行某些功能时，Decorators 非常有用。例如，让我们假设您想要基于用户登录来限制对某个功能的访问。您可以将代码放入装饰器中，并将装饰器应用于所有函数，而不是为您创建的每个函数编写相同的条件语句。现在，无论何时调用一个函数，条件语句仍然会运行，但是您可以节省几行代码。这是 Flask 框架的一个真实例子，它使用 decorators 基于用户认证限制对某些页面的访问。今天晚些时候我们会看到一个最小的例子。

### 高阶函数

一个*高阶函数*是一个对其他函数进行操作的函数，要么把一个函数作为它的自变量，要么返回一个函数。在上周的课程中，我们看到了用 *lambdas，map，filter 和 reduce* 完成的。装饰器是高阶函数，因为它们接受一个函数并返回一个函数。

### 创建和应用装饰器

为了创建装饰器，我们需要声明一个接受另一个函数作为参数的函数。在这个装饰器中，我们可以定义另一个要返回的函数，它将运行作为参数传入的函数。我们来看看这是怎么写的:

```
 1| # creating and applying our own decorator using the @ symbol
 3| def decorator(func):
 4|   def wrap( ):
 5|          print("======")
 6|          func( )
 7|          print("======")
 8|   return wrap
10| @decorator
11| def printName( ):
12|   print("John!")
14| printName( )

```

去查查手机。我们将得到一个" **John！**"以名字上下的等号作为边框。在第 10 行，我们将装饰器附加到了 *printName* 函数上。每当调用 *printName* 函数时，装饰器就会运行，并且 *printName* 会作为“ *func* 的参数传入。在*装饰器*中，我们声明了一个名为*包装*的函数。这个 *wrap* 函数会打印一个边框，然后调用 func 参数，再打印另一个边框。记住装饰者必须返回一个函数才能运行。我们声明的装饰器可以附加到我们编写的任何函数上。使用这个装饰器的所有函数将简单地运行，它们的上下都有一个边框。

### 带参数的装饰器

虽然 decorators 只是简单地给函数增加了额外的功能，但是它们也可以像其他函数一样有参数。让我们以下面的例子为例，我们想要运行函数 *x* 次:

```
 1| # creating a decorator that takes in parameters
 3| def run_times(num):
 4|   def wrap(func):
 5|           for i in range(num):
 6|                   func( )
 7|   return wrap
 9| @run_times(4)
10| def sayHello( ):
11|   print("Hello!")

```

去查查手机。这个单元格会输出" **Hello！**“四次。当装饰器接受一个参数时，语法会改变。我们的装饰器这次接受了一个参数 *num* ，而 *wrap* 函数这次接受了该函数作为参数。在我们的 *wrap* 函数中，我们创建了一个 for 循环，它将运行附加到装饰器的函数，运行次数与第 9 行装饰器上声明的参数一样多。

### 注意

当向装饰器传递参数时，函数会自动运行，所以在这个实例中我们不需要调用 sayHello。

### 带有装饰符和参数的函数

当您需要一个函数接受参数，同时还附加了一个装饰器时， *wrap* 函数必须接受与原始函数完全相同的参数。让我们来试试:

```
 1| # creating a decorator for a function that accepts parameters
 3| def birthday(func):
 4|  def wrap(name, age):
 5|           func(name, age + 1)
 6|  return wrap
 8| @birthday
 9| def celebrate(name, age):
10|  print( "Happy birthday { }, you are now { }.".format(name, age) )
12| celebrate("Paul", 43)

```

去查查手机。这将输出一个格式良好的字符串，其中包含第 12 行传入的信息。当我们调用*庆祝*时，装饰器接受*庆祝*作为 *func* 的参数，两个参数“**保罗**和“ **43** ”被传递到*包装*。当我们在*包装*中调用我们的函数时，我们将相同的参数传递给函数调用；然而，我们将*年龄*参数增加 1。

### 限制功能访问

你可能想知道装饰者如何服务于一个目的，因为最后几个单元格似乎没有意义。对于它们中的每一个，我们可以简单地在原始函数中添加这些行。不过这只是为了语法理解。Decorators 在框架中经常使用，它可以帮助您在框架中编写的许多函数增加功能。一个例子是能够基于用户登录凭证来限制对页面或功能的访问。让我们创建一个装饰器，如果密码不匹配，它将有助于限制访问:

```
 1| # real world sim, restricting function access
 3| def login_required(func):
 4| def wrap(user):
 5|         password = input("What is the password?")
 6|         if password == user["password"]:
 7|                 func(user)
 8|         else:
 9|                 print("Access Denied")
10|   return wrap
12| @login_required
13| def restrictedFunc(user):
14|   print( "Access granted, welcome { }".format(user[ "name" ]) )
16| user = { "name" : "Jess", "password" : "ilywpf" }
18| restrictedFunc(user)

```

去查查手机。在第 13 行，我们声明了一个普通的函数，它接受一个用户，并输出一个包含他们的名字和可访问性的语句。我们的装饰器附在第 12 行，这样当我们调用 *restrictedFunc* 并传入我们创建的用户时，它将通过装饰器运行。在 *wrap* 函数中，我们要求用户输入密码，并在第 6 行检查密码是否正确。如果他们输入正确的密码，那么我们允许他们访问该功能并打印出“**访问授权**”。然而，如果密码不正确，那么我们输出“**拒绝访问**”，并且从不运行 *restrictedFunc* 。这是一个简单的例子，说明了 *Flask* 如何处理页面的用户限制，但是它证明了装饰者的重要性。我们现在可以将 *login_required* 附加到我们认为应该只由用户访问的任何功能上。

### 星期二练习

1.  **用户输入**:创建一个装饰器，要求用户输入一个数字，只有当数字小于 100 时，才运行这个函数。该功能应该简单地输出“**小于 100** ”。在下面使用函数声明:

    ```
    >>> @decorator
    >>> def numbers( ):
    >>>          print("Less than 100")

    ```

2.  **创建路由**:创建一个装饰器，它接受一个字符串作为参数，一个包装函数接受 *func* 。让 wrap 函数打印出字符串，并运行传入的函数。传入的函数不需要做任何事情。在 Flask 中，您可以通过使用接受 URL 字符串的 decorators 来创建页面。使用下面的函数声明来启动:

    ```
    >>> @route("/index")
    >>> def index( ):
    >>>        print("This is how web pages are made in Flask")

    ```

今天是为使用 Python 的其他技术(比如框架)做准备的重要一课。装饰器有助于改善函数的执行，可以附加到任何必要的函数上。这有助于减少代码并提供改进的功能。

## 星期三:模块

大多数程序倾向于包含许多行代码，以至于你不能把它们都存储在一个文件中。相反，您将代码分成几个文件，这有助于保持项目的组织性。这些文件中的每一个都称为**模块**。这些模块中有变量、函数、类等。，您可以将其导入到项目中。幸运的是，Python 拥有一大批开发人员，他们创建模块供我们使用，以增强我们自己的项目。今天，我们将看看 Python 中包含的一些模块，如何导入它们，如何使用它们，以及如何编写我们自己的模块在 Jupyter Notebook 中使用。

为了跟上这一课，让我们从笔记本文件“ *Week_09* ”继续，只需在底部添加一个标有“**模块”的降价单元格。**

### 导入模块

在接下来的几个例子中，我们将使用 *math* 模块，这是 Python 的内置模块之一。这个特定的模块有函数和变量来帮助我们解决任何与数学相关的问题，无论是舍入、计算圆周率还是许多其他与数学相关的任务。对于第一个单元格，我们将导入整个*数学*模块及其内容:

```
# import the entire math module
import math
print( math.floor(2.5) )     # rounds down
print( math.ceil(2.5) )        # rounds up
print(math.pi)

```

去查查手机。我们会得到“ **2** ”、“ **3** ”和“ **3.14** 的输出。当我们导入 *math* 时，我们能够访问 *math* 的所有函数、变量和类。在这个例子中，我们调用了存储在 *math* 模块中的两个函数和一个变量。为了导入整个模块及其内容，只需在模块名称前加上关键字 import。无论何时你想访问它的任何内容，你都需要使用点语法。现在我们可以使用任何数学的代码。

### 仅导入变量和函数

当您知道您不需要使用整个模块，而是需要使用几个函数或变量时，您可以直接导入它们。您应该始终确保只导入您需要的东西。在前一个单元格中，我们导入了整个 *math* 模块；然而，我们并不真的需要，因为我们只使用了其中的两个函数和一个变量。要导入特定的内容，您需要包括来自关键字的*和您想要导入的内容的名称:*

```
# importing only variables and functions rather than an entire module, better efficiency
from math import floor, pi
print( floor(2.5) )
# print( ceil(2.5) )     will cause error because we only imported floor and pi, not ceil and not all of math
print(pi)

```

去查查手机。我们将得到“ **2** ”和“ **3.14** ”的输出。导入模块的特定部分时，import 语句会稍有变化。要从单个模块中分离多个导入，可以使用逗号。我们注释掉了 *ceil* 的打印语句，因为它不起作用。我们只直接导入了 *floor* 和 *pi* ，没有导入 *ceil* 函数。注意，我们也不需要在名称前引用带有点语法的 *math* 模块。这是因为我们直接导入了 *floor* 函数和 *pi* 变量，所以现在可以不用点语法引用它们了。记住只导入你需要的东西。

### 注意

您可以像前面一样从模块中导入类；简单地使用类名。

### 使用化名

通常，您想要导入的内容的名称可能很长。您可以在导入时给出一个“**别名**或昵称，而不必每次都写出完整的名称:

```
# using the 'as' keyword to create an alias for imports
from math import floor as f
print( f(2.5) )

```

去查查手机。我们将得到与前两个单元格相同的输出，除了这次我们能够将 *floor* 函数引用为字母“ *f* ”。这是因为我们使用“*作为*关键字来编写我们的进口声明。您可以给导入的任何内容重新命名，尽管通常最好只给较大的名称重新命名。

### 创建我们自己的模块

现在我们知道了如何导入和调用一个模块，让我们创建自己的模块。继续打开你电脑上的任何文本编辑器，如*记事本*或*文本编辑*。在文件中编写以下代码，保存在您的“ *Week_09* ”文件所在的同一个文件夹中，文件名为“ *test.py* ”。如果这两个文件不在同一个目录中，它会产生一个错误:

```
# creating our own module in a text editor
# variables to import later
length = 5
width = 10
# functions to import later
def printInfo(name, age):
      print( "{ } is { } years old.".format(name, age) )

```

参见图 [9-1](#Fig1) 中文本编辑器中的代码示例。

![../images/481544_1_En_9_Chapter/481544_1_En_9_Fig1_HTML.jpg](../images/481544_1_En_9_Chapter/481544_1_En_9_Fig1_HTML.jpg)

图 9-1

文本编辑器(notepad++)中带有代码的 test.py 模块

您刚刚编写了第一个模块！请记住，模块只不过是在其他文件中编写的代码，我们可以将它们导入到我们的任何项目中。现在让我们看看如何使用它们。

### 使用我们在 jupiter 笔记本中的模块

在任何其他情况下，您都可以用来自关键字的*导入*和*来导入我们在 *test.py* 中编写的变量和函数。然而，Jupyter Notebook 在使用您创建的模块时会有所不同。我们将使用“ **run** 命令来加载我们创建的整个模块。运行文件后，我们可以使用我们在模块中编写的变量和函数。让我们来看看如何做到这一点:*

```
# using the run command with Jupyter Notebook to access our own modules
%run test.py
print(length, width)
printInfo("John Smith", 37)       # able to call from the module because we ran the file in Jupyter above

```

去查查手机。您会注意到我们能够输出在 *test.py* 模块中声明的变量和函数打印语句。请记住，run 命令将文件当作单个单元格来运行。模块中的任何函数调用或打印语句都会立即运行。要测试这一点，请尝试在模块底部放置一个打印语句。当您在开发环境中工作时( *IDE* ，您将像平常一样编写导入，如下所示:

```
>>> from test import length, width, printInfo

```

这就是 Jupyter Notebook 处理我们创建的文件的方式。

### 注意

您可以将在 Python 文件夹中创建的任何模块放在硬盘上。一旦文件存在，就可以正常访问它们，而不用使用 run 命令。

### 周三练习

1.  **时间模块**:导入*时间*模块，调用*睡眠*函数。让电池休眠 5 秒，然后打印“**时间模块导入**”。虽然我们还没有介绍这个模块，但是这个练习将为你提供一个很好的练习，让你自己尝试使用一个模块。请随意使用谷歌、Quora 等。

2.  **计算区域**:创建一个名为“ *calculation.py* 的模块，该模块内部有一个单一的函数。该函数应该接受两个参数，并返回它们的乘积。我们可以想象我们正在试图计算一个矩形的面积，它需要接受长度和宽度属性。在 Jupyter Notebook 中运行该模块，并在单元格中使用以下函数调用:

    ```
    >>> calcArea(15, 30)

    ```

今天的重点是关于模块，如何导入它们，如何使用它们，如何创建我们自己的模块，以及如何在 Jupyter Notebook 中调用我们自己的模块。理解模块是如何工作的会让你有能力使用 Python 中的框架。例如，Flask 使用了许多不同的模块，因为每个模块都有特定的用途。当你需要组织你的项目时，模块就是答案。

## 周四:理解算法复杂性

在这本书里，我们一直在边做边学。在开始时，我说过我们不会深入理论，而是通过一起构建项目和编码来学习。今天的重点主要是编程和算法的理论。如果编程中有一个理论你应该懂，那应该是**大 O 记法**。

为了跟上这一课，让我们从之前的笔记本文件“ *Week_09* ”继续，并在底部简单地添加一个标记单元格，写着“**理解算法复杂性”。**

### 什么是大 O 记数法？

作为一名软件工程师，你经常需要估计一个程序的执行时间。为了给出一个合适的估计，你必须知道程序的时间复杂度。这就是算法复杂性发挥作用的地方，也称为**大 O 符号**。它是描述一个算法或程序执行需要多长时间的概念。以一个列表为例。随着列表中项目数量的增加，遍历列表所需的时间也在增加。这就是所谓的 *O(n)* ，其中 *n* 代表运算次数。之所以叫大 O 记法，是因为你在运算次数前面加了一个“*大 O* ”。

大 O 建立了一个最坏情况的运行时。即使你搜索了 100 个条目的列表，并且第一次就找到了你想要的，这仍然会被认为是 *O(100)* ，因为它可能需要多达 100 次操作。

最有效率的大 O 记数法是 *O(1)* ，也称为常数时间。这意味着无论需要多少项目或步骤，都将花费相同的时间，并且通常是即时发生的。如果我们采用相同的 100 个条目的列表并直接访问一个索引，这将被称为 *O(1)* 。我们将立即检索该索引中的值，而不需要遍历列表。

效率最低的时间复杂度之一是*O(n∫2)*。这是一个双循环的表示。我们编写的冒泡排序算法使用了双 for 循环，被认为是编程中效率较低的排序算法之一；然而，它很容易理解，因此是对算法的一个很好的介绍。我们将在今天晚些时候看到冒泡排序与另一种设计得更高效的算法相比是如何的。

当你将遍历列表中每个元素的简单搜索与像二分搜索法这样的高效算法进行比较时，你会发现它们不会随着时间以相同的速度增长。以表格 [9-1](#Tab1) 为例，该表格显示了搜索给定物品所需的时间。

表 9-1

大 O 批注增长率对比 <sup>[1](#Fn1)</sup>

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

元素数量

 | 

简单搜索

 | 

二进位检索

 |
| --- | --- | --- |
| *运行时用大 O 表示法* | *O(n)* | *O(对数 n)* |
| Ten | 10 毫秒 | 3 毫秒 |
| One hundred | 100 毫秒 | 7 毫秒 |
| Ten thousand | 10 秒 | 14 毫秒 |
| One billion | 11 天 | 32 毫秒 |

我们可以清楚地看到，有效的算法可以帮助提高我们的程序速度。因此，在编写代码时，记住效率和时间复杂性是很重要的。图 [9-2](#Fig2) 中的图片描绘了操作数量相对于元素数量的复杂性。

![../images/481544_1_En_9_Chapter/481544_1_En_9_Fig2_HTML.jpg](../images/481544_1_En_9_Chapter/481544_1_En_9_Fig2_HTML.jpg)

图 9-2

大 O 符号复杂度随时间变化图

这里没有涵盖所有的大 O 符号，所以如果你想进一步理解这些概念，一定要做进一步的研究。这只是对什么是大 O 以及为什么它在编写我们的程序时很重要的一个介绍。

### 散列表

当我们最初讨论字典时，我们非常简要地回顾了一下**哈希**。既然我们已经介绍了大 O 符号，理解**散列表**以及它们为什么重要就容易多了。字典可以以 O(1) 的复杂度被访问，因为它们是如何存储在内存中的。它们使用哈希表来存储键值对。在讨论哈希表之前，让我们快速回顾一下哈希函数以及如何使用它:

```
>>> a, c = 'bo', "bob"
>>> b = a
>>> print(hash(a), hash(b), hash(c))

```

从前面的代码中，我们将为 *a* 和 *b* 获得相同的值，并为 *c* 的散列获得单独的值。哈希函数用于创建给定值的整数表示。在这种情况下，字符串“ **bo** 的整数和变量 *a* 和 *b* 是相同的；但是，“ **bob** 和 *c* 变量完全不同，因为它们的值不同。

当字典将键值对存储到内存中时，它们使用了这个概念。哈希表用于存储哈希、键和值。当您需要通过键检索给定值时，会用到存储的散列。以表 [9-2](#Tab2) 为例。有三个键值对，都有不同的哈希值。当您想要访问*名称*的值时，您应该写:

```
>>> person[ "name" ]

```

所发生的是 Python 散列字符串" **name** "并寻找散列值而不是密钥本身。您可以把这想象成通过索引来检索列表中的项目。这是非常有效的，因为您可以在 *O(1)* 时间几乎立即检索基于散列的值。

表 9-2

Python 哈希表的逻辑表示

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

混杂

 | 

钥匙

 | 

价值

 |
| --- | --- | --- |
| Two billion eight hundred and thirty-nine million seven hundred and two thousand five hundred and seventy-two | 名字 | 约翰·史密斯 |
| Eight billion two hundred and sixty-seven million three hundred and forty-eight thousand seven hundred and twelve | 年龄 | Thirty-two |
| -2398350273 | 语言 | 计算机编程语言 |

字典是有用的数据集合，不仅可以保持信息的联系，还可以提高效率。当你试图回答编程问题或让程序运行得更快时，请记住这一点。像关于大 O 符号的信息一样，这只是对散列表的介绍。如果你想了解更多，一定要使用谷歌、Quora 等搜索。

### 字典与列表

为了理解哈希表和 Python 字典的真正威力，让我们将其与列表进行比较。我们将编写一个条件语句，让 Python 检查字典和列表中的给定项，并计算每一项需要多长时间。我们要把代码分成两个单元。第一个单元格将生成包含 1000 万个条目的字典和列表:

```
# creating data collections to test for time complexity
import time
d = { }        # generate fake dictionary
for i in range(10000000):
      d[ i ] = "value"
big_list = [ x for x in range(10000000) ]       # generate fake list

```

去查查手机。什么都不会发生。我们只是在这个单元格中创建了变量，所以我们不必重新创建它们，因为根据您的计算机，这需要几秒钟的时间。在下面的单元格中，我们将为每次数据收集寻找最后一个元素所花费的时间设置一个计时器。我们将使用*时间*模块来跟踪开始和结束时间:

```
 1| # retrieving information and tracking time to see which is faster
 3| start_time = time.time( )       # tracking time for dictionary
 5| if 9999999 in d:
 6|  print("Found in dictionary")
 8| end_time = time.time( ) – start_time
10| print( "Elapsed time for dictionary: { }".format(end_time) )
12| start_time = time.time( )        # tracking time for list
14| if 9999999 in big_list:
15|   print("Found in list")
17| end_time = time.time( ) – start_time
19| print( "Elapsed time for list: { }".format(end_time) )

```

去查查手机。在第 3 行和第 12 行，我们以 UTC 格式访问当前时间。检查完我们的条件后，我们再次获得 UTC 格式的当前时间；然而，我们从中减去开始时间，得到整个执行所用的秒数。你会注意到这两个时间有很大的不同。这个列表通常需要花费 **1** 到 **1.5** 秒，而字典几乎每次都是即时的。现在这看起来没有太大的区别，但是如果你需要搜索 1000 个项目呢？使用列表现在成了一个问题，因为字典会继续立即做，但是列表会花更长的时间。

### 注意

除非另有说明，时间模块以 UTC ( *通用时间*)获取时间。UTC 始于 1970 年 1 月 1 日。输出 time.time()时看到的数字是从那天上午 12:00 开始的秒数。

### 算法之战

测试时间复杂度的一个最明显的方法是运行两个算法。这将让我们真正看到高效算法背后的力量。我们将测试**冒泡排序**和另一种叫做**插入排序**的排序算法。虽然插入排序不是排序时最有效的算法，但我们会发现它仍然比冒泡排序强大得多。让我们继续写下第一个单元格中的两个排序算法:

```
 1| # testing bubble sort vs. insertion sort
 3| def bubbleSort(aList):
 4|  for i in range( len(aList) ):
 5|          switched = False
 6|          for j in range( len(aList) – 1 ):
 7|                  if aList[ j ] > aList[ j + 1 ]:
 8|                          aList[ j ], aList[ j + 1 ] = aList[ j + 1 ], aList[ j ]
 9|                          switched = True
10|          if switched == False:
11|                  break
12|   return aList
14| def insertionSort(aList):
15|   for i in range( 1, len(aList) ):
16|           if aList[ i ] < aList[ i – 1 ]:
17|                   for j in range( i, 0, -1 ):
18|                           if aList[ j ] < aList[ j – 1 ]:
19|                                   aList[ j ], aList[ j + 1 ] = aList[ j + 1 ], aList[ j ]
20|                   else:
21|                           break
22|   return aList

```

去查查手机。现在我们已经定义了需要调用的两个函数，让我们设置一些要排序的随机数据，并像在上一节中一样设置一个计时器:

```
 1| # calling bubble sort and insertino sort

to test time complexity
 2| from random import randint
 4| nums = [ randint(0, 100) for x in range(5000) ]
 6| start_time = time.time( )     # tracking time bubble sort
 7| bubbleSort(nums)
 8| end_time = time.time( ) – start_time
 9| print( "Elapsed time for Bubble Sort: { }".format(end_time) )
11| start_time = time.time( )     # tracking time insertion sort
12| insertionSort(nums)
13| end_time = time.time( ) – start_time
14| print( "Elapsed time for Insertion Sort: { }".format(end_time) )

```

去查查手机。这甚至不是一场比赛。插入排序是一种比它的对应物更有效的算法。尽管两者都使用了双 for 循环的概念，但冒泡排序的步骤效率要低得多，因为它每次都是从列表的前面开始。在设计你的程序和算法时，记住时间复杂性总是很重要的。如果你不确定什么是最好的，试着像我们这里一样测试一下。

### 周四练习

1.  **归并排序**:做一些研究，尝试找出归并排序算法的“大 O”表示。

2.  二分搜索法:二分搜索法要在一千万个数字中找到一个数字，最多可以猜多少次？

虽然今天更多的是关于理论，而不是这本书的其他部分，但它是编程最重要的方面之一。大 O 符号帮助我们理解程序和算法的效率。理解我们为什么使用像字典或列表这样的数据集合总是很重要的。当效率很重要时，可以实现字典来改进程序。这是我们使用字典进行缓存的另一个原因。

## 周五:面试准备

如果你正在寻找一份新的职业或工作，比如 Python 开发人员，那么如果你不能通过面试，那么所有这些课程都是徒劳的。本周五，我们将讲述一个通用软件开发面试的过程。我们将涵盖每个阶段，面试前后要做什么，白板，回答一般性和技术性问题，以及如何勾画你的简历和个人资料。这一课对于那些在面试过程中挣扎的人或者那些从未参加过正式软件开发面试的人来说是有帮助的。如果你对这一部分不感兴趣，并希望继续下去，就把今天作为本书时间表的一个休息。

### 开发人员面试流程

开发人员角色的面试过程可以分为许多不同的阶段。在下文中，你会发现业内许多公司实践的主要阶段。请记住，这是一个一般的面试过程，并不是每个公司都会严格遵循这些流程。请将本节更多地用作可能发生的情况的指南:

*   **第一阶段**
    *   关于你自己和过去工作经验的基本问题。第一步通常是打电话给第三方招聘人员、内部招聘人员、人力资源或公司的人才招聘人员。在面试过程的第一步，面试官试图判断你是否适合这个职位。他们希望你提到“*流行语*”，同时提供为什么你非常适合这个职位的信息。你想把自己和这个职位联系起来。一定要谈论你使用他们寻找的语言和技术的经历。面试官在找你满足一半的要求，让自己很匹配。没有人会知道所有的事情，但是向他们展示你所知道的和你学习的意愿是很好的。

### 注意

流行语是该职位寻找的关键词。例如，使用 Python 的后端职位会期望听到类似于 *API、JSON、Python、Flask、Django、Jinja、关系数据库、PostgreSQL* 等词。

*   **第二阶段**
    *   如果你通过了电话面试，你通常会被要求参加一次面对面的面试。这个阶段通常是你遇到目前在公司工作的其他开发人员的地方。虽然他们会问你一些面试问题，但这个阶段通常是让员工看看他们是否愿意和你一起工作，并在更私人的层面上了解你。一般来说，你会一次面试一小部分员工。您将有两到五次这样的会议，每次持续 10 到 15 分钟。在雇用一个人之前，这些小组通常会聚在一起讨论下一阶段的潜在候选人。在这个阶段，一定要适当地介绍自己，和每个人握手。了解每一位员工，试着在个人层面上与他们建立联系。

*   **第三阶段**
    *   这是技术回合。在这一阶段，将提出问题来评估开发人员的技能和能力。通常，会有一个白板问题、几个纸上技术问题和一个脑筋急转弯。这一阶段通常由招聘经理或你将共事的团队经理来进行。当被问到一个问题时，确保你清楚地理解它。非常欢迎您在回答问题之前，根据需要提出尽可能多的问题，以便清楚地了解问题。如果你不知道问题的答案，让面试官知道你没有用过这个概念或者没有看到问题。在这个阶段，面试官会知道你是否不知道自己在说什么，所以不要试图编造一些东西。他们会对你的诚实留下更深刻的印象，并试图引导你解决问题。在这个阶段，他们不在乎你是对是错。他们更感兴趣的是你如何思考，你解决问题的能力如何。

*   **第四阶段**
    *   此时，你通常和招聘经理或人力资源人员坐在一起。在这个阶段，你可以问关于公司的问题，以及工作角色。如果你已经做到了这一步，公司已经看到了你作为一名潜在员工的价值。通常，这是合同谈判和薪资谈判的地方。在面试结束时，准备好要问的问题，而且要问很多。如果你没有问题，这通常是没有准备好或懒惰的表现。

### 面试前要做什么

几乎在你生活中做的每一件事上，你都要做好充分的准备。面试也是一样。以下是你在面试前应该做的一些提示:

*   **研究**
    *   一定要研究你面试的公司。不要仅仅了解他们创造了什么产品，或者提供了什么服务，还要知道他们支持什么慈善机构，他们合作的公司等等。这表明你参与并关心公司的利益。一点点就够了。

*   **做好准备**
    *   准备一个文件夹或文件夹，里面包括你的简历、一叠面试笔记纸、工作实例等。

*   **简历**
    *   总是用高质量的纸打印简历。

    *   让你的简历符合你要面试的工作。比如后端角色，提到 Python，SQL，数据库相关技术等。

    *   保持你的简历在一页以内。

    *   不要添油加醋。

    *   用经验、技能和教育等部分来组织。

    *   把你的简历想象成 30 秒的电梯推销。

    *   通常，让设计师忽略你的简历会有所帮助。一些网站会收取很少的费用，但是会让你的简历看起来更专业，更有条理。

*   **组合网** ***S*** **ite**
    *   不是所有的开发者都有个人网站，但是如果你没有的话，看起来肯定很糟糕。想象一下去看一个没有牙齿的牙医。把你自己看作是你试图卖给公司的产品，你应该有一个网站来展示你的技能，并让别人联系你。

*   **Github**
    *   几乎每个招聘机构和公司都会通过你的 Github 来查看你参与过的项目。

    *   最好在你的投资组合中也有完整的项目。一个大项目总会比 10 个小项目更突出。

    *   在你的简历、作品集网站和电子邮件中包含你的 Github 账户。

*   **LinkedIn**
    *   大多数招聘人员和公司登录 LinkedIn 只有一个原因，那就是寻找潜在的求职者。

    *   确保你的个人资料是最新的，包含所有相关信息和你参与过的项目。

    *   你的个人资料图片应该是专业的。你不需要穿西装打领带，但是最好不要有你在沙滩上的照片。

    *   把这个网站看作是你的专业网络服务。

    *   经常发布你想从事的领域的信息。你发布的内容越多，招聘人员就越容易认出你。

*   **社交媒体**
    *   保密或保持干净。你最好相信公司会看你的帖子，以了解你是谁，如果他们不喜欢他们看到的，你就不会得到回复。

*   **直接申请**
    *   直接向公司提交申请看起来总是更专业。通常，你会在 Indeed 或 ZipRecruiter 上找到一份自己喜欢的工作；然而，这些公司每天都被这些网站上的申请淹没，他们通常有算法来淘汰大多数候选人。发送一封直接的电子邮件表明你投入了时间和精力去直接联系公司。

### 一般问题

下面是一个非技术性问题的列表，后面是一个好答案的例子。选择这些问题是因为它们通常被不恰当地提问和回答:

*   你期望的薪水是多少？
    *   “我现在没有确切的数字。我想对其他公司提供的类似职位做一些调查。这个职位你给员工的平均工资是多少？”

    *   当他们询问时，千万不要说出一个数字，这在任何谈判过程中都会给他们提供筹码。

    *   用另一个问题来反驳他们的问题。

    *   如果他们继续问你一个数字，简单地陈述同样的回答。

*   你认为自己五年后会怎样？
    *   “未来五年，我会更加关注自己的技能。我知道，专注于继续我的教育和自我提升将引领我到达我需要的地方。”

    *   专注于提高你的技能表现出同情心。

*   你为什么想成为一名软件开发人员？
    *   “我一直对能够从无到有创造出一些东西很感兴趣，我也一直喜欢挑战。当你能够解决问题并构建应用程序时，那是一种美妙的感觉。”

    *   展示你作为开发人员的激情；这将永远是一种优势。

    *   永远不要提是钱的问题，即使是。

*   你为什么要转行？
    *   “我觉得我在以前的职业生涯中没有受到足够的挑战，我一直对编程感兴趣，并对构建改善人们生活的应用程序感到兴奋。”

    *   像上一个问题一样，展示你对这个职业的热情和动力。

    *   解释你喜欢接受挑战，这表明你并不懒惰。

    *   永远不要提是钱的问题，即使是。

*   你为什么想在这里工作？
    *   “你们在这里构建的应用程序帮助了世界各地如此多的用户，我很乐意成为其中的一员。”

    *   谈论公司合作的应用程序或慈善机构。这表明你有激情，在团队中工作出色，而且你有动力。

    *   提及公司文化也是一个很好的答案。

    *   不提工资，福利，甚至更惨…没有答案。

*   告诉我一个棘手的软件问题，以及你是如何解决的。
    *   “我当时正在做一个项目，我被指派在应用程序中实现 Steam API。不幸的是，API 无法正确连接。使用调试器，我在导入和函数调用位置设置了断点。在意识到他们根本没有被击中后，我想这一定是连接的问题。在尝试了几种导入方式并通读了文档之后，我决定将应用程序设置为在函数被点击时关闭。当我第二次运行这个程序时，它立刻就关闭了。意识到函数正在被调用，但是应用程序没有正常运行，我认为这一定是一个导入问题。直到我在一个更新的应用程序中测试该 API 时，才发现问题是由于代码是在 2.2 版本中编写的，而该 API 需要 3.6 版本。为了连接 API，我必须通过 mapper 函数手动导入库，该函数可以在版本之间翻译代码。在意识到映射器工作后，我能够实现 Steam API 包含在其 SDK 中的库。”

    *   尽可能深入地研究这个问题。他们想知道导致问题的每一个细节，你是如何解决问题的，以及你试图解决问题的所有想法。虽然前面的答案可能对你来说没有太大的意义，但它显示了问题，我做了什么来试图找到问题，以及一旦我找到问题，我是如何想出解决方案的。

### 白板和技术问题

这一部分列出了在白板和技术问题的面试流程的第三阶段您应该考虑使用的技巧:

*   **慢慢来**
    *   绝对不要急着解决问题。在回答问题之前，先考虑一个合适的解决方案。通常，给定时间后，你会想到两三种不同的解决方案。

*   **大声说出**
    *   总是谈论你的思考过程。这会让面试官感觉更舒服，这样你们就不会坐在一个安静的房间里思考了。

    *   这向面试官展示了你解决问题的能力。

    *   即使你没有给出正确的答案，他们至少能明白你错在哪里，并提供一些指导。

*   **步骤>语法**
    *   写白板时，你需要当着面试官的面在白板上写下一个功能或几行代码。要记住的最重要的事情是，你的思维过程比你的实际代码更重要。

    *   你可以在白板上有语法错误，但仍然可以通过面试；然而，不正确的算法或步骤会导致失败。

*   **提问**
    *   如果你不确定，问问题。当试图解决一个问题时，提出问题是完全可以的。

    *   记住你问的问题很重要。问一个排序方法是做什么的，和你想让我用什么类型的排序方法相比，有很大的不同。

*   **算法复杂度**
    *   永远记住算法的复杂性。在你写完代码后，你通常会被问到是否有办法进一步提高代码的性能。

    *   知道你刚写的算法的大 O 符号范畴。

    *   考虑什么样的数据类型或集合最适合您的场景。

*   **要诚实**
    *   如果你不知道一个答案，绝对不要试图通过你的方式说话。这个阶段的面试官是一个专业的开发人员，可以挑出任何没有意义的东西。

    *   诚实地说你不确定，但愿意学习这些材料，这将被证明是回答你不知道如何解决的问题的更好方法。

### 面试问题结束

你绝不会希望在面试结束时，当他们问你是否有任何问题时，你两手空空。在面试中做笔记，写下你想到的问题通常是一个好习惯。在下文中，你会发现一系列你应该考虑问的问题:

*   通勤情况如何？

*   停车是免费的吗？

*   你会举办社交活动吗？

*   如果我想进一步发展我的职业技能，你们会提供服务或学费补偿吗？

*   你们提供什么样的福利？

*   公司文化是什么样的？

*   有多少人将和我一起在团队中工作？

*   会有辅导吗？

*   你能告诉我更多关于这个职位的日常职责吗？

*   在这家公司工作，你最喜欢的是什么？

*   对于这个职位的人来说，在这个公司里典型的职业道路是什么？

*   面试过程的下一步是什么？

*   在典型的一天里，我会期待些什么？

*   这家公司支持哪些慈善机构？

*   有什么公司活动吗，比如运动队？

### 面试后做什么

即使你通过了前三个阶段，如果你没有在面试后执行正确的步骤，你仍然会悲惨地失败。在下文中，你会发现一些例子，告诉你在面试过程结束后应该做些什么:

*   **跟进**
    *   总是，总是，总是立即给面试官发一封电子邮件，感谢他们抽出时间。这表示尊重，也是一种礼貌的姿态。

*   **自我批判**
    *   理解自己的错误。不要把它当成个人问题；你能变得更好的唯一方法是理解和自我反省。

*   **继续建造**
    *   总是致力于项目，努力改善你的投资组合。

    *   与最新的库、语言和技术保持同步。

    *   经常更新你的简历和作品集。

*   **冒险外出**
    *   出去参加当地的社交活动。在这里你会遇到很多熟人。当你认识在公司工作的人时，总是更容易找到工作。

    *   像 code alongs 或 hackathons 这样的活动是结识其他希望一起工作的开发人员的好方法。

*   **拒绝**
    *   这种情况时有发生，你不会总是得到这份工作。如果真的发生了，一定要礼貌地问面试官为什么你没有得到这份工作。不要往心里去；相反，利用这些信息成为更好的开发人员并进行改进。

今天的主题是了解面试过程以及如何提高面试技巧。即使是最伟大的程序员也可能是糟糕的面试官。找到一份合适的工作需要大量的努力和专注，即使这样，也可能不会成功。最好的建议是继续提高你的技能，并与其他软件开发人员建立联系。

## 每周总结

本周是更高级的 Python 概念的第二部分。本周教授的许多课程不仅对面试很重要，而且对提高你的项目表现也很重要。迭代器和生成器是一种可以用来创建更好的循环结构和算法的对象。能够使用 decorators 将有助于提高函数能力，并且在 Flask 或 Django 这样的框架中被广泛使用。模块允许我们通过将函数或整个文件导入我们的程序来使用其他开发者的代码。能够编写我们自己的模块允许我们减少每个文件中的代码量。您通常希望尽可能保持组织有序，因为这使得项目更容易阅读、维护和修复。然而，如果这周你需要理解一个主题，那就是大 O 符号。了解大 O 是如何工作的，可以在求职面试中有所帮助，知道如何提高申请的速度。还有更多关于 Python 和编程的高级主题，但这最后两周将为您提供足够的时间来开始构建自己的项目，甚至继续学习框架和使用数据库的大型应用程序。

## 挑战问题解决方案

在周四的课程中，我们复习了这个问题的确切答案。显而易见，字典显然是存储和检索数据的更有效的方式。在处理大型数据集时，记住要使用的正确数据结构总是很重要的。可以肯定的是，在面试过程中也会问到类似的问题。

## 每周挑战

要测试你的技能，请尝试以下挑战:

1.  **了解市场**:上 Indeed 或 Monster 这样的求职网站，寻找你感兴趣的潜在工作。记下他们寻找的资格和技术。看了几个职位描述，排名前三的技术是什么？这些应该是你前进的重点。

2.  购物车模块:从我们几周前编写的购物车程序中取出代码，并将其放入一个模块中。在 Jupyter 笔记本上，运行模块，让程序正常工作。

3.  **增强的购物车**:在程序中增加一个新功能，允许用户保存购物车。在运行程序时，应该加载保存的购物车。该方法应该在模块中编写。**提示**:使用 CSV 或文本文件。

4.  **代码大战**:在 [`www.codewars.com`](http://www.codewars.com) 上算账，想办法解决一些问题。代码战争已被用于面试练习问题，提高你的算法和解决问题的技能，等等。这将有助于提高本书教授的技能。试着每天解决一个问题，你会发现你的 Python 编程技能会提高。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

[T2`https://guide.freecodecamp.org/computer-science/notation/big-o-notation/`](https://guide.freecodecamp.org/computer-science/notation/big-o-notation/)

 </aside>