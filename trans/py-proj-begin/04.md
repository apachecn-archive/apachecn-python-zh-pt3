# 4.列表和循环

在这一周里，我将介绍一种叫做“**列表**的新数据类型和一种叫做“**循环**的新概念列表将赋予我们存储大型数据集的能力，而循环将允许我们重新运行部分代码。

这两个主题是一起介绍的，因为列表很适合循环。尽管列表是 Python 中最重要的数据类型之一，但在介绍它们之前，我们需要理解数据类型和分支语句的基础。到这个周末，我们将有必要的工具来建立一个小规模的刽子手游戏。我们将使用我们在前几周和本周学到的所有概念。

通过应用和重复，每次介绍一个概念时，你都能进一步理解它。如果你还没有一个概念，重要的是要坚持下去，不要停留在单一的课程上。

**概述**

*   了解列表数据类型

*   如何以及为什么使用 for 循环

*   如何以及为什么使用 while 循环

*   了解如何使用列表

*   一起创造刽子手

### 挑战问题

想象你是一个大城市的市长。对于这个例子，让我们假设主要城市是马萨诸塞州的波士顿。你刚刚收到警报，你需要撤离这座城市。你首先做什么？

## 星期一:列表

今天我们将介绍 Python 中最重要的数据类型之一，**列表**。在其他语言中，它们也被称为“*数组*，具有类似的特征。这是你学习的第一个**数据收集**。在接下来的几周里，我们将看到其他数据收集类型。

为了继续今天的内容，让我们从“ *python_bootcamp* ”文件夹中打开 Jupyter 笔记本。打开后，创建一个新文件，并将其重命名为“ *Week_04* 接下来，制作第一个标题为:“**列出了**的单元格我们将开始在那间牢房下面工作。

### 什么是列表？

一个**列表**是 Python 中的一个数据结构，是元素的**可变**、**有序序列**。可变意味着你可以改变里面的项目，而有序序列是指索引位置。列表中的第一个元素总是位于*索引 0* 。列表中的每个元素或值被称为一个*项目*。正如字符串被定义为引号之间的字符一样，列表是通过在方括号 **[ ]** 之间使用不同的数据类型来定义的。同样，像字符串一样，列表中的每一项都被分配了一个**索引**或位置，用于该项在内存中的保存位置。列表也被称为**数据集合**。数据集合只是可以存储多项的数据类型。在后面的章节中，我们会看到其他的数据集合，比如字典和元组。

### 声明数字列表

对于我们的第一个**列表**，我们将创建一个只填充数字的列表。定义一个**列表**就像任何其他数据类型一样；运算符的左边是变量的名称，右边是值。这里的区别在于，值是一组在方括号中声明的项。这对于存储类似的信息很有用，因为您可以轻松地传递一个存储多个元素的变量名。为了分隔**列表**中的每一项，我们简单地使用逗号。让我们试试:

```py
# declaring a list of numbers
nums = [5, 10, 15.2, 20]
print(nums)

```

去查查那个手机。你会得到**【5，10，15.2，20】**的输出。当输出一个列表时，它包括括号。这个当前列表由三个整数和一个浮点数组成。

### 访问列表中的元素

现在我们知道了如何定义一个列表，我们需要采取下一步，了解如何访问列表中的条目。为了访问列表中的特定元素，您使用了一个**索引**。当我们声明列表变量时，每一项都有一个索引。请记住，Python 中的索引从零开始，用括号括起来。第 2 周的星期三也包括索引:

```py
# accessing elements within a list
print( nums[1] )          # will output the value at index 1 = 10
num = nums[2]             # saves index value 2 into num
print(num)                # prints value assigned to num

```

去查查那个手机。这里我们将得到两个值输出， **10** 和 **15.2** 。输出第一个值是因为我们正在访问我们的 *nums* 列表中的索引位置 1，其中存储了一个整数 10。在我们创建了一个名为 *num* 的新变量之后，第二个值被打印出来，这个变量被设置为存储在我们的 *nums* 列表中索引 2 处的值。

### 声明混合数据类型列表

列表可以保存任何数据类型，甚至其他列表。让我们来看看几种数据类型的例子:

```py
# declaring a list of mixed data types
num = 4.3
data = [num, "word", True]         # the power of data collection
print(data)

```

去查查那个手机。这会输出**【4.3，'字'，真】**。它输出 *4.3* 作为第一项，因为当定义列表时，它存储的是 *num* 的值，而不是变量本身。

### 列表中的列表

让我们变得复杂一点，看看列表如何存储在另一个列表中:

```py
# understanding lists within lists
data = [5, "book", [ 34, "hello" ], True]     # lists can hold any type
print(data)
print( data[2] )

```

去查查那个手机。这将输出 **[5，'书'，[34，'你好']，True]** 和 **[34，'你好']** 。第一个输出是整个*数据*变量的值，它存储了一个整数、一个字符串、一个列表和一个布尔数据类型。第二个输出是存储在我们的*数据*变量中的列表，它位于索引 2 处，包含一个整数和字符串数据类型。

### 访问列表中的列表

在最后一个单元格中，我们看到了如何输出存储在数据变量中的列表。现在，我们将看看如何访问内部列表中的项目。要正常访问列表中的条目，我们只需使用括号符号和索引位置。当该项目是另一个列表时，只需在第一组括号后添加第二组括号。让我们先来看一个例子，然后再回过头来看:

```py
# using double bracket notation to access lists within lists
print( data[2][0] )       # will output 34
inner_list = data[2]      # inner list will equal [34, 'hello']
print( inner_list[1] )    # will output 'hello'

```

去查查那个手机。第一个输出将是 **34** 。这是因为我们的第一个索引位置正在访问*数据*中的第二个索引，这是一个列表。然后，指定的第二个索引位置正在访问位置 0 处的那个*列表*中的值，这导致整数 34。第二个输出是**“你好”。**我们得到这个结果是因为我们声明了一个变量来存储我们的*数据*变量的索引 2 处的值，这个变量恰好是一个列表。我们的 *inner_list* 变量现在等于*【34，' hello '】*，我们访问索引 1 处的值，它是字符串**“hello”**。为了更好地理解多重索引的工作原理，请查看表格 [4-1](#Tab1) 。

表 4-1

多重索引值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

索引位置

 | 

位置值

 | 

数据类型

 | 

可以再次索引

 |
| --- | --- | --- | --- |
| Zero | five | 整数 | 不 |
| one | “书” | 线 | 是 |
| Two | [34，'你好'] | 目录 | 是 |
| three | 真实的 | 布尔代数学体系的 | 不 |

请注意，字符串还可以进一步索引。如果您只想打印出“book”中的“b”，您只需简单地写下以下内容:

```py
>>> print( data[ 1 ][ 0 ] )    # will output 'b'

```

### 更改列表中的值

当您使用列表时，您需要能够改变列表中项目的值。这就像将一个普通变量重新声明为一个不同的值，除了您首先访问索引:

```py
# changing values in a list through index
data = [5, 10, 15, 20]
print(data)
data[0] = 100            # change the value at index 0 - (5 to 100)
print(data)

```

去查查那个手机。在我们改变索引 0 处的值之前，它输出**【5，10，15，20】**。一旦我们访问了零索引并将其值更改为 *100* ，然而，列表最终更改为**【100，10，15，20】**。

### 可变存储

当变量被声明时，赋值被放入内存中的一个位置。这些位置有一个特定的参考 ID。您不经常需要检查变量的 ID，但是出于教育目的，了解存储是如何工作的是有好处的。我们将使用 **id()** 函数来检查变量在内存中的存储位置:

```py
>>> a = [ 5, 10 ]
>>> print( id(a) )     # large number represents location in memory

```

当一个列表存储在内存中时，每个条目都有自己的位置。使用索引符号更改该值将会更改存储在该内存块中的值。现在，如果一个变量的值是另一个变量，就像这样:

```py
>>> a = [5, 10]
>>> b = a

```

更改特定索引处的值将会更改这两个列表的值。让我们看一个例子:

```py
# understanding how lists are stored
a = [5, 10]
b = a
print( "a: { }\t b: { }".format(a, b) )
print( "Location a[0]: { }\t Location b[0]: { }".format( id(a[0]), id(b[0]) ) )
a[0] = 20                # re-declaring the value of a[0] also changes b[0]
print( "a: { }\t b: { }".format(a, b) )

```

去查查那个手机。我们会得到几个输出。第一个是打印出两个列表变量的值，以显示它们具有相同的值。第二个 print 语句将输出每个列表的第一项在内存中的位置。最后，在我们改变了列表*“a”*中第一项的值之后，列表*“b”*中的值也会改变。这是因为它们共享相同的内存位置。

### 复制列表

那么，如何在不改变原始列表的情况下创建一个类似的列表呢？你抄！让我们看看如何:

```py
# using [:] to copy a list
data = [5, 10, 15, 20]
data_copy = data[ : ]       # a single colon copies the list
data[0] = 50
print( "data: { }\t data_copy: { }".format(data, data_copy) )

```

去查查那个手机。这次的输出将导致只有我们的*数据*变量的第一项被设置为 **50** 。由于 *data_copy* 仅仅是列表的一个副本，现在如果我们需要再次使用它，我们可以一直保持原始列表的完整性。

### 注意

您也可以使用方法。复制()。

### 周一练习

1.  Sports:定义一个字符串列表，其中每个字符串都是一项运动。然后用下面的一行输出每项运动“我喜欢玩{ }”…

2.  第一个字符:对于下面的列表，打印出每个项目的第一个字母。*(输出应为‘J’，‘A’，‘S’，‘K’)*

    *names = ['约翰'，'亚伯拉罕'，'山姆'，'凯利']*

今天是关于我们的第一个数据收集类型，列表。有很多内容要介绍，但是理解如何定义、更改值和复制列表是很重要的。

## 星期二:循环

今天我们将讨论编程中的一个重要概念，**循环**。在大多数应用程序中，您需要能够多次运行相同的代码。我们使用循环，而不是多次编写相同的代码行。在 Python 中有两种类型的循环，今天的课程是关于循环的

 **为了跟上这一课，让我们从之前的笔记本文件“ *Week_04* ”继续，简单地在底部添加一个标有“ **For Loops** ”的降价单元格

### 循环如何工作

循环是程序员多次重新运行同一行代码的方式。循环将一直运行，直到满足某个条件。以一个第一人称射击游戏为例，游戏将继续运行，直到要么你赢了，要么你的生命值为零。一旦出现任何一种情况，游戏就结束了。

### 注意

将你的代码压缩到尽可能少的行总是很重要的，因为这对程序来说更有效率。

不管你是否知道，循环在生活中无处不在。每天我们醒来，去工作，去睡觉，我们知道这是例行公事，但这只是一个循环。我们每天重复同样的过程，直到周末。同样的概念也适用于我们程序中的循环。

### 编写 For 循环

For 循环主要用于循环一定的次数。以图 [4-1](#Fig1) 为例，这个语法表明循环将运行五次。让我们进一步分析一下。每个 for 循环都以关键字**“for”**开始。然后定义一个临时变量，有时称为*计数器*或*索引*。接下来是“关键字中的**”，后面是 range 函数(后面会解释)。最后，我们用冒号来结束语句。所有 for 循环都将遵循关键字、变量、关键字、函数和冒号的精确结构。**

![img/481544_1_En_4_Fig1_HTML.jpg](img/481544_1_En_4_Fig1_HTML.jpg)

图 4-1

For 循环语法

现在我们已经讨论了编写 for 循环的结构，让我们来编写一个:

```py
# writing your first for loop using range
for num in range(5):
      print( "Value: { }".format(num) )

```

去查查那个手机。这将为我们的值输出“ **0，1，2，3，4** ”。这个循环实际上是数到五并打印出每个数字。那么它是如何打印出每个数字的呢？创建 for 循环时，默认情况下，range 函数从零开始，并将零值赋给我们的临时变量 *num* 。每次循环都是我们所谓的*迭代*。对于每一次迭代，一旦块中的所有代码都运行了，当前的迭代就结束了，循环从顶部重新开始。除了这次，它增加了 *num* 的值，默认为 **1** 。我们的临时变量被赋值为 **1** 的值，并继续运行 for 循环中的代码行，这只是打印出 *num* 的值。它将继续这样做，直到我们达到数字 5。为了给你一个每次迭代赋值的概念，参考表 [4-2](#Tab2) 。

表 4-2

使用 range()为每次迭代分配的值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

循环迭代

 | 

数字的值

 | 

输出

 |
| --- | --- | --- |
| one | Zero | 值:0 |
| Two | one | 值:1 |
| three | Two | 值:2 |
| four | three | 值:3 |
| five | four | 值:4 |

### 注意

不输出值 5，因为 range()计数到但不包括

### 范围( )

范围允许我们从一个数字计数到另一个数字，同时能够定义从哪里开始**开始**和**结束**，以及我们**增加**或**减少**多少。也就是说，如果我们愿意，我们可以每隔一个数字或者每隔五个数字计算一次。当与 for 循环一起使用时，它使我们能够循环一定的次数。在前面的例子中，我们看到范围 5 打印出五个数字。这是因为范围默认从 0 开始，每次递增 1。让我们看另一个例子:

```py
# providing the start, stop, and step for the range function
for num in range(2, 10, 2):
      print( "Value: { }".format(num) )  # will print all evens between 2 and 10

```

去查查那个手机。这一次，我们指定程序从值 2 开始循环，计数到 10，但增量为 2。我们的值的输出变为“ **2，4，6，8** ”。

### 按元素循环

当处理*可迭代*的数据类型时，意味着它们有一个可以循环的元素集合，我们可以用不同的方式编写 for 循环:

```py
# printing all characters in a name using the 'in' keyword
name = "John Smith"
for letter in name:
      print( "Value: { }".format(letter) )

```

去查查那个手机。输出将是每次打印出一个字母。记住，字符串可以被索引，并且是字符或符号的集合，这使得它们*是可迭代的*。这个 for 循环将遍历每个字符，并在包含该字符/符号的块中运行代码。表 [4-3](#Tab3) 回顾了该循环的前几次迭代。

表 4-3

在具有范围的字符串上循环的迭代值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

循环迭代

 | 

信的价值

 | 

输出

 |
| --- | --- | --- |
| one | J | 值:J |
| Two | o | 值:o |
| three | h | 值:h |
| four | n | 值:n |
| five | 空格符号 | 价值: |
| six | S | 值:S |

### 连续语句

现在我们已经看到了循环是如何工作的，让我们来讨论几个可以用于循环的重要语句。第一个是**继续**语句。一旦 continue 语句被命中，当前迭代将停止并返回到循环的顶部。让我们看一个例子:

```py
# using the continue statement within a foor loop
for num in range(5):
      if num == 3:
              continue
      print(num)

```

去查查那个手机。输出将导致 **0，1，2，4** ，因为只有当 *num* 等于 **3** 的值时，才会读取 *continue* 语句。一旦命中该语句，它将停止当前的迭代，并返回到顶部，继续在下一次迭代中循环。这完全阻止了 *continue* 下面的代码被解释，所以它不会命中 print 语句。

### break 语句

我们可以使用的最重要的语句之一是 break 语句。它允许我们在任何时间点打破循环。让我们看一个例子:

```py
# breaking out of a loop using the 'break' keyword
for num in range(5):
      if num == 3:
              break
      print(num)

```

去查查那个手机。输出将导致“ **0，1，2** ”，因为当 *num* 等于 **3** 时，我们完全打破了循环。一旦*断点*被读取，循环完全停止，循环内不再运行代码。这对于在满足条件时停止循环非常有用。

### 注意

如果使用双循环，break 语句将只从该语句所在的循环中断开。也就是说，如果在内部循环中使用 break 语句，它将不会同时跳出两个循环。

### Pass 语句

这三个语句的最后一个是 pass。pass 语句只是一个占位符，这样程序就不会中断。让我们看一个例子:

```py
# setting a placeholder using the 'pass' keyword
for i in range(5):
      # TODO: add code to print number
      pass

```

去查查那个手机。什么都没发生，但这是件好事。如果你完全去掉 pass 语句，程序将会崩溃，因为块中需要某种代码。

它的存在只是为了让我们不必在循环中写代码。这对设计一个程序很有用。

### 注意

使用“ *TODO* 是设置提醒的一般惯例。

### 星期二练习

1.  **可被三整除**:编写一个 for 循环，打印出从 1 到 100 的所有可被三整除的数字。

2.  **Only 元音字母**:要求用户输入，编写一个 for 循环，输出循环中的所有元音字母。例如:

    ```py
    >>> "Hello" ➔ "eo"

    ```

今天我们学习了所有关于 for 循环及其工作原理的知识。循环允许我们多次运行相同的代码行。

## 星期三:While 循环

我们今天将讨论另一种循环，即 **while** 循环。昨天我们看到了循环是如何工作的，以及为什么我们要使用 for 循环。当您需要基于条件而不是计数进行循环时，通常会使用 **while** 循环。今天我们将讨论基于条件的循环。

为了跟上这一课，让我们从之前的笔记本文件“ *Week_04* ”继续，并简单地在底部添加一个 markdown 单元格，表示“ **While 循环**”

### 编写 While 循环

像 for 循环一样，while 循环以关键字**“while**”开始。接下来，我们有一个条件，就像我们用来写一个 *if 语句*。让我们看一个例子:

```py
# writing your first while loop
health = 10
while health > 0:
      print(health)
      health -= 1     # forgetting this line will result in infinite loop

```

去查查那个手机。这将继续打印出*健康*的值，直到满足条件。在这种情况下，一旦*健康*不再大于零，循环就停止运行。在最后一行，我们将*的生命值*减 1，因此每次迭代都会将*的生命值*减少到接近零。如果我们没有在任何时间点减少*健康*，这将成为一个无限循环(*这是不好的*)。

### While 与 For

我已经解释了几次为什么我们要使用每个循环；然而，重申概念总是好的。For 循环通常在需要对元素集合进行计数或迭代时使用。While 循环通常用于基于条件的循环。当使用 while 循环时，通常会使用布尔变量。每个循环都有它们的用例；在大多数情况下，这是个人偏好，但一般的经验法则是用 for 循环计数，用 while 循环计数。

### 注意

对于 while 循环，pass、break 和 continue 语句的工作方式都是一样的。

### 无限循环

在之前的一个单元格中，我提到过无限循环是不好的。无限循环将继续运行，直到程序中断、计算机关闭或时间停止。了解了这一点，就不要制造无限循环了。下面是一个无限循环的例子:

```py
>>> game_over = False
>>> while not game_over:
>>>           print(game_over)

```

如果您要在一个单元中运行它，最终您将不得不关闭 Jupyter Notebook 并重启它(*或者至少是内核*)。这是因为 *game_over* 变量永远不会变为 **True** ，并且该条件一直运行到 *game_over* 变为 **True** 为止。始终确保你有办法退出循环，不管是通过*中断*还是通过一个条件。

### 嵌套循环

循环中循环的概念就是我们所说的**嵌套循环**。循环的概念仍然适用。当使用嵌套循环时，内部循环必须总是在外部循环继续之前完成运行。让我们看一个例子:

```py
# using two or more loops together is called a nested loop
for i in range(2):    # outside loop
      for j in range(3):     # inside loop
            print( i, j )

```

去查查那个手机。起初，这似乎有点令人困惑，因为这里发生了很多事情。让我们用表 [4-4](#Tab4) 分解输出。

表 4-4

跟踪嵌套循环值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"></colgroup> 
| 

循环

 | 

I 的值

 | 

j 的值

 | 

内部循环计数

 | 

外部循环计数

 |
| --- | --- | --- | --- | --- |
| one | Zero | Zero | one | one |
| Two | Zero | one | Two | one |
| three | Zero | Two | three | one |
| four | one | Zero | four | Two |
| five | one | one | five | Two |
| six | one | Two | six | Two |

总的来说，我们可以看到内部循环运行了六次，外部循环运行了两次。只有当外循环运行时， *i* 的值才会增加，直到内循环结束时才会增加。内循环每次都必须从 0 数到 3，才能在外循环上运行下一次迭代。

### 周三练习

1.  **用户输入**:编写一个 while 循环，继续要求用户输入，一直运行到用户输入“quit”为止。

2.  **双循环**:在 while 循环中写一个 for 循环，从 0 数到 5，但是当它达到 3 时，它将 *game_over* 变量设置为 *True* 并且*将*从循环中断开。while 循环应该继续循环，直到 *game_over* 为 *True* 为止。输出应该只有 **0，1，2** 。

今天是一个有点短的一天，因为循环的概念是相同的，无论是一会儿还是一会儿。记住 while 循环用于条件循环，而我们使用 for 循环用于计数/迭代。

## 星期四:使用列表

既然我们已经学习了什么是列表以及如何使用循环，我们今天就来复习一下如何使用列表。列表对于 Python 中的任何程序来说都是一把重要的钥匙，所以我们在使用它们时需要了解我们的能力。

为了跟上这一课，让我们从之前的笔记本文件“ *Week_04* ”继续，并在底部简单地添加一个 markdown 单元格，表示“**使用列表**”

### 检查长度

通常，我们需要知道一个列表中有多少项。为此，我们使用了 **len()** 函数:

```py
# checking the number of items within a list
nums = [5, 10, 15]
length = len(nums)        # len() returns an integer
print(length)

```

去查查那个手机。这将输出 **3** 。我们将 length 函数用于多种用途，无论是检查空列表还是在 range 函数中使用它来循环列表。

### 切片列表

几周前，我们讨论了切割字符串。列表以同样的方式工作，以便您能够访问特定的项目。切片遵循与*范围*功能**开始、停止、步进**相同的参数:

```py
# accessing specific items of a list with slices
print( nums[ 1 : 3 ] )       # will output items in index 1 and 2
print( nums[ : 2 ] )         # will output items in index 0 and 1
print( nums[ : : 2 ] )       # will print every other index - 0, 2, 4, etc.
print( nums[ -2 : ] )        # will output the last two items in list

```

去查查那个手机。输出显示在每个语句旁边的注释中。我们使用括号符号，就好像我们在访问一个索引；然而，我们通过冒号分隔其他值。顺序永远是**【开始:停止:步进】**。默认情况下，start 为零，step 为一。如果您想保留默认值，可以选择不使用这些值。对步长位置使用负数将导致向后切片。如果在开始或停止位置使用负数，切片将从后面开始或停止。也就是说，如果您将-5 作为停止位置，它将从列表的开头一直切片到列表结束之前的五个元素。

### 添加项目

当需要向列表中添加项目时，Python 有两种不同的方法。

#### 。追加( )

Append 总是将括号中的值添加到列表的后面。让我们看看:

```py
# adding an item to the back of a list using append
nums = [10, 20]
nums.append(5)
print(nums)           # outputs [10, 20, 5]

```

去查查那个手机。我们声明了一个包含两个条目的列表，然后将整数值 5 添加到列表的后面。

#### 。插入( )

向列表添加条目的第二种方法是使用 insert。此方法需要一个索引来将值插入到特定位置。让我们看一个例子:

```py
# adding a value to the beginning of the list
words = [ "ball", "base" ]
nums.insert(0, "glove")   # first number is the index, second is the value

```

去查查那个手机。输出将导致 **['手套'，'球'，' basex']** 。Glove 现在位于零索引中，因为我们在 insert 方法中指定了该索引。

### 移除项目

从列表中删除项目有几种方法，下面是主要的两种方法。

#### 。流行( )

默认情况下， *pop* 方法删除列表中的最后一项；但是，您也可以指定要删除的索引。这种方法也广泛用于保存被删除的项目。当使用 *pop* 时，它不仅移除项目，还会返回项目。这允许我们将该值保存到一个变量中，供以后使用:

```py
# using pop to remove items and saving to a variable to use later
items = [5, "ball", True]
items.pop( )                   # by default removes the last item
removed_item = items.pop(0)    # removes 5 and saves it into the variable
print(removed_item, "\n", items)

```

去查查那个手机。使用 *pop* ，我们可以看到它先移除了 **True** 项，然后是索引零中的元素，恰好是整数 **5** 。在将它从列表中弹出时，我们将它保存到一个变量中，稍后我们将它与新列表一起输出。

#### 。移除( )

remove 方法允许我们根据给定的值从列表中删除项目:

```py
# using the remove method with a try and except
sports = [ "baseball", "soccer", "football", "hockey" ]
try:
      sports.remove("soccer")
except:
      print("That item does not exist in the list")
print(sports)

```

去查查那个手机。这里我们将看到输出是我们的*体育*列表，没有**足球**，因为我们能够正确地删除它。现在我们之所以使用一个 *try，并把*去掉，是因为如果**“足球”**不在列表中，那么程序就会崩溃。

### 使用数字列表数据

Python 为我们提供了一些函数来处理数字数据列表，比如 min、max 和 sum。还有几个我们可以使用的，尽管这些是最常用的:

```py
# using min, max, and sum
nums = [5, 3, 9]
print( min(nums) )   # will find the lowest number in the list
print( max(nums) )   # will find the highest number in the list
print( sum(nums) )   # will add all numbers in the list and return the sum

```

去查查那个手机。输出将导致 **3、9 和 17** 。正如他们的名字所说，他们会找到最小和最大的数字。 *sum* 函数将简单地把所有的数字相加。

### 对列表进行排序

通常，你需要使用一个排序列表。有几种方法可以做到这一点，但它们非常不同。一个将改变原始列表，而另一个返回一个副本。

#### 已排序( )

*排序的*函数可以在数字或字母列表上工作，但不能在混合列表上工作。Sorted 也返回列表的一个副本，所以它不会改变原来的列表。通常如果你需要保持原件完好无损，一定要使用这个功能:

```py
# using sorted on lists for numerical and alphabetical data
nums = [5, 8, 0, 2]
sorted_nums = sorted(nums)     # save to a new variable to use later
print(nums, sorted_nums)       # the original list is in tact

```

去查查那个手机。您会注意到我们的 *nums* 列表的输出仍然是我们声明它时的原始顺序。要使用新的排序列表，我们只需将它保存到一个新变量中。

#### 。排序( )

sort 方法的用途与我们前面的 sort 函数的用途相同；但是，它会直接改变原来的列表:

```py
# sorting a list with .sort() in-place
nums = [5, 0, 8, 3]
nums.sort( )          # alters the original variable directly
print(nums)

```

去查查那个手机。结果输出将是一个正确排序的列表。请记住，变量 *nums* 现在已经被更改为**。sort()** 直接改变数值。

### 条件和列表

使用列表时，通常需要检查值是否存在。现在我们将介绍如何在列表上运行条件语句。在列表上运行条件有许多原因；这只是几个例子。

#### 使用“在”和“不在”关键字

当我们上周讨论条件语句时，我们已经看到了这些关键字的用法。使用列表时，它们有助于快速查找列表中的值:

```py
# using conditional statements on a list
names = [ "Jack", "Robert", "Mary" ]
if "Mary" in names:
      print("found")          # will run since Mary is in the list
if "Jimmy" not in names:
      print("not found")      # will run since Jimmy is not in the list

```

去查查那个手机。输出结果为**“发现”**、**“未发现”**。在第一条语句中，我们试图查看列表中是否存在*【玛丽】*，它确实存在。第二个条件语句检查是否*“Jimmy”*不存在，这也是真的，所以它也运行。

#### 检查空列表

有太多的理由需要检查空列表。这通常是为了确保您不会在程序中导致任何错误，所以让我们看看如何检查:

```py
# using conditionals to see if a list is empty
nums = [ ]
if not nums:            # could also say 'if nums == []'
      print("empty")

```

去查查那个手机。这将输出**“空”**。评论中提到了，但是我们也可以检查它是否等于空括号。在这里，我想告诉你如何使用*【非】*关键字。要检查包含项目的列表，您需要编写以下代码:

```py
>>> if nums:

```

### 循环和列表

您可以使用 for 和 while 循环来遍历列表中的项。

#### 使用 For 循环

当用 for 循环遍历一个列表时，语法看起来像我们以前使用 range 函数时一样；然而，这一次我们使用了一个临时变量、in 关键字和列表名称。对于每次迭代，临时变量被赋予该项的值。让我们试一试:

```py
# using a for loop to print all items in a list
sports = [ "Baseball", "Hockey", "Football", "Basketball" ]
for sport in sports:
      print(sport)

```

去查查那个手机。这里我们可以看到这个单元格将输出列表中的每一项。在第一次迭代中，临时变量*“sport”*被赋值为*“棒球*，一旦打印出来，它就移动到下一项。

#### 使用 While 循环

While 循环总是用于条件循环。列表 while 循环的一个很好的用例是删除一个项目。有很多用途，这只是其中之一:

```py
# using the while loop to remove a certain value
names = [ "Bob", "Jack", "Rob", "Bob", "Robert" ]
while "Bob" in names:
      names.remove("Bob")    # removes all instances of 'Bob'
print(names)

```

去查查那个手机。输出将是我们的姓名列表，列表中没有*“Bob”*。我们使用 while 循环和一个条件的组合来检查列表中的*“鲍勃”*值，然后继续删除它，直到我们的条件不再为真。

### 周四练习

1.  **删除重复项**:从下面的列表中删除所有重复项。提示:使用*。*计数()方法。输出应该是 *['鲍勃'，'肯尼'，'阿曼达']*

    ```py
    >>> names = ['Bob', 'Kenny', 'Amanda', 'Bob', 'Kenny']

    ```

2.  **用户输入**:使用 while 循环不断要求用户输入一个单词，直到他们键入“*退出*”。一旦他们输入一个单词，就把它添加到列表中。一旦他们退出循环，使用 for 循环输出列表中的所有项目。

今天很重要，这样我们就能理解如何使用列表，不管是条件语句还是循环。列表可以使用很多方法；在本书的其余部分，我们将更多地讨论它们。

## 星期五:创造刽子手

随着时间的推移，项目通常会变得更长。今天我们将利用过去四周学到的所有概念来建造 Hangman。像往常一样，随着我们编码的进行，新的概念将被引入。今天的目标是有一个功能齐全的刽子手游戏，我们可以猜测，失去一条生命，赢得或失去游戏。我们不会添加图形，虽然在我们一起完成这个项目后，你可以自己随意添加。

为了跟上这一课，让我们从之前的笔记本文件“ *Week_04* ”继续，并在底部添加一个减价单元格，内容为“**星期五项目:创建刽子手**”

### 完工图纸

像往常一样，我们希望在开始编码之前就设计好最终的设计。本周不会像上周一样以图形为基础，所以我们将把重点放在运行程序的逻辑和必要步骤上。幸运的是，逻辑本质上就是玩这个游戏所需的步骤:

1.  选择一个单词来玩。

2.  要求用户输入。

3.  检查猜测是否正确。
    1.  如果是，请在适当的位置显示该字母。

    2.  如果不是，赔一条命。

4.  继续步骤 2 和 3，直到出现以下情况之一:
    1.  用户猜对了单词。

    2.  用户失去了他们所有的生命。

这是主要的游戏功能。在实际运行游戏之前，我们还需要执行其他几个步骤，比如声明游戏变量；然而，这是我们在开始编码之前需要布局的主要功能。了解这种结构将使我们能够继续我们的计划。

### 先前引入的线符号

就像我们在第一周如何添加行号一样，我们将为这个项目和所有其他项目引入线符号的概念。由于需要编辑以前编写的线，甚至在项目中间添加代码，我们将引入线符号的概念。这些符号将通过使用三个空方块来显示，并将代表先前编写的代码。你可以在这里看到一个例子:

```py
1| if num > 1:   ◻◻◻
3|            # new code will go here
5|            print(   ◻◻◻

```

当我们在之前编写的代码之间添加行时，我将使用这三个方块来表示哪一行应该在我们正在编写的代码的上面和下面。这也意味着你应该保持这条线不变。当我们需要覆盖之前的一行时，我会让你知道。当你看到这三个方块时，一定要注意行号，因为这将有助于让你知道你是否错过了一行。

### 注意

点按单元格的边后按下“L”来打开线条

### 添加导入

我们将在一个单元格中编写这个程序，它大约有 50 行长。第一步是导入一些我们需要的附加函数:

```py
1| # import additional functions
2| from random import choice
3| from IPython.display import clear_output

```

第二行是导入一个名为**“choice”**的函数，它将从列表中选择一个随机项目。我们将用它来随机选择单词。第三行是导入一个 Jupyter Notebook 特定的函数，该函数清除输出。当使用循环时，如果我们不清除输出，它将继续在彼此之上输出。

### 声明游戏变量

下一步是理解运行游戏需要哪些变量，并声明它们。如果你想到 Hangman 和我们需要跟踪的东西，我们需要跟踪用户的生活，他们试图猜测的单词，可供选择的单词列表，以及游戏是否结束:

```py
5| # declare game variables
6| words = [ "tree", "basket", "chair", "paper", "python" ]
7| word = choice(words)     # randomly chooses a word from words list
8| guessed, lives, game_over = [ ], 7, False   # multi variable assignment

```

第七行声明了一个名为*单词*的变量，它将从我们的*单词*列表中选择一个随机项目。第八行是我们一起声明三个变量的地方；*猜测的*将被赋予一个**空列表**，*生命*将被设置为 **7** ， *game_over* 将被声明为**假**。

### 注意

在我们编码的过程中，可以随意编写打印语句来检查每个变量的值。这有助于了解我们所声明的内容。

### 生成隐藏单词

在游戏中，我们希望用户能够看到单词中有多少个字母。为此，我们可以创建一个字符串列表，其中每个字符串都是一个下划线。列表中的项目数将被设置为与所选单词的长度相同:

```py
10| # create a list of underscores to the length of the word
11| guesses = [ "_ " ] * len(word)

```

在第 11 行，我们声明了一个名为*guess*的变量，它被设置为一个下划线列表。我们通过将列表乘以单词的长度得到合适的长度。

### 创建游戏循环

无论程序大小，每个游戏都有一个主循环。我们的主循环将执行我们在**最终设计**部分定义的逻辑。与其一次写完，不如让我们一步一步来。第一步是能够接受用户输入并停止玩游戏:

```py
13| # create main game loop
14| while not game_over:
15|           ans = input("Type quit or guess a letter: ").lower( )
17|           if ans == "quit":
18|           print("Thanks for playing.")
19|           game_over = True

```

去查查手机。如果您输入*“退出*”，程序应该会停止，因为我们正在循环，直到 *game_over* 被设置为 **True** ，这仅在我们输入*“退出*”时发生。

### 注意

在继续之前，务必确保单元运行完毕。

### 输出游戏信息

下一步是开始向用户输出信息。让我们用一个格式良好的语句输出他们的生活和他们试图猜测的单词:

```py
14| while not game_over:   ◻◻◻
15|           # output game information
16|           hidden_word = "".join(guesses)
17|           print( "Word to guess: { }".format(hidden_word) )
18|           print( "Lives: { }".format(lives) )
20|           ans = input(   ◻◻◻

```

去查查手机。根据选择的单词，您将得到不同的输出。如果选择的单词是四个字母，我们将得到“**单词猜:_ _ _ _ _ _ _**”和“**生命:7 【T3”)的输出。格式没什么新意，但是第 16 行呢？我们之所以能够在第 17 行创建一个下划线字符串输出，是因为 join 方法。它声明我们希望将猜测列表中的所有项目连接在一起，中间没有空格。例如:**

```py
>>> chars = ['h', 'e', 'l', 'l', 'o']
>>> print('-'.join(chars))

```

前面两行将输出“ **h-e-l-l-o** ”。这是一个将列表显示为字符串的简单方法。

### 核实猜测

下一步是检查用户的输入是否是正确的猜测。我们暂时不会更改任何字母，因为我们首先要确保我们可以识别正确的猜测，并输出他们正确的猜测或删除一个生命:

```py
24|            game_over = True   ◻◻◻
25|            elif ans in word:       # check if letter in word
26|            print("You guessed correctly!")
27|            else:                   # otherwise lose life
28|            lives -= 1
29|            print("Incorrect, you lost a life.")

```

去查查手机。如果你继续错误地猜测，你会注意到生命会降到零度以下。一定要猜出一个正确的字母和一个不正确的字母，这样才知道这是有效的。

### 清除输出

现在我们的程序进行得更深入了，我们可以看到这个循环不断地输出低于先前输出的信息。让我们开始清除输出:

```py
20|        ans = input(   ◻◻◻
22|        clear_output( )          # clear all previous output
24|        if ans == 'quit':   ◻◻◻

```

去查查手机。你会注意到，无论我们玩多长时间，它都会正确地清除之前显示的信息。这是 Jupyter 笔记本特有的功能。

### 创造失败的条件

下一个逻辑操作将是创造一种失败的方式，因为我们的生活可以降到零度以下:

```py
31|         print('Incorrect,  ◻◻◻
33|         if lives <= 0:
34|         print("You lost all your lives, you lost!")
35|         game_over = True

```

去查查手机。现在如果你输了所有的生命，游戏会停止运行，告诉你输了。请记住，循环只运行到 *game_over* 为**真**，这是一旦*生命*的变量下降到**零**时我们设置的值。

### 处理正确的猜测

既然我们可能会输，我们需要看到正确猜测的能力。为了理解如何改变显示的字母，我们首先需要记住输出的是什么。我们的*猜测*列表被转换成一个字符串并输出。这意味着当用户猜对了，我们需要改变我们的*猜测*列表中的条目到它们相应的位置。列表的长度与我们在单元格开头选择的单词的长度相同，因此每个下划线代表一个字母位置。如果单词是**“运动”**，那么“ **_ _ _ _** ”中的第一个下划线将代表“ **s** ”。我们只需要用猜测的字母替换列表中正确的下划线。我们可以通过使用 for 循环并跟踪索引来做到这一点:

```py
28|              print('You guessed correctly!')   ◻◻◻
30|              # create a loop to change underscore to proper letter
31|              for i in range( len(word) ):
32|                              if word[ i ] == ans:      # comapares values at indexes
33|                                     guesses[ i ] = ans
34|              else:   ◻◻◻

```

去查查那个手机。现在当猜中一个正确的字母时，它会输出变化。for 循环循环到单词的长度，我们使用变量" *i* "来跟踪索引。然后我们检查每个字符是否等于猜测的字母。如果是，那么我们将该项从下划线改为在该索引处猜测的字母。查看表 [4-5](#Tab5) 中的流程示例。让我们用**【流行】**来表示单词，用 **p** 来表示猜测。

表 4-5

取索引值检查猜测

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"></colgroup> 
| 

ans 的值

 | 

I 的值

 | 

单词[i]的值

 | 

条件值

 | 

变化后的猜测值

 |
| --- | --- | --- | --- | --- |
| p ' | Zero | p ' | 真实的 | ['p '，' _ '，' _ '] |
| p ' | one | 的 | 错误的 | ['p '，' _ '，' _ '] |
| p ' | Two | p ' | 真实的 | ['p '，' _ '，' p'] |

### 创造成功的条件

完成这个项目的最后一步是建立成功的条件。为了获胜，用户需要猜出随机选择的单词中的所有字母。我们已经跟踪了他们正确猜测的单词，所以我们只需要对照随机单词进行检查:

```py
40|        game_over = True   ◻◻◻
41|        elif word == "".join(guesses):
42|        print("Congratulations, you guessed it correctly!")
43|        game_over = True

```

去查查手机。现在，如果用户猜对了所有字母，就可以正式获胜。我们使用与前面相同的连接方法，将我们的列表转换成一个字符串，这样，如果列表中还有下划线，连接的字符串就不等于随机单词。然后，我们打印一份祝贺，并将我们的 *game_over* 变量改为 True，以结束循环。

### 输出猜测的字母

虽然我们的游戏现在已经完成，我们可以赢或输，我们应该添加一个关键的功能，这是处理以前猜测的字母。每当用户猜出了之前的字母，他们不应该因此受到惩罚，但是他们也应该能够看到之前的猜测。在这个项目开始的时候，我们创建了一个名为 *guessed* 的变量，到现在都没有用过。到目前为止，这个变量仍然是一个空列表，所以让我们来实现它。在我们添加到列表中之前，让我们确保可以正确地打印出信息:

```py
16|        hidden_word =   ◻◻◻
17|        print("Your guessed letters: { }".format(guessed) )
18|        print("Word to guess   ◻◻◻

```

去查查手机。在我们输出信息的顶部，我们现在打印出猜测字母的完整列表。以列表的形式保留它是完全没问题的。即使您猜测，它仍然会显示一个空列表，因为我们还没有添加该功能。

### 添加猜测的字母

现在让我们添加将用户的猜测添加到我们的*猜测*列表的功能:

```py
37|         print("Incorrect,   ◻◻◻
39|         if ans not in guessed:
40||        guessed.append(ans)       # add ans to guessed list
42|         if lives <= 0:   ◻◻◻

```

去查查手机。现在*猜测*列表会随着用户玩游戏而更新。

### 处理先前的猜测

最后一项任务是确保当他们再次猜中同一封信时，他们不会被夺走一条生命，而是提醒他们已经被猜中了。我们需要重写整个条件语句来检查字母是否在单词 though 中:

```py
27||          game_over = True   ◻◻◻
28|           elif ans in word and ans not in guessed:
29||          print("You guessed correctly!")   ◻◻◻
34|                                  guesses[ i ] = ans   ◻◻◻
35|           elif ans in guessed:
36||          print("You already guessed that. Try again.")
37|           else:   ◻◻◻

```

去查查手机。我们不得不更改第 *28* 行的 *elif 语句*，因为我们还需要检查该字母是否尚未添加到*猜测列表*中。在第 *35* 行，我们添加了第二个 *elif 语句*，该语句将检查该字母是否在*猜测的*列表中。请记住，一旦 *if/elif 语句*运行，下面的语句将不会运行。如果那两个条件句都不是**真**，那么说明他们还没猜到字母，而且不在随机词里。游戏现在已经完成了全部功能。

### 最终输出

祝贺您完成这个项目！由于项目的规模，完整的代码将不会写在这里。相反，你可以在 Github 上找到本书资源文件所在的完整版本的代码。你可以在书的前面找到链接。每周的所有资源文件都位于该链接中。要找到这个项目的具体代码，只需打开或下载“ **Week_04.ipynb** ”文件。如果您在这个过程中遇到了错误，请确保将您的代码与该文件中的代码进行交叉引用，看看您可能在哪里出错了。所有未来项目的最终代码输出也可以在同一个位置找到，所以一定要将这个页面加入书签。

多好的一天啊！我们能够使用循环的概念，以及列表的力量来创建一个有趣的游戏。试着添加你自己的信号弹，或者打破它，以进一步了解什么可能或可能不工作。

## 每周总结

这无疑是漫长的一周，充满了大量的信息。一定要花些时间练习这些概念，或者自己练习，或者完成周末练习。我们讨论了为什么列表在 Python 中如此重要，以及如何在我们的程序中使用它们。还介绍了 Python 提供的两个循环，for 循环和 while 循环。使用循环，我们可以根据需要多次重新运行代码，或者迭代列表之类的数据集合。如果你对所有的信息感到不知所措，请放心，我们做的每件事都使用循环和列表。这会给你大量的练习和重复。

## 挑战问题解决方案

尽管我们在寻找一个特定的答案，但这是一个有点棘手的问题。如果你的第一个动作是转身问:“出了什么问题？"或"*我为什么要撤离这座城市？*”，那你回答对了。之所以需要先问这个问题，是因为不同的问题需要不同的解决方案。如果你开始写一个需要使用汽车的疏散计划，如果问题是所有的街道都被淹没了呢？建议人们开车出城是不明智的。有时候问题的答案就是问题本身。另一个教训是，你应该总是后退一步，思考每个问题。永远不要假设你马上就知道解决方案；问问题没问题。

## 每周挑战

要测试你的技能，请尝试以下挑战:

1.  **金字塔**:使用 for 循环建立 x 的金字塔。它应该是模块化的，这样，如果您循环到 5 或 50，它仍然创建均匀间隔的行。**提示** : *将字符串“x”乘以行。*例如，如果您循环到范围 4，它应该产生以下结果:

    ```py
    >>>     x
    >>>    x x
    >>>   x x x

    ```

2.  **Output Names** :编写一个循环，遍历一个项目列表，只输出字符串中有字母的项目。以下面的列表为例，应该只输出**【约翰】**和**【阿曼达】**:

    ```py
    >>> names = ['John', '  ', 'Amanda', 5]

    ```

1.  **Convert Celsius** :给定一个以摄氏度为单位的温度列表，编写一个循环来遍历该列表，并输出转换为华氏温度的温度。提示:换算为“F =(9/5)÷C+32”:

    ```py
    >>> temps = [32, 12, 44, 29]
    Output would be [89.6, 53.6, 111.2, 84.2]

    ```**