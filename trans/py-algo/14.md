附录 C

![image](images/frontdot.jpg)

图表术语

他打了一个赌，我们可以从地球上 15 亿居民中找出任何一个人，通过最多五个熟人，其中一个是他认识的，他可以找到那个被选中的人。

-脆脆脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆香脆

下面的介绍大致基于赖因哈德·迪斯特尔的*图论*和邦-詹森和古丁的*有向图* 的第一章，以及科尔曼等人的*算法简介*的附录(注意，不同书籍之间的术语和符号可能不同；它不是完全标准化的。)如果你认为似乎有很多东西需要记住和理解，你可能不必担心。是的，前面可能会有很多新单词，但大部分概念都很直观和直接，它们的名字通常有意义，更容易记住。

所以……一个*图* 是一个抽象的网络，由*节点*(或*顶点*)，通过*边*(或*弧*)连接而成。更正式地说，我们将一个图定义为一对集合， *G* = ( *V* ， *E* )，其中节点集 *V* 是任意有限集，边集 *E* 是一组(无序的)节点对。 [<sup>2</sup>](#Fn2) 我们把这个叫做 V 上的图*。我们有时也会写 *V* ( *G* )和 *E* ( *G* )，来表示集合属于哪个图。 [<sup>3</sup>](#Fn3) 图通常用网络图来说明，像[图 C-1](#Fig1) 中的那些(暂时忽略灰色高亮)。例如[图 C-1](#Fig1) 中称为*G*T43】1 的图，可以用节点集 *V* = { *a* 、 *b* 、 *c* 、 *d* 、 *e* 、 *f* }和边集*E*来表示***

 *你不必总是严格区分图和它的节点和边集。例如，我们可能会谈到图 *G* 中的一个节点 *u* ，实际上意味着在 *V* ( *G* )，或者等价地，一条边{ *u* ， *v* }在 *G* 中，意味着在 *E* ( *G* )。

![Image](images/sq.jpg) **注**在渐近表达式中直接使用集合 *V* 和 *E* 是很常见的，比如θ(*V*+*E*)，用来表示图形大小的线性度。在这些情况下，集合应该被解释为它们的*基数*(即大小)，更正确的表达应该是θ(|*V*|+|*E*|)，其中| |是基数运算符。

![9781484200568_AppC-01.jpg](images/9781484200568_AppC-01.jpg)

[图 C-1](#_Fig1) 。各种类型的图和有向图

基本的图形定义给出了我们通常所说的*无向图*，它有一个近亲:*有向图*，或*有向图*。唯一不同的是，边不再是无序的对，而是有序的*对:节点 *u* 和 *v* 之间的边现在要么是从 *u* 到 *v* 的边( *u* 、 *v* )要么是从*到*v*、 *u* )换句话说，在有向图 *G* 中， *E* ( *G* )是关于 *V* ( *G* )的关系。[图 C-1](#Fig1) 中的图形*G*T42 3 和*G*G<sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">4</sub>是边缘方向用箭头表示的有向图。注意*G*T52】3 在 *a* 和 *d* 之间有所谓的*反平行*边，也就是说边是双向的。这是可以的，因为( *a* 、 *d* )和( *d* 、 *a* )是不一样的。但是，平行边(即相同的边，重复的边)是不允许的，无论是在图中还是在有向图中。(这是因为边形成一个集合。)还要注意，一个无向图不能在一个节点和它自己之间有一条边，尽管这在一个有向图中是可能的(所谓的*自循环*)，惯例是不允许的。**

![Image](images/sq.jpg) **注意***所做的*允许诸如平行边和自循环之类的事情。如果我们构建我们的网络结构，使得我们可以有多条边(也就是说，这些边现在形成了一个*多重集*)，并且自循环，我们称之为(可能有向)*伪图*。一个没有自循环的伪图仅仅是一个多重图。还有更奇特的版本，比如*超图*，每条边可以有多个节点。

尽管图和有向图是完全不同的东西，但我们处理的许多原理和算法在这两种情况下都同样适用。因此，有时在更一般的意义上使用术语*图*是很常见的，包括有向图和无向图。还要注意，在许多情况下(比如当*穿过*或者在图中“四处移动”时)，无向图可以用有向图来模拟，用一对反向平行的有向边来代替每个无向边。这通常是在将图作为数据结构实际实现时完成的(在[第二章](02.html)中有更详细的讨论)。如果很清楚一条边是有向还是无向的，或者关系不大，我有时会写 *uv* 而不是{ *u* ， *v* }或( *u* ， *v* )。

一条边的*事件发生在*它的两个节点上，称为它的*端节点*。即 *uv* 入射在 *u* 和 *v* 上。如果边是有向的，我们说它*离开*(或者*事件从* ) *u* 并且它*进入*(或者*事件到* ) *v* 。我们分别称 *u* 和 *v* 为其*尾*和*头*。如果无向图中有一条边 *uv* ，则节点 *u* 和 *v* 是*的邻居*，称为*邻居*。一个节点 *v* 的邻居集合，也称为 *v* 的*邻域*，有时写成 *N* ( *v* )。比如*G*T59】1 中 *b* 的邻域 *N* ( *b* )是{ *a* ， *c* ， *d* }。如果所有节点都是两两相邻的，那么这个图叫做*完全*(参见[图 C-1](#Fig1) 中的 *G* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">2</sub> )。对于一个有向图，边 *uv* 意味着 *v* 与 u 相邻*，但是只有当我们也有一条反平行边 *vu* 时，反过来才成立。(换句话说，与 *u* 相邻的节点是那些我们可以从 *u* 沿着从它开始的正确方向的边“到达”的节点。)*

入射在一个节点 *v* 上的(无向)边数(即 *N* ( *v* )称为其*度*，常写成 *d* ( *v* )。比如在*G*T14】1([图 C-1](#Fig1) )中，节点 *b* 的度为 3，而 *f* 的度为 0。(零度节点称为*孤立*。)对于有向图，我们可以将这个数字分成*入度*(输入边的数量)和*出度*(输出边的数量)。我们还可以将节点的邻域划分为 - *邻域*中的*，有时称为*父节点*，以及*外邻域*，或*子节点*。*

一个图可以是另一个图的一部分。我们说一个图 *H* = ( *W* ， *F* )是 *G* = ( *V* ， *E* )的*子图*或者反过来说 *G* 是 *H* 的 ，如果 *W* 也就是说，我们可以通过(可能)去掉一些节点和边，从 *G* 得到 *H* 。在[图 C-1](#Fig1) 中，突出显示的节点和边表示一些示例子图，这些子图将在下文中详细讨论。如果 *H* 是 *G* 的子图，我们常说 *G 包含 H* 。我们说如果 *W* = *V* 则 *H 跨越 G* 。也就是说，一个*生成*子图是一个覆盖原图所有节点的子图(比如图*G*T54】4 图[C-1](#Fig1)中的子图)。

路径是一种特殊的图，当它们以子图的形式出现时，人们主要感兴趣。一条*路径*是，通常由一系列(不同的)节点标识，例如 *v* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">1</sub> 、 *v* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">2</sub> 、…、 *v* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">*n*</sub> ，连续节点对之间有边(仅):T17【E】= {*v*<sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">1</sub>*v*注意，在有向图中，路径必须沿着边的方向；也就是说，路径中的所有边都指向前方。路径的*长度*就是它的边数。我们说这是一条 *v* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">1</sub> 到*v*<sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">n</sub>*之间的路径(或者，在导演的情况下，从 *v* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">1</sub> 到 *v* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">*n*</sub> )。在示例图*G*T71】2 中，高亮显示的子图是 *b* 和 *e* 之间的一条路径，例如长度为 3。如果一条路径 *P* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">1</sub> 是另一条路径 *P* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">2</sub> 的子图，我们说 *P* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">1</sub> 是 *P* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">2</sub> 的*子路径。例如， *G* <sub xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">2</sub> 中的路径 *b* 、 *a* 、*d*a*、 *d* 、 *e* 都是 *b* 、 *a* 、*d*的子路径*****

该路径的近亲是*周期*。通过将路径的最后一个节点连接到第一个节点来构建一个循环，如*G*T11】3([图 C-1](#Fig1) )中通过 *a* 、 *b* 和 *c* 的(有向)循环所示。一个圈的长度也是它包含的边的数量。就像路径一样，循环必须遵循边的方向。

![Image](images/sq.jpg) **注意**这些定义不允许路径自身交叉，也就是说，包含循环作为子图。一个更一般的类似路径的概念，通常被称为*行走*，仅仅是节点和边的交替序列(也就是说，它本身不是一个图)，这将允许节点和边被多次访问，特别是，将允许我们“循环行走”相当于一个循环的是一个*封闭行走*，它在同一个节点开始和结束。为了区分没有循环的路径和普通的步行，有时使用术语*简单路径*。

到目前为止所讨论的概念的一个普遍概括是引入了*边权重*(或*成本*或*长度*)。每个边 *e* = *uv* 被分配一个实数， *w* ( *e* )，有时写成 *w* ( *u* ， *v* )，通常表示与该边相关联的某种形式的成本。例如，如果节点是地理位置，则权重可以表示道路网络中的行驶距离。一个图 *G* 的权重 *w* ( *G* )简单来说就是 *G* 中所有边 *e* 的 *w* ( *e* )之和。然后，我们可以将路径和循环长度的概念分别推广到路径 *P* 和循环 *C* 的 *w* ( *P* )和 *w* ( *C* )。最初的定义对应于每条边的权重为 1 的情况。两个节点之间的*距离*是它们之间最短路径的长度。(寻找这样的最短路径在书中有广泛的论述，主要是在第 9 章。)

如果一个图包含每对节点之间的一条路径，那么它就是*连通的*。如果所谓的*底层无向图* (即忽略边方向后得到的图)是连通的，那么我们说这个图是连通的。在[图 C-1](#Fig1) 中，唯一没有连接的图是*G*T9】1。一个图的*与*连通的最大子图称为它的*连通分量*。在[图 C-1](#Fig1) 中，*G*T19】1 有两个连通分量，而其他只有一个(每个)，因为图本身是连通的。

![Image](images/sq.jpg) **注**这里使用的术语*极大*是指某物不能被扩展而仍具有给定的性质。例如，在某种意义上，连通分量是最大的，因为它不是一个更大的*图(有更多节点或边的图)的子图，也是连通的。*

在计算机科学和其他领域，有一类图特别受到关注:不含圈的图，或*无圈图*。 非循环图有向和无向两种变体，并且这两种变体具有相当不同的性质。先重点说一下无向的那种。

无向无环图的另一个术语是*森林*，森林的相连部分被称为 *树*。换句话说，一棵树就是一个连通的森林(即由单个连通分量组成的森林)。比如*G*T8】1 是一片有两棵树的森林。在一棵树中，度数为 1 的节点称为*叶子*(或*外部节点*)、 [<sup>4</sup>](#Fn4) ，而所有其他节点称为*内部节点*。例如，*G*T22】1 中较大的树有三片叶子和两个内部节点。较小的树只包含一个内部节点，尽管在少于三个节点的情况下谈论叶子和内部节点可能没有太大意义。

![Image](images/sq.jpg) **注意**有 0 或 1 个节点的图被称为*琐碎的*，往往会使定义比必要的更复杂。在很多情况下，我们只是忽略了这些情况，但有时记住它们可能很重要。例如，作为归纳的起点，它们可能非常有用(在第 4 章的[中有详细介绍)。](04.html)

树有几个有趣和重要的属性，其中一些与整本书的特定主题有关。不过，我会在这里给你一些。设 *T* 是一个无向图，有 *n* 个节点。那么下面的陈述是等价的(练习 2-9 要求你证明事实确实如此):

1.  *T* 是树(即无环且连通)。
2.  *T* 是非循环的，有*n*–1 条边。
3.  *T* 是连通的，有*n*–1 条边。
4.  任何两个节点都由一条路径连接。
5.  T 是无循环的，但是给它添加任何新的边都会产生一个循环。
6.  T 是连通的，但是移除任何一条边都会产生两个连通的分量。

换句话说，这些关于 *T* 的陈述中的任何一个，就其本身而言，都和其他任何一个一样具有特征。例如，如果有人告诉你在 *T* 中的任何一对节点之间正好有一条路径，你马上就知道它是连通的，有*n*–1 条边，并且它没有圈。

通常，我们通过选择一个*根节点*(或者简单地说*根节点*)来锚定我们的树。结果被称为*根树*、，与我们目前看到的*自由树*相对。(如果从上下文可以清楚一棵树是否有根，我将简单地在有根和自由两种情况下使用非限定术语 *tree* 。)像这样挑出一个节点让我们定义向上*和向下*的概念。矛盾的是，计算机科学家(以及一般的图形理论家)倾向于将根放在顶部，将叶放在底部。(我们或许应该多出去走走……)。对于任何节点， *up* 都是在根的方向上(沿着节点和根之间的单一路径)。*向下*则是任何其他方向(自动向树叶方向)。注意，在一个有根的树中，根被认为是一个内部节点，*而不是*一片叶子，*，即使它碰巧有一个度*。

正确定位后，我们现在定义一个节点的*深度*为它到根的距离，而它的*高度*是到任何叶子的最长向下路径的长度。树的高度就是根的高度。例如，考虑图 C-1 中*G*T6】1 中较大的树，让 *a* (高亮显示)为根。树的高度是 3，而深度，比如说， *c* 和 *d* 是 2。一个*级别*由具有相同深度的所有节点组成。(本例中，0 级由 *a* ，1 级 *b* ，2 级 *c* 和 *d* ，3 级*e*组成。)

这些方向也允许我们定义其他关系，使用家谱中相当直观的术语(奇怪的是，我们只有单亲)。你的上一级邻居(也就是更接近根的邻居)是你的*父*，而你的下一级邻居是你的*子*。 [<sup>5</sup>](#Fn5) (根当然没有父，叶子也没有子。)更一般来说，你向上走能到达的任何节点都是*祖先*，而你向下走能到达的任何节点都是*后代*。跨越节点 *v* 及其所有后代的树被称为以 v 为根的*子树。*

![Image](images/sq.jpg) **注意**与一般的子图相反，术语*子树*通常不*而*适用于所有碰巧是树的子图——尤其是当我们谈论有根树的时候。

其他类似的术语一般都有其明显的含义。例如，*兄弟节点*是具有共同父节点的节点。有时候，兄弟姐妹是按*排序的*，这样我们就可以谈论节点的“第一个孩子”或“下一个兄弟姐妹”。在这种情况下，该树被称为一棵*有序树*。

正如[第五章](05.html)中所解释的，很多算法都是基于*遍历*，系统地探索图，从某个初始起点(一个起始节点)开始。尽管探索图形的方式可能不同，但它们有一些共同点。只要它们遍历整个图，它们都会产生*生成树*。 [<sup>6</sup>](#Fn6) (生成树就是恰好是树的简单生成子图。)遍历产生的生成树 ，称为*遍历树* ，以起始节点为根。在处理单个算法时，将重新讨论其工作原理的细节，但是图 C-1 中的图*G*T17】4 说明了这个概念。突出显示的子图就是这样一个遍历树，根在 *a* 。注意，从 *a* 到树中其他节点的所有路径都遵循边方向；有向图中的遍历树总是这样。

![Image](images/sq.jpg) **注意**一个有向图，它的底层图是一棵有根树，并且所有的有向边都指向远离根的方向(也就是说，所有的节点都可以通过从根开始的有向路径到达),这个有向图被称为*树形图*，尽管我将主要把这样的图简单地称为树。换句话说，有向图中的遍历确实给了你一个*遍历树形图*。术语*定向树*既用于有根(无方向)树，也用于树状树，因为有根树的边具有远离根的隐含方向。

术语疲劳设置了吗？振作起来——只剩下一个图形概念了。如上所述，有向图可以是无环的，就像无向图一样。有趣的是，这些图形通常看起来不太像有向树的森林。因为基本的无向图可以是任意循环的，一个*有向无环* *图* ，或 DAG 可以有任意的结构(见练习 2-11)，只要边指向正确的方向——也就是说，它们指向不存在*有向*循环。在样本图*G*T10】4 中可以看到这样的例子。

Dag 作为依赖性的表示是非常自然的，因为循环依赖性通常是不可能的(或者至少是不期望的)。例如，节点可能是大学课程，一条边( *u* ， *v* )将表明课程 *u* 是 *v* 的先决条件。理清这种依赖关系是第 5 章中[拓扑排序部分的主题。Dag 也是动态编程技术的基础，在第 8 章](05.html)中讨论。

__________________

阿尔伯特-拉斯洛·巴拉巴希在他的书【T4 链接:网络的新科学(基础书籍，2002)中引用的话。

[<sup>2</sup>](#_Fn2) 你可能根本没想到这是个问题，但你可以假设 *V* 和 *E* 不重叠。

[<sup>3</sup>](#_Fn3) 即使我们给集合取了其他的名字，这些函数仍然被称为 *V* 和 *E* 。例如，对于一个图形 *H* = ( *W* ， *F* )，我们会得到*V*(*H*)=*W*，*E*(*H*)=*F*。

[<sup>4</sup>](#_Fn4) 不过正如后面解释的，根不被认为是叶。此外，对于只包含两个相连节点的图，将它们都称为叶子有时没有意义。

[<sup>5</sup>](#_Fn5) 注意，这与有向图中的内外邻域是同一个术语。一旦我们开始确定树边的方向，这两个概念就一致了。

[<sup>6</sup>](#_Fn6) 只有从起始节点可以到达所有节点时才成立。否则，遍历可能不得不在几个地方重新开始，导致一个*跨越森林*。生成林的每个组件都有自己的根。*