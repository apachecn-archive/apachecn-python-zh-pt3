# 7.通信协议

在上一章中，我们讨论了如何利用微控制器读取传感器，即利用微控制器上的模数转换器。然而，当我们开始使用串行通信时，可以与微控制器接口的器件种类会急剧增加。在本章中，我们将了解 UART、SPI 和 I2C 的串行通信协议。理解这些协议将扩展我们微控制器的接口能力。

## 微控制器通信

在我们开始研究微控制器上的具体通信协议之前，我们先讨论一下微控制器的一般通信。在微控制器系统中，有两种类型的通信。有串行通信和并行通信。并行通信系统利用多条信号线来传输数据。并行通信速度很快，是老式计算系统中传输数据的首选方法。这是因为这些旧设备中的处理器速度不够快，无法处理与串行通信相关的开销。当我们谈到开销时，我们指的是软件开销，即 CPU 花费在做额外工作上的额外时间。

在串行通信中，数据以比特流的形式通过比并行系统少得多的通信线路发送。虽然串行通信比并行通信慢，但如果数据传输速率相等，现代硬件的速度足以消除对并行系统的需求。这并不是说并行通信已经过时。例如，像显示器这样的设备受益于使用并行通信获得的更高的传输速率。

如今，并行通信被保留用于与彼此距离较近的设备进行通信。这是因为通过并行总线传输数据需要大量额外的硬件。例如，组成传输线的电线需要使用额外的资源。因此，每当我们远距离传输数据时，我们倾向于使用串行通信。

如今存在无数的串行通信方法。有些很简单，而有些则采用复杂的协议，这些协议足够强大，可用于航空航天和汽车应用。

## USART 通信公司

在本节深入探讨之前，我们应该花点时间讨论一下串行通信。串行通信有两种方式:异步或同步。

异步通信以比特流的形式发送数据。这个比特流通常包括三个部分。在数据流的开头是一个起始位，表示数据开始传输的时间。最后还有一个停止位，指示数据停止传输的时间。在起始位和停止位之间，有一个数据包，其中包含我们要传输的数据。数据包是我们给一个字节的格式化数据起的名字。发送开始和停止位的需要增加了一点软件开销，这限制了传输的速度。然而，这些起始和停止位对于实现通信设备之间的同步是必要的。

同步串行通信消除了与发送起始和停止位相关的开销，因此需要较少的软件开销。这是通过使用时钟来同步数据传输来实现的。然而，这种方法确实需要额外的线路来传送时钟信号。因此，虽然它确实提高了数据传输效率，但它需要额外的硬件才能正常运行。

到目前为止，在我们的整个项目中，我们一直在利用 USART 通信形式的串行通信，而没有意识到这一点。USART 是一种串行通信协议，代表通用同步异步收发器。每次我们在机器上使用 PuTTY 与 CircuitPython 微控制器对话时，我们都在利用 USART 的强大功能。

虽然它是一种能够同步使用的协议，但这些功能很少被利用，而且在基于微控制器的系统中，绝大多数 UART 通信都是异步使用的。因此，USART 通常被称为 UART(通用异步收发器)，缩写中省略了同步位。因此，我们将把重点放在异步通信方法上。

异步 UART 有两条通信线路，分别连接到发送(TX)引脚和接收(RX)引脚。这些引脚在发送数据的发送器和接收数据的接收器之间共享。为了成功实现数据通信，器件之间还必须有公共接地连接。

由于没有时钟线来帮助通过异步 UART 传输数据，接收器和发送器必须就数据传输速率达成一致。这种数据传输速率称为波特率。波特率衡量每秒传输的位数。大多数低级通信接口使用 9600 波特的波特率。CircuitPython UART 接口的波特率约为 115，200。

UART 模块可以在三种通信模式下工作，即单工、半双工和全双工通信方式。为了理解这些是如何工作的，假设我们有一个 UART 通信系统，如图 [7-1](#Fig1) 所示。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig1_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig1_HTML.jpg)

图 7-1

UART 通信系统

如果数据从器件 1 单向传输到器件 2，这称为单工通信。如果数据从器件 1 传输到器件 2，然后从器件 2 传输到器件 1，但不是同时传输，则这称为半双工通信。如果数据从器件 1 传输到器件 2，然后同时从器件 2 传输到器件 1，这称为全双工通信。

## 更深入地了解 UART

我们之前在 UART 环境中讨论的比特流称为数据帧。数据帧是我们给单个数据传输单元起的名字。如果我们观察 UART 数据帧，会发现它由 1 个起始位、5 至 9 个数据位、0 至 1 个奇偶校验位和 1 至 2 个停止位组成。当我们将所有这些放在一起时，UART 数据帧类似于图 [7-2](#Fig2) 所示的排列。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig2_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig2_HTML.jpg)

图 7-2

UART 数据帧

我们知道，起始位的目的是指示数据传输的开始，而停止位指示数据传输何时停止。但是，您可能想知道奇偶校验位的用途是什么。使用奇偶校验位原因是为了帮助错误检测。

异步 UART 有可能发生干扰。当我们谈到干扰时，我们的意思是某些因素可能导致数据损坏和数据传输中的错误。奇偶校验位用于帮助这种情况。奇偶校验位被添加到数据包的停止位之前。添加该奇偶校验位使得数据帧中 1 的数量为偶数或奇数。当数据包到达目的地时，如果数据帧与预期的偶数值或奇数值不同，我们就知道传输中有错误。利用这些信息，可以重新发送或丢弃数据包。

## CircuitPython 中的 UART

在 CircuitPython 中，可以使用板载硬件外设进行串行通信，也可以通过称为位碰撞的过程使用软件例程来执行串行通信。由于使用硬件外设更有效，这是我们将用来控制串行设备的方法。

CircuitPython 提供“busio”库，支持 UART、SPI 和 I2C 通信的硬件外设。

这些是我们将用来与 CircuitPython MCU 进行 UART 通信的模块:

*   board–board 模块包含我们正在使用的电路板的引脚常量。

*   时间–时间库包含允许微控制器使用时间相关功能的函数。睡眠方法是我们用来帮助微控制器计时的方法。

*   busio——这个库包含允许我们使用 CircuitPython 工具来控制硬件的函数。

## 带 MCU 原理图的 USB-UART

我们连接微控制器，如图 [7-3](#Fig3) 所示。我们可以使用 USB 转 UART 转换器，将微控制器连接到计算机。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig3_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig3_HTML.jpg)

图 7-3

带 UART 的 MCU

## 带 USB-UART 电路连接提示的 MCU

以下是连接电路的推荐步骤:

1.  首先，在进行串行通信连接时，最好保持电路断电，因为错误的连接会损坏计算机的 USB 端口。

2.  用跳线将 MCU 连接到 USB 转 UART 模块，如下所示。用第一根跳线将 USB-UART 模块上的 RX 引脚连接到微控制器的 TX 引脚，并将 USB-UART 模块的 TX 引脚连接到微控制器的 RX 引脚。

3.  如果你的 USB-UART 模块是 5 伏的，你必须通过一个逻辑电平转换器将 MCU 连接到模块。为此，将 USB-UART 模块的 RX 和 TX 引脚连接到逻辑电平转换器的 HL 引脚，并将微控制器的 RX 和 TX 引脚连接到逻辑电平转换器的 LV 引脚。

4.  用跳线将模块上的接地引脚连接到试验板接地轨的接地引脚。

5.  连接好所有东西后，仔细检查你的连接，然后给你的电路通电。

当你完成连接电路时，它应该看起来如图 [7-4](#Fig4) 所示。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig4_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig4_HTML.jpg)

图 7-4

MCU 连接到 USB-UART 试验板

## UART 与 CircuitPython 程序

一旦您的电路被连接，在 Mu 编辑器中编辑您的 code.py 文件以反映清单 [7-1](#PC1) 。

```
# import the board module
import board

# import time library
import time

# import library for working with UART
   1   import busio

#setup uart 9600 baudrate, 8 bits, no parity, 1 stop
   2   uart = busio.UART(board.TX, board.RX, baudrate=9600,
                  bits=8, parity=None,
                  stop=1, receiver_buffer_size=64)

   3   while True:
    # read up to 64 bytes of data
    dataRead = uart.read(64)

    # once we got data print it
    if dataRead is not None:
       print("I got data")

Listing 7-1Our Program

```

我们的程序是一个简单的程序，用于验证 UART 模块是否工作。首先，我们导入开发板和时间库来启动和运行开发板。在(1)中，我们导入了 busio 库来使用 UART。在(2)处，UART 模块随后设置为板的默认 RX 和 TX 引脚。我们还将 UART 配置为 9600 波特值和 8 位数据，并且不执行任何奇偶校验。此外，我们设置了 1 个停止位，并为接收器设置了 64 字节的缓冲区大小。这些设置是标准 UART 值。在(3)中，我们有一个无限循环，它从 UART 模块读取数据，然后让我们知道 UART 模块何时接收到数据。

当您保存文件和程序运行时，您可以开始与您的电路进行交互。如果您通过 USB-UART 模块的串行连接输入数据，您的串行终端将显示消息“我有数据”。

## SPI 通信

我们接下来要讨论的串行通信协议是 SPI。SPI 代表串行外设接口。SPI 是微控制器使用的另一种串行通信方法。与可以同步或异步操作的 USART 不同，SPI 是一种仅同步协议。同步使得 SPI 成为一种快速协议，因为对模块速度的限制通常取决于模块的硬件限制。SPI 使用时钟来保持器件同步，该模块可以以通信时钟允许的最快速度运行。

SPI 对相互交互的器件采用主从关系。产生时钟的器件称为主器件，与之通信的另一个器件称为从器件。微控制器上的典型 SPI 模块可以在主机模式和从机模式下工作。

SPI 有四条线路。第一行叫做主出从入(MOSI)。该线路从主机向从机发送数据。另一条线路从从机向主机发送数据；我们称之为主入从出(MISO)。还有一条时钟线(SCK ),负责传送时钟信号，使器件保持同步。最后，还有一个从机选择(SS)线路，也称为片选(CS)线路。这条线有特殊的用途。您可以看到，SPI 总线可以支持从机选择线路允许的从机数量。当主机选择器件的从机选择线时，从机将知道必须选择该线。

你可以在图 [7-5](#Fig5) 中看到典型的 SPI 总线连接。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig5_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig5_HTML.jpg)

图 7-5

SPI 总线

## 深入 SPI

查看图 [7-6](#Fig6) 中的图像，这样您就可以了解 SPI 通信的内部情况。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig6_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig6_HTML.jpg)

图 7-6

SPI 基本框图

SPI 利用几个移位寄存器将并行数据转换成串行数据，然后通过 SPI 总线传输。回想一下，我们说过主机生成时钟。该时钟用作模块内所有移位寄存器的输入，进而让主机控制传输速度。

为了传输数据，SPI 总线的工作原理如下。从机选择线从高电平变为低电平，开始传输。然后根据时钟的上升沿或下降沿传输数据。我们称之为时钟阶段。根据用户选择的时钟极性，SPI 模块将知道何时工作。时钟极性是时钟线默认状态的名称，在我们称之为空闲状态期间，它可以是高电平或低电平。在该阶段结束时，从机选择线从低电平变为高电平。

## SPI 电路连接

1.  用一根跳线将 MCU 上的 MOSI 引脚连接到 MISO 引脚。

## SPI 与 CircuitPython 程序

在将一根跳线从 MISO 引脚连接到 MOSI 引脚后，打开 Mu 编辑器并编辑您的程序，使其类似于清单 [7-2](#PC2) 。

```
# import the board module
import board

# import time library
import time

# import library for working with SPI
1   import busio

# setup SPI
2   spi = busio.SPI(board.SCK, board.MOSI, board.MISO)

# lock spi bus
3   while not spi.try_lock():
    pass

# super loop
4   while True:
    # print numbers 0 to 8 via SPI bus
    for x in range(48, 57, 1):
        # buffer for send
        tx = chr(x)

        # buffer for receive
        rx = bytearray(1)

        # SPI RX_TX

        spi.write_readinto(tx, rx)

        # print sent and received data
        print("tx: " + str(tx))
        print("rx: " + str(rx))

        # sleep for 500 ms
        time.sleep(0.5)

Listing 7-2Our SPI Loopback Program

```

我们使用的 SPI 程序就是所谓的回送程序。回送程序是发送者发送和接收它已经发送的消息的程序。该回送程序可以用来验证 SPI 总线的工作情况。

在(1)中，我们使用 busio 库来处理 SPI 硬件外设。在(2)中，我们通过创建实例来设置 SPI 模块，同时设置 SCK、MOSI 和 MISO 引脚。在(3)中，我们需要锁定 SPI 总线才能使用。这是 CircuitPython 的要求之一，在您希望使用总线的任何时候都必须这样做。在(4)的超级循环中，我们使用 SPI 模块打印数字 0 到 8 来传输字符。发送完字符后，我们使用 SPI 模块读取已发送的字符。一旦字符被传输，我们每 500 毫秒将发送和传输的字符打印到串行终端。

## I2C 通信公司

我们要看的最后一个通信协议是 I2C(集成电路间)协议。I2C 是一种串行协议，最近变得非常流行。你看，I2C 只需要两条通信线路。它们是串行时钟线(SCL)和串行数据线(SDA)。像 SPI 一样，I2C 也有一个主机，负责控制与之通信的总线和从机。在这方面，它与 SPI 的不同之处在于，I2C 总线上的任何器件都可以在任何时间点成为主机。看看图 [7-7](#Fig7) 你就知道 I2C 公共汽车是什么样子了。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig7_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig7_HTML.jpg)

图 7-7

I2C 公共汽车

正如您所观察到的，主设备不需要使用从设备选择线来与总线上的 I2C 设备通信。这是因为 I2C 总线上的每个设备都被分配了一个我们可以用来读取它们的地址。该地址长度为 7 位，有效地址范围从 0 到 127，最多允许 128 个设备连接到总线。

由于我们缺少从机选择线，因此只有总线上的主机才能发起通信，这一点尤为重要。如果两个设备试图同时发起通信，就可能发生总线上的冲突。I2C 总线上的两条线被称为开漏引脚。开漏引脚需要一个上拉电阻才能输出高电平。因此，在 I2C 总线上，需要一个 4.7k 的上拉电阻来保证总线正常工作。

## 深入 I2C

当时钟线为低电平时，I2C 通过让数据线改变状态(高电平或低电平)来工作。当时钟线为高电平时，使用启动和停止信号读取数据，以实现无错误的数据传输。起始和停止条件都是通过保持时钟线为高电平，同时改变数据线上的电平来实现的。

像在所有串行通信协议中一样，数据在 I2C 中是通过使用包来传输的。为确保从机与主机通信，数据包中会发送一个特殊的应答位，称为应答位。当与接收器通信时，发送设备将释放 SDA 线。如果线路被拉低，那么我们将得到一个确认“ACK ”,因为我们知道器件已准备好通信。如果没有，我们将得到一个不承认“NACK”，我们知道设备不能正常通信。

图 7-8 向我们展示了 I2C 传输序列的样子。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig8_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig8_HTML.jpg)

图 7-8

I2C 传输

最近进入嵌入式设备领域的一种新总线是系统管理总线(SMBus)。SMBus 主要与 I2C 兼容，只是在功耗、超时要求和最大总线速度等方面有所改进。

## CircuitPython 中的 I2C 支持

CircuitPython 提供了一个库，用于处理微控制器上的 I2C 模块。我们使用与 UART 和 SPI 模块相同的模块，即 busio 模块。

## MPU6050

我们将用来测试 CircuitPython 的器件是 MPU6050。该器件在一个封装中集成了加速度计和陀螺仪，这使得它可以方便地用于传感器融合和机器人应用等领域。

设备内的陀螺仪测量角速度。这意味着陀螺仪测量旋转物体的角度变化率。另一种说法是，陀螺仪本质上是测量某个物体相对于三个轴的旋转，这三个轴是 X、Y 和 Z 轴。

设备中的加速度计测量物体速度变化的速率(实质上是作用在物体上的力)。这通常用重力或米/秒(或米/秒的平方)来衡量。

MPU6050 还包括一个板载温度传感器，我们可以用它来读取温度数据。

由于器件采用 SMD 封装，因此在使用器件时，通常在分线板上使用。分线板是一种特殊电路板的名称，通过提供外部焊盘，我们可以轻松连接到 MPU6050 等 SMD 器件。我们看到一个这样的 MPU6050 分线板，如图 [7-9](#Fig9) 所示。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig9_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig9_HTML.jpg)

图 7-9

MPU6050 早餐信贷:Adafruit，adafruit.com

来自加速度计和陀螺仪的数据可以在我们称之为传感器融合的过程中结合起来。当我们融合来自加速度计和陀螺仪的传感器数据时，我们得到的就是所谓的惯性测量单元(IMU)。IMU 通常使用软件过滤器将这些数据融合在一起。这种类型的过滤器本质上是对时间点上的一些数据进行采样的数学运算。有许多方法可以实现这种滤波，包括互补滤波器、卡尔曼滤波器和 Madgwick 滤波器。每种过滤器都有其优点和缺点，您可以根据自己的应用来决定。本书不涉及传感器融合；但是，如果您愿意，您可以使用各种过滤器对我们从 MPU6050 读取的数据进行研究。

## 带 MCU 原理图的 I2C

我们将 MPU6050 连接到 MCU，如图 [7-10](#Fig10) 所示。我们必须确保包括上拉电阻。请注意，1k 和 10k 之间的值将适用于 4.7k，这是一个很好的最佳值。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig10_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig10_HTML.jpg)

图 7-10

MCU 连接到 MPU6050 原理图

## I2C 电路连接提示

以下是连接电路的推荐步骤:

1.  首先，我们将每个电阻的一条引线连接到 VCC。

2.  如下连接每个电阻的另一根引线。将第一个电阻的自由端连接到 SCL 线，将另一个电阻的自由端连接到 SDA 线。

3.  接下来，在 MPU6050 的 SCL 和 SDA 引脚与微控制器的 SCL 和 SDA 引脚之间连接一条跳线。

4.  将 MPU6050 上的 VCC 引脚连接到试验板上的 VCC 轨，将 GND 引脚连接到试验板的 GND 轨。

当你完成连接电路时，它应该看起来如图 [7-11](#Fig11) 所示。

![../images/511128_1_En_7_Chapter/511128_1_En_7_Fig11_HTML.jpg](../images/511128_1_En_7_Chapter/511128_1_En_7_Fig11_HTML.jpg)

图 7-11

MCU 连接到 MPU6050 试验板

## I2C 与 CircuitPython 程序

打开 Mu 编辑器并编辑您的程序，使其类似于清单 [7-3](#PC3) 。

```
# import the board module
import board

# import time library
import time

# import library for working with I2C
import busio

# setup the I2C module
1   i2c = busio.I2C(board.SCL, board.SDA)

# lock the I2C bus
2   while not i2c.try_lock():
    pass

# super loop

3   while True:
    # scan for addresses on the bus
    print("I2C addresses found:", [hex(device_address)
                                   for device_address in i2c.scan()])

    # every two seconds
    time.sleep(2)

Listing 7-3Our I2C Test Program

```

我们编写的程序将确保传感器设置正确，并且通过 I2C 总线进行通信。我们执行通常的导入来让微控制器运行。在(1)中，我们为 I2C 通信进行了设置，创建了我们可以使用的 I2C 总线的实例，具有设备的物理 I2C 引脚的参数。在(2)中，我们锁定了总线的实例，因为这是 CircuitPython 所要求的。在(3)的主循环中，我们一直扫描 I2C 总线，并将连接的设备打印到我们的串行控制台。

一旦传感器正确连接，您应该看到连接到总线的 MPU6050(地址为 0x68)将被打印到我们的串行控制台。

## 添加库

检测到传感器在那里是好的；然而，我们也可能想要读取传感器数据。为此，我们必须添加已创建的库，以便轻松连接传感器。为设备添加库很简单。首先，请确保从 Adafruit 网站下载适用于您正在使用的设备的库包，网址是:

[T2`https://circuitpython.org/libraries`](https://circuitpython.org/libraries)

一旦你下载了你的库，解压它。打开连接到计算机的“CIRCUITPY”驱动器，并打开 lib 文件夹。将库包中的以下文件放入“CIRCUITPY”驱动器的 lib 文件夹中，以使用本节内容:

*   adafruit_register 文件夹

*   adafruit_bus_device 文件夹

*   adafruit_mpu6050.mpy 文件

一旦添加了这些文件，您就可以继续下一部分了。

## MPU6050 与 CircuitPython 程序

现在我们已经导入了库，我们将能够读取 MPU6050。我们将读取温度、陀螺仪和加速度计数据，并将其打印到串行控制台。打开管理部门编辑器并编辑文件，使其类似于清单 [7-4](#PC4) 。

```
# import the board module
import board

# import time library
import time

# import library for working with SPI
import busio

#import library for working with the MPU6050
1   import adafruit_mpu6050

# setup I2C

2   i2c = busio.I2C(board.SCL, board.SDA)

# create instance of MPU6050
3   mpu = adafruit_mpu6050.MPU6050(i2c)

#super loop
4   while True:
    #print accelerometer data
    print("Acceleration: X:%.2f, Y: %.2f, Z: %.2f m/s^2" % (mpu.acceleration))

    # print gyroscope data
    print("Gyro X:%.2f, Y: %.2f, Z: %.2f degrees/s" % (mpu.gyro))

    # print temperature data
    print("Temperature: %.2f C" % mpu.temperature)

    # print space
    print("")

    # every second
    time.sleep(1)

Listing 7-4Reading Information from the MPU6050

```

在程序中，我们导入我们的库，以便与电路板和 I2C 模块一起工作。在(1)中，我们导入了用于使用 MPU6050 传感器的库。在(2)中，我们为要使用的微控制器上的管脚设置了 I2C 模块。在(3)中，我们创建了一个我们想要使用的 MPU6050 模块的实例。在我们的超级循环 at (4)中，我们使用我们库中可用的方法，每秒钟将加速度计、陀螺仪和温度数据等信息打印到控制台。

## 结论

在本章中，我们学习了如何在 CircuitPython 中使用串行通信。我们讨论了 UART、SPI 和 I2C 的使用。我们还学习了如何使用 MPU6050 传感器并从器件中读取陀螺仪、加速度计和温度数据。今天有如此多的传感器使用本章中涵盖的所有协议，你将能够感知和操纵来自我们物理世界的几乎任何数据。