# 4.用科学的方法调试

我有这方面的背景。我不认为任何事情是理所当然的。—匿名

在前两章中，我们已经看到了 Python 中一些经常出现的缺陷。这不仅有助于我们识别和修复类似的缺陷，我们还知道缺陷可能会在程序中传播，并且诊断可能不明显。现在是我们把注意力转向修复更困难的错误的时候了。我们如何修复一个从未见过的错误？在这一章中，我们将系统地分析 MazeRun 游戏控件中的一个 bug。

在任何游戏中，玩家都有一个机制来控制正在发生的事情。在我们的例子中，控件非常简单:玩家使用箭头键移动一个图形。因为许多准游戏程序员很久以前就有同样的想法，所以 Pygame 提供处理键盘和鼠标事件的基础设施也就不足为奇了。我们将使用该基础结构来编写一个事件循环。事件循环应持续检查新的关键事件。Pygame 使用函数`pygame.event.pump()`在内部准备事件，使用函数`pygame.event.poll()`检索事件。然后，事件循环将按下的键发送到执行动作(例如，移动图形)的自定义函数。事件循环的代码如下所示:

```py
from pygame.locals import KEYDOWN
import pygame

def event_loop(handle_key, delay=10):
    """Processes events and updates callbacks."""
    while True:
        pygame.event.pump()
        event = pygame.event.poll()
        if event.type == KEYDOWN:
            handle_key(event.key)
        pygame.time.delay(delay)

if __name__ == '__main__':
    pygame.init()
    event_loop(print)

```

我们将`print`作为回调函数传递给`event loop`，这样可以直接看到玩家输入的按键。因为回调函数是作为参数传递的，所以稍后我们可以很容易地用不同的函数替换它。然而，当我们运行这段代码时，什么也没有发生。完全没有键盘输出。我们发现了另一个语义错误。在这一章中，我们将使用一种系统的方法，即科学的方法，来追踪潜在的缺陷。科学方法是编程中的一个关键的最佳实践，首先因为它提供了一个其他调试技术适用的概念框架，其次因为它完美地补充了我们将在本书后面看到的测试和维护的最佳实践。

## 运用科学方法

在第 [2](02.html) 章中，我们能够通过查看生成的错误消息来追踪错误的原因。在这些错误消息中，发生错误的行和缺陷的位置通常是不同的。然而，这些都是相对简单的缺陷。这种缺陷通常可以通过非系统的猜测来解决:您查看症状，查看您的代码，尝试一些可能的解决方案，并(有希望地)解决问题。

通过第 3 章[中的语义错误，我们了解到缺陷会在程序中传播，最终导致错误。当错误传播的性质或缺陷本身变得更加复杂时(对必须修复缺陷的人来说是复杂的，而不是绝对复杂)，猜测策略将彻底失败。在一个复杂的缺陷中，症状和潜在的缺陷通过一个长的因果链联系在一起。仅仅更努力地看代码和尝试更多的猜测会很快让程序员筋疲力尽(见图](03.html) [4-1a](#Fig1) )。猜测策略失败的主要问题是，我们很少(如果有的话)获得关于缺陷的新信息。

![A419627_1_En_4_Fig1_HTML.jpg](A419627_1_En_4_Fig1_HTML.jpg)

图 4-1。

Suggestive comparison of a) trying to guess the source of the defect and b) systematically testing hypotheses with the scientific method

科学方法是解决未知问题的最佳实践。简而言之，我们不是只关注解决方案，而是通过收集确凿的证据，尝试首先确定缺陷的来源。它在许多方面都优于查看代码的直观想法。类似于你在科学教科书中发现的，科学方法由五个步骤组成(也见图 [4-1b](#Fig1) ):

1.  观察:我们从观察我们想要改变的程序行为开始。
2.  假设:我们表达一个想法，一个假设，为什么观察到的行为会发生。
3.  预测:基于我们的假设，我们做出一个可测试的预测，如果假设是正确的，我们的程序还会做什么。
4.  测试:我们通过将程序暴露在实验条件下并观察结果来检验我们的预测。
5.  总结:最后，我们根据结果接受或拒绝我们的假设。除非我们找到了缺陷的原因，否则我们会回到第二步，进一步完善我们的假设——或者提出一个全新的假设。

科学方法把一个猜测问题变成了一个演绎问题。严格遵循，科学方法很容易跟踪甚至复杂的缺陷。它优于猜测，还因为它导致更干净的解决方案和更容易维护的代码。有四种技术值得了解，它们将帮助我们在实践中有效地将科学方法应用于调试。这些是

*   复制缺陷
*   自动化缺陷
*   隔离缺陷
*   获得帮助

我们将在跟踪事件循环中的 bug 时遇到这四个问题。

Tip

给自己设定一个快速解决问题的时间限制。有许多缺陷，你不需要应用科学的方法。如果您看到一个错误，并在几个简单的测试后知道发生了什么，您可能可以马上修复这个缺陷。根据经验，如果 10-15 分钟后你还没有发现缺陷，那么是时候转向系统化的方法了。

## 重现错误

我们首先观察到我们的事件循环根本不产生任何输出(如果您在控制台上看到一些奇怪的字符，这些字符来自 Unix，而不是来自我们的程序，因为`print`应该在每个键后产生一个换行符)。在制定任何假设之前，我们需要确保这是一个持久的问题，而不是一个临时或随机的条件。为了收集证据，我们至少需要第二次运行程序，并检查我们是否得到相同的观察结果(我们得到了)。

再现性是成功调试的先决条件。如果我们能复制一个缺陷，我们就能找到它。如果我们能找到它，我们就能修好它。如果我们不能重现错误，我们就是在追逐幽灵——一场永无止境的 bug 搜索。因此，重现错误是调试中最基本的最佳实践。在某些情况下，错误可能很难重现。自然，包含随机数的程序会产生不可预测的结果。例如，第 3 章中的迷宫生成器每次都会创建一个不同的迷宫。大约五分之一的迷宫包含不可接近的区域(例如，被墙壁包围的单个点)。如果我们想消除这些问题，那么多次重新运行程序并扫描输出会很麻烦。使用默认的随机数生成器，这很容易解决。为了使我们的生成器生成的迷宫可重现，我们需要用一个种子值初始化随机数生成器。尝试在调用和不调用`random.seed`的情况下运行以下程序几次:

```py
import random
random.seed(0)
print(create_maze(12,   7))

```

为了更好地调试，使用种子值使程序的行为可预测是完全可以的。当一个系统变得更复杂时，误差通常变得更难重现。这是两台或多台计算机相互通信的常见情况。在 web 和服务器编程中，涉及到过多的设备和协议，导致失败的原因有很多。缺陷可能会因为 HTTP 超时而出现，但另一次不会。缺陷可能会出现在生产服务器上，但不会出现在测试服务器上。当 web 流量很大时，当可用内存很少时，当用户快速点击网页时，只有在星期三，等等，缺陷可能会出现。最严重的这类错误在被检测时会改变它们的行为，因此被称为海森伯格，借用了量子力学的名称。在找到导致 Heisenbug 的缺陷之前，期望从日志文件和监控工具中收集大量关于程序生态系统的信息(这可能非常简单)。

尽管事件循环在可再现性方面似乎没有任何问题，但我们不确定是否所有的键都受到了影响。为了使我们最初的观察更精确，我们制定了第一个假设:键盘上没有一个键产生输出。假设允许一个直接的预测:如果我们按下每个键一次，我们仍然看不到输出。这个假设的测试可以用一个手指来完成。事实上，我们仍然没有观察到来自`print`的任何输出，因此接受了这个假设。我们更精确、可重复的观察变成:键盘上没有一个键在回调函数中产生输出。

Tip

许多初学者面临的一个最常见的不可重现的错误是，他们在自己的计算机上维护同一个程序的两个版本，却不小心运行了错误的版本。当用两个不同的 Python 版本运行同一个程序时，也会发生同样的情况(如果您并行使用 Anaconda 或 Canopy 等 IDE 和手动安装的 Python，就有可能发生这种情况)。如果你在一个简单的程序中遇到一个不可重现的错误，首先检查你的 Python 文件(和你的 Python 解释器)的位置。

## 自动化错误

有时很难重现一个 bug，因为我们需要手动输入大量信息。严格来说，“大量信息”意味着“我们需要按下不止一个按钮来查看问题是否仍然存在。”尽早实现自动化可以节省大量后期调试时间。自动化也有助于再现性。例如，如果我们的事件循环只在我们以一定的速度打字时才响应，我们可能每次都会看到不同的结果。自动化消除了我们观察中潜在的不确定性来源。

让我们为事件循环制定第二个假设:我们程序中的事件处理通常是中断的。为了通过自动化测试这个假设，我们创建了一个人工键盘事件。如果假设是真的，我们预测我们仍然什么也看不见。在 Pygame 中，使用`pygame.event.post()`函数生成人工事件非常简单。我们在事件循环的开头插入以下代码:

```py
eve = pygame.event.Event(KEYDOWN, key=42)
pygame.event.post(eve)

```

当我们重新运行程序时，我们观察到它打印

```py
42
42
42
..

```

我们观察到我们的程序能够完美地处理我们的人工按键事件。只有物理键会被忽略。因此，我们拒绝这个假设。事实证明，自动化并不适合发现我们的缺陷，但它为我们提供了新的信息:其他一切似乎都正常工作。因此，我们将暂时坚持手动输入。关于自动化还有很多要说的(例如，我们可以创建一个自动测试功能，但是我们会把它保存到第 8 章)。

## 隔离缺陷

我们分析的代码越多，可能隐藏缺陷的地方就越多。调试中的一个关键任务是使调试的代码量尽可能少，或者隔离缺陷。我们可以将这本书的大部分内容视为隔离缺陷的不同技术，或者使隔离缺陷变得更容易。这里我们将坚持一个例子:事实上，按下的键没有到达我们的程序代码仍然可以用两种替代的方式来解释。我们可以把它们表述为可供选择的假设:

*   Pygame 安装不正确，因此 Pygame 和物理键盘无法通信。
*   我们使用 Pygame 的方式是错误的，所以它不会产生一个关键事件。
*   Pygame 产生了事件，但是我们不能正确显示它。

让我们逐一检查这些假设。当面临多种选择时，最佳实践是首先检查较简单的选项。一方面，更简单的替代方案更容易测试，另一方面，它们通常更有可能。在三个可供选择的假设中，第一个是不太可能的(毕竟，我们的人工事件工作得很好，前两章中的例子也工作得很好)。然而，它很容易测试。要 100%确定 Pygame 安装正确，可以在同一个 Python 安装上执行另一个基于 Pygame 的游戏(我推荐 Bub-n-Bros，见 [`http://bub-n-bros.sourceforge.net/`](http://bub-n-bros.sourceforge.net/) ，虽然可能会分散注意力)。这是可行的，所以我们可以拒绝第一个假设，专注于剩下的两个假设。第二种选择似乎可行，但难以检验。第三种选择更容易测试。查看代码，我们看到`if`条件只检查标记为`KEYDOWN`的事件，并丢弃所有其他事件。可能我们正在寻找的键盘事件有不同的类型。我们可以制定另一个预测:如果我们打印所有事件，不管它们的类型，我们应该看到按下的键。

### 脱衣策略

为了测试我们的预测并查看所有没有条件的生成事件，我们需要简化代码。我们希望找到重现错误所需的最少的行。一种方法是在 Python shell 中执行代码。另一种是将函数复制到一个测试脚本中，并连续删除行(应该命名为`test_event_loop.py`)。更糟糕的方法是复制粘贴整个脚本，或者注释掉代码中的一半行。这两种方法都会很快搞乱我们的整个工作场所。

有了测试脚本，我们可以在多次迭代中删除行，试图找到一个错误消失或者只剩下几行的点。移除了`if`和回调函数后，最小化的事件循环如下所示:

```py
import pygame

pygame.init()
while True:
    pygame.event.pump()
    event = pygame.event.poll()
    print(event)

```

生成的代码更短，更容易阅读。运行这段代码时，我们会看到无限的消息输出，所有消息都与

```py
<Event(0-NoEvent {})>

```

我们做的任何事情(按键、点击、移动鼠标、对着你的摄像头做鬼脸)都不会改变这个信息。我们观察到，显然没有 Pygame 事件到达我们的代码，因此拒绝第三个替代假设。通过将我们的程序缩减到六行，其中三行是琐碎的(`import, while,`和`print`语句)，剩下的潜在故障点非常少。我们已经隔离了缺陷。目前唯一剩下的解释是我们使用 Pygame 的方式不对。

Tip

为以后保留这样短的测试脚本是值得的。通常，它们可以被开发成测试函数，我们将在后面的章节中看到。

### 二分搜索法战略

缩小缺陷位置的另一种策略是使用二分搜索法(见图 [4-2](#Fig2) )。如果我们有很多可能隐藏缺陷的代码，这种技术是非常有用的。为了执行二分搜索法，我们将代码分成大小相似的两部分(例如，主要模块或功能)。然后我们检查缺陷在哪个部分传播。然后我们第二次分割那个部分，以此类推(见图 [4-3](#Fig3) )。这是一个有效的隔离策略，因为在每次迭代中，剩余代码的大小减少了一半。有了 10 个分区，我们可以将缺陷的来源从数千行代码缩小到一个功能或更少。使用二分搜索法策略的唯一先决条件是缺陷必须在过程中相对容易识别。在事件循环的例子中，这并不容易，因为我们在跟踪一些不存在的东西。在某种程度上，二分搜索法和剥离搜索策略是互补的。

![A419627_1_En_4_Fig3_HTML.jpg](A419627_1_En_4_Fig3_HTML.jpg)

图 4-3。

Binary search for isolating bugs: a) initially, the bug can be everywhere; b) code to examine after a first division; c) code remaining after a second division; d) isolated bug location after a third division.

![A419627_1_En_4_Fig2_HTML.jpg](A419627_1_En_4_Fig2_HTML.jpg)

图 4-2。

Looking for defects using binary search if your program were a building

## 获得帮助

在调试过程的这一点上，我们可能会变得疲倦(至少我在这个问题上挣扎了 15 分钟)。似乎在我们的代码中找不到问题的解决方案。我们最近的结论(我们以错误的方式使用 Pygame)并没有告诉我们如何正确使用 Pygame。我们需要帮助。这是一个非常强大但经常被低估的调试策略。承认在问题上投入更多的时间/意志力/咖啡不会有帮助通常是建设性解决问题的关键。至少有五种方法可以获得帮助。这五个都是每个程序员应该记住的最佳实践，尤其是在压力下。

### 休息一下

有时候，我们看不到解决方案是因为我们累了。这很正常。一双新鲜的眼睛可能是你自己的。因此，通过散步、小睡、午餐、锻炼来暂时摆脱这个问题，可能会产生奇迹，让我们更接近解决方案。如果我们正在解决的问题感觉足够强烈，过夜也有帮助。我们的潜意识会继续为我们工作。我经历过很多次，一个下午看起来令人厌倦和难以应付的问题在新的一天到来时，在五分钟内消失了。

### 向别人解释这个问题

向同事或其他程序员解释这个问题会有很大帮助。通常，我们会获得以前没有想到的新鲜想法。解释这个问题不需要看代码。事实上，当我们被迫可以理解地制定我们的思路时，我们可能会在这个过程中自己发现新的方面。令人惊讶的是，如果我们向初级开发人员或非程序员解释这个问题，这种技术同样有效。我经常看到有人在向我解释一个 bug 时中途停下来，而他们自己已经意识到了解决方法。甚至有报道称，程序员会与一只鸭子或一只泰迪熊交谈，以寻找解决方案。就我个人而言，我更喜欢与人交谈，但如果你在隐居中编程，而人是一种奢侈品，那么与熊交谈听起来是一个合理的替代选择。

### 结对编程

结对编程意味着两个人坐在电脑前一起解决一个问题。我发现在两个人的团队中工作对调试特别有价值。如果有第二双眼睛，就很难忽略事物。此外，它通常有助于避免肮脏的修复。关于结对编程是否普遍比单独编程更有效，存在争议。我不会在这个话题上偏袒任何一方，但我确信，成对解决一个问题是调试代码的好方法。

### 代码审查

代码审查是让另一个人阅读我们的代码。通常，评论者会问一些天真的问题，指出我们以前没有想到的事情。即使代码审查不包括编辑或修改代码，我们也可以学到很多:一个熟练的审查者会指出实际的缺陷，但也会指出含糊不清的书面陈述，甚至更大的架构弱点。我们也可能在代码审查后找到更有效的方法来使用库或了解值得了解的新技术，或者只是决定更新文档以使代码更容易理解。评审期间的一个可能的活动是一行一行地检查代码。检查每一行的作用以及下一步执行哪一行。如果你一个人做这个，需要非常高的专注力，很累。如果你在两三个人的团队中做，这就变成了一种优越的调试技术。

正式的代码评审(确定会议时间并在会后编写协议)是构建必须满足最高质量标准的软件的既定技术。有一些研究证据表明，代码审查在发现缺陷方面甚至优于自动化测试(然而，相应的研究已经超过 10 年了，并且不包括 Python，所以它有点超出了我们的范围；有关详细信息，请参见 Ian Sommerville，软件工程第 9 版。，皮尔森，2011)。所有类型的代码评审都是为了揭示程序员在开发过程中制造的盲点。

### 阅读

有时候我们需要退一步，阅读背景资料。这意味着，如果我们正在实现一个算法，我们需要彻底理解它的理论。如果我们使用数据库，我们需要详细了解数据库架构和接口。如果我们正在调试数据记录，很好地理解数据是关于什么的会有所帮助。对于任何库，我们都需要了解它的基础知识。很多调试问题只要做足功课就能解决。阅读不会给我们带来快速的结果，尤其是如果我们现在想修复一个 bug 的话(在 Python 控制台中键入`import this`看看吉多·范·罗苏姆现在推荐什么)。但是从长远来看，阅读肯定是有回报的。

在我们的事件循环中，最可能的假设是我们以错误的方式使用了 Pygame。那么，什么是正确的方法呢？Pygame 文档是研究这个问题的好地方。当我们在 [`www.pygame.org/docs/ref/event.html`](http://www.pygame.org/docs/ref/event.html) 上查看`pygame.event`模块的文档时，我们会发现模块内的函数和类的列表。之后，第一段文字是:

> Pygame handles all event messages through an event queue. The routines in this module help you manage the event queue. The input queue is heavily dependent on Pygame display module. If the monitor is not initialized and the video mode is not set, the event queue will not really work.

抓住你了！我们已经用`pygame.init()`初始化了显示屏，但是我们还没有设置视频模式。多读一点关于 [`www.pygame.org/docs/ref/display.html`](http://www.pygame.org/docs/ref/display.html) 上的`pygame.display`模块很快就引出了`pygame.display.set mode()`功能。我们可以将它纳入我们计划的主要部分:

```py
pygame.init()
pygame.display.set_mode((640, 400))
event_loop(print)

```

令人惊奇的是，程序开始工作了。一个黑色背景的额外窗口出现(Pygame 显示)，我们的键盘输入出现在控制台上(见图 [4-4](#Fig4) )。请注意，Pygame 窗口需要被选中(活动)。我们已经成功地找到了缺陷的根源并消除了它。

![A419627_1_En_4_Fig4_HTML.jpg](A419627_1_En_4_Fig4_HTML.jpg)

图 4-4。

Working event loop. The Pygame window, although empty, is essential to make the program work. Reality Check

这个例子有多现实？有人真的会漏掉一个在模块文档的第一段写得很清楚的重要命令吗？第一，这是一个发生在我身上的真实 bug。有那么一会儿，我骄傲地认为在用 Pygame 写了半打小游戏后，我不再需要文档了。第二，我相信同样的事情也会发生在其他人身上。第三，每个程序员关于库和工具的知识都是有限的。有时我们很快意识到我们正在接近知识的边界，但有时我们还是选择走得更远一点。当面临是读材料还是写代码的决定时，我们中的许多人更喜欢写代码。我想这就是我们最初成为程序员的原因。

请注意这个错误主要是基于一个错误的假设。当编写有缺陷的版本时，假设是:我们不需要创建一个从键盘读取的窗口。这个假设被证明是错误的。我们最终意识到 Pygame 库需要自己的窗口来读取键盘事件。吸取教训！调试时，在身边放一个记事本是个好主意。对我们正在考虑的假设做笔记有助于我们在遵循它们的过程中保持专注。此外，在艰难的调试过程中，划掉我们已经拒绝的假设可能是我们在一段时间内得到的唯一满足(见图 [4-5](#Fig5) )。在我看来，用来做笔记的纸远远胜过电子记事本。我甚至在桌子上放了一本剪贴簿，记录我在写这本书时故意引入的错误。

![A419627_1_En_4_Fig5_HTML.jpg](A419627_1_En_4_Fig5_HTML.jpg)

图 4-5。

Notepad with hypotheses tested on the event loop

## 清理

即使程序现在处于工作状态，我们还没有完成。我们仍然需要清理我们的建筑工地。这意味着删除我们在过程中引入的任何注释或额外的行，以及我们创建的附加文件。我们可能会决定保留我们的测试脚本，并将它放在我们之前编写的其他测试代码旁边。之后，我们需要再次检查事件循环是否还在工作。在一个更复杂的项目中，清理工作涉及许多其他事情。我们需要重新组织我们的代码来使缺陷的修复干净地适合现有的代码吗？我们需要重写代码来保持一致的风格吗？我们需要编写额外的自动测试吗？该修复是否会影响软件的其他组件？我们需要多长时间在最终产品中加入修正？我们需要更新任何文档吗？我们需要通知团队成员甚至客户吗？等等。

打扫卫生听起来像是一项无聊的任务，但绝对不能推迟。认真处理这些和类似的问题是保持我们项目健康发展的关键。持续忽视清理会直接导致一种令人讨厌的现象，称为技术债务，这是对正在慢慢恶化的软件的官方术语。在我们完成清理之后，我们终于可以运行程序并识别出我们将用于游戏控制的箭头键的代码(见图 [4-6](#Fig6) )。

![A419627_1_En_4_Fig6_HTML.jpg](A419627_1_En_4_Fig6_HTML.jpg)

图 4-6。

Arrow keys and their key codes produced by Pygame

## 科学方法和其他最佳实践

在调试过程中应用科学方法是调试程序的一般最佳实践。在应用该方法时，我们可能会使用多种调试工具，就像接下来三章中的工具:使用第 [5](05.html) 中的`print`，第 [6](06.html) 中的自省函数，以及第 [7](07.html) 章中的交互式调试器。一旦我们发现了一个缺陷，在修复它的时候，一些最佳实践补充了科学方法:在关于自动化测试的第二部分中，我们将使用技术来证明，一旦修复了，缺陷就不会再出现。在关于维护的第三部分中，我们将学习支持结构，它帮助我们将缺陷的修复与程序的其余部分干净地集成在一起。我们要吸取的教训是，调试不仅仅是查看代码。为了构建可靠的软件，我们需要应用系统化的方法。

## 最佳实践

*   通过非系统猜测进行调试只对小缺陷有效。
*   在科学的方法中，你制定关于缺陷的假设，做出预测，然后测试它们。
*   根据观察到的测试结果，你接受或拒绝假设。
*   反复完善假设，直到找到错误的根本原因。
*   重现错误是成功调试的必要前提。
*   自动重现缺陷有助于您更快地迭代。
*   缺陷可以通过剥离代码或代码中的二分搜索法来隔离。
*   当其他方法都不起作用时，寻求帮助是调试过程中很自然的一部分。
*   向别人解释这个问题也有帮助。
*   调试后的清理保持了较低的技术债务。