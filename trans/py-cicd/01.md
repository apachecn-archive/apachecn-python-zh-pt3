# 1.自动化测试

在深入研究如何测试 Python 代码的例子之前，必须更详细地讨论测试的本质。为什么我们要进行测试？我们从他们那里得到了什么？缺点是什么？什么是好的测试；什么是糟糕的测试？我们如何对测试进行分类？我们应该写多少种类型的测试？

## 1.1 我们想从测试中得到什么？

为什么要费心编写测试呢？我们想写或者至少有测试的原因有很多。

一个测试套件中有几个测试是为了响应不同的需求而编写的，这种情况并不少见。

### 快速反馈

对代码的每一次修改都伴随着引入错误的风险。研究表明，7%到 20%的 bug 修复会引入新的 bug。 <sup>[1](#Fn1)</sup>

如果我们能在这些错误找到客户之前找到它们，那不是很好吗？或者甚至在你的同事看到他们之前？这不仅仅是虚荣心的问题。如果您收到快速反馈，说您引入了一个错误，您更有可能记住您刚刚工作的代码库部分的所有细节，因此当您收到快速反馈时，修复错误往往会快得多。

许多测试用例被编写来给出这种快速反馈循环。您通常可以在将您的更改提交到源代码控制系统之前运行它们，它们使您的工作更加高效，并保持您的源代码控制历史清晰。

### 信心

与前一点相关，但值得单独提及的是，知道测试套件将为您捕捉简单的错误，您可以获得信心的提升。在大多数基于软件的企业中，有一些关键领域存在严重的错误，可能会危及整个企业。想象一下，作为一名开发人员，你不小心弄乱了一个医疗保健数据管理产品的登录系统，现在人们看到了别人的诊断。或者想象一下，自动计费向客户的信用卡收取了错误的金额。

甚至非软件企业也曾因软件错误而遭遇灾难性的失败。由于软件问题，火星气候轨道器 <sup>[2](#Fn2)</sup> 和阿丽亚娜 5 号火箭 <sup>[3](#Fn3)</sup> 的[首次发射都遭受了各自运载工具的损失。](http://sunnyday.mit.edu/accidents/Ariane5accidentreport.html)

他们工作的重要性给软件开发人员带来了情绪压力。自动化测试和良好的开发方法可以帮助减轻这种压力。

即使人们正在开发的软件不是任务关键型的，风险逆境也可能导致开发人员或维护人员尽可能地进行最小的更改，并推迟必要的重构以保持代码的可维护性。一个好的测试套件所提供的信心可以让开发人员做必要的事情来防止代码库变成众所周知的[大泥巴球](https://en.wikipedia.org/wiki/Big_ball_of_mud)。 <sup>[4](#Fn4)</sup>

### 调试工具

当开发人员更改代码，从而导致测试失败时，他们希望测试有助于找到 bug。如果测试只是简单地说“有问题”，这比不知道错误要好。如果测试能够提供开始调试的提示，那就更有帮助了。

例如，如果一个测试失败表明函数`find_shortest_path`引发了一个异常，而不是像预期的那样返回一个路径，那么我们知道要么这个函数(或者它调用的一个函数)中断了，要么它接收到了错误的输入。这是一个更好的调试工具。

### 设计帮助

[极限编程(XP)](https://en.wikipedia.org/wiki/Extreme_programming) <sup>[5](#Fn5)</sup> 运动主张你要实践*测试驱动开发* (TDD)。也就是说，在您编写任何解决问题的代码之前，您首先要编写一个失败的测试。然后你写足够的代码通过测试。要么你做完，要么你写下一个测试。冲洗并重复。

这有明显的好处:你确保你写的所有代码都有测试覆盖，并且你不会写不必要的或不可及的代码。然而，TDD 实践者也报告说测试优先的方法帮助他们写出了更好的代码。一个方面是，编写测试迫使您考虑实现将具有的应用程序编程接口(API ),因此您开始在头脑中实现一个更好的计划。另一个原因是纯函数(其返回值仅取决于输入，并且不会产生副作用或从数据库读取数据的函数，等等。)很容易测试。因此，测试优先的方法引导开发人员将算法或业务逻辑从支持逻辑中更好地分离出来。这种关注点的分离是好的软件设计的一个方面。

应该注意的是，并不是每个人都同意这些观点，从经验或论据来看，有些代码比编写代码更难测试，这导致了工作的浪费，因为要求对所有事情都进行测试。尽管如此，测试可以提供的设计帮助是开发人员编写代码的原因之一，因此不应该在这里遗漏。

### 产品规格

软件项目的大的、统一的规范文档的日子已经过去了。大多数项目都遵循某种迭代开发模型，即使有详细的规范文档，也往往是过时的。

当没有详细的和最新的散文规范时，测试套件可以扮演规范的角色。当人们不确定一个程序在某种情况下应该如何表现时，一个测试可能会提供答案。对于编程语言、数据格式、协议和其他东西，提供一个可以用来验证多个实现的测试套件可能更有意义。

## 1.2 测试的缺点

对考试可能带来的负面影响保持沉默是不诚实的。这些缺点不应该分散你写测试的注意力，但是意识到它们将帮助你决定测试什么，如何写测试，以及，也许，写多少测试。

### 努力

编写测试需要时间和精力。因此，当你被赋予实现一个特性的任务时，你不仅要实现这个特性，还要为它编写测试，结果是更多的工作和更少的时间去做其他可能给业务带来直接好处的事情。当然，除非测试提供了足够的时间节约(例如，通过不必修复生产环境中的错误和清理被错误破坏的数据)来分摊编写测试所花费的时间。

### 要维护的额外代码

测试本身就是代码，必须维护，就像被测试的代码一样。一般来说，您希望使用尽可能少的代码来解决您的问题，因为您拥有的代码越少，需要维护的代码就越少。将代码(包括测试代码)视为负债而非资产。

如果您编写测试以及您的特性和错误修复，当需求改变时，您必须改变这些测试。当重构时，一些测试也需要改变，使得代码库更难改变。

### 脆性

有些测试可能很脆弱，也就是说，它们偶尔会给出错误的结果。即使有问题的代码是正确的，测试仍然失败，这被称为*假阳性*。这样的测试失败需要花费时间来调试，而不会提供任何价值。一个*假阴性*是当测试中的代码被破坏时不会失败的测试。假阴性测试也不提供任何价值，但往往比假阳性更难发现，因为大多数工具会引起对失败测试的注意。

脆弱的测试破坏了对测试套件的信任。如果失败测试的产品部署成为常态，因为每个人都认为那些失败的测试是假阳性，那么测试套件的信号价值已经下降到零。您仍然可以使用它来跟踪与上一次运行相比哪些测试失败了，但是这往往会退化成许多没有人愿意做的手工工作。

不幸的是，有些测试很难稳健地进行。图形用户界面(GUI)测试往往对布局或技术变化非常敏感。依赖于您控制之外的组件的测试也可能是脆性的来源。

### 虚假的安全感

测试套件的完美运行会给你一种错误的安全感。这可能是由于假阴性(应该失败但没有失败的测试)或者遗漏了测试场景。即使一个测试套件实现了测试代码的 100%语句覆盖率，它也可能会错过一些代码路径或场景。因此，您看到一个通过的测试运行，并把它作为您的软件工作正常的指示，一旦真正的客户接触到产品，就会被错误报告淹没。

测试套件无法直接解决过度自信的问题。只有通过对代码库及其测试的体验，您才能感受到绿色(即通过)测试运行所提供的真实置信度。

## 1.3 优秀测试的特征

一个好的测试是结合了编写测试的几个原因，同时尽可能避免缺点。这意味着测试应该快速运行，易于理解和维护，在失败时给出良好和具体的反馈，并且是健壮的。

可能有点令人惊讶的是，它偶尔也会失败，尽管人们预计测试会失败。从不失败的测试也不会给你反馈，不能帮助你调试。这并不意味着您应该删除一个您从未记录失败的测试。也许它在开发人员的机器上失败了，他或她在检查更改之前修复了 bug。

不是所有的测试都符合好测试的所有标准，所以让我们来看看一些不同种类的测试和它们固有的权衡。

## 1.4 各种测试

基于测试的范围(覆盖多少代码)和目的，有一个如何对测试进行分类的传统模型。该模型将测试正确性的代码分为单元测试、集成测试和系统测试。它还增加了冒烟测试、性能测试和其他不同目的的测试。

### 单元测试

单元测试独立地测试一个程序中最小的单元。在过程式或函数式编程语言中，它往往是一个子程序或函数。在 Python 这样的面向对象语言中，它可以是一个方法。根据您对定义的理解，它也可以是一个类或一个模块。

单元测试应该避免在被测试单元之外运行代码。因此，如果您正在测试一个数据库密集型业务应用程序，那么您的单元测试仍然不应该执行对数据库(访问网络进行 API 调用)或文件系统的调用。有一些方法可以替代这种外部依赖来进行测试，我将在后面讨论，但是如果您可以构建代码来避免这种调用，至少在大多数单元中，那就更好了。

因为对外部依赖的访问是导致大多数代码变慢的原因，所以单元测试通常非常快。这使得它们非常适合测试算法或核心业务逻辑。

例如，如果您的应用程序是一个导航助手，其中至少有一段算法上具有挑战性的代码:路由器，在给定地图、起点和目标的情况下，它会生成一条路线，或者可能是一列可能的路线，并附带长度和预期到达时间等指标。这个路由器，或者甚至是它的一部分，是你想要尽可能彻底地用单元测试来覆盖的东西，包括可能导致无限循环的奇怪的边缘情况，或者检查从柏林到慕尼黑的旅程没有经过罗马。

对于这样一个单元，您想要的测试用例的绝对数量使得其他类型的测试不切实际。此外，您不希望由于不相关的组件而导致这样的测试失败，因此将它们集中在一个单元上可以提高它们的特异性。

### 集成测试

如果你用单个部件组装了一个复杂的系统，比如一辆汽车或一艘宇宙飞船，并且每个部件都可以独立工作，那么整体工作的可能性有多大？出问题的方式有很多:一些线路可能有故障，组件想要通过不兼容的协议交谈，或者可能关节无法承受操作期间的振动。

在软件中没有什么不同，所以人们编写集成测试。综合测试一次练习几个单元。这使得单元之间的边界处的不匹配变得明显(通过测试失败)，使得这样的错误能够被及早纠正。

### 系统测试

系统测试将一个软件放到一个环境中，并在那里进行测试。对于经典的三层体系结构，系统测试从用户界面的输入开始，测试所有层直到数据库。

单元测试和集成测试是白盒测试(需要并利用软件如何实现的知识的测试)，而系统测试往往是黑盒测试。他们站在用户的角度，不关心系统的内部。

就如何测试软件而言，这使得系统测试最现实，但是它们也有一些缺点。

首先，管理系统测试的依赖关系可能非常困难。例如，如果您正在测试一个 web 应用程序，您通常首先需要一个可以用来登录的帐户，然后每个测试用例需要一组它可以使用的固定数据。

第二，系统测试经常一次测试如此多的组件，以至于测试失败不能给出关于实际错误的好线索，并且需要开发人员查看每个测试失败，经常发现变化与测试失败无关。

第三，系统测试暴露了您不打算测试的组件中的故障。由于软件使用的 API 中的传输层安全性(TLS)证书配置错误，系统测试可能会失败，这可能完全在您的控制之外。

最后，系统测试通常比单元和集成测试慢得多。白盒测试允许您只测试您想要的组件，因此您可以避免运行不感兴趣的代码。在 web 应用程序的系统测试中，您可能必须执行登录，导航到您想要测试的页面，输入一些数据，然后最终执行您实际想要执行的测试。系统测试通常比单元测试或集成测试需要更多的设置，增加了它们的运行时间，延长了人们收到代码反馈的时间。

### 烟雾测试

冒烟测试类似于系统测试，因为它测试技术堆栈中的每一层，尽管它不是对每一层的彻底测试。它通常不是用来测试应用程序某个部分的正确性，而是用来测试应用程序在当前上下文中是否能正常工作。

web 应用程序的冒烟测试可以像登录一样简单，然后调用用户的个人资料页面，验证用户名是否出现在该页面的某个位置。这不会验证任何逻辑，但会检测到诸如配置错误的 web 服务器或数据库服务器，或者无效的配置文件或凭证。

为了从冒烟测试中获得更多好处，您可以向应用程序添加一个状态页或 API 端点来执行额外的检查，例如检查数据库中是否存在所有必需的表、相关服务的可用性等等。只有满足了所有这些运行时依赖关系，状态才会是“OK”，冒烟测试可以很容易地确定这一点。通常，您只需为每个可部署的组件编写一到两个冒烟测试，但要为您部署的每个实例运行它们。

### 性能测试

到目前为止，讨论的测试集中在正确性上，但是非功能性的质量，比如性能和安全性，可能同样重要。原则上，运行性能测试相当容易:记录当前时间，运行某个动作，再次记录当前时间。两个时间记录之间的差异是该动作的运行时间。如有必要，根据这些值重复并计算一些统计数据(如中值、平均值、标准差)。

一如既往，细节决定成败。主要的挑战是创建真实可靠的测试环境、真实的测试数据和真实的测试场景。

许多商业应用程序严重依赖数据库。因此，您的性能测试环境也需要一个数据库。从硬件和许可成本的角度来看，为测试环境复制一个大型生产数据库实例可能非常昂贵。因此，使用缩小的测试数据库是一种诱惑，这带来了结果无效的风险。如果在性能测试中有些东西很慢，开发人员倾向于说“那只是较弱的数据库；prod 可以轻松解决这个问题”——他们可能是对的。或者不是。没有办法知道。

环境设置的另一个潜在的方面是当涉及到性能时有许多活动部件。在虚拟机(VM)上，您通常不知道 VM 从虚拟机管理程序获得了多少 CPU 周期，或者虚拟化环境是否对 VM 内存玩了有趣的把戏(例如将 VM 的部分内存换出到磁盘)，从而导致不可预测的性能。

在物理机器(也是每个虚拟机的基础)上，你会遇到现代的电源管理系统，这些系统根据散热因素来控制时钟速度，在某些情况下，[甚至根据 CPU](https://blog.cloudflare.com/on-the-dangers-of-intels-frequency-scaling/)[中使用的特定指令来控制时钟速度。<sup>6</sup>](https://blog.cloudflare.com/on-the-dangers-of-intels-frequency-scaling/)[6](#Fn6)T7】

所有这些因素导致性能测量比你可能从像计算机这样的确定性系统中天真地期望的更不确定。

## 1.5 摘要

作为软件开发人员，我们希望自动化测试为我们提供快速的变更反馈，在回归到达客户之前捕捉它们，并为我们提供足够的信心来重构代码。好的测试是快速、可靠的，并且当它失败时具有高诊断价值。

单元测试往往很快，具有很高的诊断价值，但只覆盖了一小部分代码。一个测试覆盖的代码越多，它就越慢，越脆弱，它的诊断价值就越低。

在下一章，我们将看看如何用 Python 编写和运行单元测试。然后我们将研究如何为每次提交自动运行它们。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

吉姆·伯德，“bug 和数字:你的代码中有多少 bug？”构建真实软件:在真实世界中开发和维护安全可靠的软件， [`http://swreflections.blogspot.de/2011/08/bugs-and-numbers-how-many-bugs-do-you.html`](http://swreflections.blogspot.de/2011/08/bugs-and-numbers-how-many-bugs-do-you.html) ，2011 年 8 月 23 日。

  [2](#Fn2_source)

维基百科，《火星气候轨道器》， [`https://en.wikipedia.org/wiki/Mars_Climate_Orbiter`](https://en.wikipedia.org/wiki/Mars_Climate_Orbiter) ，2018 年。

  [3](#Fn3_source)

J.L. Lions，“阿丽亚娜 5 号:501 航班故障。调查委员会的报告，“ [`http://sunnyday.mit.edu/accidents/Ariane5accidentreport.html`](http://sunnyday.mit.edu/accidents/Ariane5accidentreport.html) ，1996 年 7 月。

  [4](#Fn4_source)

维基百科，《大泥球》， [`https://en.wikipedia.org/wiki/Big_ball_of_mud`](https://en.wikipedia.org/wiki/Big_ball_of_mud) ，2018 年。

  [5](#Fn5_source)

维基百科，《极限编程》， [`https://en.wikipedia.org/wiki/Extreme_programming`](https://en.wikipedia.org/wiki/Extreme_programming) ，2018。

  [6](#Fn6_source)

弗拉德·克拉斯诺夫(Vlad Krasnov)，《论英特尔频率缩放的危险》，Cloudflare， [`https://blog.cloudflare.com/on-the-dangers-of-intels-frequency-scaling/`](https://blog.cloudflare.com/on-the-dangers-of-intels-frequency-scaling/) ，2017 年 11 月 10 日。

 </aside>