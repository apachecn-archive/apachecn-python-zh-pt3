# 一、密码学：不仅仅是保密

欢迎来到实用密码学的世界！这本书的目的是教你足够多的关于密码学的知识，使你能够推理它做什么，什么时候某些类型可以被有效地应用，以及如何选择好的策略和算法。每一章都有例子和练习，通常在开始会有后续练习来帮助你找到方向。这些例子往往伴随着一些虚构的舞台设置，以增加一些背景。在你有了一些接触和经验之后，那些例子后面的术语应该更有意义，也更容易记住。我们希望你喜欢它。

## 设置 Python 环境

为了深入研究，我们需要一个游泳的地方，那就是 Python 3 环境。如果您已经是 Python 3 专业版的用户，并且在安装您发现需要的模块时没有问题，请跳过这一节，做一些实际的尝试。否则，请继续阅读，我们将快速完成设置步骤。

本书中的所有例子都是使用 Python 3 和第三方“加密”模块编写的。

如果您不想弄乱您的系统 Python 环境，我们建议使用 venv 模块创建一个 Python 虚拟环境。这将使用 Python 解释器和相关模块配置一个选定的目录。通过使用“激活”脚本，shell 被指示使用 Python 的这个定制环境，而不是系统范围的安装。您安装的任何模块都只能在本地安装。

在这一节中，我们将介绍如何在 Ubuntu Linux 中安装系统。对于其他版本的 Linux 或 Unix，安装会稍有不同，对于 Windows，可能会有很大不同。

首先，我们需要安装 Python 3、Pip 和`venv`模块:

```py
apt install python3 python3-venv python3-pip

```

接下来，我们使用 venv 在一个`env`目录中设置环境:

```py
python3 -m venv env

```

这将在路径中设置解释器和模块。安装完成后，可以通过以下命令随时使用该环境:

```py
source env/bin/activate

```

现在，您应该可以在您的 shell 提示符前面看到一个前缀，其中包含您的环境名称。一旦您的环境被激活，安装`cryptography`模块。如果您不想在系统范围内安装加密技术，请记住首先激活您的 Python 虚拟环境。

```py
pip install cryptography

```

我们将在整本书中使用`cryptography`模块。很多时候我们会直接参考模块的文档，可以在 [`https://cryptography.io/en/latest/`](https://cryptography.io/en/latest/) 在线找到。

对于一些实践，我们还需要`gmpy2`模块。这个*确实*需要一些系统范围的软件包。

```py
apt install libmpfr-dev libmpc-dev libgmp-dev python3-gmpy2

```

一旦安装了这些包，就可以在虚拟环境中安装 Python `gmpy2`模块

```py
pip install gmpy2

```

请注意，在虚拟环境中，您可以使用“python”代替“python3”，使用“pip”代替“pip3”。这是因为当您使用 venv 创建环境时，您是使用 Python3 来完成的。在虚拟环境中，Python3 是唯一的解释器，不需要区分版本 2 和版本 3。如果您在系统范围内安装这些软件包中的任何一个，您可能需要使用 pip3，而不仅仅是 pip。否则，可能会为 Python 2 安装这些包。

如果您在使用`gmpy2`时遇到问题或者不希望安装所有系统范围的软件包，您可以跳过这一步。只有几个练习你不能完成。

现在让我们开始潜水吧！

## 凯撒的诡秘密码

东南极洲(EA)和西南极洲(WA)这两个(虚构的)国家彼此都不太喜欢对方，并且不停地互相刺探。在这个场景中，两个来自 EA 的间谍，代号“爱丽丝”和“鲍勃”，已经渗透到他们的西方邻居中，并通过秘密渠道来回发送消息。

他们不喜欢他们在西南极洲的对手阅读他们的信息，所以他们用密码交流。

不幸的是，东南极洲在加密领域并不特别先进。对于一个代码，东南极洲真相间谍机构(EATSA)创造了一个简单的替换，用字母表中后来的另一个字母替换每个字母。两个国家都使用标准的 ASCII 字母表，字母“A”到“z”

假设他们选择使用这种替换技术对他们的消息进行编码，将*移位距离*设置为 1。在这种情况下，字母“A”将被替换为“B”，字母“B”将被替换为“C”，依此类推。字母表的最后一个字母“Z”将绕到开头，并被替换为“a”。该表显示了从**明文**(原始的，未接触的)字母到**密文**(编码的)字母的完整(大写)映射。像空格和标点符号这样的非字母保持不变。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"> <col class="tcol6 align-left"> <col class="tcol7 align-left"> <col class="tcol8 align-left"> <col class="tcol9 align-left"> <col class="tcol10 align-left"> <col class="tcol11 align-left"> <col class="tcol12 align-left"> <col class="tcol13 align-left"></colgroup> 
| A | B | C | D | E | F | G | H | 我 | J | K | L | M |
| B | C | D | E | F | G | H | 我 | J | K | L | M | 普通 |
| 普通 | O | P | Q | 稀有 | S | T | U | V | W | X | Y | Z |
| O | P | Q | 稀有 | S | T | U | V | W | X | Y | Z | A |

使用该表，`HELLO WORLD`编码为`IFMMP XPSME`。

现在试试距离 2，其中“A”到“C”，“B”到“D”，依此类推，直到“Y”映射到“A”，而“Z”映射到“B”

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"> <col class="tcol6 align-left"> <col class="tcol7 align-left"> <col class="tcol8 align-left"> <col class="tcol9 align-left"> <col class="tcol10 align-left"> <col class="tcol11 align-left"> <col class="tcol12 align-left"> <col class="tcol13 align-left"></colgroup> 
| A | B | C | D | E | F | G | H | 我 | J | K | L | M |
| C | D | E | F | G | H | 我 | J | K | L | M | 普通 | O |
| 普通 | O | P | Q | 稀有 | S | T | U | V | W | X | Y | Z |
| P | Q | 稀有 | S | T | U | V | W | X | Y | Z | A | B |

现在，消息`HELLO WORLD`被编码为`JGNNQ YQTNF`。

东南极洲真相调查机构(EATSA)对他们简单的移位密码感到满意，决定创建一个 Python 程序来处理信息的编码和解码。

### 提示:编写代码

这本书介绍了许多示例 Python 程序。在每一个的开始，我们将列出需求，也许还有一个密码 API 的提示或概述。你应该先试着自己写程序。如果你卡住了或者犯了错误，那也没关系。即使您不能自己解决所有问题，您尝试编写程序的经验将帮助您更好地理解所提供的示例。

### 练习 1.1。移位密码编码器

创建一个 Python 程序，使用本节中描述的移位密码对消息进行编码和解码。移位量必须是可配置的。

让我们一起来完成这个练习。我们在所有练习中都使用 Python 3。

首先，让我们创建一个简单的函数来创建我们的替换表。为了简单起见，我们将创建两个 Python 字典:一个包含编码表，另一个创建解码表。我们也将只编码和解码大写的 ASCII 字母，如清单 [1-1](#PC7) 所示。

```py
 1   # Partial Listing: Some Assembly Required
 2
 3   import string
 4
 5   def create_shift_substitutions(n):
 6       encoding = {}
 7       decoding = {}
 8       alphabet_size = len(string.ascii_uppercase)
 9       for i in range(alphabet_size):
10           letter       = string.ascii_uppercase[i]
11           subst_letter = string.ascii_uppercase[(i+n)%alphabet_size]
12
13           encoding[letter]       = subst_letter
14           decoding[subst_letter] = letter
15       return encoding, decoding

Listing 1-1Creating Substitution Tables

```

注意该功能在`n`(移位参数)上被参数化。我们在这个函数中没有任何错误检查；我们将在别处检查参数。但是请注意，n 的任何整数值都是有效的，因为 Python 以合理的方式处理负模数。甚至值 0 也可以:它只是产生一个从每个字符到其自身的映射！大于 26 的值也工作得很好，因为我们在索引到字母表之前应用了最终模数`alphabet_size`。

现在，为了编码和解码，我们简单地用消息中的每个字母替换相应字典中的一个字母，如清单 [1-2](#PC8) 所示。

```py
 1   # Partial Listing: Some Assembly Required
 2
 3   def encode(message, subst):
 4       cipher = ""
 5       for letter in message:
 6           if letter in subst:
 7               cipher += subst[letter]
 8            else:
 9                cipher += letter
10       return cipher
11
12   def decode(message, subst):
13       return encode(message, subst)

Listing 1-2Shift Encoder

```

### 注意:紧凑与清晰

当它们之间有冲突时，我们倾向于支持普遍清晰而不是紧凑。如果有助于说明正在发生的事情，我们甚至会用不被广泛认为是惯用的方式来写东西。

清单 [1-2](#PC8) 中的代码是一个比普通习惯用法更倾向于清晰的好例子。惯用的函数体可能是一行代码:

`def encode(message, subst):`

`return "".join(subst.get(x, x) for x in message)`

如果你已经习惯了，这是一个可爱的 Python，但是我们在这里尽量不做太多的假设。

在我们的实现中，`encode`函数接受一条传入消息和一个替换字典。对于消息中的每一个字母，如果可以替换的话，我们就替换它。否则，我们只包括字符本身，不进行任何转换(保留空格和标点符号)。

显然，这个清单中的`decode`操作是完全不必要的，但是我们包含它是为了强调在替代密码中编码和解码是完全一样的。只有字典需要改变。

这些函数足以构建一个应用，但是为了好玩，我们将在清单 [1-3](#PC9) 中添加另一个函数，以获取一个替换字典并创建一个显示映射的字符串。这将允许我们打印出从不同的移位值创建的不同表格。

```py
 1   # Partial Listing: Some Assembly Required
 2
 3   def printable_substitution(subst):
 4       # Sort by source character so things are alphabetized.
 5       mapping = sorted(subst.items())
 6
 7       # Then create two lines: source above, target beneath.
 8       alphabet_line = " ".join(letter for letter, _ in mapping)
 9       cipher_line = " ".join(subst_letter for _, subst_letter in mapping)
10       return "{}\n{}".format(alphabet_line, cipher_line)

Listing 1-3Printable Substitutions

```

使用这些函数，我们可以构建一个编码和解码消息的简单应用，如清单 [1-4](#PC10) 所示。

```py
 1   # Partial Listing: Some Assembly Required
 2
 3   if __name__ == "__main__":
 4       n = 1
 5       encoding, decoding = create_shift_substitutions(n)
 6       while True:
 7           print("\nShift Encoder Decoder")
 8           print("--------------------")
 9           print("\tCurrent Shift: {}\n".format(n))
10           print("\t1\. Print Encoding/Decoding Tables.")
11           print("\t2\. Encode Message.")
12           print("\t3\. Decode Message.")
13           print("\t4\. Change Shift")
14           print("\t5\. Quit.\n")
15           choice = input(">> ")
16           print()
17
18           if choice == '1':
19               print("Encoding Table:")
20               print(printable_substitution(encoding))
21               print("Decoding Table:")
22               print(printable_substitution(decoding))
23
24           elif choice == '2':
25               message = input("\nMessage to encode: ")
26               print("Encoded Message: {}".format(
27                  encode(message.upper(), encoding)))
28
29           elif choice == '3':
30               message = input("\nMessage to decode: ")
31               print("Decoded Message: {}".format(
32                   decode(message.upper(), decoding)))
33
34           elif choice == '4':
35               new_shift = input("\nNew shift (currently {}): ".format(n))
36               try:
37                   new_shift = int(new_shift)
38                   if new_shift < 1:
39                       raise Exception("Shift must be greater than 0")
40               except ValueError:
41                   print("Shift {} is not a valid number.".format(new_shift))
42               else:
43                   n = new_shift
44                   encoding, decoding = create_shift_substitutions(n)
45
46           elif choice == '5':
47               print("Terminating. This program will self destruct in 5 seconds .\n")
48               break
49
50           else:
51               print("Unknown option {}.".format(choice))

Listing 1-4Shift Cipher Application

```

编码和解码程序完成后，东南极洲真相间谍机构(EATSA)将爱丽丝和鲍勃送到他们的秘密目的地，希望他们的通信如果被截获，不会被西南极洲中央骑士办公室(WACKO)读取。

问题是这个代码很容易被破解。你能看出为什么吗？通过巧妙的猜测，有各种各样的方法可以想出来。比如，试着打破这个:

```py
FA NQ AD ZAF FA NQ FTMF UE FTQ CGQEFUAZ

```

使用几个简单的两个字母的单词，如“if”、“or”、“in”、“to”等等，很快就可以看出这个短语是

```py
TO BE OR NOT TO BE THAT IS THE QUESTION

```

保留的空间很容易辨认。因此，在现代加密技术出现之前，真正的间谍通常会删除消息中的所有空格，就像这样:

```py
FANQADZAFFANQFTMFUEFTQCGQEFUAZ

```

有了这样的改变，至少在哪里尝试简单的单词替换并不明显。但即使爱丽丝和鲍勃去掉所有空格和标点符号，破解他们的代码仍然是微不足道的。虽然这段代码非常琐碎，可以用笔和纸来破解，但我们将编写一个 Python 程序来破解它。你已经明白了吗？如果是这样，那就自己动手吧。如果没有，继续读下去！

EATSA 使用的替代密码的问题是只有 25 个唯一有效的移位。您可以轻松构建一个 Python 程序来尝试所有可能的 25 种组合。

我们如何知道我们何时与 Alice 和 Bob 使用相同的班次？当我们看到它的时候就会知道，因为它是可读的。

让我们在这场南极冷战中交换立场，为西南极洲中央骑士办公室(WACKO)工作。他们知道间谍已经渗透到他们的国家，他们正在监控这些间谍和 EATSA 之间的通信。他们的一名代号为“Eve”的反情报人员刚刚收到了以下信息:

```py
FANQADZAFFANQFTMFUEFTQCGQEFUAZ

```

通过这条消息，Eve *也*得到情报，EA 特工正在使用替代密码。她决定构建一个程序来编码和解码这样的信息。一个惊人的巧合是，她像 EATSA 一样构造了一个 Python 程序！

运行程序时，她尝试用移位 1 解码消息，结果如下:

```py
EZMPZCYZEEZMPESLETDESPBFPDETZY

```

这看起来不对劲。因此 Eve 再次尝试第二、第三班，以此类推。

```py
1:  EZMPZCYZEEZMPESLETDESPBFPDETZY
2:  DYLOYBXYDDYLODRKDSCDROAEOCDSYX
3:  CXKNXAWXCCXKNCQJCRBCQNZDNBCRXW
4:  BWJMWZVWBBWJMBPIBQABPMYCMABQWV
5:  AVILVYUVAAVILAOHAPZAOLXBLZAPVU
6:  ZUHKUXTUZZUHKZNGZOYZNKWAKYZOUT
7:  YTGJTWSTYYTGJYMFYNXYMJVZJXYNTS
8:  XSFISVRSXXSFIXLEXMWXLIUYIWXMSR
9:  WREHRUQRWWREHWKDWLVWKHTXHVWLRQ
10: VQDGQTPQVVQDGVJCVKUVJGSWGUVKQP
11: UPCFPSOPUUPCFUIBUJTUIFRVFTUJPO
12: TOBEORNOTTOBETHATISTHEQUESTION

```

使用移位 12，Eve 看到一串明显的英语文本。这显然是信息。

这种替代密码通常被称为凯撒密码，因为朱利叶斯·凯撒用它来传递秘密信息。这个密码已经有 2000 多年的历史了。显然，自那时以来，我们已经走过了漫长的道路。这项技术已经过时了。

尽管如此，使用凯撒密码可以讨论许多现代密码学的原理，包括

1.  密钥大小

2.  块大小

3.  保留的结构(编码后仍然存在的结构)

4.  暴力攻击

在本书中，我们将在现代密码学的背景下学习所有这些概念。数学的进步使得新的密码成为可能，如果正确使用的话，几乎不可能破解。不过，在我们继续之前，这里有几个额外的练习供求知欲者参考。

### 练习 1.2。自动解码

在我们的例子中，Eve 尝试解码各种信息，直到她看到看起来像英语的东西。尝试自动化这一点。

*   得到一个包含几千个英文单词的数据结构。 <sup>[1](#Fn1)</sup>

*   创建一个程序，接受一个编码字符串，然后尝试用所有 25 个移位值解码它。

*   使用字典来尝试自动确定最有可能是哪一个班次。

因为您必须处理没有空格的消息，所以您可以简单地记录解码输出中出现了多少字典单词。偶尔，一两个单词可能会偶然出现，但正确的解码应该有更多的命中。

### 练习 1.3。一种强替代密码

如果不是移动字母表，而是随机打乱字母，会怎么样？创建一个使用这种替代编码和解码消息的程序。

一些报纸刊登类似这样的谜题，叫做*密码*。

### 练习 1.4。清点字典

对于上一个练习中的密文样式的替换，有多少个替换字典是可能的？

### 练习 1.5。识别字典

修改你的密码程序，这样你就可以识别和挑选带有数字的乱糟糟的字符替换图。也就是说，每个映射都有一个唯一的编号来标识它:每次选择替换 *n* 都应该创建相同的替换映射。这个练习比其他的稍微难一点。尽力而为！

### 练习 1.6。蛮力

试着让你的密码解码程序暴力破解一条信息。测试每个可能的映射需要多长时间？你能写一个程序用任何一种“聪明的猜测”来加速这个吗？

## 密码学的简明介绍

示例结束后，我们就可以开始真正的密码学了。欢迎光临！希望你对替代密码感兴趣。如前所述，这种特殊形式的加密被称为“凯撒密码”，因为它被凯撒大帝用于保护重要文件。

像凯撒一样，我们大多数人都有我们想要保密的信息。用密码学的术语来说，我们希望保密。加密是数据机密性的基石。

你对凯撒密码有什么看法？即使没有电脑，你认为你要花多长时间才能打破这样的东西？也许在凯撒的时代，如果凯撒的敌人没有受过良好的教育，这是相当有效的。这是密码学和计算机安全的重要一课。密码术的有效性通常*依赖于上下文*。无论你的对手受过多少教育，他们有多少台计算机，他们是否知道你使用的算法，或者他们有多大的动机，好的加密技术都是有效的。

简而言之，当你不太依赖环境时，你会过得更好，至少环境是在你控制之外的。

然而，良好的安全性将永远取决于你的选择(T2)。本书的目标是帮助密码初学者了解一些特定密码算法的工作原理以及它们的设计环境。这本书是针对程序员的，因此使用了大量的源代码来教授和阐释概念。当我们使用 Python 编程语言时，Python 程序员会特别喜欢这些练习。然而，这些概念并不依赖于语言。

因此，我们假设对编程有些熟悉。Python 很容易学习和阅读，任何人都应该很容易至少理解示例，为了方便起见，我们尽量远离非常特殊的 Python 习惯用法。

然而，我们不*也不*假设读者事先熟悉密码学。如果你对密码学略知一二，请耐心阅读书中可能针对绝对初学者的一些解释。如果你是初学者，这本书适合你。我们希望你喜欢弄湿你的脚。

## 密码学的用途

您可能已经意识到，在当今互联的现代世界中，加密技术无处不在。世界上的人们正在以令人难以置信的数量和速度交换信息。2018 年福布斯的一篇文章报道了以下统计数据[10]:

1.  每天都会产生 2.5 *万亿*字节的数据，而且这个数字还在加速增长。

2.  谷歌每天处理 35 亿次搜索。

3.  Snapchat 用户每秒分享 50 万张照片*。*

**   每秒钟发送超过 1600 万条短信。

     *   每秒钟发送超过 1.5 亿封电子邮件。

     *

 *从信息安全的角度来看，令人惊讶的是，这些传输中的绝大多数都应该受到某种方式的保护。在我写这篇文章的时候，有将近 40 亿互联网用户，但是几乎所有传输的数据都是给他们中极小的一部分人的。甚至当有人在社交媒体上公开发帖给全世界看时，他们也是在特定的平台上发帖。这种交流首先是给脸书、Twitter、Snapchat 或 insta gram*的，然后这个平台会让它公开。*

 *密码学是保护信息的主要工具。加密可用于帮助提供以下保护:

*   **保密**:只有授权方*才能读取*受保护的信息。当你想到加密或密码时，这可能是你想到的第一件事。

*   **认证**:你知道你正在与*正确的实体/个人*交谈，并且他们*没有委派他们的身份*(他们“在场”)。许多人知道他们浏览器上的小锁图标意味着他们的数据被加密，但是很少有人知道这也意味着服务的身份(例如，你的银行)已经被可信的权威机构验证。毕竟，这一点非常重要:将数据加密给错误的一方并没有真正的帮助。

*   **完整性**:消息在发送方和接收方之间没有被*改变*。这同样适用于明文和加密消息。在某些情况下，这可能看起来不直观，但是在无法阅读的情况下更改加密的消息是可能的，即使是以对接收者“有意义”的方式。

虽然有很多关于密码学的书，但是没有几本书把编程作为教授算法和相关原理的主要方法。我们的目标是通过动手练习帮助计算机程序员理解和使用这些概念。

## 什么会出错？

不幸的是，有很多方法可以错误地使用加密技术。事实上，错误地使用它的方法比正确地使用它的方法要多得多。造成这种情况的原因有很多，但这里我们将重点讨论两个。

首先，密码学基于许多非常深奥的数学，大多数程序员和 IT 专业人员都没有什么经验。您不必了解使用加密技术的数学知识，但有时不了解背后的数学知识会使您很难对什么可行、什么不可行有正确的直觉。

第二，也可能是最大的问题是，正确的用法也依赖于上下文。很难找到一个通用的“在任何情况下你都应该这样做”的算法。学习密码学的很大一部分是学习各种参数设置如何影响操作。

我们会在书中多次谈到这一点。事实上，你的许多练习都是为了*破解*错误设置的加密系统。观察事物的变化是理解其工作原理的好方法。这也很有趣。

## 亚那克:你不是密码学家

### 警告

这一部分至关重要。请仔细阅读

重复一遍，搞乱密码学的方法多得超乎你的想象。密码学的历史充满了非常聪明的人无意中创造出易受攻击的算法和系统的故事。很多时候，非专业人士了解到足够危险，于是拼凑出一个基于密码术的模块，提供了一种虚假的安全感。即使是一些最优秀的加密专家在发现他们忽略了一个微妙的边缘情况后，也不得不修正他们的协议。

如果这本书是你第一次接触密码学，当你读完的时候，你仍然不会是一个专家。这本书不会让你准备好创建算法和协议来提供工业强度保护。请，*请*，不要读完这本书，然后认为你已经准备好为一个真正的应用拼凑你自己的定制密码。

即使对于专家来说，目前密码学社区最好的想法是*而不是*创建新的或定制的机制。这通常被表述为，“不要使用你自己的密码”相反，找到并使用现有的库、协议和算法，这些库、协议和算法已经过大量测试，并且都有很好的文档记录和一致的维护。当真正需要新算法时，这些算法通常由专家委员会创建并测试，然后提交给同行审查和公众评论，最后才被信任来保护敏感数据。

那么，为什么要读这本书呢？如果只有专家才应该开发密码学，为什么非专家要学习这种东西？

首先也是最重要的，密码学很有趣！无论您对保护您编写的应用和后端服务器之间的数据通信做了多少准备，学习密码学都是有趣、愉快和值得的。此外，也许在你尝到甜头后，你会想要努力工作，让自己成为专家！也许这本书将是你成为密码学奇才的第一步！

第二，我们生活在一个不完美的世界。您可能正在从事一个项目，其中以前的贡献者(不幸的是)确实推出了他们自己的加密技术。如果您处于这种情况，您需要鼓励您的组织尽快更换它。这种情况就像一个随时会爆炸的地雷，可能需要大量的财政投资来修复。您的组织可能需要雇用一名加密顾问来调查和评估风险。在没有提前通知坏人的情况下，您可能需要向所有客户发送强制安全补丁。尽管这种情况很糟糕，但你自己去发现总比等着坏人来找你要好。阅读这本书可以帮助你认识到这些问题，并对你正在处理的问题做出初步评估。

第三，即使您使用的是著名的算法(或者更好的是第三方库)，至少了解一点底层的加密原理也是有帮助的。知道如何使用加密技术，尤其是如何设置各种加密方法的参数，会很方便。密码学社区中的一些人大力推动用 API 创建库，这些 API 只需要最少的配置，而且几乎不可能被错误地使用(我们将在本书的后面讨论一个例子)。然而，即使对于这些来说，如果在这些黑盒中发现了弱点，知情的用户可以更好地理解该弱点如何影响系统的安全性，从而更好地选择缓解策略。

最后，有见识的用户能够更好地识别好的建议和值得信赖的专家。让我们在接下来的几节中进一步讨论这一点。

## “跳下悬崖”——互联网

我们大多数写代码的人都非常依赖互联网。搜索 API 文档、示例代码甚至最佳实践是很常见的。但是在网上搜索关于密码术的建议时请小心。很多答案是好的，但更多的是可怕的。如果你不是专家，可能很难识别出其中的区别。

例如，有研究人员在 2017 年发表了一篇题为“栈溢出被认为有害？复制粘贴对 Android 应用安全性的影响”[5]。他们详细介绍了 Stack Overflow 网站上的 4000 多个帖子，其中包括与安全相关的代码片段。在对 130 万个 Android 应用进行法医检查后，他们发现整整 15%的应用包含了从这些帖子中复制的代码，其中大多数都在某种程度上不安全。

你可以做的第一件事就是在实践中自学密码学，这也是我们写这本书的目的之一。你不一定要成为专家才能见多识广。阅读本书的大多数人对计算机硬件都有足够的了解，即使你没有亲自设计电路板，也不会被咄咄逼人的推销员利用。类似地，多了解一点密码学基础知识可以帮助你辨别好的建议和坏的建议。它可以帮助你知道什么时候你可以自己解决，什么时候你应该寻求专家的帮助。

## cryptodoneright.org 项目

作者之一是 Crypto Done Right 项目的创始成员。这个项目的目标是在一个地方汇集最好的实用密码指南。在 cryptodoneright.org 网站上，我们正在创建和维护一个为软件开发人员、IT 专业人员和管理人员设计的加密推荐集。目标是在了解所有疯狂数学的加密专家和只需要一个应用与基于云的服务器安全通信的加密用户之间架起一座桥梁。

任何人都可以向 Crypto Done Right 提交或建议一个条目，但由最优秀的专家组成的编辑委员会可以确保正确的内容。在撰写本文时，编辑控制权仍在约翰·霍普金斯大学，但将它转移到一个独立的、由社区驱动的组织正在进行中。

我们鼓励您将此网站用作加密最佳实践的权威来源，我们认可其内容。作为一个通用知识库，它永远不会拥有每个人需要的一切，也不会回答每个应用的每个问题。但是，理解加密算法如何工作、哪些参数很重要以及应该避免哪些常见问题是一个良好的开端。如果您试图弄清楚在您的开发项目中如何使用加密技术，那么从那里开始，然后扩展到其他来源，以获得适用于您的情况的更详细的建议。Crypto Done Right 可以让你对相关问题敏感，这样你就可以识别哪些来源是可信的。

## 说够了，让我们总结一下

这本书是一本 Python 编程的书。我们会写很多非常好玩、非常有趣的代码来学习密码学。为了保持趣味性，我们将在整本书中依靠爱丽丝、鲍勃和伊芙。计算机安全人员实际上是这样谈论场景的，其中“Alice”代表“甲方”，Bob 代表“乙方”，Eve 代表“窃听者”。有时还有其他常见的名字，但这将是我们最常见的三个演员。

我们将使用一个假设的东西南极洲之间的冷战来激发我们的许多例子，这是完全虚构的。请不要对此事进行任何政治解读。我们用南极洲是因为它是我们能想到的最没有政治色彩的地方。如果我们无意中冒犯了您，我们提前道歉。

虽然示例代码是为了娱乐而编写的，但它也是为了相关和启发而编写的。花点时间研究一下这些例子。尝试你自己的实验。从正反两方面的例子中学习。

请小心不要在你的项目中使用“坏”的代码样本。即使是“好”的代码也不应该在没有仔细确定它是否合适的情况下就复制并粘贴到应用中。

本书的其余部分组织如下:

在第 [2](2.html) 章，我们将从*哈希*开始。你可能已经在某种程度上熟悉了哈希，但我们将在针对哈希算法的暴力攻击中做一些有趣的实验，甚至谈一谈工作证明，如比特币中使用的工作证明。从安全角度来看，哈希对于密码保护极其重要。它们对文件完整性也很有用，在后面的章节中当我们谈到消息完整性和数字签名时，它们会再次出现。

在第 [3](3.html) 章中，我们通过讨论*对称加密*真正进入加密领域。如果你听说过 AES，那就是对称加密方案的一个例子。它被称为“对称的”,因为加密数据的同一密钥被用来解密数据。这些算法速度很快，几乎专门用于加密大多数数据，无论是传输中的数据还是磁盘上的数据。

与对称算法相反，第 4 章[深入到*非对称加密*。这种加密涉及两个协同工作的密钥。一个加密，另一个解密。这些类型的算法用在证书和数字签名中，尽管在那一章中我们将集中讨论算法本身。](4.html)

虽然大多数人一听到密码学就会想到加密，但是它还有其他用途。第 [5](5.html) 章关注完整性和认证。完整性是确保消息在发送方和接收方之间不会改变。你可能会惊讶地发现，即使你不能阅读一条信息，你仍然可以用有用和有意义的方式改变它。当我们读到那一章时，我们将会探讨一些简洁的例子。此外，我们将看看数字签名和证书，将第四章[中的非对称工具和第二章](4.html)[中的哈希工具结合起来。](2.html)

第 [6](6.html) 章介绍了如何同时使用不对称和对称加密以及为什么要这样做，第 [7](7.html) 章探讨了对称加密的其他现代算法。

在第 [8](8.html) 章中，我们将特别关注用于保护 HTTPS 流量的 TLS 协议。这一章将把我们在整本书中看到的几乎所有东西都集中在一起，因为 TLS 是一个建立在所有这些工具之上的复杂协议。不过不要担心复杂的东西；你会发现这是对这本书的一个很好的评论，也是一个很有帮助的方式来了解所有的事情。

## 向前

我们现在已经快速介绍了密码学的基础知识，包括简单的密码和它不仅仅是关于保密的事实:还有其他重要的因素。理想情况下，您现在已经建立了一个良好的 Python 环境，自己尝试了一些代码，并准备学习更多内容。

我们走吧！

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

您可以在网上找到这些单词的列表，并且您的程序可以用它们自动填充您的数据结构。

 </aside>**