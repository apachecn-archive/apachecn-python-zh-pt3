# 2.用 Twisted 进行异步编程的介绍

前一章从基本原则中推导出 Twisted 的事件驱动架构。Twisted 程序和所有事件驱动的程序一样，以增加数据流控制的难度为代价，使并发变得更容易。当事件驱动程序发送的数据超过接收方的处理能力时，它不会通过阻塞 I/O 来自动暂停执行。确定这种情况何时发生以及如何处理是程序的责任。

通信方之间的数据流动方式也会影响数据在单个程序中的流动方式。因此，*组成*一个事件驱动应用程序的不同组件的策略不同于阻塞程序中使用的策略。

## 事件处理程序和合成

考虑一个不是事件驱动的程序，它使用阻塞 I/O 来执行网络操作:

```py
def requestField(url, field):
    results = requests.get(url).json()
    return results[field]

```

`requestField`用`requests` HTTP 库检索一个 URL，将响应的主体解码为 JSON，然后从结果字典中返回所请求的`field`属性的值。`requests`使用阻塞 I/O，所以对`requestField`的调用会暂停整个程序，直到 HTTP 请求所需的网络操作完成。因此，该函数可以假设在它返回之前，`results`将可用于操作。这个函数的调用者可以做出同样的假设，因为`requestField`会阻塞它们，直到它计算出结果:

```py
def someOtherFunction(...):
    ...
    url = calculateURL(...)
    value = requestField(url, 'someInteger')
    return value + 1

x = someOtherFunction(...)

```

在`requestField`从 JSON 响应中检索到 URL 并提取出`someInteger`属性的值之前，`someOtherFunction`和顶级`x`赋值都无法完成。这是一种*合成* : `someOtherFunction`调用`requestField`来完成自己执行的一部分。我们可以通过显式函数组合使这一点更清楚:

```py
def someOtherFunction(value):
    return value + 1

x = someOtherFunction(requestField(calculateURL(...), 'someInteger'))

```

这段代码用嵌套的函数调用替换了`someOtherFunction`的局部变量，但在其他方面是等效的。

功能组合是组织程序的基本工具。它允许一个程序被*分解*，或者分解成独立的单元，形成一个整体，其行为与未分解的版本完全匹配。这提高了可读性、可重用性和可测试性。

不幸的是，事件处理程序不能像`someOtherFunction`、`requestField`和`calculateURL`那样构成。考虑一个假设的非阻塞版本的`requestField`:

```py
def requestField(url, field):
    ??? = nonblockingGet(url)

```

在非阻塞版本的`requestField`中，什么可以取代`???`？这是一个很难回答的问题，因为`nonblockingGet`不会暂停程序的执行来完成构成对`url`的 HTTP 请求的网络操作；相反， `requestField`外的一个事件循环*复用可读和可写的事件，只要有可能就调用事件处理程序发送和接收数据。没有明显的方法可以从我们假设的`nonblockingGet`函数中返回`event handlers'`值。*

幸运的是，通过将事件处理程序表示为函数，我们可以利用函数组合的通用性将事件驱动的程序分解成独立的组件。让我们假设假设的`nonblockingGet`函数本身接受一个事件处理函数作为参数，当请求的完成事件发生时，它调用这个函数。这个较高级别的事件将由较低级别的事件合成，类似于我们在第 [1](01.html) 章中看到的传输为了它们的协议而发出一个`connectionLost`事件的方式。然后我们可以重写`requestField`来利用这个新论点:

```py
def requestField(url, field):
    def onCompletion(response):
        document = json.loads(response)
        value = response[field]

    nonblockingGet(url, onCompletion=onCompletion)

```

`onCompletion`是一个*回调*，或者是一个可调用的对象，作为一个参数传递给一些其他可调用的对象，这些对象执行一些期望的操作。当该操作完成时，用一些相关的参数调用回调。在这种情况下，`nonblockingGet`在其 HTTP 请求解析为完整的响应对象时调用其`onCompletion`回调。在前一章的`BuffersWrites`实现中，我们看到了一个等价的`onCompletion`回调；在那里，当所有缓冲的数据都被写入套接字时，它被调用。

回调在内部组合*，而其他函数，比如上面的`someOtherFunction`示例，在外部组合*；在可调用程序的执行过程中，值可用于回调，从而获得所需的结果，而不是从该可调用程序返回。**

 **与`nonblockingGet`提取事件驱动的 HTTP 请求代码的方式相同，`requestField`可以通过接受自己的回调提取字段的使用方式。我们将让`requestField`接受一个`useField`回调，然后让`onCompletion`回调调用它:

```py
def requestField(url, field, useField):
    def onCompletion(response):
        document = json.loads(response)
        value = response[field]
        useField(value)

    nonblockingGet(url, onCompletion=onCompletion)

```

我们可以通过将`someOtherFunction`作为`useField`回调来编写一个事件驱动的程序，它相当于我们的阻塞 I/O 版本:

```py
def someOtherFunction(useValue):
    url = calculateURL(...)
    def addValue(value):
        useValue(value + 1)
    requestField(url,"someInteger", useField=addValue)

```

反过来，`someOtherFunction`也必须通过接受其*自己的*回调来进行内部合成，这与之前在外部合成的`calculateURL`不同。这种回调驱动的方法足以编写任何程序；事实上，在计算机科学的研究中，回调可以被细化为称为*延续*的控制流原语，并被用于一种称为*延续传递风格*的技术中，在这种技术中，函数通过调用它们的延续并产生结果来终止。延续传递风格已经在各种语言编译器中使用，以支持程序分析和优化。

尽管延续传递式的理论很强大，但读起来和写起来都很笨拙。此外，外部构图——如`requestField`和`calculateURL`——和内部构图——如`requestField`和`useField`——彼此之间没有明显的构图。例如，很难想象`calculateURL`如何会被视为回调。最后，错误处理是一个关键的因果关系；想象一下我们将如何以延续传递的方式处理异常！在这个例子中，我们有意省略了任何错误处理，以保持代码足够短，便于阅读。

幸运的是，*异步编程*提供了一个强大的抽象，简化了事件处理程序的组成，并解决了这些问题。

## 什么是异步编程？

我们最初的`requestField`实现是*同步*，因为整个程序的执行是随着时间的推移线性进行的。例如，给定对`request.get`的两个调用，第一个将在第二个之前完成。同步编程是一种适用于阻塞 I/O 的常见范例。包括 Python 在内的大多数编程语言都默认通过阻塞 I/O 来启用同步操作。

我们的事件驱动`requestField`的延续传递风格是一种*异步编程*:当通过`nonblockingGet`回调的逻辑流暂停直到必要的数据可用时，整个程序的执行继续。两个独立的`nonblockingGet`调用的执行将交错进行，没有保证它们完成的顺序；一个比另一个早开始并不保证它会先完成。这就是并发的定义。

利用非阻塞 I/O 的事件驱动程序必然是异步的，因为*所有的* I/O 操作都是基于可以在任何时间以任何顺序到达的事件进行的。值得注意的是，异步程序不需要事件驱动的 I/O；不同的平台基于完全不同的原语提供 I/O 和调度模式。例如，Windows 提供了 I/O 完成端口(IOCP ),它通知程序请求操作的*完成*,而不是执行操作的机会。例如，请求 IOCP 基础设施在套接字上执行读取的程序将被通知读取完成的时间和数据。Twisted 以其 IOCP 反应器的形式对此提供了一些支持，但就我们的目的而言，我们可以将异步编程理解为事件驱动范式的脱节和零碎执行的结果，就像同步编程是阻塞 I/O 的结果一样

## 未来值的占位符

事件驱动程序中的回调模糊了控制流，因为它们在内部组成了*；它们不是将值返回给调用者，而是将结果转发给作为参数接收的回调。这导致了应用程序逻辑和控制流的混合，使重构变得困难，并且在错误发生点和对错误感兴趣的代码之间出现了脱节。*

 *引入一个表示尚未计算的值的对象允许回调在外部*被组合*。考虑一下当允许返回这种占位符时，我们的非阻塞`requestField`示例是如何变化的:

```py
def requestField(url, field):
    def onCompletion(response):
        document = json.load(response)

    return jsonDoc[field]
placeholder = nonblockingGet(url)
return placeholder.addCallback(onCompletion)

```

`nonblockingGet`现在返回一个*占位符*，这个占位符不是响应，而是一个容器，当响应准备好时，它将被放入这个容器。没有操作的容器不会提供太多好处，所以这个占位符接受它在值准备好时调用的*回调*。我们没有将`onCompletion`直接传递给`nonblockingGet,`，而是将其作为回调附加到占位符`nonblockingGet`的返回中。内部`onCompletion`回调的实现现在可以返回值——从 JSON 文档中提取的字段——该值将成为后续回调的参数。

`requestField`现在可以暂时删除自己的回调参数，并将占位符返回给`someOtherFunction`，后者可以添加自己的回调:

```py
def someOtherFunction(...):
    url = calculateURL(...)
    def addValue(value)
        return value + 1
    placeholder = requestField(url,"someInteger")
    return placeHolder.addCallback(addValue)

```

我们的占位符值并没有完全消除回调。相反，它提供了一个控制流抽象，将回调定位到它们的起始范围，这样它们就可以在外部被组合。当多个回调处理一个异步结果时，这变得更加清晰。考虑以下内部编写的回调:

```py
def manyCallbacks(url, useValue, ...):
    def addValue(result):
        return divideValue(result + 2)
    def divideValue(result):
        return multiplyValue(result // 3)
    def multiplyValue(result):
        return useValue(result * 4)
    requestField(url, "someInteger", onCompletion=addValue)

```

控制从`addValue`流向`divideValue`，最后从`multiplyValue`退出，进入由`manyCallbacks`的调用者提供的`useValue`回调。改变三个内部回调的顺序需要重写每一个。然而，占位符对象将该顺序移出每个回调:

```py
def manyCallbacks(url, ...):
    def addValue(result):
        return result + 2
    def divideValue(result):
        return result // 3
    def multiplyValue(result):
        return result * 4
placeholder = requestField(url, "someInteger")
placeholder.addCallback(addValue)
placeholder.addCallback(divideValue)
placeholder.addCallback(multiplyValue)
return placeholder

```

`divideValue`不再直接依赖于`multiplyValue`，所以可以在`multiplyValue`之前移动，甚至不需要改变它或者`multiplyValue`就可以移除。

回调的实际组合发生在`placeholder`对象中，其核心实现非常简单。我们将我们的占位符类命名为`Deferred`,因为它代表一个*延迟*值——一个尚未准备好的值:

```py
class Deferred(object):
    def __init__ (self):
        self._callbacks = []
    def addCallback(self, callback):
        self._callbacks.append(callback)
    def callback(self, result):
        for callback in self._callbacks:
            result = callback(result)

```

当结果可用时，`Deferred`实例的创建者调用`callback`。每个回调用当前结果调用，其返回值成为传递给下一个回调的结果。这就是上面的`onCompletion`如何将 HTTP 响应变成唯一感兴趣的 JSON 字段。

由`Deferred`的`for`循环施加的控制流足以依次调用每个回调，但是不能比内部合成的回调更好地处理异常。解决这个问题需要添加某种分支逻辑来检测异常并将异常重新路由到它们的目的地。

## 异步异常处理

同步 Python 代码用`try`和`except`处理异常:

```py
def requestField(url):
    response = requests.get(url).content
    try:
        return response.decode('utf-8')
    except UnicodeDecodeError:
        # Handle this case

```

通过`addCallback`方法添加到`Deferred`的回调在没有异常发生时运行，因此是`try`块的异步等价物。我们可以通过为`except`块引入一个类似的回调来添加错误处理，该回调接受异常作为它的参数。像这样被异常调用的回调被称为*错误返回*。

同步代码可以通过省略`try`和`except`来选择让异常向上传播到它的调用者。然而，`Deferred`的控制流将允许回调引发的异常从`for`循环向上返回到`Deferred.callback`的调用者。这将是放置异常处理的错误位置，因为为`Deferred`提供值的代码不知道添加回调的代码想要的错误处理行为。将这种错误处理封装在我们传递给`Deferred` s 的`errbacks`中，允许那些`Deferred` s 在正确的时间调用它们，而不是麻烦`Deferred.callback`的调用者。

然后，在回调链的每一步，循环必须捕捉任何异常，并将其转发给下一个 errback。因为每个步骤都可能调用回调或错误返回，所以我们的`callbacks`列表将更改为包含(`callback`、`errback`)对:

```py
def passthrough(obj):
    return obj

class Deferred(object):
    def __init__ (self):
        self._callbacks = []
    def addCallback(self, callback):
        self._callbacks.append((callback, passthrough))
    def addErrback(self, errback):
        self._callbacks.append((passthrough, errback))
    def callback(self, result):
        for callback, errback in self._callbacks:
            if isinstance(result,BaseException):
                handler = errback
            else:
                handler = callback
            try:
                result = handler(result)
            except BaseExceptionas e:
                result = e

```

循环的每次迭代都检查当前结果。异常被传递给下一个 errback，而其他的都像以前一样被传递给下一个回调。由 errback 或回调引发的任何异常都将成为链中下一个 errback 要处理的结果。这就产生了下面的`Deferred`代码:

```py
someDeferred = Deferred()
someDeferred.addCallback(callback)
someDeferred.addErrback(errback)
someDeferred.callback(value)

```

相当于这个同步代码:

```py
try:
    callback(value)
except BaseExceptionas e:
    errback(e)

```

错误返回通过返回异常来传播异常，并通过返回任何不是*而不是*异常的值来抑制异常。下面的`Deferred`代码过滤掉 ValueErrors，同时让所有其他异常传播到下一个 errback:

```py
def suppressValueError(exception):
    if not isinstance(exception, ValueError):
        return exception

someDeferred.addErrback(suppressValueError)

```

当`isinstance(exception, ValueError)`评估为`True`时`suppressValueError`隐式返回`None`，因此`Deferred`回调循环中的异常检查将`None`传递到下一个回调。每隔一个异常从`suppressValueError`返回，进入`for`循环，并继续下一个 errback。总的效果相当于下面的同步代码:

```py
try:
    callback(value)
except ValueError:
    pass

```

当我们考虑它可能遇到异常的两个地方时，`Deferred`的新控制流的一个方便的结果变得明显:

1.  在`Deferred`的回调列表中的任何回调都可能引发异常。例如，我们的`manyCallback`函数的回调序列中的一个错误可能导致`addValue`返回`None`，在这种情况下`divideValue`将引发一个`TypeError`。

2.  将实际值传递给`Deferred`的`callback`方法的代码可能会引发一个异常。例如，想象一下，`nonblockingGet`试图将 HTTP 响应的主体解码为 UTF-8，并使用结果回调一个`Deferred`。如果主体包含非 UTF 8 字节序列，将引发一个`UnicodeDecodeError`。这种异常意味着实际值永远无法计算，这是`Deferred`的 errbacks 应该知道的错误情况。

`Deferred`现在处理这两种情况；第一个问题可以通过在一个`try`块中运行每个回调和错误返回来解决，而第二个问题可以通过捕捉异常并将其转发给`Deferred.callback`来解决。考虑一个 HTTP 协议实现，它试图用 UTF-8 解码的响应体调用`Deferred`的回调:

```py
class HTTP(protocol.Protocol):
    def dataReceived(self, data):
        self._handleData(data)
        if self.state == "BODY_READY":
            try:
                result = data.decode('utf-8')
            except Exceptionas e:
                result = e
            self.factory.deferred.callback(e)

class HTTPFactory(protocol.Factory)
    protocol = HTTP
    def __init__ (self, deferred):
        self.deferred = deferred

def nonblockingGet(url):
    deferred = Deferred()
    factory = HTTPFactory(deferred)
    ...
    return deferred

```

这是因为`Deferred`的`for`循环通过检查当前结果的性质来开始每次迭代。第一次通过循环，结果是无论调用者提供什么`callback`；在对`Exception`进行编码的情况下，上面的代码向`callback`提供了那个异常。

异常处理现在可以在 errbacks 中本地化，就像应用程序逻辑在回调中本地化一样。这允许我们将同步异常控制流转换为异步异常控制流。此代码:

```py
def requestField(url, field):
    results = requests.get(url).json()
    return results[field]

def manyOperations(url):
    result = requestField(url, field)
    try:
        result += 2
        result //= 3
        result *= 4
    except TypeError:
        return -1
    return result

```

变成了这样的代码:

```py
def manyCallbacks(url):
    def addValue(result):
        return result + 2
    def divideValue(result):
        return result // 3
    def multiplyValue(result):
        return result * 4
    def onTypeError(exception):
        if isinstance(exception,TypeError):
            return -1
        else:
            return exception
    deferred = requestField(url, "someInteger")
    deferred.addCallback(addValue)
    deferred.addCallback(divideValue)
    deferred.addCallback(multiplyValue)
    deferred.addErrback(onTypeError)
    return deferred

```

Twisted 提供了一个`Deferred`实现，它的 API 是这里显示的 API 的超集；正如我们将在下一节中看到的，真正的`Deferred`自己组成，并提供额外的功能，如超时和取消。然而，在其核心，它的行为与我们的玩具实现相匹配。

## 扭曲的延期介绍

了解 Twisted 的`Deferred`的最好方法是在 Python 会话中使用它。我们将从从`twisted.internet.defer`导入开始:

```py
>>> from twisted.internet.defer import Deferred

```

### 回收

像我们的玩具实现一样，`twisted.internet.defer.Deferred`的`addCallback`方法接受一个回调来添加到实例的回调列表中。与我们的实现不同，Twisted 还接受将传递给回调的位置和关键字参数:

```py
>>> d = Deferred()
>>> def cbPrint(result, positional, **kwargs):
...     print("result =", result, "positional =", positional,
...           "kwargs =", kwargs)
...
>>> d.addCallback(cbPrint, "positional", keyword=1) is d
True
>>> d.callback("result")
result = result positional = positinal, kwargs = {'keyword': 1}

```

我们创建一个名为 d 的`Deferred`，添加`cbPrint`作为回调，然后用`"result". d`回调 d，将它传递给`cbPrint`作为它的第一个位置参数，而传递给`d.addCallback`的附加参数作为它的剩余参数。

注意，`d.addCallback`返回 d 本身，这允许像

```py
d.addCallback(...).addCallback(...).addCallback(...).

```

现在`d`已经用一个值回调了，它不能再被回调:

```py
>>> d.callback("whoops")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "site-packages/twisted/internet/defer.py", line 459, in callback
    self._startRunCallbacks(result)
  File "site-packages/twisted/internet/defer.py", line 560, in _startRunCallbacks
    raise AlreadyCalledError
twisted.internet.defer.AlreadyCalledError

```

这是因为`Deferred` s 记得他们被召回的价值:

```py
>>> d2 = Deferred()
>>> d2.callback("the result")
<Deferred at 0x12345 current result: 'the result'>

```

`Deferreds`存储结果的事实提出了一个问题:当有结果的`Deferred`被添加了回调时会发生什么？

```py
>>> d2.addCallback(print)
the result

```

一旦将`print`作为回调添加到`d2`中，它就会运行。一个有结果的`Deferred`s*立即运行添加给它的回调*。人们很容易想象`Deferred` s 总是代表一个尚不可用的值。然而，假设这一点的代码是错误的，并且是令人沮丧的错误的来源。请考虑以下几点:

```py
class ReadyOK(twisted.internet.protocol.Protocol):
    def connectionMade(self):
        someDeferred = someAPI()
        def checkAndWriteB(ignored):
            self.transport.write(b"OK\n")
        someDeferred.addCallback(checkAndWriteB)
        self.transport.write(b"READY\n")

```

顾名思义，这个`ReadyOK`协议应该用一条`READY`线路来迎接新的连接，只写`OK`，当`someAPI`回叫它的`Deferred`时就断开。当`someDeferred`直到`connectionMade`返回后才被回调时，`READY`才会出现在`OK`之前，但这并不能保证；如果`someAPI`返回`someDeferred`一个结果，那么`OK`出现在`READY`之前。这种预期行顺序的颠倒会破坏正确要求先发送`READY`的客户端。

这种情况下的解决方法是将`self.transport.write(b"READY\n")` *移到* `someDeferred = someAPI()`之前。您可能需要类似地重新组织您自己的代码，以确保结果的`Deferreds`不违反不变量。

### 错误和失败

`Deferreds`也有 errbacks 来处理由回调和调用代码提供的异常`Deferred.callback`。我们首先考虑第一种情况:

```py
>>> d3 = Deferred()
>>> def cbWillFail(number):
...     1 / number
...
>>> d3.addCallback(cbWillFail)
<Deferred at 0x123456>
>>> d3.addErrback(print)
<Deferred at 0x123456>
>>> d3.callback(0)
[Failure instance: Traceback: <class 'ZeroDivisionError'>: division by zero
<stdin>:1:<module>
site-packages/twisted/internet/defer.py:459:callback
site-packages/twisted/internet/defer.py:567:_startRunCallbacks
--- <exception caught here> ---
site-packages/twisted/internet/defer.py:653:_runCallbacks
<stdin>:2:cbWillFail
]

```

`d3 Deferred`有一个将 1 除以其参数的回调函数，内置的`print`函数作为 errback，因此回调函数引发的任何异常都将出现在我们的交互会话中。用 0 回调`d3`自然会产生一个`ZeroDivisionError`，但也会产生其他东西:一个*失败*实例。请注意，`Failure`字符串表示是用括号([。。。]).errback 打印的是单个故障，而不是有一个故障的`list`！

Python 2 中的异常对象不包含回溯或其他关于其来源的信息。为了提供尽可能多的上下文，Twisted 引入了`Failures`作为记录回溯的异步异常的容器类型。在`except`块中构造的`Failure`吸收活动异常及其回溯:

```py
>>> from twisted.python.failure import Failure
>>> try:
...     1 /0
... except:
...     f = Failure()
...
>>> f
<twisted.python.failure.Failure builtins.ZeroDivisionError: division by zero>
>>> f.value ZeroDivisionError('division  by  zero',)
>>> f.getTracebackObject()
<traceback object at 0x1234567>
>>> print(f.getTraceback())Traceback (most recent call last):
--- <exception caught here> ---
  File "<stdin>", line 2, in <module>

builtins.ZeroDivisionError: division by zero

```

`Failure`实例在其`value`属性下存储实际的异常对象，并以几种不同的方式使回溯本身可用。

还有一些方便的方法，可以在出错时轻松地与它们交互。`check`方法接受多个异常类，并返回属于`Failure`的异常或`None`的一个:

```py
>>> f.check(ValueError)
>>> f.check(ValueError, ZeroDivisionError)
<class 'ZeroDivisionError'>

```

`Failure.trap`的行为类似于`check`，除了当`Failure`的异常与任何提供的异常类都不匹配时，它会重新引发异常。这允许 errbacks 复制过滤 except 子句的行为:

```py
>>> d4 = Deferred()
>>> def cbWillFail(number):
...     1 / 0
...
>>> def ebValueError(failure):
...     failure.trap(ValueError):
...     print("Failure was ValueError")
...
>>> def ebTypeErrorAndZeroDivisionError(failure):
...     exceptionType = failure.trap(TypeError, ZeroDivisionError):
...     print("Failure was", exceptionType)
...
>>> d4.addCallback(cbWillFail)
<Deferred at 0x12345678>
>>> d4.addErrback(ebValueError)
<Deferred at 0x12345678>
>>> d4.addErrback(ebTypeErrorAndZeroDivisionError)
<Deferred at 0x12345678>
>>> d4.callback(0)
Failure was <class 'ZeroDivisionError'>

```

`ebValueError`和`ebTypeErrorAndZeroDivisionError`的功能类似于同步代码中的两个块:

```py
try:
    1/0
except ValueError:
    print("Failure was ValueError")
except (TypeError,ZeroDivisionError) as e:    exceptionType = type(e)
    print("Failure was", exceptionType)

```

最后，`Deferreds`可以被提供一个`Failure`或者可以从当前异常合成一个。

用一个`Failure`实例回调一个`Deferred`开始执行它的错误返回。`someDeferred.callback(Failure())`因此类似于通过我们的玩具实现的`callback`异常。

`Deferreds`还要暴露一个`errback`方法。传递这个`Failure`实例与传递`callback`实例具有相同的效果；然而，不带参数调用`Deferred.errback`会导致失败，从而很容易捕获异步处理的异常:

```py
>>> d5 = Deferred()
>>> d5.addErrback(print)
<Deferred at 0x12345678>
>>> try:
...    1/0
... except:
...    d.errback()
...
[Failure  instance:  Traceback:<  class 'ZeroDivisionError'>:  division  by  zero
---<exception caught here>---
<stdin>:2:<module>
]

```

### 撰写延期

是一个控制流抽象，支持回调和错误的组合。他们还和自己一起作曲，这样一个`Deferred`可以侍候一个`Deferred`。

考虑一个名为`outerDeferred`的`Deferred`，它有以下回调序列，其中一个返回`innerDeferred`，它有自己的*回调:*

```py
>>> outerDeferred = Deferred()
>>> def printAndPassThrough(result, *args):
...     print("printAndPassThrough",
...           " ".join(args), "received", result)
...     return result
...
>>> outerDeferred.addCallback(printAndPassThrough, '1')
<Deferred at 0x12345678>
>>> innerDeferred = Deferred()
>>> innerDeferred.addCallback(printAndPassThrough,  '2',  'a')
<Deferred at 0x123456789>
>>> innerDeferred.addCallback(printAndPassThrough,  '2',  'b')
<Deferred at 0x123456789>
>>> def returnInnerDeferred(result, number):
...     print("returnInnerDeferred #", number, "received", result)
...     print("Returning innerDeferred...")
...     return innerDeferred
...
>>> outerDeferred.addCallback(returnInnerDeferred, '2')
<Deferred at 0x12345678>
>>> outerDeferred.addCallback(printAndPassThrough, '3')
<Deferred at 0x12345678>
>>> outerDeferred.addCallback(printAndPassThrough, '4')
<Deferred at 0x12345678>

```

回调`outerDeferred`清楚地调用了标识符为 1 的`printAndPassThrough`回调，但是当控制到达`returnInnerDeferred`时会发生什么呢？

我们可以用图 [2-1](#Fig1) 中执行流程的可视化表示来回答这个问题。

![../images/455189_1_En_2_Chapter/455189_1_En_2_Fig1_HTML.jpg](../images/455189_1_En_2_Chapter/455189_1_En_2_Fig1_HTML.jpg)

图 2-1

`outerDeferred`和`innerDeferred`之间的执行和数据流。执行遵循虚线箭头，而数据流遵循实线箭头。

标有 **A** 的方框代表开始`outerDeferred`回调循环的`outerDeferred.callback(` ' `result` ' `)`调用，而虚线和实线箭头分别表示执行和数据的流向。

标识符为`1`的第一个回调函数—`printAndPassThrough`—接收‘`result`’作为第一个参数，并打印出一条消息。因为它返回'【T3 '，`outerDeferred`用相同的对象调用下一个回调。`returnInnerDeferred`打印它的标识符和一条它正在返回的消息`innerDeferred`在这样做之前:

```py
>>> outerDeferred.callback("result")
printAndPassThrough 1 received result
returnInnerDeferred 2 received result
Returning innerDeferred...

```

`outerDeferred`内部的回调循环检测到`returnInnerDeferred`返回了一个`Deferred`而不是一个实际值，并且*暂停*自己的回调循环，直到`innerDeferred`解析为一个值。图 [2-1](#Fig1) 中的虚线箭头表示执行已经转移到`innerDeferred`处，`outerDeferred`的`repr`也是如此:

```py
>>> outerDeferred
<Deferred at 0x12345678 waiting on Deferred at 0x123456789>

```

标有 **B** 的方框代表继续执行的`innerDeferred.callback(` ' `result` ' `)`调用。自然地，`innerDeferred`自己的回调，`printAndPassThrough`的标识符`2 a`和`2 b`，现在运行。

一旦`innerDeferred`已经运行了它所有的回调，执行返回到`outerDeferred`的回调循环，其中`printAndPassThrough`的`3`和`4`用`innerDeferred`最后一次回调返回的值执行。

```py
>>> innerDeferred.callback('inner result')
printAndPassThrough 2 a received inner result
printAndPassThrough 2 b received inner result
printAndPassThrough 3 received inner result
printAndPassThrough 4 received inner result

```

实际上，`printAndPassThrough 3`和`4`变成了`innerDeferred`的回调。如果任何`innerDeferred`自己的回调返回`Deferred` s，它的回调循环将以与`outerDeferred`相同的方式暂停。

从回调(以及错误返回)返回`Deferreds`的能力允许在外部组合返回`Deferreds`的函数:

```py
def copyURL(sourceURL, targetURL):
    downloadDeferred = retrieveURL(sourceURL)
    def uploadResponse(response):
        return uploadToURL(targetURL, response)
    return downloadDeferred.addCallback(uploadResponse)

```

`copyURL`使用两个假设的 API:`retrieveURL`，它检索一个 URL 的内容；和`uploadToURL`，它上传数据到一个目标 URL。添加到由`retrieveURL`返回的`Deferred`中的`uploadResponse`回调使用来自源 URL 的数据调用`uploadResponse`，并返回结果`Deferred`。记住一个`Deferred`的`addCallback`返回相同的实例，所以`copyURL`返回`downloadDeferred`给它的调用者。

`copyURL`的用户首先等待下载，然后等待上传。`copyURL`的实现组合返回`Deferred`的函数，就像它组合回调函数一样，没有任何特殊用途的 API。

Twisted 的`Deferred` s 的基本接口允许用户在外部编写回调、错误返回和`Deferred` s，简化了异步程序的构建。

异步程序可以从外部组合它们的事件处理程序，这并不是唯一的方法。自从 Twisted 的`Deferred`问世以来的近 20 年里，Python 已经开发了语言级机制来暂停和恢复特殊类型的函数。

## 生成器和内联回调

### 产量

Python 从 2.5 版本开始支持*生成器*。生成器是在它们的主体中使用一个`yield`表达式的函数和方法。调用生成器会返回一个可迭代的*生成器对象*。迭代执行生成器主体，直到下一个`yield`表达式，此时执行暂停，迭代器计算出`yield`表达式的操作数。

考虑以下生成器的执行:

```py
>>> def generatorFunction():
...     print("Begin")
...     yield 1
...     print("Continue")
...     yield 2
...
>>> g = generatorFunction()
>>> g
<generator object generatorFunction at 0x12345690>
>>> result = next(g)
Begin
>>> result
1

```

被调用时返回一个新的生成器对象。请注意，`generatorFunction`的身体还没有跑起来。内置的`next`函数推进了一个迭代器；推进生成器对象`g`开始执行`generatorFunction`的主体，将`Begin`输出到我们的交互式 Python 会话中。执行在到达第一个`yield`表达式时暂停，提供给`yield`的值成为`next`调用的返回值。再次调用`next`继续执行发生器，直到它到达第二个`yield`:

```py
>>> nextResult = next(g)
Continue
>>> nextResult
2

```

再次调用`next`恢复生成器。这一次它的整个身体都被处决了。没有进一步的`yields`可以暂停，所以生成器对象不能为后续的`next`调用提供另一个值。根据 Python 的迭代协议，在 generato 对象上调用`next`会引发`StopIteration`来表明它已经被耗尽:

```py
>>> next(g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

```

因此，生成器遵循与任何其他迭代器相同的 API:要么像上面那样通过对`next`的显式调用返回值，要么像在`for`循环中那样通过隐式调用返回值，而`StopIteration`异常表明不能再返回更多的值。然而，生成器实现的不仅仅是迭代 API。

### 派遣

发生器可以*接收*值，也可以发送它们。`yield`操作数可以出现在赋值语句的右边。通过将值传递给生成器的`send`方法，可以使生成器暂停的`yield`表达式计算出某个值。给定生成器`gPrime`中的以下`yield`表达式:

```py
def gPrime():
    a = yield 4

```

`gPrime.send(5)`导致赋值右侧的`yield`计算为`5`，这样生成器中的代码就相当于:

```py
def gPrime():
    a = 5

```

结果，发电机本地变量`a`取值为 5。与此同时，`gPrime().send(5)`调用推进生成器，并评估为`4`。让我们通过检查一个完全工作的例子及其在图 [2-2](#Fig2) 中的可视化来更详细地探索`send`的控制流。

![../images/455189_1_En_2_Chapter/455189_1_En_2_Fig2_HTML.jpg](../images/455189_1_En_2_Chapter/455189_1_En_2_Fig2_HTML.jpg)

图 2-2

执行和数据流入流出`receivingGenerator`。执行向下移动，而数据流沿着实线箭头。

```py
>>> def receivingGenerator():
...     print("Begin")
...     x = 1
...     y = yield x
...     print("Continue")
...     z = yield x + y
...     print(x + y + z)
...
>>> g = receivingGenerator()
>>> result = next(g) # A Begin
>>> result
1
>>> nextResult = g.send(2) # B
Continue
>>> nextResult
3
>>> g.send(3) # C
6
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

```

我们从`next`开始执行`receivingGenerator`，与我们开始执行`generatorFunction`的方式相同；生成器必须总是通过迭代一次来启动。图 [2-2](#Fig2) 中标有 **A** 的方框表示对`next`的初始调用。和以前一样，`g`一直运行，直到暂停在它的第一个`yield`表达式上，这个`next`调用计算那个`yield`的操作数。因为该操作数是被赋值为 1 的局部变量`x`，所以`next`调用的值为 1。从`yield x`出来的黑色箭头，穿过方框 **A** ，在数值`1`穿过`next`离开发生器时追踪该数值。

现在，发电机已经启动，我们可以使用 send 再次恢复它，如框 **B** 所示。g. `send(2)`将值`2`传递给生成器，生成器将其赋给变量`y`。执行继续，经过`print("Continue")`，直到在下一个`yield`暂停。这里的操作数是表达式`x + y`，其计算结果为 3，并通过`g.send(2)`返回。从`x + y`穿过框 **B** 的黑色箭头显示结果 3 采用的退出路径。

由框 **C** 表示的调用`g.send(3)`，将 3 发送到生成器并再次继续执行，将`x` + `y` + `z` = 6 打印到会话。然而，生成器不能像以前一样暂停执行，因为在`receivingGenerator`中没有进一步的`yield`表达式。因为生成器遵循迭代协议，所以当耗尽时它们抛出`StopIteration`；`g.send(3)`因此引发 StopIteration，而不是计算一个值，如图 [2-2](#Fig2) 所示，并在示例代码中演示。

### 扔

正如`send`允许将值传递给生成器一样，`throw`允许在生成器中引发异常。考虑以下代码:

```py
>>> def failingGenerator():
...     try:
...         value = yield
...     except ValueError:
...         print("Caught ValueError")
...
>>> tracebackG = failingGenerator()
>>> next(tracebackG)
>>> tracebackG.throw(TypeError())
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in failingGenerator
TypeError
>>> catchingG = failingGenerator()
>>> next(catchingG)
>>> catchingG.throw(ValueError())
Caught ValueError
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

```

`failingGenerator`将其`yield`表达式包装在一个`try`块中，该块的`except`捕获`ValueError`，然后打印一条消息。所有其他异常都传递回调用者。

我们通过调用`failingGenerator`并将其命名为`tracebackG`来创建一个新的生成器。我们像往常一样先给`next`打个电话。注意`failingGenerator`的`yield`缺少一个操作数；Python 用`None`表示值的*缺失*，所以`next`计算为`None`(当函数返回`None`时，迭代 Python 会话不打印`None`)。在生成器内部，第一个`yield`本身评估为`None`，因为`next`不能向生成器发送任何值。因此，`g.send(None)`相当于`next(g)`。当我们研究*协程*时，这种等价将变得非常重要。

接下来，我们通过`throw`方法将`TypeError`扔进`tracebackG`。发生器恢复到其`yield`表达式，但是`yield` *没有计算出一个值，而是提高了`throw`传递的`TypeError`*。结果回溯在`failingGenerator`内终止。从回溯中不太清楚的是`TypeError`从`tracebackG.throw`上升。这是有意义的:调用`throw`导致了生成器的恢复，这又引发了`TypeError`，未处理的异常返回调用堆栈是很自然的。

一个名为`catchingG`的新生成器演示了当`failingGenerator`的`except`方块遇到`ValueError`时会发生什么。正如所料，`yield`引发了传递给`throw`的异常，正如 Python 的异常处理所料，`except`块捕获了`ValueError`并输出了它的消息。然而，没有进一步的`yield`来暂停发电机，所以这次`throw`产生一个`StopIteration`来指示`failingGenerator`的耗尽。

### 带内联回调的异步编程

生成器暂停和恢复执行对应于`Deferred`执行回调和错误返回:

*   当到达一个`yield`表达式时，生成器暂停其执行，而当一个返回另一个`Deferred`时，`Deferred`暂停其回调和出错；

*   暂停的生成器可以通过它的`send`方法用一个值恢复，而等待另一个`Deferred`的`Deferred`在那个`Deferred`解析为一个值时恢复执行它的回调；

*   暂停的生成器可以通过它的`throw`方法接收和捕获异常，而等待另一个`Deferred`的`Deferred`在那个`Deferred`解决了异常时继续执行它的 errbacks。

通过比较以下两个代码示例，我们可以看到这些等效性的作用:

```py
def requestFieldDeferred(url, field):
    d = nonblockingGet(url)

    def onCompletion(response):
        document = json.load(response)
        return jsonDoc[field]

        def onFailure(failure):
            failure.trap(UnicodeDecodeError)

        d.addCallack(onCompletion)
        d.addErrback(onFailure)

        return d

    def requestFieldGenerator(url, field):
        try:
            document = yield nonblockingGet(url)
        except UnicodeDecodeError:
            pass
        document = json.load(response)
        return jsonDoc[field]

```

`requestFieldDeferred`给`nonblockingGet`的响应`Deferred`附加一个回调，将响应解码为 JSON 并提取一个属性，以及一个 errback，只隐藏`UnicodeDecodeError` s

`requestFieldGenerator`反而产生`nonblockingGet`的`Deferred`。然后，当响应可用时，生成器可以恢复响应，或者如果发生异常，则恢复异常。callback 和 errback 都被移到了调用`nonblockingGet`的同一个作用域中。将函数体移入调用者被称为*内联*。

我们不能像写的那样使用`requestFieldGenerator`: Python 2 不允许生成器返回值，我们需要一个包装器来接受`yield` ed `Deferred`,并在`Deferred`解析为值或异常时安排调用生成器的`send`或`throw`。

Twisted 在`twisted.internet.defer.inlineCallbacks`中提供了这个包装器。它修饰返回生成器的可调用程序，并在每个产出的`Deferred`解析为一个值或异常时调用`send`和`throw`。反过来，调用修饰的生成器函数或方法的调用者会收到一个`Deferred`,而不是一个生成器对象。这确保了期望`Deferreds`的现有 API 与`inlineCallbacks`无缝协作。

这是我们用`inlineCallbacks`装饰的`requestFieldGenerator`:

```py
from twisted.internet import defer

@defer.inlineCallbacks
def requestFieldGenerator(url, field):
    try:
        document = yield nonblockingGet(url)
    except UnicodeDecodeError:
        pass

    document = json.load(response)
    defer.returnValue(jsonDoc[field])

def someCaller(url, ...):
    requestFieldDeferred = requestFieldGenerator(url,"someProperty")
    ...

```

`returnValue`函数抛出一个包含其参数的特殊异常；`inlineCallbacks`捕捉到这个，并安排用那个值回调`requestFieldGenerator`。Python 3 中的一个`return`语句引发了一个等价的异常，`inlineCallbacks`也会捕获它，所以在只在 Python 3 下运行的代码中`returnValue`是不必要的。

通过将代码从回调和错误返回到单个局部范围，生成器使得异步扭曲程序读起来就像同步的一样。短程序尤其受益于随之而来的函数定义的减少和更清晰的控制流。

发电机用熟悉来换取新的困难。最关键的是，生成器函数或方法的调用者不可能知道返回的生成器对象是使用用`send`发送给它的值，还是默默地忽略它。例如，这两个发生器提供相同的接口:

```py
def listensToSend():
    a = 1
    b = yield a
    print(a+b)

def ignoresSend():
    a = 1
    yield a
    print(a)

```

意外地用`ignoreSend`替换`listensToSend`会导致一个难以诊断的细微错误。两者都是有效的 Python 代码，适用于不同的环境:`listensToSend`允许带值的恢复，使其适用于`inlineCallbacks`，而`ignoreSend`只是产生一个值，适合于对文件中的行进行操作的处理管道。Python 生成器 API 模糊了这两个不同的用例。

幸运的是，Python 3 的最新版本提供了为`inlineCallbacks`风格的生成器量身定制的新语法。

## Python 中的协同程序

在计算机科学中，生成器是*协同程序*的一个特例，它可以挂起自己，并将执行传递给任何其他协同程序，当它们接收到返回值时继续执行。我们的`inlineCallbacks`修饰生成器类似于协程，因为它可以产生和接收值，但是它不像协程，它不能像调用任何其他函数那样直接调用另一个生成器。相反，它需要`inlineCallbacks`内部的机器来代表它将执行任务交给另一个生成器。这个机器管理执行代码的请求，并将结果返回给请求者，被称为*蹦床*。为了理解其中的原因，想象一下执行就好像在不同的发生器之间反弹`inlineCallbacks`。

### 产自的协同程序

Python 3.3 引入了一种新的语法，允许一个生成器直接将其执行委托给另一个生成器:`yield from`。以下 Python 3.3+专用代码演示了从另一个生成器生成的生成器的行为:

![../images/455189_1_En_2_Chapter/455189_1_En_2_Fig3_HTML.jpg](../images/455189_1_En_2_Chapter/455189_1_En_2_Fig3_HTML.jpg)

图 2-3

执行和数据流入流出`e`和`f`。执行向下移动，而数据流沿着实线箭头。

```py
>>> def e():
...     a = yield 1
...     return a + 2
...
>>> def f():
...     print("Begin f")
...     c = yield from e()
...     print(c)
...
>>> g = f()
>>> g.send(None)
Begin f
1
>>>  g.send(2)
4
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

```

生成器`e`的行为与上一节中描述的生成器函数完全一样:如果我们调用它，我们将通过调用它的`next`(或者传递它的`send`方法`None`)来启动返回的生成器，这将返回 1，它的`yield`的操作数；然后，我们可以用`send`将值传递回生成器，它会将操作数返回给下一个`yield`表达式或者返回给 return 语句(记住，在 Python 3 中，生成器可以返回值)。

由`f` *返回的生成器`g`从*产生由`e`返回的生成器，暂停以允许子生成器执行。对`g`发出的`next`、`send`和`throw`调用被代理到底层的`e`生成器，因此生成器`g`看起来是一个`e`生成器。在图 [2-3](#Fig3) 中，方框 **A** 表示开始执行`g`的初始`g.send(None)`。执行通过`f()`的`yield from`移动到由`e()`返回的生成器，暂停在`e`主体内的`yield`表达式上，该表达式将`1`发送回`g.send(None)`。

当子生成器终止时，用`yield from`将执行委托给另一个生成器的生成器重新获得控制。图 [2-3](#Fig3) 中的框 **B** 表示对`g.send(2)`的第二次调用，该调用通过暂停的`f`生成器将值`2`传递给子生成器`e`，子生成器恢复并将`2`赋给变量`a`。执行进行到`return`语句，并且`e`子生成器以值`4`退出。现在`f`在其`yield from`表达式的左侧重新开始，并将接收到的`4`赋给变量`c`。在`print`调用之后，没有进一步的`yield`或`yield from`表达式，因此`f()`终止，导致`g.send(2)`引发`StopIteration`错误。

这种语法不需要像`inlineCallbacks`这样的蹦床将调用从一个生成器分派到另一个生成器，因为它允许生成器直接将执行委托给其他生成器。有了`yield from`，Python 生成器的行为就像真正的协程一样。

### 协同程序异步和等待

不幸的是，`yield from`仍然遭受着和`yield`一样的不确定性:接受值和忽略值的生成器对于调用代码来说是一样的。Python 以后的版本通过在区分协程的`yield from`:`async`和`await`之上引入新的语法特性来解决这种歧义。

当应用于一个函数或方法定义时，`async`标记将那个函数或方法变成一个*协程*:

```py
>>>  async def function(): pass
...
>>> c = function()
>>> c
<coroutine object function at 0x9876543210>

```

与生成器不同，协程不能迭代:

```py
>>> list(function())
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'coroutine' object is not iterable
>>> next(function())
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'coroutine' object is not iterable

```

像生成器一样，协程有 *send* 和 *throw* 方法，调用者可以用这些方法恢复它们:

```py
>>> function().send(None)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> function().throw(Exception)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 1, in function
Exception

```

协程可以*等待*其他协程，语义与从其他生成器生成的生成器相同:

```py
>>> async def returnsValue(value):
...     return 1
...
>>> async def awaitsCoroutine(c):
...     value = await c
...     print(value)
...
>>> awaitsCoroutine(returnsValue(1)).send(None)
1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

```

这种行为展示了协同程序合成的先决条件，但是`await`做一些立即返回值的事情并不能激发它们在异步编程中的使用。我们需要能够向一个暂停的协程发送一个任意值，但是因为`async`和`await`的目的是呈现一个与普通生成器不兼容的 API，我们既不能像`yield from`那样`await`一个普通生成器，也不能像`yield`那样省略它的操作数:

```py
>>> def plainGenerator():
...     yield 1
...
>>> async def brokenCoroutineAwaitsGenerator():
...     await plainGenerator()
...
>>> brokenCoroutineAwaitsGenerator().send(None)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in brokenCoroutineAwaitsGenerator
TypeError: object generator can't be used in 'await' expression
>>> async def brokenCoroutineAwaitsNothing():
...     await
  File "<stdin>", line 2
    await
        ^
SyntaxError: invalid syntax

```

为了学习如何用值恢复协程，我们回到`yield from`。我们之前的例子为`yield from`提供了另一个生成器，因此对包装生成器的`send`和`throw`方法的调用被代理到内部生成器。可能有许多生成器，每个生成器都通过`yield from`将执行委托给继任者，但是在底层，必须有一些东西产生向上的价值。例如，考虑一组五个发电机，如图 [2-4](#Fig4) 所示。

![../images/455189_1_En_2_Chapter/455189_1_En_2_Fig4_HTML.jpg](../images/455189_1_En_2_Chapter/455189_1_En_2_Fig4_HTML.jpg)

图 2-4

一堆发电机。`g1`到`g4`已经向下委托`g5`执行。

```py
>>> def g1(): yield from g2
...
>>> def g2(): yield from g3
...
>>> def g3(): yield from g4
...
>>> def g4(): yield from g5
...
>>> def g5(): yield 1

```

`g1`、`g2`、`g3`和`g4`不能取得任何进展，直到`g5`产生一个将从`g4`传播到`g1`的值。`g5`不必是发电机，但是；如下例所示，`yield from`只需要一个*可迭代对象*来推进它的生成器:

```py
>>> def yieldsToIterable(o):
...     print("Yielding from object of type", type(o))
...     yield from o
...
>>> list(yieldsToIterable(range(3)))
Yielding from object of type <class 'range'>
[0, 1, 2]

```

`yieldsToIterable`将执行委托给它的参数，在本例中是一个`range`对象。通过构建一个列表来迭代`yieldsToIterable`生成器，演示了`range`对象就像生成器一样接管迭代。

用`async def`定义的协程与`yield from`共享它们的实现，因此通过适当的步骤，它们也可以`await`特殊类型的可迭代程序和生成器。

与前面的例子显示的相反，只要生成器*被用`types.coroutine`装饰器标记为协程，它们就可以被等待。使用这种修饰生成器的协程接收该生成器的返回值:*

```py
>>> import types
>>> @types.coroutine
... def makeBase():
...     return (yield "hello from a base object")
...
>>> async def awaitsBase(base):
...     value = await base
...     print("From awaitsBase:", value)
...
>>> awaiter = awaitsBase(makeBase())
>>> awaiter.send(None)
'hello from a base object'
>>> awaiter.send("the result")
From awaits base: the result
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

```

用`send(None)`启动`awaitsBase`协程跳转到`base`生成器的`yield`语句，并遵循生成器的典型执行路径，返回`"hello from base object."`现在协程已将执行委托给`base`，因此`send("the result")`用该字符串恢复`base`。`base`立即`returns`这个值，这导致协程的`await`解析到它的值。

如果 Iterable 对象实现了一个返回迭代器的特殊的`__await__`方法，也可以等待它。这个迭代器的最终值——也就是说，无论它最后产生什么或者包装在一个`StopIteration`异常中——都将成为传递给`await`的结果。一个符合这个接口的物体被说成是*类未来*。当我们稍后探索`asyncio`时，我们将看到它的`Future`提供了这个接口，因此授予它它们的名字。

一个类似未来的对象的简单实现演示了控制流:

```py
class FutureLike(object):
    _MISSING="MISSING"
    def __init__(self):
        self.result = self._MISSING
    def __next__(self):
        if self.result is self._MISSING:
            return self
        raise StopIteration(self.result)
    def __iter__(self):
        return self
    def __await__(self):
        return iter(self)

async def awaitFutureLike(obj):
    result = await obj
    print(result)

obj = FutureLike()
coro = awaitFutureLike(obj)
assert coro.send(None) is obj
obj.result = "the result"
try:
    coro.send(None)
except StopIteration:
    pass

```

`FutureLike`的实例是可迭代的，因为它们的`__iter__`方法返回一个本身具有`__next__`方法的对象。在这种情况下，迭代一个`FutureLike`实例将一遍又一遍地产生同一个实例，直到它的`result`属性被设置，这时它将引发一个包含该值的`StopIteration`异常。这相当于来自发电机的`returning`值。

`FutureLike`的实例也是类似未来的，因为它们的`__await__`方法返回一个迭代器，所以`awaitFutureLike`可以`await`一个`FutureLike`的实例。通常，协程从`send(None)`开始。这将返回`awaitFutureLike`协程`await` s 的`FutureLike`实例，这是我们传递给它的同一个实例。设置`FutureLike`对象的`result`属性允许我们通过将其 await 解析为一个值来恢复协程，协程接收结果，打印结果，然后以一个`StopIteration`异常终止。

注意，第二个`coro.send`调用*也*将`None`传递给协程。协程，`await`类未来对象解析为这些对象的迭代器提供的最后一个值。它们仍然必须被恢复以利用这些值，但是它们必然会忽略它们的`send`方法的参数。

Twisted 提供了一个可适应的对象和一个协程适配器，这样协程和现有的 API 就可以无缝地交互。正如我们所见，协程与`asyncio`是完全分离的，所以我们在本节讨论的扭曲 API 不足以集成两者。我们将在下一章学习必要的附加 API。

## 等待延期

从 Twisted 16.4.0 开始，延迟是类似未来的对象，提供了一致的`__next__`、`__iter__`和`__await__`方法。这允许我们用一个`Deferred`替换前面代码中的`FutureLike`:

```py
from twisted.internet.defer import Deferred

async def awaitFutureLike(obj):
    result = await obj
    print(result)

obj = Deferred()
coro = awaitFutureLike(obj)
assert coro.send(None) is obj
obj.callback("the result")
try:
    coro.send(None)
except StopIteration:
    pass

```

`awaiting`一个`Deferred`解析为`Deferred`在其正常回调和错误返回处理循环后做的任何事情:

```py
>>> from twisted.internet.defer import Deferred
>>> import operator
>>> d = Deferred()
>>> d.addCallback(print, "was received by a callback")
<Deferred at 0x7eff85886160>
>>> d.addCallback(operator.add, 2)
<Deferred at 0x7eff85886160>
>>> async def awaitDeferred():
...     await d
...
>>> g = awaitDeferred()
>>> g.send(None)
<Deferred at 0x7eff85886160>
>>> d.callback(1)
1 was received by a callback
>>> g.send(None)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in awaitDeferred
  File "twisted/src/twisted/internet/defer.py", line 746, in send
    raise result.value
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

```

我们的`Deferred`的`print`回调运行，但返回`None`，导致第二次回调失败，当它试图向第一个参数添加 2 时，返回`TypeError`。恢复的协程因此失败，并且`TypeError`存储在`Deferred`中。

在这种情况下，协程和`Deferreds`的组合暴露了一个 bug，但是测试的代码路径表明错误和数据在两者之间自然地流动。

允许我们在协程中调用扭曲的 API，但是如果我们想让扭曲的 API 使用我们的协程呢？

## 使用 ensureDeferred 延迟的协同例程

Twisted 可以用`Deferreds`包装协程，允许期望`Deferreds`的 API 接受协程。

`twisted.internet.defer.` `ensureDeferred`接受一个协程对象并返回一个 Deferred，当协程返回一个:

```py
>>> from twisted.internet.defer import Deferred, ensureDeferred
>>> async def asyncIncrement(d):
...     x = await d
...     return x + 1
...
>>> awaited = Deferred()
>>> addDeferred = ensureDeferred(asyncIncrement(awaited))
>>> addDeferred.addCallback(print)
<Deferred at0x12345>
>>> awaited.callback(1)
2
>>>

```

我们的协程`asyncIncrement awaits`是一个解析为一个数字的对象，然后返回这个数字和 1 的和。我们用`ensureDeferred`将它转换成一个`Deferred`，分配给`addDeferred`，然后给它添加一个`print`回调。回调`asyncIncrement`等待的`awaited Deferred`依次回调`ensureDeferred`返回的`addDeferred Deferred`，而不需要我们调用`send`。换句话说，`addDeferred`的行为与手动构建的`Deferred`相同。异常传播也以同样的方式工作:

```py
>>>from twisted.internet.defer import Deferred, ensureDeferred
>>> async def asyncAdd(d):
...     x = await d
...     return x + 1
...
>>>awaited = Deferred()
>>>addDeferred = ensureDeferred(asyncAdd(awaited))
>>>addDeferred.addErrback(print)
Unhandled error in Deferred:

<Deferred at0x7eff857f0470>
>>>awaited.callback(None)
[Failure  instance:  Traceback:<  class 'TypeError'>:  ...
...
<stdin>:3:asyncAdd
]

```

协同程序比`Deferred`管理的回调更类似于同步代码，Twisted 使得使用协同程序变得足够容易，以至于你可能会怀疑`Deferred`是否会带来麻烦。一个显而易见的答案是它们已经被使用过了；许多扭曲的代码使用了`Deferred`,所以即使你很少使用它们，你仍然需要熟悉它们。不使用协程的另一个原因是，您必须编写在 Python 2 上运行的代码。随着 Python 2 寿终正寝，这已经不再是一个问题，PyPy，一个替代的 Python 运行时，它的实时(JIT)编译器可以极大地提高纯 Python 代码的速度，扩展了它们对 Python 3 的支持。

然而，为什么 Twisted 的`Deferreds`在一个后协同程序的世界里仍然有价值，还有一些不太明显但更持久的原因。

## 多路传输延迟

如果我们想要两个异步操作的结果，其中一个可能在另一个之前完成，会发生什么？例如，假设我们编写一个程序，同时发出两个 HTTP 请求:

```py
def issueTwo(url1, url2):
    urlDeferreds = [retrieveURL(url1), retrieveURL(url2)]
    ...

```

协程会让我们依次等待每一个:

```py
async def issueTwo(url1, url2):
    urlDeferreds = [retrieveURL(url1),  retrieveURL(url2)]
    for d in urlDeferreds:
        result = await d
        doSomethingWith(result)

```

当`issueTwo await`完成其中一个的时候，反应堆将继续回收`url1`和`url2`；等待`url1`的回收完成并不妨碍反应堆回收`url2`。这种并发性确实是异步和事件驱动编程的要点！

然而，随着操作变得更加复杂，这种效率变得不那么重要了。假设我们只想要首先检索的 URL。我们不能只使用`await`来写一个`fastestOfTwo`协程，因为我们不知道先给哪个`await`。只有反应器知道指示协程值准备就绪的底层事件何时发生，并且如果我们只有协程，事件循环将不得不暴露同步原语，该原语同时等待多个协程并检查是否所有协程都已完成。

幸运的是，无需特殊的反应堆级同步机制，多个`Deferreds`就可以轻松复用成单个`Deferred`。最简单地说，`twisted.internet.defer.DeferredList`是一个`Deferred`，它接受一个延期列表，并在所有这些`Deferreds`都有值时回调自己。

考虑以下代码:

```py
>>> from twisted.internet.defer import Deferred, DeferredList
>>>  url1 = Deferred()
>>>  url2 = Deferred()
>>> urlList = DeferredList([url1, url2])
>>> urlList.addCallback(print)
<Deferred at 0x123456>
>>> url2.callback("url2")
>>> url1.callback("url1")
[(True, "url1)", (True, "url2")]

```

`DeferredList` urlList 包装了两个`url1`和`url2 Deferreds`，并有一个`print`函数作为自己的回调函数。该回调仅在`url1`和`url2`都被回调后运行，因此`urlList`与上面的`issueTwo`协程中的全有或全无同步相匹配。

第一个线索是`DeferredList`更强大的特性集在于它返回给回调函数的`list`。每个元素是一个长度为 2 的`tuple`；第二个元素显然是传入的`list`中同一索引处的`Deferred`的值，所以索引 0 的第二个元组成员是`"url1"`，对应于索引 0 处的`url1 Deferred`。

`tuple`中的第一项表示`Deferred`是否成功终止。`url1`和`url2`都解析为字符串，而不是`Failures`，因此结果列表中相应的索引将`True`作为它们的第一个元素。

导致至少一个`DeferredList`的`Deferreds`失败演示了`Failures`是如何通信的:

```py
>>> succeeds = Deferred()
>>> fails = Deferred()
>>> listOfDeferreds = DeferredList([succeeds, fails])
>>> listOfDeferreds.addCallback(print)
<Deferred at 0x1234567>
>>> fails.errback(Exception())
>>> succeeds.callback("OK")
[(True, 'OK'), (False, <twisted.python.failure.Failure builtins.Exception: >)]

```

现在，返回列表中的第二个元组将`False`作为其第一个元素，并将代表导致其`Deferred`失败的`Exception`的`Failure`作为其第二个项目。

这个特殊的(`success`，`value or Failure`)对列表通过使用`Failures`的回溯捕获工具保留了所有可能的信息。作为这种方法带来的灵活性的一个例子，`DeferredList`的用户可以在一次回调中轻松地过滤聚合结果。

有了`DeferredList`的基本行为，我们可以研究允许我们实现`fastestOfTwo` : `fireOnOneCallback`的附加特性。

当`list`中的任何一个`Deferreds`有值时，`fireOnOneCallback`选项指示`DeferredList`回调自己:

```py
>>> noValue = Deferred()
>>> getsValue = Deferred()
>>> waitsForOne = DeferredList([noValue, getsValue], fireOnOneCallback=True)
>>> waitsForOne.addCallback(print)
<Deferred at 0x12345678>
>>> getsValue.callback("the value") ('the  value',  1)

```

现在，当只有`getsValue Deferred`解析为一个值时，`waitsForOne`的`print`回调就会运行。传递给回调函数的值`DeferredList`也是一个长度为 2 的`tuple`，但是这一次，第一项是对应的`Deferred`解析到的值，而第二项是它在列表中的索引。`getsValue`用`"the value,"`回调，它是我们传递给`DeferredList`的列表中的第二个项目，所以回调接收`("the value," 1)`作为结果。

我们现在可以实现`fastestOfTwo`:

```py
def fastestOfTwo(url1, url2):
    def extractValue(valueAndIndex):
        value, index = valueAndIndex
        return value
    urlList = DeferredList([retrieveURL(url1), retrieveURL(url2)],
                          fireOnOneCallback=True,
                          fireOnOneErrback=True)
    return urlList.addCallback(extractValue)

```

`DeferredList`也允许用`fireOnOneErrback`模拟多路传输错误。在第一个错误时触发`DeferredList`并展开它的值是一种常见的模式，Twisted 在`twisted.internet.defer.gatherResults`中提供了一个方便的包装器:

```py
>>> from twisted.internet.defer import Deferred, gatherResults
>>> d1, d2 = Deferred(), Deferred()
>>> results = gatherResults([d1, d2])
>>> results.addCallback(print)
<Deferred at 0x123456789>
>>> d1.callback(1)
>>> d2.callback(2)
>>> [1, 2]
>>> d1, d2 = Deferred(), Deferred()
>>> fails = gatherResults([d1,  d2])
>>> fails.addErrback(print)
<Deferred at 0x1234567890>
>>> d1.errback(Exception())
[[Failure instance: Traceback ...: <class 'Exception'>: ]]

```

回想一下，`Failure`的`__str__`方法返回一个以`[]`开始和结束的字符串，因此打印出的失败出现了两组括号:一组来自其`__str__`，另一组来自其包含的`list`。

还要注意的是`gatherResults`等待*所有*成功`Deferreds`，所以它不能用于`fastestOfTwo`

`DeferredList`和`gatherResults`提供了允许复杂行为但隐含分支的高级 APIs 每个选项的输出取决于它们自己的选项和它们包装的`Deferred`的输出之间的相互作用。任何一个方面的改变都可能导致意想不到的输出，从而产生令人不快的 bug。

这超出了`Deferred` s 的一般间接性:因为`Deferred.callback`几乎总是由反应器调用，而不是由间接操纵套接字的代码用户代码调用，所以在异常的来源和它的最终原因之间可能存在差距。

Twisted 通过提供对测试的特殊支持解决了异步代码固有的困难。

## 测试延期

在前一章中，我们看到 Twisted 的`trial.unittest`包提供了一个`SynchronousTestCase`，它的 API 模仿了`unittest.TestCase`的。事实上，`SynchronousTestCase`的 API 是`unittest.TestCase`的超集，它的附加特性的重要部分涉及到关于`Deferred`的断言

我们可以通过为上一节定义的`fastestOfTwo`函数编写测试来探索这些特性。首先，我们将把它一般化，接受任意两个`Deferreds`，而不是检索 URL 本身:

```py
def fastestOfTwo(d1, d2):
    def extractValue(valueAndIndex):
        value, index = valueAndIndex
        return value
    urlList = DeferredList([d1, d2],
                          fireOnOneCallback=True,
                          fireOnOneErrback=True)
    return urlList.addCallback(extractValue)

```

我们可以为这个新版本的`fastestOfTwo`编写的第一个测试断言，当它的两个`Deferreds`都没有解析为值时，它返回的`Deferred`没有解析为值:

```py
from twisted.internet import defer
from twisted.trial import unittest

class FastestOfTwoTests(unittest.SynchronousTestCase):
    def test_noResult(self):
        d1 = defer.Deferred()
        self.assertNoResult(d1)
        d2=defer.Deferred()
        self.assertNoResult(d2)
        self.assertNoResult(fastestOfTwo(d1, d2))

```

顾名思义，synchronoustestcase . assertnoresult 断言它所传递的延迟没有结果，这是一个很有价值的工具，可以确保执行符合您的预期。

然而，当它们确实有结果时，是最有用的。在`fastestOfTwo`的情况下，我们期望返回的`Deferred`取两个`Deferreds`中第一个的值:

```py
def test_resultIsFirstDeferredsResult(self):
    getsResultFirst = defer.Deferred()
    neverGetsResult = defer.Deferred()
    fastestDeferred = fastestOfTwo(getsResultFirst, neverGetsResult)
    self.assertNoResult(fastestDeferred)
    result = "the result"
    getsResultFirst.callback(result)
    actualResult = self.successResultOf(fastestDeferred)
    self.assertIs(result, actualResult)

```

`SynchronousTestCase.successResultOf`要么返回`Deferred`的当前结果，要么导致其测试失败。我们的测试在用它回调`getsResultFirst`之后，用它从`fastestDeferred`中提取`"the result"`，这样测试可以断言`fastestOfTwo`确实返回了第一个可用的结果。

注意，在我们回调`getsResultFirst`之前，我们仍然断言`fastestOfTwo`返回的`Deferred`没有结果。鉴于`test_noResult`已经做出了这个断言，这看起来可能是多余的，但是请记住，在您的代码添加回调或错误返回之前，可以回调`Deferred` s。在这种情况下，`fastestOfTwo`可能会错误地返回一个已经用`the result`回调的`Deferred`，而忽略传入的`Deferred` s，然而我们的测试仍然会通过。这在如此简单的代码中是不太可能的，但是当 a `Deferred`得到结果时，关于*的隐含假设可能会潜入代码中，导致测试忽略 bug。断言`Deferred`实际上处于给定的状态是一种好的做法，而不是假设这样以避免这些错误，并且更好的做法是针对已经有结果的`Deferred`和没有结果的`Deferred`来测试您的代码。*

我们可以添加一个测试，断言即使在`Deferred`已经触发时`fastestOfTwo`也能工作:

```py
def test_firedDeferredIsFirstResult(self):
    result = "the result"
    fastestDeferred = fastestOfTwo(defer.Deferred(),
                                 defer.succeed(result))
    actualResult = self.successResultOf(fastestDeferred)
    self.assertIs(result, actualResult)

```

`twisted.internet.defer.succeed`函数接受一个参数并返回一个`Deferred`,这个参数会立即被回调，所以`fastestOfTwo`的第二个参数是一个`Deferred`,在任何`fastestOfTwo`运行之前，它已经被用`the result`回调了。

为了完整起见，我们还可以测试当`fastestOfTwo`收到两个已经被回调的`Deferreds`时会发生什么:

```py
def test_bothDeferredsFired(self):
    first = "first"
    second = "second"
    fastestDeferred = fastestOfTwo(defer.succeed(first),
                                 defer.succeed(second))
    actualResult = self.successResultOf(fastestDeferred)
    self.assertIs(first, actualResult)

```

底层的`DeferredList`将其内部处理回调按顺序添加到其列表中的每个`Deferreds`中。有了`fireOnOneCallback=True`，列表中最早有结果的`Deferred`回调代表列表的`Deferred`。在我们的测试中，我们期望`first`是回调`fastestDeferred`的值。

错误处理是测试的关键部分，所以我们对`fastestDeferred`的测试也应该测试它如何处理`Failure`。为了保持测试简短，我们将只展示在`Deferred`被传递到`fastestOfTwo`之前失败的情况:

```py
def test_failDeferred(self):
    class ExceptionType(Exception):
        pass
fastestDeferred = fastestOfTwo(defer.fail(ExceptionType()),
                             defer.Deferred())
failure = self.failureResultOf(fastestDeferred)
failure.trap(defer.FirstError)
failure.value.subFailure.trap(ExceptionType)

```

像`SynchronousTestCase.successResultOf`，`SynchronousTestCase.failureResultOf`从一个`Deferred`返回当前的`Failure`；如果`Deferred`还没有被调用或者没有`-Failure`结果，`failureResultOf`导致测试失败。

因为返回的对象是一个`Failure`，所以我们可以在 errbacks 中使用的所有方法和属性在我们的测试中都是可用的。`DeferredList`用`fireOnOneErrback=True`将失败包装在`twisted.internet.defer.FirstError`异常中，所以我们在测试中使用了`trap`这种类型；如果`Failure`包装了任何其他异常，`trap`将再次引发它。导致`FirstError`的底层`Failure`在其`subFailure`属性上是可访问的，并且由于我们传入了`ExceptionType`的一个实例，我们`trap`断言第一个`Deferred`由于预期的原因而失败。

使用`successResultOf`和`failureResultOf`的`assertNoResult`鼓励使用关于`Deferred`状态的显式假设来编写测试。正如`fastestOfTwo`所展示的，即使是对`Deferred`的简单使用也必须进行隐式排序依赖和错误处理测试。这些也是协程和任何其他并发原语的关注点。Twisted 的测试套件自然拥有在`Deferred`环境中处理常见并发问题的最佳工具。

## 摘要

这一章通过解释事件处理程序是一种`_callback_`的方式，继承了上一章未完成的事件驱动编程。由于*延续传递式*的理论力量，非常复杂的程序可以用回调来表达。回调通过直接调用其他回调来传递值，而不是返回给它们的调用者。我们将这种组合命名为*内部组合*,因为它发生在每个回调的主体中。

内部组合使得维护回调驱动的程序变得困难:每个回调都必须知道它的后继者的名字和签名，这样它才能调用它。对一系列回调进行重新排序或消除一个回调可能需要修改几个回调。一个解决方案在于*异步编程*的范例，它允许程序在所有输入准备好之前继续运行。代表异步结果的*占位符值*可以收集回调，然后在真实值可用时运行它们。这个占位符允许回调返回值，从而在外部组合*，反过来使得逻辑单元不知道它们是如何以及在哪里被使用的。使用这些异步占位符的事件驱动代码可以像非回调驱动代码一样被分解。*

 *Twisted 的异步占位符值是`Deferred`。我们看到`Deferred`在一个循环中运行它们的回调，将一个的结果传递给下一个，并在任何异常时调用错误处理程序或错误返回。T2 内部的这个处理循环使它们成为强大的控制流抽象 T4。

控制流抽象的一个重要部分是以不同的方式响应不同的错误。Twisted 的`Failure`类捕获回溯信息以及引发的异常，并公开允许 errbacks 过滤和重新引发异常的实用方法。我们看到了回调和错误返回如何完全代表使用`try`和`except`的同步代码。

就像回调允许组合一样，它们自己组合。当回调或错误返回一个`Deferred`时，该回调或错误自身的`Deferred`暂停其执行，直到新的`Deferred`完成。这意味着返回`Deferred`的函数和方法可以被用作回调和错误返回，而不需要开发人员做任何特别的努力。

尽管`Deferred`功能强大，但它们并不是组成异步动作的唯一方式。Python 的*生成器*可以暂停它们的执行，并在从外部来源接收到值后继续执行。这个控制流映射到由延迟器提供的控制流，回调和错误可以通过使用`inlineCallbacks`转移到生成器中。

然而，生成器是不明确的，因为它们可能表示简单的迭代器或类似于`Deferred`的控制流。Python 3.5 增加了对*协程*的特殊支持，这些协程是以控制流为中心的生成器，可以通过将执行委托给其他协程来挂起自己，而不需要`inlineCallbacks`。协程可以`await`直接扭曲`Deferred`的，可以用`ensureDeferred`变成`Deferred`的。这些 API 允许 Twisted 无缝地使用协程。

不是所有的程序都可以用协程直接表达:我们的`fastestOfTwo`例子需要同时等待两件事情。幸运的是，`DeferredList`，一个建立在`Deferreds`之上的抽象，允许 Twisted 去复用的异步结果。

Twisted 还特别支持测试`Deferred`s。`SynchronousTestCase`提供了`assertNoResult`、`successResultOf`和`failureResultOf`，允许测试对`Deferred` s 的状态做出精确的断言。影响所有原语(协程、生成器和`Deferred` s)的并发问题可以用这套工具进行测试。****