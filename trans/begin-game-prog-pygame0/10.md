# 10.人工智能

电脑游戏中的人工智能(AI)是通过编程让电脑表现得像有智能一样。一般来说，这可能是显示由计算机控制的角色或对象背后的智能。

这通常不同于人们经常与人工智能联系在一起的机器学习。机器学习是一种与语音识别或模式识别等其他系统相关联的人工。

在电脑游戏中，人工智能可以像敌人采取的预先确定的路线一样简单，也可以包括一些复杂的算法，跟踪玩家的移动并以逼真的方式做出反应。为了更好地工作，需要为玩家设置一个合适的难度。机器学习的问题是，如果你用它来创造一个对手，那么它可能会变得不可战胜，而不仅仅是具有挑战性。机器学习可能更适合创建逼真的背景或特效。

当我提到人工智能时，我实际上是在寻找可以用来创建适当级别的计算机播放器的算法。这一章将会看到一些可以应用到游戏中的简单人工智能的例子，以及一些关于如何制作一个计算机播放器的理论和一些代码例子。

## 人工智能记忆游戏

从第 9 章[到第 9 章](09.html)的记忆游戏目前是一个试图超越时间的案例。这是一个小小的挑战，但和与对手比赛是不一样的。相反，创造一个人工智能玩家来对抗是可能的。为了设计 AI 播放器，考虑人们通常如何玩游戏，挑战是什么，以及他们使用什么策略来获胜。顾名思义，游戏中的挑战是记忆。如果你能在翻牌时记住所有的牌，那么赢得比赛的机会就大大增加了。也有一个运气的因素，我们可以考虑到人工智能。我也将展示人工智能可以被调整来创造不同的困难。

在我第一次尝试重写代码时，我在现有文件中添加并更改了代码。随着这种情况的发展，代码变得又长又混乱，这是一个典型的糟糕的例子。为了解决这个问题，我重构了代码，添加了新的类来简化程序。随着代码的增加，会有多个不同的类，跟踪文件变得更加困难。让这一点更容易理解的一个方法是创建一个图表来显示类之间的关系。为此，我创建了一个 UML 类图，如图 [10-1](#Fig1) 所示。该图只是一个近似值，因为包含所有的属性和方法会显得过于拥挤。它还将顶级 memory.py 文件显示为一个类，这是不正确的。尽管它不是一个“纯粹的”UML 文件，但它对于展示程序如何工作是很有用的。

![../images/488486_1_En_10_Chapter/488486_1_En_10_Fig1_HTML.jpg](Images/488486_1_En_10_Fig1_HTML.jpg)

图 10-1

记忆游戏的 UML 类图

图上的线条和箭头显示了类之间的关系。三角形箭头表示继承，其中子节点从父节点继承属性和方法。实心菱形显示组合关系，也称为“具有”关系，因为该类具有该类的一个或多个实例。大多数组合是 1 对 1 的(为了简单起见，省略了数字)，但是 CardTable 包含一对多关系(1:∑)中的多个卡片实例。

代码文件包含在名为 memorygame2 的目录中的源代码中。第一类是卡片类。这个类与以前的版本相比只有一些变化。代码如清单 [10-1](#PC1) 所示。

```
from pgzero.actor import Actor

# Card is based on an Actor (uses inheritance)
class Card(Actor):

    def __init__(self, name, back_image, card_image):
        Actor.__init__(self, back_image, (0,0))
        self.name = name
        self.back_image = back_image
        self.card_image = card_image
        # Status can be 'back' (turned over) 'front' (turned up) or 'hidden' (already used)
        self.status = 'back'
        # Number is unique number based on position
        # count left to right, top to bottom
        # updated after dealt
        self.number = None

    # Override Actor.draw
    def draw(self):
        if (self.status == 'hidden'):
            return
        Actor.draw(self)

    def turn_over(self):
        if (self.status == 'back'):
            self.status = 'front'
            self.image = self.card_image
        elif (self.status == 'front'):
            self.status = 'back'
            self.image = self.back_image
        # Attempt to turn over a hidden card - ignore
        else:
            return

    def hide(self):
        self.status = 'hidden'

    # When unhide set it to back image
    def unhide (self):
        self.status = 'back'
        self.image = self.back_image

    def is_hidden (self):
        if self.status == 'hidden':
            return True
        return False

    # Is it turned to face forward
    def is_faceup (self):
        if self.status == 'front':
            return True
        return False

    # Is it turned to face down
    def is_facedown (self):
        if self.status == 'back':
            return True
        return False

    def reset (self):
        self.unhide()

    def set_position(self, x, y):
        self.x = x
        self.y = y

    def equals (self, othercard):
        if self.name == othercard.name:
            return True
        return False

Listing 10-1Card class for AI memory game

```

一个新的类是 CardTable 类，创建它是为了简化 memory.py 文件中的一些代码。它包含了所有卡片的列表。它还包括设置牌桌，发牌，然后在屏幕上把它们都画出来的方法。有一个方法可以返回所有面朝下的牌，这是人工智能需要知道它可以从哪些牌中选择的。还有一种方法是测试是否到达关卡末尾(所有牌都配对成功)。

CardTable 类的代码如清单 [10-2](#PC2) 所示。

```
import random
from card import Card

class CardTable:

    def __init__ (self, card_back, cards_available):
        self.cards = []
        # Create individual card objects, two per image
        for key in cards_available.keys():
            # Add to list of cards
            self.cards.append(Card(key, card_back, cards_available[key]))
            # Add again (to have 2 cards for each img)
            self.cards.append(Card(key, card_back, cards_available[key]))

    def draw_cards(self):
        for this_card in self.cards:
            this_card.draw()

    # Set the table settings
    def setup_table(self, card_start_x, card_start_y, num_cards_per_row, x_distance_between_cards, y_distance_between_cards):
        self.card_start_x = card_start_x

        self.card_start_y = card_start_y
        self.num_cards_per_row = num_cards_per_row
        self.x_distance_between_cards = x_distance_between_cards
        self.y_distance_between_cards = y_distance_between_cards

    # Returns all cards that are face down as Card objects
    def cards_face_down(self):
        selected_cards = []
        for this_card in self.cards:
            if (this_card.is_facedown()):
                selected_cards.append(this_card)
        return selected_cards

    # Shuffle the cards and update their positions
    def deal_cards(self):
        # Create a temporary list of card indexes that is then shuffled
        keys = []
        for i in range (len(self.cards)):
            keys.append(i)
        random.shuffle(keys)

        # Setup card positions
        xpos = self.card_start_x
        ypos = self.card_start_y
        cards_on_row = 0
        # Give each card number based on position
        # count left to right, top to bottom
        card_number = 0
        for key in keys:
            # Reset (ie. unhide if hidden and display back)
            self.cards[key].reset()
            self.cards[key].number = card_number
            self.cards[key].set_position(xpos,ypos)
            xpos += self.x_distance_between_cards

            cards_on_row += 1
            # If reached end of row - move to next
            if (cards_on_row >= self.num_cards_per_row):
                cards_on_row = 0
                xpos = self.card_start_x
                ypos += self.y_distance_between_cards
            card_number += 1

    # If reach end of level
    def end_level_reached(self):
        for card in self.cards:
            if (not card.is_hidden()):
                return False
        return True

    def check_card_clicked (self, pos):
        for this_card in self.cards:
            # If not facedown then skip
            if (not this_card.is_facedown()):
                continue
            if (this_card.collidepoint(pos)):
                return this_card
        return None

Listing 10-2CardTable class file

```

GamePlay 类是之前 GamePlay 类的简化版本。分数属性已经被删除，因为它现在由玩家类处理，为每个玩家提供分数。还有额外的状态属性和方法来处理第二个玩家。游戏类的代码包含在清单 [10-3](#PC3) 中。

```
# State is tracked as a number, but to make the code readable constants are used
STATE_NEW = 0               # Game ready to start, but not running
STATE_PLAYER1_START = 10   # Player 1 to turn over card
STATE_PLAYER1_CARDS_1 = 11 # Card 1 turned over
STATE_PLAYER1_CARDS_2 = 12 # Card 2 turned over
STATE_PLAYER2_START = 20   # Player 2 starts go
STATE_PLAYER2_WAIT = 21    # Delay before Card 1 turned over
STATE_PLAYER2_CARDS_1 = 22 # Card 1 turned over
STATE_PLAYER2_CARDS_2 = 23 # Card 2 turned over
STATE_END = 50

# Number of seconds to display high score before allowing click to continue
TIME_DISPLAY_SCORE = 3

class GamePlay:

    def __init__ (self):
        self.state = STATE_NEW

    # If game has not yet started
    def is_new_game(self):
        if self.state == STATE_NEW:
            return True
        return False

    def is_game_over(self):
        if self.state == STATE_END:
            return True
        return False

    def is_player_1(self):
        if (self.state >= STATE_PLAYER1_START and self.state <= STATE_PLAYER1_CARDS_2):
            return True
        return False

    def is_player_2(self):
        if (self.state >= STATE_PLAYER2_START and self.state <= STATE_PLAYER2_CARDS_2):
            return True
        return False

    def is_player_2_start(self):
        if (self.state == STATE_PLAYER2_START):
            return True

        return False

    def is_player_2_wait(self):
        if (self.state == STATE_PLAYER2_WAIT):
            return True
        return False

    def is_player_2_card1(self):
        if (self.state == STATE_PLAYER2_CARDS_1):
            return True
        return False

    def is_player_2_card2(self):
        if (self.state == STATE_PLAYER2_CARDS_2):
            return True
        return False

    def set_player_2_wait(self):
        self.state = STATE_PLAYER2_WAIT

    def set_player_2_card1(self):
        self.state = STATE_PLAYER2_CARDS_1

    def set_player_2_card2(self):
        self.state = STATE_PLAYER2_CARDS_2

    def start_game(self):
        self.state = STATE_PLAYER1_START

    def set_game_over(self):
        # player gets to see high score

        self.state = STATE_END

    def is_game_running(self):
        if (self.state >= STATE_PLAYER1_START and self.state < STATE_END):
            return True
        return False

    # Continue with current player (matched correctly)
    def continue_player (self):
        if self.state <= STATE_PLAYER1_CARDS_2:
            self.state = STATE_PLAYER1_START
        else:
            self.state = STATE_PLAYER2_START

    # Switch to next player (not matched)
    def next_player (self):
        if self.state <= STATE_PLAYER1_CARDS_2:
            self.state = STATE_PLAYER2_START
        else:
            self.state = STATE_PLAYER1_START

    def set_new_game(self):
        self.state = STATE_NEW

    def is_pair_turned_over(self):
        if (self.state == STATE_PLAYER1_CARDS_2):
            return True
        return False

    # If a card is clicked then update the state accordingly
    def card_clicked(self):
        if (self.state == STATE_PLAYER1_START):
            self.state = STATE_PLAYER1_CARDS_1
        elif (self.state == STATE_PLAYER1_CARDS_1):
            self.state = STATE_PLAYER1_CARDS_2

Listing 10-3GamePlay class file

```

Timer 类与前面的相同，但是使用方式不同。它不是用来作为玩家对战的计时器，而是用来为人工智能玩家添加延迟，以便人类玩家可以看到计算机正在翻的牌。清单 [10-4](#PC4) 中显示了 Timer 类。

```
import math
import time

class Timer():

    def __init__(self, start_count):
        self.start_count = start_count
        self.start_time = time.time()

    # start count down, with optional parameter to replace the start_count value
    # -1 is used as a "magic number", this method should only be called with positive number
    # if it isn't given a number then -1 indicates no new time give
    def start_count_down(self, new_time = -1):
        if (new_time >= 0):
            self.start_count = new_time
        self.start_time = time.time()

    def get_time_remaining(self):
        current_time = self.start_count + self.start_time - time.time()
        if (current_time <= 0):
            return 0
        return math.ceil(current_time)

Listing 10-4Timer class file

```

玩家类在早期版本中被考虑过，但当时并不需要。随着 AI 的加入，为玩家提供一个独立的职业变得更加有用。这是一个简单的类，保存玩家和卡片选择的分数。它使用 card 类，该类具有在`select_card`方法期间传递的卡的实例，然后使用`get_card`方法返回它。这就是图 [10-1](#Fig1) 中玩家和卡类之间构成的原因。播放器类的代码如清单 [10-5](#PC5) 所示。

```
from card import Card

class Player():

    def __init__ (self):
        # Track which cards are turned over
        self.guess = [None, None]
        self.score = 0

    def score_point (self):
        self.score += 1

    # Returns a single card object - either 0 or 1
    def get_card (self, card_number):
        return self.guess[card_number]

    # Reset cards held in hand, but does not hide / turn_over card
    def reset_cards(self):
        self.guess[0] = None
        self.guess[1] = None

    def select_card(self, card):
        if (self.guess[0] == None):
            self.guess[0] = card

        else:
            self.guess[1] = card

    # Returns the number of cards that are selected
    def num_cards_selected(self):
        if (self.guess[0] == None):
            return 0
        elif (self.guess[1] == None):
            return 1
        else:
            return 2

Listing 10-5Player class file

```

最后一个类文件包含 PlayerAi 类，它继承了 Player 类，增加了 Ai 玩家进行随机猜测的能力。这是人工智能的一个非常基本的形式，稍后会详细介绍。代码包含在清单 [10-6](#PC6) 中。

```
import random
from player import Player

class PlayerAi (Player):

    def __init__(self):
        Player.__init__(self)

    def make_guess(self, available_cards):
        self.guess_random(available_cards)

    def guess_random (self, available_cards):
        this_guess = random.choice(available_cards)
        this_guess.turn_over()
        self.select_card(this_guess)

    def get_card (self, card_number):
        return self.guess[card_number]

Listing 10-6Player class file

```

最后，memory.py 文件已经更新。用户交互仍然在`on_mouse_down`函数中处理，但是它现在在更新函数中包括了 AI 播放器。每当人工智能玩家执行一个操作，都会有一个由`timer.start_count_down`触发的延迟，这有效地暂停了人工智能的任何操作，直到`timer.get_time_remaining`显示时间已经超过。这显示在清单 [10-7](#PC7) 中。

```
# Memory Card Game - PyGame Zero
import random

from card import Card
from gameplay import GamePlay
from player import Player
from playerai import PlayerAi
from timer import Timer
from cardtable import CardTable

# These constants are used to simplify the game
# For more flexibility these could be replaced with configurable variables
# (eg. different number of cards for different difficulty levels)
NUM_CARDS_PER_ROW = 4
X_DISTANCE_BETWEEN_CARDS = 120
Y_DISTANCE_BETWEEN_CARDS = 120
CARD_START_X = 220
CARD_START_Y = 130

TITLE = "Lake District Memory Game"
WIDTH = 800
HEIGHT = 600

cards_available = {
    'airafalls' : 'memorycard_airafalls',
    'ambleside' : 'memorycard_ambleside',
    'bridgehouse' : 'memorycard_bridgehouse',
    'derwentwater' : 'memorycard_derwentwater',
    'ravenglassrailway' : 'memorycard_ravenglassrailway',
    'ullswater' : 'memorycard_ullswater',
    'weatherstone' : 'memorycard_weatherstone',
    'windermere' : 'memorycard_windermere'
    }

card_back = "memorycard_back"

## Setup instance variables

game_state = GamePlay()
player1 = Player()
ai = PlayerAi()
# Timer is used for AI thinking time
timer = Timer(2)
all_cards = CardTable(card_back, cards_available)
all_cards.setup_table(CARD_START_X, CARD_START_Y, NUM_CARDS_PER_ROW, X_DISTANCE_BETWEEN_CARDS, Y_DISTANCE_BETWEEN_CARDS)
all_cards.deal_cards()

def update():
    if (game_state.is_player_2_start()):
        timer.start_count_down()
        game_state.set_player_2_wait()
    if (game_state.is_player_2_wait()):
        if (timer.get_time_remaining() <= 0):
            ai.make_guess(all_cards.cards_face_down())
            timer.start_count_down()
            game_state.set_player_2_card1()
    # card 1 turned

    elif (game_state.is_player_2_card1()):
        if (timer.get_time_remaining() <= 0):
            ai.make_guess(all_cards.cards_face_down())
            timer.start_count_down()
            game_state.set_player_2_card2()
    # Card 2 selected - wait then check if matches
    elif (game_state.is_player_2_card2()):
        if (timer.get_time_remaining() <= 0):
                if ai.get_card(0).equals(ai.get_card(1)):
                    # If match add points and hide the cards
                    ai.score_point()
                    ai.get_card(0).hide()
                    ai.get_card(1).hide()
                    ai.reset_cards()
                    # Game Over
                    if (all_cards.end_level_reached()):
                        game_state.set_game_over()
                    # If user guess correct then they get another attempt
                    else:
                        game_state.continue_player()
                # If not match then turn both around
                else:
                    ai.get_card(0).turn_over()
                    ai.get_card(1).turn_over()
                    ai.reset_cards()
                    game_state.next_player()

# Mouse clicked

def on_mouse_down(pos, button):
    # Only interested in the left button
    if (not button == mouse.LEFT):
        return
    # If new game then this click is to start the game
    if (game_state.is_new_game() or game_state.is_game_over()):
        game_state.start_game()
        all_cards.deal_cards()
        player1.score = 0
        ai.score = 0
        return

    ## Reach here then we are in game play
    # Is it player1's turn
    if (game_state.is_player_1()):
        # Check for both already clicked and this is a click to test
        if (game_state.is_pair_turned_over()):
            if (player1.get_card(0).equals(player1.get_card(1))):
                # If match add points and hide the cards
                player1.score_point()
                player1.get_card(0).hide()
                player1.get_card(1).hide()
                player1.reset_cards()
                # End of game
                if (all_cards.end_level_reached()):
                    game_state.set_game_over()
                # If user guess correct then they get another attempt
                else:
                    game_state.continue_player()
            # If not match then turn both around
            else:
                player1.get_card(0).turn_over()
                player1.get_card(1).turn_over()
                player1.reset_cards()
                game_state.next_player()
            return

        # Check if clicked on a card
        card_clicked = all_cards.check_card_clicked(pos)
        if (card_clicked != None):
            card_clicked.turn_over()
            player1.select_card(card_clicked)
            # Update state
            game_state.card_clicked()

def draw():
    screen.fill((220, 220, 220))
    if (game_state.is_new_game()):
        screen.draw.text("Click mouse to start", fontsize=60, center=(WIDTH/2,HEIGHT/2), shadow=(1,1), color=(255,255,255), scolor="#202020")
    if (game_state.is_game_over()):
        screen.draw.text("Game Over\nPlayer 1 score: "+str(player1.score)+"\nPlayer 2 (AI) score: "+str(ai.score), fontsize=60, center=(WIDTH/2,HEIGHT/2), shadow=(1,1), color=(255,255,255), scolor="#202020")
    if (game_state.is_game_running()):
        # Set colors based on which player is selected
        if (game_state.is_player_1()):
            player1_color = (0,0,0)
            player2_color = (128,128,128)
        else:
            player1_color = (128,128,128)
            player2_color = (0,0,0)
        all_cards.draw_cards()
        screen.draw.text("Player 1: "+str(player1.score), fontsize=40, bottomleft=(50,50), color=player1_color)
        screen.draw.text("Player 2 (AI): "+str(ai.score), fontsize=40, bottomleft=(550,50), color=player2_color)
        # Display computer status during ai turns
        if (game_state.is_player_2_wait() or game_state.is_player_2_card1()):
            screen.draw.text("Thinking which card to pick", fontsize=40, center=(WIDTH/2,HEIGHT/2), shadow=(1,1), color=(255,255,255), scolor="#202020")

Listing 10-7The main memory.py file with basic AI

```

这可以运行和发挥，但非常容易击败。游戏每次只是随机选择一张牌，所以直到只剩下几张牌的时候，他们得到匹配的概率都很小。

### 美好的记忆

为了让游戏更有挑战性，我们可以让电脑记住所做的猜测。由于播放器代码与代码的其余部分是分离的，所以只有两个文件需要更新。这些文件包含 Player 类和 PlayerAi 类。这里将列出两个修改过的文件，但是完整的源代码包含在 memory3 目录中。

首先，需要有一个地方来存放已经看过的卡片。如果看到的牌存储在 PlayerAi 类中，那么它只会看到 Ai 玩家翻出来的牌。如果卡片被存储在玩家类中，那么就有可能存储所有由人类玩家和人工智能玩家翻开的卡片。

将列表保存为类变量而不是实例变量将使它对所有实例可见，包括子类的所有实例。这是通过将变量放在类的顶部来实现的，如下所示:

```
class Player():
    card_memory = {}
    click_order = []

```

这里创建了两个变量:`card_memory`是一个保存卡片的字典，其中包含卡片名称的索引，`click_order`是一个列表，它记录了卡片被点击的顺序。目前实际上并不需要第二个，但是现在添加它将简化下一个阶段。

每当出现一张牌时，为了更新类变量，需要将以下内容添加到`select_card`方法中:

```
Player.card_memory[card.number] = card

```

由于这个方法是由 PlayerAi 继承的，因此每当人类玩家或电脑玩家翻牌时都会调用它。在一个新游戏开始时，这些变量也需要被重置，这个新游戏是在一个静态方法`reset_cards`中实现的。更新后的 player.py 文件如清单 [10-8](#PC10) 所示。

```
from card import Card

class Player():

    # Index of cards that ai remembers
    # Stored as dictionary as cards will be missing or be forgotten
    card_memory = {}
    click_order = []

    def __init__ (self):
        # Track which cards are turned over
        self.guess = [None, None]
        self.score = 0

    @staticmethod
    def new_game():
        Player.card_memory = {}
        Player.click_order = []

    def score_point (self):
        self.score += 1

    # Returns a single card object - either 0 or 1
    def get_card (self, card_number):
        return self.guess[card_number]

    # Reset cards held in hand, but does not hide / turn_over card
    def reset_cards(self):
        self.guess[0] = None
        self.guess[1] = None

    def select_card(self, card):
        if (self.guess[0] == None):
            self.guess[0] = card
        else:
            self.guess[1] = card
        Player.card_memory[card.number] = card

    # Returns the number of cards that are selected
    def num_cards_selected(self):
        if (self.guess[0] == None):
            return 0
        elif (self.guess[1] == None):
            return 1
        else:
            return 2

Listing 10-8Updated Player class to add improved AI

```

PlayerAi 类中添加了三种不同的方法，展示了实现改进内存的不同方式。更新后的源代码如清单 [10-9](#PC11) 所示。每种新方法将在后面解释。

```
import random
from player import Player

class PlayerAi (Player):

    def __init__(self):
        Player.__init__(self)

    def make_guess(self, available_cards):
        #self.guess_random(available_cards)
        #self.guess_remember_all(available_cards)
        #self.guess_remember_sometimes(available_cards)
        self.guess_remember_recent(available_cards)

    def guess_random (self, available_cards):
        this_guess = random.choice(available_cards)
        this_guess.turn_over()
        self.select_card(this_guess)

    def guess_remember_all (self, available_cards):
        # If first guess then use random
        if (self.guess[0] == None):
           self.guess_random(available_cards)
           return
        # Search to see if we have seen a matching card
        for search_card in Player.card_memory.values():
            # ignore if current card - or card has been hidden since
            if (search_card == self.guess[0] or search_card.is_hidden()):
                continue
            # Check to see if the card matches
            if (search_card.equals(self.guess[0])):
                search_card.turn_over()
                self.select_card(search_card)
                return
        # If not found the matching card then use random
        self.guess_random(available_cards)

    def guess_remember_sometimes (self, available_cards):
        # If first guess then use random
        if (self.guess[0] == None):
           self.guess_random(available_cards)
           return
        # Random whether make a proper guess or random guess
        if (random.randint(1,10) < 5):
            self.guess_random(available_cards)
            return
        # Search to see if we have seen a matching card
        for search_card in Player.card_memory.values():
            # ignore if current card - or card has been hidden since
            if (search_card == self.guess[0] or search_card.is_hidden()):
                continue
            # Check to see if the card matches
            if (search_card.equals(self.guess[0])):
                search_card.turn_over()
                self.select_card(search_card)
                return
        # If not found the matching card then use random
        self.guess_random(available_cards)

    def guess_remember_recent (self, available_cards):
        # If first guess then use random
        if (self.guess[0] == None):
           self.guess_random(available_cards)
           return
        # Get last 4 cards that were clicked
        # These are just card numbers

        recent_cards = Player.click_order[:-4]
        # Search to see if one of those is a matching card
        for search_card in Player.card_memory.values():
            # ignore if current card - or card has been hidden since
            if (search_card == self.guess[0] or search_card.is_hidden()):
                continue
            # ignore if not a recent card
            if (search_card.number not in recent_cards):
               continue
            # Check to see if the card matches
            if (search_card.equals(self.guess[0])):
                search_card.turn_over()
                self.select_card(search_card)
                return
        # If not found the matching card then use random
        self.guess_random(available_cards)

    def get_card (self, card_number):
        return self.guess[card_number]

Listing 10-9Updated PlayerAi class to add improved AI

```

新方法的第一个是`guess_remember_all`，它会记住每一张翻过来的牌。该方法从选择一张随机卡片开始。如果相应的对子已经翻了，那么它会翻相应的牌。这是通过在`Player.card_memory.values`中查找卡片来处理的，该卡片返回字典中所有值的列表。该方法的关键部分如下:

```
for search_card in Player.card_memory.values():

```

这是一个循环遍历字典中所有值的 for 循环。该值是保存在变量`search_card`中的卡对象。然后，它使用

```
if (search_card.equals(self.guess[0])):

```

如果它与先前翻过来的牌匹配，那么它使用

```
search_card.turn_over()
self.select_card(search_card)

```

由于这种方法记住了每一张翻开的牌，所以这是一个很难攻克的关卡。如果你有一个好的记忆或者你选择的牌非常幸运，那么击败它是可能的，但是这是令人沮丧的困难。

下一个方法叫做`guess_remember_sometimes`。顾名思义，它能记住以前的卡片，但只是有时候。这是基于随机检查来确定是否从存储器中搜索卡。这与`guess_remember_all`基本相同，除了以下附加代码:

```
if (random.randint(1,10) < 5):
    self.guess_random(available_cards)
    return

```

它创建一个介于 1 和 10 之间的随机数。如果数字小于 5，则它执行随机猜测。如果数字为 5 或更大，则它在存储器中搜索该卡。要比较的值(在本例中为 5)可以上下调整，以提高成功猜测的概率。

这给出了一个合理的难度水平，但不是特别现实。原因是人类玩家通常比之前翻的牌更容易记住最近翻的牌。

最后一个方法叫做`guess_remember_recent`。这为电脑玩家提供了短期记忆。所有翻过来的牌仍然存储在字典中，但是计算机在检查匹配时只使用在`Player.click_order`变量中列出的最近的牌。

这是通过创建一个单独的列表来实现的，该列表只保存`click_order`列表的最后四个条目。

```
recent_cards = Player.click_order[:-4]

```

然后，当检查匹配时，它使用以下内容跳过不在`recent_cards`列表中的任何卡:

```
if (search_card.number not in recent_cards):
               continue

```

你可以试着调整电脑浏览的最近卡片数量来改变难度。

你还可以做其他的事情来让它看起来更真实。例如，你可以将这些技术结合起来，使电脑玩家的行为更自然，因为它对最近的牌有很好的记忆，但随着牌越翻越多，随机猜对的可能性就越小。这是留给读者的一个练习。

如果你看一下`make_guess`方法，你可以看到除了`guess_remember_recent`方法，不同的方法都被注释掉了。这为您提供了一种尝试不同方法并进行比较的方式。只需删除注释掉您想要测试的字符和注释掉其他字符的“#”字符。

```
    def make_guess(self, available_cards):
        #self.guess_random(available_cards)
        #self.guess_remember_all(available_cards)
        #self.guess_remember_sometimes(available_cards)
        self.guess_remember_recent(available_cards)

```

你可以做的一件事是让玩家选择难度。想一想你可以如何添加它。我在源代码中添加了另一个版本的记忆游戏，它包含了这个选项。它存储在目录 memory4 中；在查看提供的代码之前，先考虑一下如何添加它。

## 战舰

你如何创造人工智能的另一个例子可以在游戏战舰中看到。这是你在某个阶段几乎肯定玩过的经典游戏。最初是一个纸质游戏，你必须尝试击沉你对手的船只，现在这通常是一个棋盘游戏，使用模型船和塑料桩来显示船只何时被击中或错过。如图 [10-2](#Fig2) 所示。

![../images/488486_1_En_10_Chapter/488486_1_En_10_Fig2_HTML.jpg](Images/488486_1_En_10_Fig2_HTML.jpg)

图 10-2

传统战舰棋盘游戏

这个游戏将是这个经典游戏的电脑版，用来演示人工智能。玩战舰所涉及的智力是我们大多数人下意识做的事情。的确，这个游戏很大程度上是基于运气，但如果没有策略，非智能计算机版本几乎肯定会输给人类对手。

玩战列舰有三个主要策略可以考虑:

*   随机——每回合随机出牌是最基本的策略。在尝试过许多位置之前，成功击中每艘对手船只的几率非常低。

*   随机感知船只——第二个策略是你随机射击，直到成功击中对手的船只。一旦击中对手的船，你就向邻近的位置开火，直到船被击沉。船沉了之后，你又开始尝试随机的位置。

*   概率分析——这是一种终极策略，电脑对手可以计算出剩余船只在特定位置的概率。

在这个游戏中，我实现了第二个随机射击的策略。原因是第一关对大多数玩家来说太容易了，而第三关可能太难了。

为了保持代码简短，书中列出的版本对人类和电脑玩家的飞船都有固定的位置。这使我能够演示计算机播放器的工作方式，而不必列出许多额外的代码。然而，我在源代码中加入了第二个版本，这是一个完整的游戏，玩家可以定位他们自己的船，计算机为他们的船选择随机的位置。本书列出的版本在战舰目录中，更完整的版本在战舰 2 目录中。

这个游戏中包含了六个 Python 文件，加上 image 文件夹中的一些图片。该游戏使用了与记忆游戏类似的面向对象的编程方法。文件 battleship.py 是主可执行文件。每个玩家都有一个舰队，舰队由五艘船组成。每艘船都是 Actor 类的孩子。有一个 grid 类处理网格位置，并将网格上的位置转换为屏幕上的位置。最后，Ai 类是本章最感兴趣的一个，因为它是智能编码的地方。

我将快速浏览每个文件，并在最后解释 Ai 类。

第一个文件是战舰. py 主程序文件。这显示在清单 [10-10](#PC19) 中。

```
from fleet import Fleet
from grid import Grid
from ai import Ai

WIDTH = 1024
HEIGHT  = 768

# Start of your grid (after labels)
YOUR_GRID_START = (94,180)
# Start of enemy grid
ENEMY_GRID_START = (544,180)
GRID_SIZE = (38,38)

player = "player1"

grid_img_1 = Actor ("grid", topleft=(50,150))
grid_img_2 = Actor ("grid", topleft=(500,150))

own_fleet = Fleet(YOUR_GRID_START, GRID_SIZE)
enemy_fleet = Fleet(ENEMY_GRID_START, GRID_SIZE)

## Manually position ships position random or allow
## player to choose.
own_fleet.add_ship("destroyer",(7,0),"horizontal")
own_fleet.add_ship("cruiser",(1,1),"horizontal")
own_fleet.add_ship("submarine",(1,4),"vertical")
own_fleet.add_ship("battleship",(4,5),"horizontal")
own_fleet.add_ship("carrier",(9,3),"vertical")

enemy_fleet.add_ship("destroyer",(5,8),"horizontal", True)
enemy_fleet.add_ship("cruiser",(3,4),"vertical", True)
enemy_fleet.add_ship("submarine",(4,1),"horizontal", True)
enemy_fleet.add_ship("battleship",(8,3),"vertical", True)
enemy_fleet.add_ship("carrier",(1,1),"vertical", True)

# Don't need a player1 object
# Player 2 represents the AI player
player2=Ai()

def draw():
    screen.fill((192,192,192))
    grid_img_1.draw()
    grid_img_2.draw()
    screen.draw.text("Battleships", fontsize=60, center=(WIDTH/2,50), shadow=(1,1), color=(255,255,255), scolor=(32,32,32))
    screen.draw.text("Your fleet", fontsize=40, topleft=(100,100), color=(255,255,255))
    screen.draw.text("The enemy fleet", fontsize=40, topleft=(550,100), color=(255,255,255))
    own_fleet.draw()
    enemy_fleet.draw()
    if (player == "gameover"):
        screen.draw.text("Game Over", fontsize=60, center=(WIDTH/2,HEIGHT/2), shadow=(1,1), color=(255,255,255), scolor=(32,32,32))

def update():
    global player
    if (player == "player2"):
        grid_pos = player2.fire_shot()
        result = own_fleet.fire(grid_pos)
        player2.fire_result (grid_pos, result)
        # If ship sunk then inform Ai player
        if (result == True):
            if (own_fleet.is_ship_sunk_grid_pos(grid_pos)):
                player2.ship_sunk(grid_pos)
                # As a ship is sunk - check to see if all ships are sunk
                if own_fleet.all_sunk():
                    player = "gameover"
                    return

        # If reach here then not gameover, so switch back to main player
        player = "player1"

def on_mouse_down(pos, button):
    global player
    if (button != mouse.LEFT):
        return
    if (player == "player1"):
        if (enemy_fleet.grid.check_in_grid(pos)):
            grid_location = enemy_fleet.grid.get_grid_pos(pos)
            #print (Grid.grid_to_string(grid_location))
            enemy_fleet.fire(grid_location)
            if enemy_fleet.all_sunk():
                player = "gameover"
            else:
                # switch to player 2
                player = "player2"

Listing 10-10The main battleship.py program file for Battleship game

```

这个文件导入了一些类并创建了主类的实例。这包括两个网格和相应的舰队，一个是人类玩家的舰队位置，另一个是电脑玩家的。通过人类和计算机舰队的硬编码位置，船只被添加到舰队中。这是为了减少这个阶段的代码量。draw 函数遍历各种对象，调用它们的每个绘制方法，并显示状态文本。

人类代码和人工智能代码是分离的。update 函数处理计算机玩家，而 on_mouse_down 函数处理与人类玩家的交互。

舰队类负责跟踪船只和射击。它包括测试一艘船是否沉没(在这种情况下，它被设置为可见)和测试整个舰队是否沉没的方法，这是游戏结束的触发器。fleet.py 的代码如清单 [10-11](#PC20) 所示。

```
import math
from grid import Grid
from ship import Ship
from pgzero.actor import Actor

class Fleet:

    def __init__ (self, start_grid, grid_size):
        self.start_grid = start_grid
        self.grid_size = grid_size
        self.ships = []
        self.grid = Grid(start_grid, grid_size)
        self.shots = []

    # Is there a ship at this position that has sunk
    def is_ship_sunk_grid_pos (self, check_grid_pos):
        # find ship at that position
        for this_ship in self.ships:
            if (this_ship.includes_grid_pos(check_grid_pos)):
                return this_ship.is_sunk()
        # If there is no ship at this position then return False
        return False

    def add_ship (self, type, position, direction, hidden=False):
        self.ships.append(Ship(type, self.grid, position, direction, hidden))

    # check through ships to see if any still floating
    def all_sunk (self):
        for this_ship in self.ships:
            if not this_ship.is_sunk():
                return False
        return True

    # Draws entire fleet (each of the ships)
    def draw(self):
        for this_ship in self.ships:
            this_ship.draw()
        for this_shot in self.shots:
            this_shot.draw()

    def fire (self, pos):
        # Is this a hit
        for this_ship in self.ships:
            if (this_ship.fire(pos)):
                # Hit
                self.shots.append(Actor("hit",topleft=self.grid.grid_pos_to_screen_pos(pos)))
                #check if this ship sunk
                if this_ship.is_sunk():
                    # Ship sunk so make it visible
                    this_ship.hidden = False
                return True
        self.shots.append(Actor("miss",topleft=self.grid.grid_pos_to_screen_pos(pos)))
        return False

Listing 10-11Fleet class for Battleship game

```

舰队类提供的主要内容之一是属于该舰队的所有船只的列表。这在列表`self.ships`中，是基于船舶等级创建的。它还保存所有已经发射的镜头，作为代表击中或未击中的演员的列表。

船舶等级如清单 [10-12](#PC21) 所示。它是 Actor 类的一个子类，带有一些额外的代码来处理船只在适当网格上的位置，以及船只何时隐藏或可见。

```
from pgzero.actor import Actor
from grid import Grid

# Ship is referred to using an x,y position

class Ship (Actor):

    def __init__ (self, ship_type, grid, grid_pos, direction, hidden=False):
        Actor.__init__(self, ship_type, (10,10))
        self.ship_type = ship_type
        self.grid = grid
        self.image = ship_type
        self.grid_pos = grid_pos
        self.topleft = self.grid.grid_pos_to_screen_pos((grid_pos))
        # Set the actor anchor position to center of the first square
        self.anchor = (38/2, 38/2)
        self.direction = direction
        if (direction == 'vertical'):
            self.angle = -90
        self.hidden = hidden
        if (ship_type == "destroyer"):
            self.ship_size = 2
            self.hits = [False, False]
        elif (ship_type == "cruiser"):
            self.ship_size = 3
            self.hits = [False, False, False]
        elif (ship_type == "submarine"):
            self.ship_size = 3
            self.hits = [False, False, False]
        elif (ship_type == "battleship"):
            self.ship_size = 4
            self.hits = [False, False, False, False]
        elif (ship_type == "carrier"):
            self.ship_size = 5
            self.hits = [False, False, False, False, False]

    def draw(self):
        if (self.hidden):
            return
        Actor.draw(self)

    def is_sunk (self):
        if (False in self.hits):
            return False
        return True

    def fire (self, fire_grid_pos):
        if self.direction == 'horizontal':
            if (fire_grid_pos[0] >= self.grid_pos[0] and
                fire_grid_pos[0] < self.grid_pos[0]+self.ship_size and
                fire_grid_pos[1] == self.grid_pos[1]):
                self.hits[fire_grid_pos[0]-self.grid_pos[0]] = True
                return True
        else:
            if (fire_grid_pos[0] == self.grid_pos[0] and
                fire_grid_pos[1] >= self.grid_pos[1] and
                fire_grid_pos[1] < self.grid_pos[1]+self.ship_size):
                self.hits[fire_grid_pos[1]-self.grid_pos[1]] = True
                return True
        return False

    # Does this ship cover this grid_position
    def includes_grid_pos (self, check_grid_pos):
        # If first pos then return True
        if (self.grid_pos == check_grid_pos):
            return True
        # check x axis
        elif (self.direction == 'horizontal' and
            self.grid_pos[1] == check_grid_pos[1] and
            check_grid_pos[0] >= self.grid_pos[0] and
            check_grid_pos[0] < self.grid_pos[0] + self.ship_size):
            return True
        elif (self.direction == 'vertical' and
            self.grid_pos[0] == check_grid_pos[0] and
            check_grid_pos[1] >= self.grid_pos[1] and
            check_grid_pos[1] < self.grid_pos[1] + self.ship_size):
            return True
        else :
            return False

Listing 10-12Ship class for Battleship game

```

Ship 类使用船只类型来确定船只的大小。这是根据船名来定的，比如驱逐舰(两格位)或者战列舰(四格位)。它还会更新锚点位置。这与船上使用的航海锚无关，而是与 Pygame Zero 演员的锚位置有关。默认情况下，锚点是图像的中心，但在这种情况下，它被设置为船占据的第一个网格位置(顶部，左侧)的中心。这个位置用于放置船只及其旋转。这使得在网格上定位船只更加容易，因此当船只垂直放置时，它会在网格列中旋转。

然后，构造函数创建一个对应于每个网格位置的列表，名为`self.hits`。对于每个位置，该列表都被设置为 False，然后每当命中其中一个位置时，该列表都被更新为 True。如果它们都被设置为真，那么这艘船就被认为沉没了。这可以使用`is_sunk`方法进行测试。

fire 方法通过查看其网格位置是否与船只占据的任何位置相匹配来确定火是否击中船只，并相应地更新状态。方法`includes_grid_position`执行类似的检查，但是用于检查船只是否存在于该位置并且不改变其状态。

舰队和船只类中的方法使用网格位置，而不是屏幕位置。Grid 类用于将鼠标单击的屏幕位置转换为两个网格之一上的网格位置。战舰类和战舰. py 中的`on_mouse_down`函数都使用它。网格类如清单 [10-13](#PC22) 所示。

```
import math

class Grid:
    # Grid dimensions are in terms of screen pixels
    def __init__ (self, start_grid, grid_size):
        self.start_grid = start_grid
        self.grid_size = grid_size

    # Does co-ordinates match this grid - if so which screen_position
    def check_in_grid (self, screen_pos):
        if (screen_pos[0] < self.start_grid[0] or
            screen_pos[1] < self.start_grid[1] or
            screen_pos[0] > self.start_grid[0] + (self.grid_size[0] * 10) or
            screen_pos[1] > self.start_grid[1] + (self.grid_size[1] * 10)):
                return False
        else:
            return True

    def get_grid_pos (self, screen_pos):
        x_offset = screen_pos[0] - self.start_grid[0]
        x = math.floor(x_offset / self.grid_size[0])
        y_offset = screen_pos[1] - self.start_grid[1]
        y = math.floor(y_offset / self.grid_size[1])
        if (x < 0 or y < 0 or x > 9 or y > 9):
            return None
        return (x,y)

    # Gets top left of a grid position - returns as screen position
    def grid_pos_to_screen_pos (self, grid_pos):
        x = self.start_grid[0] + (grid_pos[0] * self.grid_size[0])
        y = self.start_grid[1] + (grid_pos[1] * self.grid_size[1])
        return (x,y)

Listing 10-13Grid class for Battleship game

```

这是使用存储在`grid_pos`中的网格起始位置和存储在`grid_size`中的每个网格方块的大小来处理的。数学模块中的下限方法用于将值向下舍入到最接近的整数。

最后一个类是 Ai 类，它是实现计算机播放器的地方。这是本章的关键部分，因此将对其进行更详细的解释。代码如清单 [10-14](#PC23) 所示。

```
import random
from grid import Grid

# Provides Ai Player
class Ai:

    NA = 0
    MISS = 1
    HIT = 2

    def __init__ (self):
        # Create 2 dimension list with no shots fired
        # access using [x value][y value]
        # Pre-populate with NA
        self.shots = [ [Ai.NA for y in range(10)] for x in range(10) ]
        # Hit ship is the position of the first successful hit on a ship
        self.hit_ship = None

    def fire_shot(self):
        # If not targeting hit ship
        if (self.hit_ship == None):
            return (self.get_random())
        else:
            # Have scored a hit - so find neighboring positions
            # copy hit_ship into separate values to make easier to follow
            hit_x = self.hit_ship[0]
            hit_y = self.hit_ship[1]
            # Try horizontal if not at edge
            if (hit_x < 9):
                for x in range (hit_x+1,10):
                    if (self.shots[x][hit_y] == Ai.NA):
                        return (x,hit_y)
                    if (self.shots[x][hit_y] == Ai.MISS):
                        break
            if (hit_x > 0):
                for x in range (hit_x-1,-1, -1):
                    if (self.shots[x][hit_y] == Ai.NA):
                        return (x,hit_y)
                    if (self.shots[x][hit_y] == Ai.MISS):
                        break
            if (hit_y < 9):
                for y in range (hit_y+1,10):
                    if (self.shots[hit_x][y] == Ai.NA):
                        return (hit_x,y)
                    if (self.shots[hit_x][y] == Ai.MISS):
                        break
            if (hit_y > 0):
                for y in range (hit_y-1,-1, -1):
                    if (self.shots[hit_x][y] == Ai.NA):
                        return (hit_x,y)
                    if (self.shots[hit_x][y] == Ai.MISS):
                        break
            # Catch all - shouldn't get this, but just in case guess random
            return (self.get_random())

    def fire_result(self, grid_pos, result):
        x_pos = grid_pos[0]
        y_pos = grid_pos[1]
        if (result == True):
            result_value = Ai.HIT
            if (self.hit_ship == None):
                self.hit_ship = grid_pos
        else:
            result_value = Ai.MISS
        self.shots[x_pos][y_pos] = result_value

    def get_random(self):
        # Copy only non-used positions into a temporary list
        non_shots = []
        for x_pos in range (0,10):
            for y_pos in range (0,10):
                if self.shots[x_pos][y_pos] == Ai.NA:
                    non_shots.append((x_pos,y_pos))
        return random.choice(non_shots)

    # Let Ai know that the last shot sunk a ship
    # list_pos is provided, but not currently used
    def ship_sunk(self, grid_pos):
        # reset hit ship
        self.hit_ship = None

Listing 10-14Ai class for Battleship game

```

在导入和类定义之后，有三个类变量，称为 NA、MISS 和 HIT。这些被用作常量，只是让代码的其余部分更容易理解。看了代码，就更容易理解那个 Ai 了。不中表示不中，而不仅仅是使用数字 1，对于 NA(在那个位置没有射击)和命中也是一样。

之后是通常的构造函数 __init__ 它有一个入口

```
self.shots = [ [Ai.NA for y in range(10)] for x in range(10) ]

```

这是一种创建 2D 列表并用 Ai.NA 预先填充它的方法。最终将得到如下所示的列表:

```
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

```

网格中的每个位置都有一个条目，可以使用`self.shots[x-pos][y-pos]`来访问。如果您以前面的格式查看网格，那么 x 和 y 轴被交换(y 交叉，x 向下)，但这只是它在打印清单中的表示方式。重要的是如何使用 x，y 位置访问它。

在构造函数中创建的另一个变量是`self.hit_ship`。这将记录最后一次射击成功击中目标的位置。当船沉没时，它被重置为无。

射击时，有多个阶段:

1.  调用 fire_shot 方法，该方法计算出下一个“猜测”的射击位置。在这个阶段，Ai 类不知道那个镜头是否成功。

2.  然后，battleship.py 从 fleet 类调用 fire 方法，该方法添加适当的命中或未命中演员，并返回 True 或 False 以指示该镜头是否命中目标。

3.  调用 fire_result 方法，该方法允许 Ai 类更新镜头列表，以了解镜头是否导致命中。

4.  如果船已经被击沉，那么调用 ship _ sunk 方法，这样 Ai 类就知道它不需要继续瞄准那艘船。

之所以需要在多个阶段完成，是因为人工智能看不到敌人的船在哪里。因此，它不知道它的拍摄是否成功。

`fire_shot`做的第一件事是查看它是否知道一艘尚未沉没的船的位置。它通过查看`self.hit_ship`是否被设置为无来实现。如果它不知道敌舰的位置，那么它会使用`get_random`方法进行随机猜测，如下所示:

```
    def get_random(self):
        # Copy only non-used positions into a temporary list
        non_shots = []
        for x_pos in range (0,10):
            for y_pos in range (0,10):
                if self.shots[x_pos][y_pos] == Ai.NA:
                    non_shots.append((x_pos,y_pos))
        return random.choice(non_shots)

```

这使用`random.choice`方法从可用位置中进行选择。在调用它之前，它需要一个列表，只显示还没有尝试过的镜头，这就是代码的其余部分要做的。它创建一个`non_shots`列表，然后使用一个嵌套的 for 循环检查所有的网格位置，并将所有尚未尝试过的网格位置添加到`non_shots`列表中。然后网格位置被返回给`fire_shot`,它依次使用该位置作为其返回值。

如果已经有一艘船最近被击中了，但是还没有被击沉，那么`self.hit_ship`中就会有一个位置。在这种情况下，代码会尝试四个不同的方向，直到找到下一个合适的网格位置。合适的位置是没有尝试过的任何位置，并且与成功的拍摄相邻。从以下代码摘录中可以看出这一点:

```
            if (hit_x < 9):
                for x in range (hit_x+1,10):
                    if (self.shots[x][hit_y] == Ai.NA):
                        return (x,hit_y)
                    if (self.shots[x][hit_y] == Ai.MISS):
                        break

```

如果 hit_ship 的 x 位置小于 9(不在网格的右侧)，那么它将向右遍历所有位置。如果它遇到一个值为 NA 的位置，那么这是一个有效的镜头，所以它返回那个位置。相反，如果它遇到一个失误，那么它知道船不在那个方向，所以它使用一个 break 从 for 循环中退出，然后代码继续检查下一个方向。

其他 if 语句做同样的事情，但在其他方向寻找，直到找到一个有效的镜头。

有一个最终条目，如果四个方向都不适用，那么它将返回一个随机的猜测。这不应该被调用，因为在船沉没之前，应该总是有一个有效的位置可以尝试。对于添加“以防万一”代码是否是一个好主意，存在意见分歧。我的理由是，如果有一些我没有想到的情况，或者代码中有错误，那么这将允许游戏继续进行，而不会给用户一个错误。相反的论点是，这可能会隐藏代码中的问题，游戏会继续运行，但不是以预期的方式运行。

当快照的结果已知时，调用`fire_result`方法。它用命中是否成功来更新网格位置。如果该镜头是命中的，并且`hit_ship`的值当前被设置为无，则它还更新`hit_ship`的值。最后一种方法是`ship_sunk`，它在船只成功沉没后将`hit_ship`的值重置为 0。

这段代码很好地实现了这个策略，但是还有一些地方需要改进。一个是 Ai 总是以相同的顺序尝试位置(水平然后垂直)。如果玩家明白这一点，那么他们就可以通过始终将船只放置在远离左右边缘且始终垂直的位置来获得优势。这只会产生很小的差异，但可以通过随机决定先尝试哪个方向来解决。它也可以在两艘船接触的地方被欺骗，首先击中一艘船，然后击沉第二艘船。它不会回去干掉它撞上的第一艘船。这些不会阻止游戏运行，但是会是一个很好的挑战，让读者创建一个改进的版本。

正如我在开始时警告的，图形游戏编程使用大量代码。走到这一步需要 300 行代码，但这还不包括让用户放置自己的船只或让计算机选择船只位置的能力。这是你可能想自己实现的东西，或者你可以在源代码中的文件夹 battleship2 中查找，在那里我创建了另一个版本，它实现了那个特性以及一些其他的改进。

决赛游戏截图如图 [10-3](#Fig3) 。

![../images/488486_1_En_10_Chapter/488486_1_En_10_Fig3_HTML.jpg](Images/488486_1_En_10_Fig3_HTML.jpg)

图 10-3

完整的战舰游戏

## 摘要

这一章探讨了如何让计算机像人类玩家一样运行。在列出的两个例子中，人工智能被创建来模仿人类在玩游戏时会经历的相同过程。

当设计一些计算机程序时，你可能希望让计算机尽可能“聪明”。计算机太聪明的问题是，计算机可以分析可能的结果，这使得它很难被击败。在创作电脑游戏时，重要的是要考虑游戏的难度，使其具有挑战性，但不要太难。

通过创建不同的难度级别或使游戏看起来更像人类，这些游戏还有改进的空间。你可能喜欢尝试调整人工智能或者思考如何将人工智能添加到其他游戏中。