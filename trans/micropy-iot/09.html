<html xml:lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<title>Project 2: Stoplight Simulator</title>
<link href="springer_epub.css" type="text/css" rel="styleSheet"/>
</head>
<body>
 
<!--Begin Abstract--><h1 class="ChapterTitle" xml:lang="en">9.项目 2:交通信号灯模拟器</h1>

 
<!--End Abstract--><p>既然我们已经有了如何设计、连接和实现 MicroPython 项目的教程，现在让我们来看一个更高级的项目。在这种情况下，我们将使用一些非常基本的组件来进一步了解如何使用硬件。该项目的硬件选择将是发光二极管，电阻和一个按钮。按钮是最基本的传感器。也就是说，当按钮被按下时，我们可以让我们的 MicroPython 代码响应这个动作。</p>
<p>使用 led 可能更多的是一句“你好，世界！”风格项目的硬件，因为打开和关闭发光二极管很容易，除了搞清楚什么大小的限流电阻是必要的，接线发光二极管也很容易。像大多数基于 LED 的项目一样，我们将实现一个模拟。更具体地说，我们将实现一个交通灯和一个行人行走按钮。步行按钮是一个按钮，行人可以使用它来触发交通信号以改变和停止交通，以便他们可以穿过街道。</p>
<p>模拟项目可以很有趣，因为我们已经有了它应该如何工作的想法，我们正在模拟我们遇到的东西。例如，除非你住在非常偏远的地区，否则你很可能在十字路口遇到过带有按钮的“步行/禁止步行”标志的交通信号。如果你生活在城市，你会在各种配置中遇到这些。当一个行人(或骑自行车的人)按下步行按钮时，交通灯全部变成红色，步行标志被点亮。一段时间后(大约 30 秒)，步行标志闪烁，然后大约 15 秒后，步行信号变为禁止步行，交通信号恢复正常周期。</p>
Note
<p>“循环”一词指的是一组线性作用的状态。因此，循环是指从一种状态到另一种状态的变化。</p>

<p>我们也将增加一个新的交通灯模拟概念。我们将使用一个网页来触发 walk 请求。但首先，我们将学习如何连接和编码 LED 灯，并在第二步添加 web 界面。</p>
<h2 class="Heading">概观</h2>
<p>在这一章中，我们将实现一个带有行人行走按钮的交通信号。这个项目使用 led，它允许我们看到代码执行时的状态。对于交通灯(也称为停止灯)，我们将使用红色、黄色和绿色 led 来匹配交通灯上相同颜色的灯。我们还将使用一个红色和黄色的 LED 来对应禁止行走(红色)和行走(黄色)灯。</p>
<p>我们将使用按钮(也称为瞬时按钮)，因为它只有在被按下时才会触发(开启)。释放后，它不再被触发(关闭)。Trigger 是用于描述按钮状态的词，其中 triggered 表示从按钮的一侧到另一侧的连接被连接(on)。保持触发(锁定)状态的按钮称为锁定按钮，通常必须再次按下才能关闭。</p>
<p>我们将通过首先仅打开绿色交通灯 LED 和红色步行 LED 信号来模拟交通灯和步行信号。这是我们将使用的正常状态。当按钮被按下时，交通灯将变为黄色几秒钟，然后变为红色。几秒钟后，行走信号将变为黄色，几秒钟后开始闪烁。几秒钟后，步行信号将返回红色，交通灯将返回绿色。</p>
<p>为了让事情变得更有趣，我们还将看到如何修改这个项目来使用一个从网页模拟的按钮。是的，我们将看到如何通过网络远程控制硬件和我们的代码。如果您使用的是 Pyboard 或另一种没有任何网络功能的 MicroPython 板，您将需要一个网络模块。随着项目的发展，我们将重新审视 Pyboard 的网络。</p>
<p>现在让我们看看这个项目需要哪些组件，然后我们将看看如何将所有组件连接在一起。</p>

<h2 class="Heading">必需的组件</h2>
<p>表<a href="#Tab1"> 9-1 </a>列出了你需要的部件。您可以从 Adafruit ( <code>adafruit.com</code>)、Sparkfun ( <code>sparkfun.com</code>)或任何出售电子元件的电子商店单独购买元件。如果您想购买这些组件，可以链接到供应商。当列出同一对象的多行时，您可以选择其中一行——您不需要两个都要。此外，您可能会找到销售这些组件的其他供应商。你应该货比三家，找到最好的交易。显示的成本是估计值，不包括任何运输成本。</p>
<p>表 9-1。</p>Required Components


<table border="1"><colgroup><col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead><tr class="header"><th>成分</th>
<th>数量</th>
<th>描述</th>
<th>费用</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr class="noclass"><td rowspan="5">MicroPython 板</td>
<td rowspan="5">one</td>
<td rowspan="3">带标题的 Pyboard v1.1 版</td>
<td rowspan="3">$45-50</td>
<td><a href="https://www.adafruit.com/product/2390"><code>https://www.adafruit.com/product/2390</code></a><a href="https://www.adafruit.com/product/3499"><code>https://www.adafruit.com/product/3499</code>T5】</a></td>
</tr>
<tr class="noclass"><td><a href="https://www.sparkfun.com/products/14413">T2<code>https://www.sparkfun.com/products/14413</code></a></td>
</tr>
<tr class="noclass"><td><a href="https://store.micropython.org/store">T2<code>https://store.micropython.org/store</code></a></td>
</tr>
<tr class="noclass"><td rowspan="2">WiPy</td>
<td rowspan="2">$25</td>
<td><a href="https://www.adafruit.com/product/3338">T2<code>https://www.adafruit.com/product/3338</code></a></td>
</tr>
<tr class="noclass"><td><a href="https://www.pycom.io/product/wipy/">T2<code>https://www.pycom.io/product/wipy/</code></a></td>
</tr>
<tr class="noclass"><td>发光二极管</td>
<td>Two</td>
<td>红色指示灯</td>
<td>装备</td>
<td><a href="https://www.adafruit.com/product/2975">T2<code>https://www.adafruit.com/product/2975</code></a></td>
</tr>
<tr class="noclass"><td>发光二极管</td>
<td>Two</td>
<td>黄色发光二极管</td>
<td>装备</td>
<td><a href="https://www.adafruit.com/product/2975">T2<code>https://www.adafruit.com/product/2975</code></a></td>
</tr>
<tr class="noclass"><td>发光二极管</td>
<td>one</td>
<td>绿色发光二极管</td>
<td>装备</td>
<td><a href="https://www.adafruit.com/product/2975">T2<code>https://www.adafruit.com/product/2975</code></a></td>
</tr>
<tr class="noclass"><td>电阻器</td>
<td>five</td>
<td>220 或 330 欧姆电阻</td>
<td>$8-12</td>
<td><a href="https://www.sparkfun.com/products/10969">T2<code>https://www.sparkfun.com/products/10969</code></a></td>
</tr>
<tr class="noclass"><td>纽扣</td>
<td>one</td>
<td>瞬时按钮，试验板友好</td>
<td>装备</td>
<td><a href="https://www.sparkfun.com/products/12708">T2<code>https://www.sparkfun.com/products/12708</code></a></td>
</tr>
<tr class="noclass"><td>面包板</td>
<td>one</td>
<td>原型板，半尺寸</td>
<td>$5</td>
<td><a href="https://www.sparkfun.com/products/12002">T2<code>https://www.sparkfun.com/products/12002</code></a></td>
</tr>
<tr class="noclass"><td>网络模块(Pyboard)</td>
<td>one</td>
<td>CC3000 分线板(或同等产品)</td>
<td>$15+</td>
<td>各种各样的</td>
</tr>
<tr class="noclass"><td>跳线(WiPy)</td>
<td>nine</td>
<td>M/M 跳线，6”(10 根跳线的成本)</td>
<td>$4</td>
<td><a href="https://www.sparkfun.com/products/8431">T2<code>https://www.sparkfun.com/products/8431</code></a></td>
</tr>
<tr class="noclass"><td>跳线(线路板)</td>
<td>Seventeen</td>
<td>M/M 跳线，6”(10 根跳线的成本)</td>
<td>$4</td>
<td><a href="https://www.sparkfun.com/products/8431">T2<code>https://www.sparkfun.com/products/8431</code></a></td>
</tr>
<tr class="noclass"><td rowspan="2">力量</td>
<td>one</td>
<td>从电脑获取电源的 USB 电缆</td>
<td> </td>
<td>使用您的备件</td>
</tr>
<tr class="noclass"><td>one</td>
<td>USB 5V 电源和电缆</td>
<td> </td>
<td>使用您的备件</td>
</tr>
</tbody>
</table>

<p>注意在成本中，led 和按钮的“套件”。这是指这些组件可以在我们在第<a href="02.html"> 2 </a>章看到的 Adafruit 的零件 Pal 套件中找到。其他供应商可能有类似的套件。成套购买 led、按钮和电阻等基本元件要便宜得多。</p>
<p>同样，你可以买一套各种尺寸的电阻，比一次买几个便宜得多。事实上，你很可能会发现，购买一个每种尺寸 5 或 10 个电阻的小套件比购买一套要贵得多。Sparkfun 的套件将为您提供大多数项目所需的所有电阻器。</p>
<p>另外，请注意，WiPy 需要的跳线要少得多。这是因为我们将使用网络分线板(在本例中为 CC3000 模块)来允许 Pyboard 连接到我们的网络。</p>
<p>最后，注意我们需要一个 Pyboard 友好的网络模块。同样，目前这必须是基于 CC3000 的板或基于 WIZNET5K 的板。有关与 Pyboard 配合使用的网络分线板的示例，请参考前面的章节。</p>
<p>回想一下第<a href="07.html"> 7 </a>章，LED 需要一个限流电阻来将电流降低到 LED 的安全水平。为了确定我们需要多大的电阻，我们需要了解 LED 的几个方面。该数据可从制造商处获得，制造商以数据表的形式提供数据，或者在商业包装产品的情况下，在包装上列出数据。我们需要的数据包括最大电压、电源电压(LED 的电压)和 LED 的额定电流。</p>
<p>例如，如果我有一个像 Adafruit Parts Pal 中的 LED，在这种情况下是一个 5 毫米红色 LED，我们在 Adafruit 的网站(<code>adafruit.com/products/297</code>)上发现该 LED 的工作电流为 1.8-2.2 伏和 20 毫安。假设我们希望使用 5V 电源电压。然后我们可以将这些值代入这个公式:</p>
<p>
             
          </p>
<pre>R = (Vcc-Vf)/I
</pre>
          <p>使用更具描述性的变量名称，我们得到如下结果。</p>
<p>
             
          </p>
<pre>Resistor = (Volts_supply - Volts_forward) / Desired_current
</pre>
          <p>把我们的数据代入，我们得到这个结果。注意，我们有 mA，所以我们必须使用正确的十进制值(除以 1000)。在这种情况下，它是 0.020，我们将在中间选择一个电压。</p>
<p>
             
          </p>
<pre>Resistor = (5 – 1.8) / 0.020
         = 3.2 / 0.020
         = 160
</pre>
          <p>因此，我们需要一个 160 欧姆的电阻。然而，没有这种额定值的电阻。当这种情况发生时，我们用大一号的。例如，如果您只有 220 欧姆甚至 330 欧姆的电阻，您可以使用这些电阻。结果将是发光二极管将不会那么亮，但是具有较高的电阻比使用太小的电阻要安全得多。电流太大，LED 会烧坏。</p>
<p>现在，让我们看看如何将组件连接在一起。</p>

<h2 class="Heading">安装硬件</h2>
<p>虽然这个项目需要使用 WiPy 连接很多电线，Pyboard 甚至需要更多电线，但我们将使用的元件很容易插入试验板。表<a href="#Tab2"> 9-2 </a>显示了本项目所需的连接。</p>
<p>表 9-2。</p>Connections for the MicroPython (Pyboard and WiPy)


<table border="1"><colgroup><col/>
<col/>
<col/>
<col/>
</colgroup>
<thead><tr class="header"><th colspan="2">MicroPython 板</th>
<th> </th>
<th> </th>
</tr>
<tr class="header"><th>WiPy</th>
<th>Pyboard</th>
<th>成分</th>
<th>电线颜色</th>
</tr>
</thead>
<tbody><tr class="noclass"><td>P3</td>
<td>X7</td>
<td>停车灯:红色 LED</td>
<td> </td>
</tr>
<tr class="noclass"><td>P4</td>
<td>X6</td>
<td>停车灯:黄色 LED</td>
<td> </td>
</tr>
<tr class="noclass"><td>孕烯醇酮</td>
<td>X5</td>
<td>停车灯:绿色 LED</td>
<td> </td>
</tr>
<tr class="noclass"><td>P6</td>
<td>X4</td>
<td>行走信号:红色 LED</td>
<td> </td>
</tr>
<tr class="noclass"><td>P7</td>
<td>X3</td>
<td>行走信号:黄色 LED</td>
<td> </td>
</tr>
<tr class="noclass"><td>P23</td>
<td>X1</td>
<td>纽扣</td>
<td> </td>
</tr>
<tr class="noclass"><td>地线</td>
<td>地线</td>
<td>试验板</td>
<td> </td>
</tr>
</tbody>
</table>

<p>让我们来复习一些元件接线的技巧。将元件连接到电路板的最佳方式是使用试验板。正如我们在第<a href="07.html"> 7 </a>章中看到的，试验板允许我们插入组件，并使用跳线进行连接。在本项目中，我们将使用一根跳线从 MicroPython 板接地到试验板，然后在试验板上跳线连接到按钮。事实上，我们将使用试验板一侧的接地轨来插入 led 的一侧。</p>
<p>只要插销的方向如图所示，按钮在任何位置都可以工作–两条腿在中心槽的一侧。如果按钮的支脚可以伸到槽的任何一侧，按钮的方向就会正确。如果你把它移开 90 度，按钮要么不起作用，要么总是被触发。如果有任何疑问，使用万用表测试按钮连接的连续性。你会发现连接在未按下时打开，按下时关闭。</p>
<p>唯一极化的组件是 LED(它有一个正极和一个负极引脚)。当您查看 LED 时，您会看到 LED 的一条腿(引脚)比另一条腿长。这条较长的边是正面。我们将插入 led，使负极引脚插入接地轨，正极引脚插入试验板的主要区域。然后我们插入电阻，跳过中心槽，将电阻连接到 MicroPython 板上的 GPIO 引脚。不管你往哪个方向插电阻，它们都可以双向工作。</p>
<p>如果这听起来令人困惑，不要担心，因为接线图使连接更加明显。让我们看看如何连接 WiPy 和 Pyboard，如图所示。</p>
<h3 class="Heading">WiPy</h3>
<p>WiPy 的布线最好也是将 USB 连接器朝向扩展板的右侧。图<a href="#Fig1"> 9-1 </a>显示了 WiPy 的接线图。注意发光二极管、电阻和按钮的方向。您应该能够使用图纸和布线图来连接您自己的组件。另外，请注意 WiPy 的方向。这应该有助于您更容易地将引脚与试验板的导线对齐，但只要您使用正确的 GPIO 引脚，物理方向并不重要。</p>
<p><img src="A447395_1_En_9_Fig1_HTML.jpg" alt="A447395_1_En_9_Fig1_HTML.jpg"/></p>
<p>图 9-1。</p>Wiring the Stoplight Simulation (WiPy)



<p>现在，让我们看看 Pyboard 的接线图。由于需要添加一个网络分线板，所以变得有点复杂。</p>

<h3 class="Heading">Pyboard</h3>
<p>Pyboard 的布线最好将 USB 连接器朝向左侧。这将允许您读取电路板上的引脚数，即使在电线插入电路板之后。网络模块需要额外的连接。回想一下，CC3000 分线板需要额外的布线来将 SPI 接口连接到 Pyboard。就像我们对 led、电阻器和按钮所做的那样，我们应该计划如何连接分线板。表<a href="#Tab3"> 9-3 </a>显示了与 CC3000 分线板一起使用时 Pyboard 所需的连接。如果您使用不同的分线板，请确保使用您的连接对此计划进行注释。</p>
<p>表 9-3。</p>Additional Connections for the Pyboard and CC3000 Breakout Board


<table border="1"><colgroup><col/>
<col/>
<col/>
</colgroup>
<thead><tr class="header"><th>Pyboard</th>
<th>CC3000</th>
<th>电线颜色</th>
</tr>
</thead>
<tbody><tr class="noclass"><td>Y3</td>
<td>伊拉克</td>
<td> </td>
</tr>
<tr class="noclass"><td>Y4</td>
<td>VBEN .好吧</td>
<td> </td>
</tr>
<tr class="noclass"><td>Y5</td>
<td>特许测量员</td>
<td> </td>
</tr>
<tr class="noclass"><td>Y6</td>
<td>时钟信号</td>
<td> </td>
</tr>
<tr class="noclass"><td>Y7</td>
<td>军事情报部门组织(Military Intelligence Service Organization)</td>
<td> </td>
</tr>
<tr class="noclass"><td>Y8</td>
<td>工业博物馆</td>
<td> </td>
</tr>
<tr class="noclass"><td>V+</td>
<td>车辆识别号码</td>
<td> </td>
</tr>
<tr class="noclass"><td>地线</td>
<td>地线</td>
<td> </td>
</tr>
</tbody>
</table>

<p>由于需要这些额外的导线，Pyboard 布线图有点复杂。图<a href="#Fig2"> 9-2 </a>显示了带有 CC3000 分线板的 Pyboard 的接线图。</p>
<p><img src="A447395_1_En_9_Fig2_HTML.jpg" alt="A447395_1_En_9_Fig2_HTML.jpg"/></p>
<p>图 9-2。</p>Wiring the Stoplight Simulation (WiPy)



<p>哇，好多电线啊！您可以看到使用内置 WiFi 的 MicroPython 板的优势——您不必使用额外的电线，这些电线有时会使一个简单的项目变得更加复杂，或者当您看着您的项目全部连接起来时，它看起来像一个电线窝。</p>
Note
<p>如果您使用 Pyboard，您可以使用板载指示灯，而不是单独的指示灯。</p>

<p>最后，一定要确保仔细连接项目，仔细检查所有连接，尤其是电源、接地和用于信号的任何引脚(将设置为“高”或“开”)，如用于 SPI 接口的引脚。最重要的是，当项目(或您的板)通电时，切勿插拔跳线。这很可能会损坏您的主板或组件。</p>
Caution
<p>项目通电时，切勿插拔跳线。您可能会损坏您的主板或组件。</p>

<p>同样，在给主板通电之前，请务必仔细检查您的连接。现在，我们来谈谈我们需要编写的代码。暂时不要启动您的主板——在我们准备好测试该项目之前，还需要进行大量的讨论。</p>


<h2 class="Heading">写代码</h2>
<p>现在是时候为我们的项目编写代码了。代码并不太复杂，但是比迄今为止的例子要长一点。因此，我们将分两部分编写代码。在第一部分中，我们将看到如何编写代码来模拟行人人行横道按钮和交通灯。在第二部分中，我们将放弃使用硬件按钮，而是使用 web 浏览器来远程控制按钮动作。</p>
Note
<p>这些部分演示了 WiPy 的代码，并描述了 Pyboard 的不同之处。有关每块电路板的代码，请参见本章末尾的完整代码列表。</p>

<p>正如您将看到的，第 2 部分将重用第 1 部分的大部分代码，但是 HTML 服务器代码会稍微复杂一些。让我们从项目的第 1 部分开始。</p>
<h3 class="Heading">第 1 部分:交通信号灯模拟器-使用按钮</h3>
<p>该项目的第 1 部分的代码将需要监控按钮，当按下时，如上所述循环灯。我们还需要代码来初始化 led，将它们设置为初始关闭。我们可以编写函数来监控按钮和循环发光二极管。我们将使用一个中断来将按钮的功能绑定到硬件上，这样我们就可以避免使用轮询循环。</p>
<h4 class="Heading">进口</h4>
<p>该项目的导入将需要来自<code>machine</code>库和<code>utime</code>库的<code>Pin</code>类。下面显示了 WiPy 的导入。</p>
<p>
                 
              </p>
<pre>from machine import Pin
import utime
</pre>
              <p>Pyboard 的导入还需要来自<code>pyb</code>库的<code>Pin</code>类以及<code>delay</code>函数和<code>ExtInt</code>类。<code>ExtInt</code>类用于设置按钮被按下时触发的中断。</p>
<p>
                 
              </p>
<pre>from pyb import Pin, delay, ExtInt
</pre>
              
<h4 class="Heading">设置</h4>
<p>这个项目的设置代码将需要初始化按钮和 LED 实例，然后关闭所有的 LED(作为一种预防措施)，打开绿色的交通信号灯 LED 和红色的步行信号 LED。清单<a href="#Par48"> 9-1 </a>显示了设置和初始化的代码。</p>
<p>
                 
              </p>
<pre># Setup the button and LEDs
button = Pin('P23', Pin.IN, Pin.PULL_UP)
led1 = Pin('P3', Pin.OUT)
led2 = Pin('P4', Pin.OUT)
led3 = Pin('P5', Pin.OUT)
led4 = Pin('P6', Pin.OUT)
led5 = Pin('P7', Pin.OUT)

# Setup lists for the LEDs
stoplight = [led1, led2, led3]
walklight = [led4, led5]

# Turn off the LEDs
for led in stoplight:
    led.value(0)
for led in walklight:
    led.value(0)

# Start with green stoplight and red walklight
stoplight[2].value(1)
walklight[0].value(1)

Listing 9-1.Setup and Initialization of the Button and LEDs (WiPy)


</pre>
              <p>需要注意的一点是按钮是如何初始化的。这是一个被设置为输入(读取)的<code>Pin</code>对象实例，上拉电阻打开。这使得电路板能够检测到按钮何时被按下，因为在建立连接时(按钮被按下)，引脚的值将为正值。</p>
<p>还要注意，我创建了一个列表，其中包含交通灯和步行信号的 led(代码中称为 walklight)。这主要是为了演示，这样您可以看到如何管理类对象列表。正如您所看到的，使用一个循环为列表中的所有对象调用同一个函数更容易。请注意这项技术，因为在其他项目中您会不时地需要它。</p>
<p>Pyboard 的代码基本相同。不同之处包括 led 和按钮的不同引脚编号(见接线图)，引脚初始化的不同选项(<code>Pin.OUT_PP</code>而非<code>Pin.OUT</code>)，以及<code>Pin</code>类使用不同的功能:<code>high()</code>用于<code>value(1)</code>，而<code>low()</code>用于<code>value(0)</code>。</p>

<h4 class="Heading">功能</h4>
<p>项目的这一部分需要两个功能。首先，我们需要一个函数来循环灯光。其次，我们需要一个功能来监控按钮的按下。我们来看一下循环灯功能。</p>
<p>我们将周期灯功能命名为<code>cycle_lights()</code>。回想一下，我们需要控制灯光如何改变状态。如前所述，我们以特定的周期来完成这项工作。总的来说，当我们想要模拟按下行走请求按钮时交通灯的变化时，我们调用这个函数。因此，这个函数将从按钮的代码中调用。清单<a href="#Par54"> 9-2 </a>显示了<code>cycle_lights()</code>按钮的代码。正如您将看到的，代码相当简单。唯一棘手的部分可能是用于闪烁黄色行走 LED 的回路。一定要通读一遍，这样你才能理解它是如何工作的。</p>
<p>
                 
              </p>
<pre># We need a method to cycle the stoplight and walklight
#
# We toggle from green to yellow for 2 seconds
# then red for 20 seconds.
def cycle_lights():
    # Go yellow.
    stoplight[2].value(0)
    stoplight[1].value(1)
    # Wait 2 seconds
    utime.sleep(2)
    # Go red and turn on walk light
    stoplight[1].value(0)
    stoplight[0].value(1)
    utime.sleep_ms(500)  # Give the pedestrian a chance to see it
    walklight[0].value(0)
    walklight[1].value(1)
    # After 10 seconds, start blinking the walk light
    utime.sleep(1)
    for i in range(0,10):
        walklight[1].value(0)
        utime.sleep_ms(500)
        walklight[1].value(1)
        utime.sleep_ms(500)

    # Stop=green, walk=red
    walklight[1].value(0)
    walklight[0].value(1)
    utime.sleep_ms(500)  # Give the pedestrian a chance to see it
    stoplight[0].value(0)
    stoplight[2].value(1)

Listing 9-2.The 
cycle_lights() Function


(WiPy)


</pre>
              <p>Pyboard 的代码与前面提到的控制 led 和使用<code>delay()</code>功能代替<code>utime</code>类睡眠功能的变化非常相似。</p>
<p>我们将这个按钮功能命名为<code>button_pressed()</code>。该函数用作按钮按下中断的回调函数。从技术上讲，我们告诉 MicroPython 将这个方法与 pin 中断相关联，但是我们马上就会看到这一点。然而，这一功能还有另一个要素需要解释。</p>
<p>当我们使用像按钮这样的组件并且用户(您)按下按钮时，按钮中的触点不会立即从关闭状态变为打开状态。在很短的一段时间内，读数不稳定。因此，我们不能简单地说“当引脚变高时”，因为引脚上读取的值可能会从低到高(或从高到低)快速“反弹”。这叫弹跳。我们可以通过代码(以及其他技术)人为地克服这一点，称为去抖动。</p>
<p>在这种情况下，我们可以随时检查 pin(按钮)的值，并且只有当值在这段时间内保持稳定时才“触发”按钮按压。清单<a href="#Par59"> 9-3 </a>中显示了引脚去抖动的代码。注意，在循环中，我们等待的值是 50。这是 50 毫秒。如果触发器足够长，我们调用<code>cycle_lights()</code>函数。</p>
<p>
                 
              </p>
<pre>def button_pressed(line):
    cur_value = button.value()
    active = 0
    while (active &lt; 50):
        if button.value() != cur_value:
            active += 1
        else:
            active = 0
        utime.sleep_ms(1)
        print("")
    if active:
        cycle_lights()
    else:
        print("False press")
Listing 9-3.The 
button_pressed() Function


(WiPy)


</pre>
              Tip
<p>有关去抖和避免去抖技术的更多信息，请参见<a href="http://www.eng.utah.edu/%E2%88%BCcs5780/debouncing.pdf"> <code>http://www.eng.utah.edu/∼cs5780/debouncing.pdf</code> </a> <code>.</code></p>

<p>最后，我们需要设置当板卡检测到中断时调用<code>button_pressed()</code>函数的按钮。下面设置了 WiPy 上的回调函数。</p>
<p>
                 
              </p>
<pre># Create an interrupt for the button
button.callback(Pin.IRQ_FALLING, button_pressed)
</pre>
              <p>Pyboard 上的代码也是单行代码，但是在这种情况下，我们必须使用<code>ExtInt</code>类来设置中断处理程序，如下所示。</p>
<p>
                 
              </p>
<pre># Create an interrupt for the button
e = ExtInt('X1', ExtInt.IRQ_FALLING, Pin.PULL_UP, button_pressed)
</pre>
              Tip
<p>有关对 WiPy 使用引脚回调和对 Pyboard 使用中断的更多信息，请参见在线 MicroPython 文档。</p>

<p>现在我们已经准备好测试代码了。继续打开一个名为<code>ped_part1_wipy.py</code>(或者 Pyboard 的<code>ped_part1_pyb.py</code>)的新文件，输入上面的代码。清单<a href="#Par67"> 9-4 </a>显示了项目第一部分的完整代码。如果你正在使用 Pyboard，通过查看本章末尾的完整列表来作弊是可以的。</p>
<p>
                 
              </p>
<pre># MicroPython for the IOT - Chapter 9
#
# Project 2: A MicroPython Pedestrian Crosswalk Simulator
#            Part 1 - controlling LEDs and button as input
#
# Required Components:
# - WiPy
# - (2) Red LEDs
# - (2) Yellow LEDs
# - (1) Green LED
# - (5) 220 Ohm resistors
# - (1) breadboard friendly momentary button
#
# Note: this only runs on the WiPy.
#
# Imports for the project
from machine import Pin
import utime

# Setup the button and LEDs
button = Pin('P23', Pin.IN, Pin.PULL_UP)
led1 = Pin('P3', Pin.OUT)
led2 = Pin('P4', Pin.OUT)
led3 = Pin('P5', Pin.OUT)
led4 = Pin('P6', Pin.OUT)
led5 = Pin('P7', Pin.OUT)

# Setup lists for the LEDs
stoplight = [led1, led2, led3]
walklight = [led4, led5]

# Turn off the LEDs
for led in stoplight:
    led.value(0)
for led in walklight:
    led.value(0)

# Start with green stoplight and red walklight
stoplight[2].value(1)
walklight[0].value(1)

# We need a method to cycle the stoplight and walklight
#
# We toggle from green to yellow for 2 seconds
# then red for 20 seconds.
def cycle_lights():
    # Go yellow.
    stoplight[2].value(0)
    stoplight[1].value(1)
    # Wait 2 seconds
    utime.sleep(2)
    # Go red and turn on walk light
    stoplight[1].value(0)
    stoplight[0].value(1)
    utime.sleep_ms(500)  # Give the pedestrian a chance to see it
    walklight[0].value(0)
    walklight[1].value(1)
    # After 10 seconds, start blinking the walk light
    utime.sleep(1)
    for i in range(0,10):
        walklight[1].value(0)
        utime.sleep_ms(500)
        walklight[1].value(1)
        utime.sleep_ms(500)

    # Stop=green, walk=red
    walklight[1].value(0)
    walklight[0].value(1)
    utime.sleep_ms(500)  # Give the pedestrian a chance to see it
    stoplight[0].value(0)
    stoplight[2].value(1)

# Create callback for the button
def button_pressed(line):
    cur_value = button.value()
    active = 0
    while (active &lt; 50):
        if button.value() != cur_value:
            active += 1
        else:
            active = 0
        utime.sleep_ms(1)
        print("")
    if active:
        cycle_lights()
    else:
        print("False press")

# Create an interrupt for the button
button.callback(Pin.IRQ_FALLING, button_pressed)

Listing 9-4.Stoplight Simulation – Part 1 (WiPy)


</pre>
              
<h4 class="Heading">测试和调试代码</h4>
<p>测试项目的这一部分需要将源代码文件复制到板上，然后执行它。由于代码是在没有<code>run()</code>函数的情况下编写的，所以只需简单地导入它就可以运行代码了。在给主板通电之前，请务必检查所有连接。回想一下，连接到电路板后，我们用来导入和运行代码的命令如下所示。</p>
<p>
                 
              </p>
<pre>&gt;&gt;&gt; import ped_part1_wipy
</pre>
              <p>一旦导入，代码将运行，您可以按下按钮来查看灯光循环通过阶段。如果您没有看到任何灯亮起(绿色停车灯和红色行走信号灯应该亮起)，请检查设置和初始化代码。如果按下按钮时灯不闪烁，请检查按钮的代码以确保它是正确的。如果它们没有按顺序亮起，可能是针脚接线不正确。遇到问题时，请务必检查所有接线连接，在断开或重新连接任何电线或组件之前，请务必关闭主板电源。</p>
<p>当项目运行时，尝试几次，以确保它按预期运行。那你应该恭喜你自己！您刚刚将几个分立的电子元件连接在一起，制作了一个行人行走按钮和交通灯的工作模拟。酷！</p>
<p>现在，让我们把这个项目提升一个档次，让它可以通过互联网访问。毕竟，这就是 IOT 的全部！</p>


<h3 class="Heading">第 2 部分:交通信号灯模拟器 HTML 远程控制</h3>
<p>这一部分的代码将使用第一部分的所有代码，但我们不需要按钮的代码。相反，我们将使用<code>Socket</code>类创建一个监听器来监听来自 web 浏览器的连接。该代码将向客户端发送一个简短的基于 HTML 的响应(一个简单的 web 页面),其中包括一个包含两个按钮的表单——一个用于 walk 请求，另一个用于关闭服务器代码。侦听器将在端口 80 上侦听。</p>
Note
<p>如果您正在使用 WiPy，您不需要添加任何网络代码，但是如果您想在自己的网络上运行该项目或者将它连接到 Internet，我将向您展示如何添加代码。</p>

<p>HTML 服务器的概念非常简单。代码监听套接字端口上的连接，然后接收请求(在本例中以 HTML GET 方法的形式)并发送 HTML 响应(网页)。然后，代码检查请求是否包含来自两个按钮之一的表单数据:一个按钮请求步行周期，另一个按钮关闭服务器。正如您将看到的，关闭服务器迫使我们将代码写得更加整洁。</p>
<p>如果您以前从未使用过 HTML 代码，不要担心，因为示例代码将提供您需要的一切。您不必学习 HTML 来使用本章(或下一章)中的项目，但是如果您想详细说明该项目或在您自己的项目中使用 HTML 服务器概念，一些基础知识会很有帮助。在<a href="https://www.w3schools.com/html/"> <code>https://www.w3schools.com/html/</code> </a>可以找到关于 HTML 的一个很好的信息源。</p>
<p>让我们看看 imports 部分需要做的更改。</p>
<h4 class="Heading">进口</h4>
<p>在导入部分我们还需要几个库。我们需要<code>socket</code>库(为了清楚起见，用别名重新命名了)<code>machine</code>库，以及来自<code>network</code>库的<code>WLAN</code>类。以这种方式编写导入是完全正常的，但是只要有一点想象力，您就可以简化它们。你明白了吗？下面显示了 WiPy 的完整导入部分。</p>
<p>
                 
              </p>
<pre>from machine import Pin
import usocket as socket
import utime
import machine
from network import WLAN
</pre>
              <p>Pyboard 的导入有点短。我们需要为网卡添加<code>SPI</code>库和<code>network</code>库以及<code>socket</code>库。下面显示了 Pyboard 的完整导入部分。</p>
<p>
                 
              </p>
<pre>from pyb import Pin, delay, ExtInt, SPI
import network
import usocket as socket
</pre>
              <p>现在，让我们看看设置部分的变化。</p>

<h4 class="Heading">设置</h4>
<p>对于项目的这一部分，我们需要添加代码，通过无线连接将我们的电路板连接到我们的网络(或互联网)。我们还需要将 HTML 代码以字符串的形式放在这里。这通常是在 Python 中定义大字符串的地方(和方式)。在任一侧使用三重引号会使字符串成为文档字符串(也称为 docstring)。详见<a href="https://www.python.org/dev/peps/pep-0257/"> <code>https://www.python.org/dev/peps/pep-0257/</code> </a>。</p>
<p>WiPy 的网络代码与我们在本书前面看到的代码相同。在这种情况下，它设置无线网络功能以连接到现有的无线网络，而不是 WiPy 的默认接入点行为。清单<a href="#Par85"> 9-5 </a>显示了 WiPy 的网络代码。</p>
<p>
                 
              </p>
<pre># Setup the board to connect to our network.
wlan = WLAN(mode=WLAN.STA)
nets = wlan.scan()
for net in nets:
    if net.ssid == 'YOUR_SSID':
        print('Network found!')
        wlan.connect(net.ssid, auth=(net.sec, 'YOUR_PASSWORD'), timeout=5000)
        while not wlan.isconnected():
            machine.idle() # save power while waiting
        print('WLAN connection succeeded!')
        print("My IP address is: {0}".format(wlan.ifconfig()[0]))
        break
Listing 9-5.
Wireless Network Setup


(WiPy)


</pre>
              <p>Pyboard 的网络代码与我们在本书前面看到的代码相同。在这种情况下，它首先设置 SPI 接口到网络板(在本例中是 CC3000 分线板)，然后启动到现有无线网络的无线连接，而不是 WiPy 的默认接入点行为。清单<a href="#Par87"> 9-6 </a>显示了 Pyboard 的网络代码。</p>
<p>
                 
              </p>
<pre># Setup network connection
nic = network.CC3K(SPI(2), Pin.board.Y5, Pin.board.Y4, Pin.board.Y3)
# Replace the following with yout SSID and password
nic.connect("YOUR_SSID", "YOUR_PASSWORD")
print("Connecting...")
while not nic.isconnected():
    delay(50)
print("Connected!")
print("My IP address is: {0}".format(nic.ifconfig()[0]))
Listing 9-6.Wireless Network Setup (Pyboard)


</pre>
              Tip
<p>您必须更改代码中的 SSID 和密码以匹配您的网络。</p>

<p>设置的另一部分是 HTML 响应代码。这似乎是代码中很难的部分，但是很简单。我们正在构造一个字符串，我们将通过套接字把它发送回客户机。该字符串包含以头开始的 HTML 代码。然后，我们提供一个标题(出现在浏览器的标题栏中)，一些显示在页面上的文本，以及一个包含这两个按钮的表单。这些按钮的形式是，当每个按钮被按下时，都会通过套接字向服务器发送一个 HTML GET 请求。简单！清单<a href="#Par90"> 9-7 </a>显示了项目的 HTML 字符串。还是那句话，不用担心细节。你可以以后再改进网页。</p>
<p>
                 
              </p>
<pre># HTML web page for the project
HTML_RESPONSE = """&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;MicroPython for the IOT - Project 2&lt;/title&gt;
  &lt;/head&gt;
  &lt;center&gt;&lt;h2&gt;MicroPython for the IOT - Project 2&lt;/h2&gt;&lt;/center&gt;&lt;br&gt;
  &lt;center&gt;A simple project to demonstrate how to control hardware over the Internet.&lt;/center&gt;&lt;br&gt;&lt;br&gt;
  &lt;form&gt;
    &lt;center&gt;
        &lt;button name="WALK" value="PLEASE" type="submit" style="height: 50px; width: 100px"&gt;REQUEST WALK&lt;/button&gt;
        &lt;br&gt;&lt;br&gt;
        &lt;button name="shutdown" value="now" type="submit" style="height: 50px; width: 100px"&gt;Stop Server&lt;/button&gt;
    &lt;/center&gt;
  &lt;/form&gt;
&lt;/html&gt;
"""
Listing 9-7.
HTML Response String






</pre>
              <p>注意代码<code>(&lt;button&gt;&lt;/button&gt;</code>标签中的按钮)。名称和值将在请求中发送到服务器。按钮的类型被定义为 submit，当按钮被放置在表单上时，当按钮被按下时，会使客户端将表单数据发送到服务器。最后，结束标记前的字符串是将显示在按钮上的标签。</p>
<p>如果你担心这是一个占用内存的大字符串，你是对的，确实如此。如果您正在计划一个使用大量 HTML 响应或者多个响应的项目，您可能希望考虑将这些响应存储在一个文件中(每个文件一个响应),并在将数据发送到客户端之前从文件中读取数据。这将节省一些数据空间，并可能对使用更多内存的大型项目产生影响。</p>
<p>不要在意这里使用的行数。空白主要是用来装饰的，所以如果你想减少它的整体视觉尺寸，你可以去掉空白，但是通常的做法是像这样缩进 HTML 代码以便于阅读。</p>
Tip
<p>如果您担心安全性(谁不担心呢？)，您可以使用安全套接字层连接来使您与 MicroPython 板的连接更加安全。MicroPython 提供了一个名为<code>ussl</code>的类供您使用。更多信息参见<code>ussl</code>类文档，或者你可以看看<a href="https://github.com/micropython/micropython/blob/master/examples/network/http_server_ssl.py"> <code>https://github.com/micropython/micropython/blob/master/examples/network/http_server_ssl.py</code> </a>的例子。</p>

<p>关于在 MicroPython 板上使用 HTML，还有一件重要的事情需要弄清楚:这个例子和您可能在互联网上找到的许多其他例子不应该与健壮的 web 服务器混淆。更具体地说，这个例子只是在侦听网络套接字时，一旦检测到来自客户机的 HTML GET 方法(请求),就将 HTML 发送回客户机。所以，这个例子仅仅是一个简单的 HTML 服务器，而不是一个 web 服务器，因为它能做 web 服务器能做的所有事情——它不能。因此，您应该注意对项目进行编码，将操作限制在特定的 GET(或 POST)请求上，并返回适当的 HTML 响应。</p>
Using Web Pages with Images
<p>由于 MicroPython 中还没有内置的 web 服务器，因此为 web 页面提供图像或任何其他媒体是有问题的。然而，你可以使用一个小技巧和你的电脑在你的项目中使用图像。我们可以在我们的 PC 上使用 Python 中的<code>SimpleHTTPServer</code>来提供一个基本的 web 服务器。在我们的 MicroPython 板的 HTML 中，我们可以对图像使用<code>img</code>标签，它使用一个 URL 指向我们 PC 上的文件。例如，下面的 HTML 将引用与我们 PC 上的 HTTP 服务器在同一个文件夹中的图像。</p>
<p>
                   
                </p>
<pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;MicroPython for the IOT - Project 2&lt;/title&gt;
    &lt;meta http-equiv="refresh" content="10"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Pedestrian Stoplight Simulation&lt;/p&gt;
    &lt;form&gt;
        &lt;img src="http://localhost:8000/red.png"&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
                <p>注意,<code>img</code>标签使用了一个到本地主机 8000 端口的 URL。当我们在 PC 上运行 Python 中的<code>SimpleHTTPServer</code>时，我们确定了这一点，如下所示。在您想要使用的图像所在的文件夹中运行此命令。</p>
<p>
                   
                </p>
<pre>$ python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 ...
127.0.0.1 - - [07/Aug/2017 14:42:30] "GET /red.png HTTP/1.1" 200 -
</pre>
                <p>这创建了一个混合解决方案，它将允许您在您的 MicroPython 基于 web 的项目中使用图像，尽管需要我们的 PC(或您网络上的任何其他 PC)的一点帮助。</p>

<p>现在我们来看看如何制作<code>run()</code>函数。</p>

<h4 class="Heading">功能</h4>
<p>代码中剩下要做的就是更改硬件按钮的代码，并创建一个包含代码主要部分的<code>run()</code>函数。在这个项目中，包括设置套接字的代码以及监听和响应代码。您可以保留<code>button_pressed()</code>功能，但它不是必需的。清单<a href="#Par103"> 9-8 </a>显示了<code>run()</code>函数的代码。</p>
<p>
                 
              </p>
<pre># Setup the socket and respond to HTML requests
def run():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(('', 80))
    sock.listen(5)
    server_on = True
    while server_on:
        client, address = sock.accept()
        print("Got a connection from a client at: %s" % str(address))
        request = client.recv(1024)
        # Process the request from the client. Payload should appear in pos 6.
        # Check for walk button click
        walk_clicked = (request[:17] == b'GET /?WALK=PLEASE')
        # Check for stop server button click
        stop_clicked = (request[:18] == b'GET /?shutdown=now')
        if walk_clicked:
            print('Requesting walk now!')
            cycle_lights()
        elif stop_clicked:
            server_on = False
            print("Goodbye!")
        client.send(HTML_RESPONSE)
        client.close()
Listing 9-8.The 
run() Function


(WiPy)


</pre>
              <p>注意，我们从设置套接字并将其绑定到端口 80 开始这个函数。<code>bind()</code>函数使用空字符串来指示套接字使用当前的 IP 地址。接下来，我们使用<code>listen(5)</code>函数告诉套接字侦听套接字，超时时间为 5 秒。然后，我们设置一个布尔变量，当它为真时，在监听和响应代码上循环。在这种情况下，我们使用布尔值，并在按下关闭按钮时将其设置为 False。</p>
<p>循环内部是事情变得有趣的地方。我们做的第一件事是使用<code>sock.accept()</code>接受来自套接字的连接，它返回两项:客户机对象实例和客户机的地址。我们可以打印出客户端的地址以供调试之用。</p>
<p>接下来，我们告诉客户端通过<code>client.recv(1024)</code>调用接收多达 1024 个字节。这将一直等到有来自客户端的响应，所以请注意这不是一个抢占式循环——它将一直等到客户端响应。当客户端发送数据时(比如第一次连接或按下按钮时)，我们可以搜索为命令发送的字符串。</p>
<p>注意，在代码中，我们检查搜索<code>b'GET /?WALK=PLEASE'</code>的行走请求或搜索<code>b'GET /?shutdown=now'</code>的关闭事件。这里有一点需要解释的诡计。我们使用请求字符串作为一个数组，从字符串中的字符数(17 或 18)开始搜索，用<code>[:17]</code>或<code>[:18]</code>表示。</p>
<p>如果检测到 walk 请求，我们就调用<code>cycle_lights()</code>函数，这是第 1 部分中没有修改的函数。如果检测到关机事件，我们将循环设置为终止，然后退出<code>run()</code>功能。</p>
<p>花些时间通读代码，直到你理解它是如何工作的。准备好后，打开一个名为<code>ped_part2_wipy.py</code>(或者 Pyboard 的<code>ped_part2_pyb.py</code>)的新文件，输入上面的代码。</p>
<p>最后，您必须删除设置按钮回调(或 Pyboard 上的<code>ExtInt()</code>调用)的代码行。把它留在里面不会损害代码，但是因为我们不使用按钮，所以不需要它，所有不必要的代码都应该删除。</p>
<p>现在，让我们看看 WiPy 和 Pyboard 的完整代码。</p>


<h3 class="Heading">完整代码</h3>
<p>在本节中，我们将看到 WiPy 和 Pyboard 的最终完整代码。这些列表供您参考，以确保您拥有适合您的主板的正确代码。清单<a href="#Par113"> 9-9 </a>显示了在 WiPy 上运行项目的完整代码。</p>
<p>
               
            </p>
<pre># MicroPython for the IOT - Chapter 9
#
# Project 2: A MicroPython Pedestrian Crosswalk Simulator
#            Part 3 - controlling LEDs over the Internet
#
# Required Components:
# - WiPy
# - (2) Red LEDs
# - (2) Yellow LEDs
# - (1) Green LED
# - (5) 220 Ohm resistors
#
# Note: this only runs on the WiPy.
#
# Imports for the project
from machine import Pin
import usocket as socket
import utime
import machine
from network import WLAN

# Setup the board to connect to our network.
wlan = WLAN(mode=WLAN.STA)
nets = wlan.scan()
for net in nets:
    if net.ssid == 'YOUR_SSID':
        print('Network found!')
        wlan.connect(net.ssid, auth=(net.sec, 'YOUR_PASSWORD'), timeout=5000)
        while not wlan.isconnected():
            machine.idle() # save power while waiting
        print('WLAN connection succeeded!')
        print("My IP address is: {0}".format(wlan.ifconfig()[0]))
        break

# HTML web page for the project
HTML_RESPONSE = """&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;MicroPython for the IOT - Project 2&lt;/title&gt;
  &lt;/head&gt;
  &lt;center&gt;&lt;h2&gt;MicroPython for the IOT - Project 2&lt;/h2&gt;&lt;/center&gt;&lt;br&gt;
  &lt;center&gt;A simple project to demonstrate how to control hardware over the Internet.&lt;/center&gt;&lt;br&gt;&lt;br&gt;
  &lt;form&gt;
    &lt;center&gt;
        &lt;button name="WALK" value="PLEASE" type="submit" style="height: 50px; width: 100px"&gt;REQUEST WALK&lt;/button&gt;
        &lt;br&gt;&lt;br&gt;
        &lt;button name="shutdown" value="now" type="submit" style="height: 50px; width: 100px"&gt;Stop Server&lt;/button&gt;
    &lt;/center&gt;
  &lt;/form&gt;
&lt;/html&gt;
"""

# Setup the LEDs (button no longer needed)
led1 = Pin('P3', Pin.OUT)
led2 = Pin('P4', Pin.OUT)
led3 = Pin('P5', Pin.OUT)
led4 = Pin('P6', Pin.OUT)
led5 = Pin('P7', Pin.OUT)

# Setup lists for the LEDs
stoplight = [led1, led2, led3]
walklight = [led4, led5]

# Turn off the LEDs
for led in stoplight:
    led.value(0)
for led in walklight:
    led.value(0)

# Start with green stoplight and red walklight
stoplight[2].value(1)
walklight[0].value(1)

# We need a method to cycle the stoplight and walklight
#
# We toggle from green to yellow for 2 seconds
# then red for 20 seconds.
def cycle_lights():
    # Go yellow.
    stoplight[2].value(0)
    stoplight[1].value(1)
    # Wait 2 seconds
    utime.sleep(2)
    # Go red and turn on walk light
    stoplight[1].value(0)
    stoplight[0].value(1)
    utime.sleep_ms(500)  # Give the pedestrian a chance to see it
    walklight[0].value(0)
    walklight[1].value(1)
    # After 10 seconds, start blinking the walk light
    utime.sleep(1)
    for i in range(0,10):
        walklight[1].value(0)
        utime.sleep_ms(500)
        walklight[1].value(1)
        utime.sleep_ms(500)

    # Stop=green, walk=red
    walklight[1].value(0)
    walklight[0].value(1)
    utime.sleep_ms(500)  # Give the pedestrian a chance to see it
    stoplight[0].value(0)
    stoplight[2].value(1)

# Setup the socket and respond to HTML requests
def run():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(('', 80))
    sock.listen(5)
    server_on = True
    while server_on:
        client, address = sock.accept()
        print("Got a connection from a client at: %s" % str(address))
        request = client.recv(1024)
        # Process the request from the client. Payload should appear in pos 6.
        # Check for walk button click
        walk_clicked = (request[:17] == b'GET /?WALK=PLEASE')
        # Check for stop server button click
        stop_clicked = (request[:18] == b'GET /?shutdown=now')
        if walk_clicked:
            print('Requesting walk now!')
            cycle_lights()
        elif stop_clicked:
            server_on = False
            print("Goodbye!")
        client.send(HTML_RESPONSE)
        client.close()
    sock.close()

Listing 9-9.Complete Code for the Stoplight Simulation (WiPy)


</pre>
            <p>现在，让我们看看 Pyboard 的代码。正如您将看到的，除了网络代码、导入和 pin 函数调用之外，它基本上是相同的。清单<a href="#Par115"> 9-10 </a>显示了在 Pyboard 上运行项目的完整代码。</p>
<p>
               
            </p>
<pre># MicroPython for the IOT - Chapter 9
#
# Project 2: A MicroPython Pedestrian Crosswalk Simulator
#            Part 2 - Controlling the walklight remotely
#
# Required Components:
# - Pyboard
# - (2) Red LEDs
# - (2) Yellow LEDs
# - (1) Green LED
# - (5) 220 Ohm resistors
# - (1) breadboard friendly momentary button
# - (1) CC3000 breakout board
#
# Note: this only runs on the Pyboard.
#
# Imports for the project
from pyb import Pin, delay, ExtInt, SPI
import network
import usocket as socket

# Setup network connection
nic = network.CC3K(SPI(2), Pin.board.Y5, Pin.board.Y4, Pin.board.Y3)
# Replace the following with yout SSID and password
nic.connect("YOUR_SSID", "YOUR_PASSWORD")
print("Connecting...")
while not nic.isconnected():
    delay(50)
print("Connected!")
print("My IP address is: {0}".format(nic.ifconfig()[0]))

# HTML web page for the project
HTML_RESPONSE = """&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;MicroPython for the IOT - Project 2&lt;/title&gt;
  &lt;/head&gt;
  &lt;center&gt;&lt;h2&gt;MicroPython for the IOT - Project 2&lt;/h2&gt;&lt;/center&gt;&lt;br&gt;
  &lt;center&gt;A simple project to demonstrate how to control hardware over the Internet.&lt;/center&gt;&lt;br&gt;&lt;br&gt;
  &lt;form&gt;
    &lt;center&gt;
        &lt;button name="WALK" value="PLEASE" type="submit" style="height: 50px; width: 100px"&gt;REQUEST WALK&lt;/button&gt;
        &lt;br&gt;&lt;br&gt;
        &lt;button name="shutdown" value="now" type="submit" style="height: 50px; width: 100px"&gt;Stop Server&lt;/button&gt;
    &lt;/center&gt;
  &lt;/form&gt;
&lt;/html&gt;
"""

# Setup the LEDs
led1 = Pin('X7', Pin.OUT_PP)
led2 = Pin('X6', Pin.OUT_PP)
led3 = Pin('X5', Pin.OUT_PP)
led4 = Pin('X4', Pin.OUT_PP)
led5 = Pin('X3', Pin.OUT_PP)

# Setup lists for the LEDs
stoplight = [led1, led2, led3]
walklight = [led4, led5]

# Turn off the LEDs
for led in stoplight:
    led.low()
for led in walklight:
    led.low()

# Start with green stoplight and red walklight
stoplight[2].high()
walklight[0].high()

# We need a method to cycle the stoplight and walklight
#
# We toggle from green to yellow for 2 seconds
# then red for 20 seconds.
def cycle_lights():
    # Go yellow.
    stoplight[2].low()
    stoplight[1].high()
    # Wait 2 seconds
    delay(2000)
    # Go red and turn on walk light
    stoplight[1].low()
    stoplight[0].high()
    delay(500)  # Give the pedestrian a chance to see it
    walklight[0].low()
    walklight[1].high()
    # After 10 seconds, start blinking the walk light
    delay(10000)
    for i in range(0,10):
        walklight[1].low()
        delay(500)
        walklight[1].high()
        delay(500)

    # Stop=green, walk=red
    walklight[1].low()
    walklight[0].high()
    delay(500)  # Give the pedestrian a chance to see it
    stoplight[0].low()
    stoplight[2].high()

# Setup the socket and respond to HTML requests
def run():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(('', 80))
    sock.listen(5)
    server_on = True
    while server_on:
        client, address = sock.accept()
        print("Got a connection from a client at: %s" % str(address))
        request = client.recv(1024)
        # Process the request from the client. Payload should appear in pos 6.
        # Check for walk button click
        walk_clicked = (request[:17] == b'GET /?WALK=PLEASE')
        # Check for stop server button click
        stop_clicked = (request[:18] == b'GET /?shutdown=now')
        if walk_clicked:
            print('Requesting walk now!')
            cycle_lights()
        elif stop_clicked:
            server_on = False
            print("Goodbye!")
        client.send(HTML_RESPONSE)
        client.close()
    sock.close()

Listing 9-10.Complete Code for the Stoplight Simulation (Pyboard)


</pre>
            <p>好了，现在我们准备好执行这个项目了。</p>


<h2 class="Heading">执行！</h2>
<p>现在是有趣的部分！我们已经设置好了控制 led 的代码，从第 1 部分我们就知道它是有效的。我们还有代码来设置一个套接字侦听器，以通过我们的 MicroPython 板上的端口 80 接受连接。我们现在所需要的就是那块板的 IP 地址来指向我们的网络浏览器。我们可以通过运行代码从我们的调试语句中得到答案。清单<a href="#Par118"> 9-11 </a>显示了项目在 WiPy 上的初始运行(Pyboard 的结果类似)。</p>
<p>
             
          </p>
<pre>MicroPython v1.8.6-694-g25826866 on 2017-06-29; WiPy with ESP32
Type "help()" for more information.
&gt;&gt;&gt; import ped_part3_wipy as w
Network found!
WLAN connection succeeded!
My IP address is: 192.168.42.128
&gt;&gt;&gt; w.run()
Got a connection from a client at: ('192.168.42.127', 49236)
Got a connection from a client at: ('192.168.42.127', 49237)
Got a connection from a client at: ('192.168.42.127', 49243)
Requesting walk now!
Got a connection from a client at: ('192.168.42.127', 49254)
Goodbye!
&gt;&gt;&gt;
Listing 9-11.Running the Stoplight Simulation (WiPy)


</pre>
          <p>注意，在这种情况下，IP 地址是 192.168.42.127。我们需要做的就是把它放入我们的浏览器，如图<a href="#Fig3"> 9-3 </a>所示。</p>
Caution
<p>如果您使用 WiPy 和 telnet 打开 REPL 控制台，请注意，一旦您运行代码的网络部分，您的 REPL 控制台将断开连接。这是因为 IP 地址会变！因此，当使用 WiPy 连接到您的网络时，最好通过 USB 使用屏幕或其他终端程序来获得 REPL 控制台。</p>

<p><img src="A447395_1_En_9_Fig3_HTML.jpg" alt="A447395_1_En_9_Fig3_HTML.jpg"/></p>
<p>图 9-3。</p>Stoplight Simulation Project



<p>输入 URL 后，您应该会看到如图所示的网页。如果没有，一定要检查代码中的 HTML，确保它和显示的完全一样；否则，页面可能无法正常显示。您还应该确保您的 PC 所连接的网络可以连接到您的主板所连接的网络。如果您的家庭办公室像我一样设置，可能有几个 WiFi 网络可供您使用。最好你的主板和你的电脑在同一个网络(和同一个子网)。</p>
<p>一旦你解决了这个问题，继续按下按钮。请记住，步行按钮将启用，您将看到灯光循环，但您将无法做任何事情，直到步行循环完成。这是因为我们直到循环完成后才返回响应 HTML(请看代码来说服自己)。此外，当您单击 shutdown 按钮时，您将需要重新启动代码来重新运行它。只需再次调用<code>run()</code>函数。</p>
<p>再看一下上面的清单。注意，每次客户端连接时都会打印调试消息(代码接受连接和 GET 请求)以及一个关于它正在做什么的声明。您应该会在 REPL 控制台中看到类似的内容。</p>
<p>在这一点上，你应该沐浴在你的第一个成功的 MicroPython IOT 远程控制硬件项目的奇迹中。花些时间享受出色完成的工作。</p>
<p>这个过程的最后一步对于这个项目来说是可选的，因为除了测试之外，您不太可能希望它运行更多。然而，如果您确实想让它在每次启动您的板时运行，您可以修改板上的<code>main.py</code>代码模块来导入您的代码并调用<code>run()</code>函数。</p>
When Things Go Wonky<a href="#Fn1" id="Fn1_source"><sup>1</sup></a>

<p>有时，当处理更大的脚本或更复杂的逻辑、许多库(驱动程序)，甚至当使用许多字符串(内存)时，有时会遇到奇怪、简洁的错误。下面是一个例子。</p>
<p>
               
            </p>
<pre>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "ped_part2_wipy.py", line 97, in run
OSError: [Errno 12] ENOMEM
</pre>
            <p>在这种情况下，该错误是一个内存不足错误，意味着您的 MicroPython 板已经为您的代码分配了所有(或几乎所有)内存，并且它无法继续。此时你唯一能做的就是重启主板。您可以尝试软启动(CTRL-D)，但这通常不能解决问题，但硬重启可以。</p>

<p>至此，您已经完成了第一个真正的 MicroPython IOT 项目。我们可以称之为 IOT 项目，因为它使用互联网，但它只是一个模拟，并不实际控制真正的交通灯，但我们在这个项目中看到的技术允许我们将我们的 MicroPython 板连接到互联网并与之交互-这就是 IOT 的全部内容！</p>

<h2 class="Heading">更进一步</h2>
<p>这个项目展示了在其他项目中重用这些技术的良好前景。对于 HTML 服务器方面来说尤其如此。如果您喜欢通过互联网控制您的 MicroPython 板，您应该考虑花时间探索一些修饰。这里有一些你可以考虑的。有些很容易，有些可能是一个挑战或需要更多的研究。<a href="#Fn2" id="Fn2_source"> <sup> 2 </sup> </a></p>
<ul class="UnorderedListMarkBullet"><li>使用新像素(<a href="https://www.adafruit.com/category/168"> <code>https://www.adafruit.com/category/168</code> </a>)代替 led。这些是 RGB 发光二极管，所以你只需要两个——一个用于交通信号灯，一个用于步行灯。更多信息和示例见<a href="https://github.com/JanBednarik/micropython-ws2812"> <code>https://github.com/JanBednarik/micropython-ws2812</code> </a>。</li>
<li>修改 HTML 响应以显示灯的状态。</li>
<li>探索 HTML 代码，根据您的喜好更改网页。考虑使用级联样式表来更改按钮被按下时的背景。</li>
<li>将您的板连接到互联网，并呼叫朋友连接到您的板并进行测试。</li>
<li>使用显示屏代替行走标志的发光二极管来显示“行走”或“不要行走”</li>
</ul>

<p>当然，如果你想继续下一个项目，欢迎你这样做，但是花些时间探索这些潜在的修饰——这将是一个很好的实践。</p>
<p>如果您准备迎接真正的挑战，您可以在这个项目中重用代码，并用继电器板替换按钮逻辑，这样您就可以使用 MicroPython 板等低压设备来打开或关闭高压电路。在这种情况下，您可以使用 HTML 按钮通过互联网打开或关闭中继。</p>

<h2 class="Heading">摘要</h2>
<p>使用分立的电子元件会非常有趣。当你刚开始接触电子学时，光是让电路工作就令人兴奋不已。现在我们对 MicroPython 有了更多的了解，我们可以看到拥有像 Python 这样的易于编程的语言来直接处理硬件——甚至通过互联网——是多么强大。</p>
<p>在这一章中，我们实现了一个行人人行横道按钮和交通信号灯的模拟。我们用一系列发光二极管来代表交通信号灯和步行信号。我们还添加了一个硬件按钮来模拟按下真正的步行按钮，然后通过简单的 HTML 从我们的 MicroPython 板上将它转换成一个遥控按钮。如果你喜欢这个项目，你会更喜欢接下来的两个项目。</p>
<p>在下一章中，我们将探索一个项目，该项目使用传感器读取值，然后将数据存档，并在需要时显示在网页上。这是我们构建真正的 MicroPython IOT 项目的倒数第二步。本章和下一章将向您展示如何通过互联网提供数据，项目的最后一章将向您展示如何通过云服务提供您的传感器数据。</p>

Footnotes
<a href="#Fn1_source">1</a><p>一个高度技术性的术语，描述一种极度混乱和普遍执行失败的状态。不要与 hinky 混淆，hinky 表示当某件事情工作但不太正确时，情况稍微不太严重。</p>

 

<a href="#Fn2_source">2</a><p>我把这些包括在内，这样你可以增长你的知识，超越这本书的范围。当你完成书中的其他项目时，试试这些。</p>

 



</body>
</html>