# 5.替代接口

我们有一个命令行工具来报告服务器上各种数据收集功能的结果，但是能够连接到服务器并运行命令行工具来检查它们的当前状态并不是监控大量数据收集系统的可持续方式。我们不想记下多次命令行工具调用的结果，并手动分析它们。最好能够自动收集信息，并能够分析原始值，而不是我们向用户显示的格式化结果。

我们可以创建一个简单的基于 HTTP 的 web 服务器，它返回传感器的值来响应 API 调用，而不是编写一个程序通过 SSH 依次连接到每个服务器并调用命令行工具。为此，我们必须为相同的传感器创建一个新的接口。

## Web 微服务

在过去的几年中，有一种趋势是通过松散耦合许多服务来创建 web 应用程序，每个服务执行一个特定的任务。这种架构牺牲了统一代码库的便利性，换取了独立开发每个组件的灵活性。有些 web 框架比其他框架更适合这类问题——有些是专门为这一领域开发的。

有很多 Python web 框架，比如 Django、Pyramid、Flask 和 Bottle，它们都可以作为 API 服务器的基础。Django 和 Pyramid 都是复杂 web 应用程序的绝佳选择，它们提供了许多内置特性，如翻译、会话管理和数据库事务管理。其他的，像烧瓶和瓶子，要小得多。他们有少量的依赖项，并擅长作为微服务的基础。

我们需要一个非常简单的 API 服务器，没有任何为人类设计的界面。不需要 HTML 模板、导航系统或者 CSS 和 Javascript 管理。为微服务设计的 Web 框架非常适合非常小的 API 服务器。

### WSGI(消歧义)

所有 Python web 框架都使用一种标准来创建通过 HTTP 提供服务的应用程序，这种标准称为 web 服务器网关接口，简称 WSGI。WSGI 是一个简单的 API，我们可以直接使用它来编写向 Web 公开的函数。

WSGI 应用程序是一个 Python 可调用程序，它接受两个参数。第一个是表示环境的字典(它包含各种 HTTP 头和服务器信息，比如客户机的远程地址)，第二个是`start_response(...)`函数，它期望 HTTP 状态代码是一个字符串，响应头的 iterable 是两个字符串元组。

Python 标准库包括一个简单的 WSGI 服务器，用于测试 WSGI 应用程序。对于用于生产代码来说，它还不够好，但是对于开发来说却很方便。它是从`wsgiref.simple_server`模块导入的，其中`make_server(...)`上下文管理器接受主机和端口绑定参数以及要服务的函数。得到的上下文对象有一个`serve_forever()`方法来运行 HTTP 服务器，直到被`<CTRL+c>`中断，还有一个`handle_request()`方法来响应单个请求。使用 wsgiref 服务器运行一个演示，Hello World 网站如清单 [5-1](#PC1) 所示。

```py
import wsgiref.simple_server

def hello_world(environ, start_response):
    headers = [
        ("Content-type", "text/plain; charset=utf-8"),
        ("Content-Security-Policy", "default-src 'none';"),
    ]
    start_response("200 OK", headers)
    return [b"hello  world", ]

if __name__ == "__main__":
    with wsgiref.simple_server.make_server("", 8000, hello_world) as server:
        server.serve_forever()

Listing 5-1Hello world WSGI app

```

`start_response(...)`函数特定于负责处理传入连接的 WSGI 兼容服务器，但是它总是以相同的方式运行。如果在 Python 的内置测试 web 服务器上使用,`hello_world(...)`函数也会工作得很好，比如 Gunicorn 这样的专业生产质量 web 服务器，甚至是 Heroku 这样的 PaaS 提供商。在`hello_world(...)`中没有涉及特定于服务器的导入或函数调用；这完全是通用的。

这个函数的返回值是响应的主体，这可能与直觉相反，是一个可迭代的字节串，而不是单个字节串。如果我们在网页浏览器中打开`http://localhost:8000`，我们会看到“hello world”，如图 [5-1](#Fig1) 所示。

![../images/481001_1_En_5_Chapter/481001_1_En_5_Fig1_HTML.jpg](../images/481001_1_En_5_Chapter/481001_1_En_5_Fig1_HTML.jpg)

图 5-1

hello world 应用程序的浏览器视图

使用生成器函数允许服务器在所有数据生成之前就开始向客户机传递一些数据，即在计算其余数据之前先处理部分数据。如果我们从纯文本切换到 HTML， <sup>[1](#Fn1)</sup> 我们可以通过引入一些有意的延迟来看到这种效果，如清单 [5-2](#PC2) 所示。

```py
import time
import wsgiref.simple_server

def hello_world(environ, start_response):
    headers = [
        ("Content-type", "text/html; charset=utf-8"),
        ("Content-Security-Policy", "default-src 'none';"),
    ]
    start_response("200 OK", headers)
    yield b"<html><body>"
    for i in range(20):
        yield b"<p>hello world</p>"
        time.sleep(1)
    yield b"</body></html>"

if __name__ == "__main__":
    with wsgiref.simple_server.make_server("", 8000, hello_world) as server:
        server.serve_forever()

Listing 5-2Generator-based hello world WSGI app

```

当我们在浏览器中打开`http://localhost:8000`时，我们现在看到 hello world 消息每秒钟以新行的形式出现一次。就吞吐量而言，这对于较大的响应非常有用，并且可以减少服务器上的内存使用。例如，如果我们编写了一个 WSGI 应用程序来传输一个 500MB 日志文件的每一行，那么遍历这些行并一行一行地生成它们就意味着内存中一次不会有超过一行，并且一旦文件开始被读取就发送数据。如果我们必须返回一个单独的字符串，那么整个文件必须被读入内存，然后作为一个整体传递给服务器进行传输。

我们可以使用同样的方法来创建一个 WSGI 端点，它遍历传感器并依次获取关于每个传感器的信息。然而，单个 JSON 对象更容易解析为 API 响应，因此最好创建一个传感器标题字典来赋值，并将其作为一个整体进行序列化。现在是向该函数添加类型信息的好时机，这样我们就可以利用 mypy 的类型提示来标记错误。结果服务器列出了 [5-3](#PC3) ，我们应该将其保存为`src/apd/sensors/wsgi.py`。

```py
import json
import typing as t
import wsgiref.simple_server

from apd.sensors.cli import get_sensors

if t.TYPE_CHECKING:
    # Use the exact definition of StartResponse, if possible
    from wsgiref.types import StartResponse
else:
    StartResponse = t.Callable

def sensor_values(
    environ: t.Dict[str, str], start_response: StartResponse
) -> t.List[bytes]:
    headers = [
        ("Content-type", "application/json; charset=utf-8"),
        ("Content-Security-Policy", "default-src 'none';"),
    ]
    start_response("200 OK", headers)
    data = {}
    for sensor in get_sensors():
        data[sensor.title] = sensor.value()
    encoded = json.dumps(data).encode("utf-8")
    return [encoded]

if __name__ == "__main__":
    with wsgiref.simple_server.make_server("", 8000, sensor_values) as server:
        server.handle_request()

Listing 5-3Basic WSGI server to show sensor data

```

我们可以通过在我们的开发机器上使用

```py
> pipenv run python -m apd.sensors.wsgi

```

访问这个 web 服务器并通过`jq` JSON 格式化程序 <sup>[2](#Fn2)</sup> 传递它会产生以下输出:

```py
{
  "AC Connected": false,
  "CPU Usage": 0.098,
  "IP Addresses": [
    [
      "AF_INET6",
      "fe80::xxxx:xxxx:xxxx:fa5"
    ],
    [
      "AF_INET6",
      "2001:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:1b9b"
    ],
    [
      "AF_INET6",
      "2001:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:fa5"
    ],
    [
      "AF_INET",
      "192.168.1.246"
    ]
  ],
  "Python Version": [

    3,
    8,
    0,
    "final",
    0
  ],
  "RAM Available": 716476416,
  "Relative Humidity": null,
  "Ambient Temperature": null,
  "Solar panel cumulative output": null
}

```

Note

我们已经检查了`t.TYPE_CHECKING`并且有条件地进口了一些东西。有些名字只能在 mypy 中导入，不能在普通 Python 中导入。当在`.pyi`文件中定义了帮助变量，而不是直接在`.py`文件中集成类型提示时，就会发生这种情况。`StartResponse`变量就是其中之一；它表示标准`start_response(...)`函数的类型，wsgiref 服务器的实际定义不需要它，只需要类型提示。这个块让我们在类型检查时导入正确的值，但是在其他情况下，我们退回到不太具体的`t.Callable`，因为类型提示在类型检查运行之外并不重要。

当然，我们应该编写一个测试来确保端点按预期工作。由于我们还没有编写任何代码来处理错误情况，所以我们可以编写的测试并不多，但是类似于`test_sensors.py`中 CLI 的高级功能测试是合适的。

由于 WSGI 接口是一个 Python API，所以可以通过调用带有`environ`和`start_response`参数占位符值的`sensor_values(...)`函数来为它们编写功能测试。WebTest 包提供了一种封装 WSGI 函数并使用行为类似于高级 HTTP API 的 API 与之交互的方法，这使得编写测试更加容易。安装 WebTest 后，我们可以将清单 [5-4](#PC7) 中的测试添加到`tests/`目录中并运行它。

```py
import pytest

from webtest import TestApp

from apd.sensors.wsgi import sensor_values
from apd.sensors.sensors import PythonVersion

@pytest.fixture
def subject():
    return sensor_values

@pytest.fixture
def api_server(subject):
    return TestApp(subject)

@pytest.mark.functional
def test_sensor_values_returned_as_json(api_server):
    json_response = api_server.get("/sensors/").json
    python_version = PythonVersion().value()

    sensor_names = json_response.keys()
    assert "Python Version" in sensor_names
    assert json_response["Python Version"] == list(python_version)

Listing 5-4Functional test for wsgi service

```

```py
> pipenv install --dev webtest

```

虽然我们的 WSGI 应用程序可以工作，但是它离产品质量还很远。这就是微框架有用的地方；它们让我们从没有错误检查的单端点 web 应用程序过渡到可靠的、生产质量的 web 应用程序。

### API 设计

在我们继续之前，我们应该计划我们想要提供的 API。我们希望能够检索所有的传感器值，但是获得单个特定值可能是有用的，因为提取传感器值可能需要一些时间。我们还需要决定这个 API 的身份验证，因为它将不再受到保护，因为只有能够登录到相关服务器的人才能使用它。

大多数 API 不使用传统的用户名和密码登录系统；相反，他们使用单个 API 密钥作为凭证。无论我们的用户是由用户名和密码标识的人，还是由 API 键标识的其他程序，选择授权系统的考虑因素都是相同的。

有三种广泛的用户授权方法。 <sup>[3](#Fn3)</sup> 扁平的权限结构在简单的应用程序中很流行，用户只需要登录就可以访问网站的所有功能。这种方法通常用在简单的 Django 应用程序中。如果用户登录并且在用户对象上设置了`is_staff`属性，他们就可以访问网站的管理员功能。

Django 的完全授权制度表明了第二种选择。它在一个组和许可系统上工作。可以直接或通过用户的组成员身份为用户分配权限。这些权限是细粒度的，但相对来说是全局的。例如，如果用户拥有“编辑用户”权限，他们将能够编辑任何用户。

最后，最复杂的系统涉及用户和数据之间具有灵活关系的权限。在这种情况下，不会直接为用户分配权限，而是将权限分配给站点中某个数据上下文中的用户或组。在这种情况下，我们可能会看到，在给定用户的上下文中,“编辑用户”权限被分配给整个管理员组和相关的单个用户。

图 [5-2](#Fig2) 显示了我推荐用来确定三种方法中哪一种最适合您的用例的决策树。

![../images/481001_1_En_5_Chapter/481001_1_En_5_Fig2_HTML.jpg](../images/481001_1_En_5_Chapter/481001_1_En_5_Fig2_HTML.jpg)

图 5-2

用于选择不同 authz 方法的决策树

我们的 API 将是只读的；我们需要保护的唯一功能是读取传感器值的能力。要回答第一个问题，我们需要决定是否要根据请求用户的身份向不同组的传感器授予 API 访问权限。是否允许部分用户看到 Python 版本却看不到温度？这个 API 的唯一用例是从多个来源收集信息并集中存储，这意味着我们只希望加载所有传感器值，并且希望使用最少的 HTTP 请求来完成。对所有用户一视同仁的授权解决方案是最合适的。这种访问控制的目的不是区分具有不同权限级别的用户；我们只关心用户是否有效。

因此，我们在第一个问题上采取右边的分支。下一个决定是我们是否需要能够通过系统创建新用户，或者我们是否可以预先定义用户凭证。我们只需要一个用户就可以访问这些信息，所以我们不需要添加新的用户。

这样做的结果是，我们在最右边有认证系统；用户帐户预先定义为部署的属性。

#### 证明

我们选择的认证框架也应该与我们期望的与 API 服务器的交互方式相匹配。用户最熟悉的身份验证形式是提供会话凭据的专用登录页面，通常采用 cookie 的形式。Cookies 有一个有限的生命周期，尽管这可能是一个很长的时间，这使得用户可以避免定期主动重新认证。

另一种在 API 中更常见的方法是，每个请求可以包含身份验证信息，或者作为专用的 HTTP 头，或者通过使用 HTTP Basic 和 Digest auth 特性。

因为我们打算让我们的 API 被一个自动化的过程访问，并且登录信息不会改变，所以 API key 风格的认证系统符合我们的需求。

### 瓶

这个 *Flask* 微框架的灵感来自于一个愚人节玩笑:一个叫做*的微框架否认了*是作为一个单一文件发布的，接口非常简单。作者阿明·罗纳彻写了一个 160 行的框架，强调营销胜于高级功能。也许毫不奇怪，当大多数 web 框架关注大型的、功能齐全的应用程序时，许多人实际上对 web 编程的简单接口感兴趣。一年后， *Flask* 诞生了，这是一个高质量的 web 框架，旨在满足那些对*如此感兴趣而对*不感兴趣的人。

Flask 提供使用 Jinja2 模板语言生成 HTML，管理请求和响应头，管理 URL 路由，并在需要时生成错误。这种灵活性使得简化我们之前编写的函数(删除一些实现细节)以及扩展接口以提供更多功能变得更加容易。

在开始编写基于 Flask 的 web 服务器之前，我们需要将 Flask 添加到项目的依赖项中。我们将采取不同于以往的方法，并将此作为“额外内容”添加进来。Extras 是 Python 包的可选依赖集，用户可以在安装时选择。只想要命令行工具的用户将运行`pipenv install apd.sensors`，而想要 API 访问的用户将运行`pipenv install apd.sensors[webapp]`。

*setup.cfg 段定义了* `webapp` *多余的*

```py
[options.extras_require]
webapp = flask

```

选择将 CLI 依赖项作为核心要求，而将 API 服务器作为可选项，这是完全随意的；开发人员完全有可能需要额外的两个特性，或者将它们作为默认依赖项包含进来。

Tip

您应该根据用户的需求决定默认安装哪些依赖项，哪些是额外的。如果您怀疑有些用户可能不想使用完全独立的特性，特别是如果它有很大的依赖集，那么它是额外的一个很好的候选。

请记住，试图从`extras_require`中指定的包导入一个模块会导致导入错误。如果您在这样的模块中有一个命令行脚本，您应该捕捉导入错误并在命令行上返回一个有用的错误。对于试图运行 CLI 工具而没有在安装时指定他们需要 CLI 依赖项的用户来说,`ImportError` traceback 并不是一个合适的错误。

一旦我们添加了`webapp`额外声明，我们就可以使用`pipenv install -e .[webapp]`声明我们的环境需要这个额外声明。这将导致 flask 被添加到依赖项集并安装到环境中。安装了一个 flask 可执行文件，可以通过`pipenv run flask`访问，但对我们来说重要的是我们能够导入 Flask 应用程序代码。

我们创建的基本传感器列表 WSGI 应用程序的等效 Flask 应用程序非常相似(列表 [5-5](#PC9) ),它展示了 Flask 在 web 服务器和程序员之间的介入是多么少。这里的关键是`@app.route(...)`装饰器调用。我们将在下一节中讨论 decorator，但是现在只需要知道 decorator 操作它直接位于其定义之前的函数或类就足够了。在这种情况下，`@app.route("/sensors/")`定义了下面的函数是负责`http://localhost:8000/sensors/`的实现。

```py
import json
import typing as t
import wsgiref.simple_server

from flask import Flask

from apd.sensors.cli import get_sensors

app = Flask(__name__)

@app.route("/sensors/")
def sensor_values() -> t.Tuple[t.Dict[str, t.Any], int, t.Dict[str, str]]:
    headers = {"Content-Security-Policy": "default-src 'none'"}
    data = {}
    for sensor in get_sensors():
        data[sensor.title] = sensor.value()
    return data, 200, headers

if __name__ == "__main__":
    with wsgiref.simple_server.make_server("", 8000, app) as server:
        server.serve_forever()

Listing 5-5Minimal example of sensor API server in Flask

```

如果我们没有设置任何显式的头值，我们可以进一步简化`sensor_values()`函数，只返回数据字典。 <sup>[4](#Fn4)</sup> Flask 自动处理将视图函数返回的字典转换为 JSON 表示，以及编码字符串和设置适当的内容类型头。

这个 WSGI 端点与我们手工创建的基本端点的最大区别是，这个端点根据 URL 返回不同的内容。我们最初的实现不检查特定的 URL，总是返回传感器的值。新的实现将为任何 URL 返回 404，除了`/sensors/`(和`/sensors`，它将被重定向到`/sensors/`)。

为了测试这个新的 Flask 版本，我们需要导入名称`app`而不是`sensor_values()`，因为`sensor_values()`已经成为实现细节，而`app`是实际的 WSGI 端点。此外，如果我们以前没有这样做，我们必须确保我们对正确的 URL 发出了 GET 请求。

DISPATCHING FUNCTIONS ON THE WEB

在第二章[中，我们讨论了动态分派的概念，在运行时通过调用的类来查找函数。因此，我们使用的`@app.route(...)`装饰器有一个 app 的隐式第一个参数，允许装饰器将被装饰的函数注册为`app`对象上的已知路径。](02.html)

无论请求是什么，WSGI 应用程序都使用相同的环境和请求类型调用相同的函数。由这个函数来决定哪个代码负责响应这个请求。

`app`对象有一组注册的视图函数可供选择。这些通常带有条件注释，比如匹配 URL 的特定正则表达式；请求是 GET、POST 还是 DELETE 等等；甚至像权限查找或接受头这样的复杂条件。

框架的职责是为给定的 web 请求确定应该调用哪个用户提供的函数。由于这允许将单个函数映射到 URL，这使得为 Web 编写代码的过程比 WSGI 默认的单个函数做所有工作更容易管理。

金字塔 web 框架通过其谓词系统将这一点发挥到了极致，允许将任意条件与视图函数相关联。它允许不同的函数根据任意条件负责给定的 URL，这是一个非常强大的特性。

### Python 装饰者

在我们能够称这个 API 为生产就绪之前，我们需要实现我们讨论过的访问控制。我们可以通过使用装饰器来实现这一点，就像 Flask 使用与 route 装饰器相关联的 URL 模式来注释函数一样。

decorator 是一个 Python 函数，它将单个可调用的类或类作为参数，并返回传递给它的相同类型的参数。装饰模式允许用户编写定制的函数序言或后记——在函数主体之前或之后运行的代码。您无法访问函数的内部变量，只能访问输入和输出，但这足以对输入或输出的转换添加额外的错误检查。此外，一些 decorator 函数代码在函数定义时运行，可用于在应用程序启动时设置元数据(如 URL 路由)。

通过在函数体的开头或结尾调用一个实用函数，可以完成装饰者做的许多事情；装饰者是一个非常方便的特性。Python 开发人员通常更喜欢编写 decorators，因为他们被认为更符合该语言的习惯，但是他们也有一些真正的优势。

使用一个效用函数来完成装饰器的工作意味着被操作的函数需要添加一些条件逻辑来处理各种效用函数的结果。表 [5-1](#Tab1) 显示了一个效用函数和装饰器的例子，如果一个函数的任何参数为负，它将返回 0。`has_negative_arguments(...)`函数决定我们要禁止的情况是否适用，但是处理该情况的代码必须添加到`power(...)`函数本身。

表 5-1

一个助手函数和一个装饰器方法来验证参数

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| *辅助功能方法*`def has_negative_arguments(*args):``for arg in args:``if arg < 0:``return True``return False``def power(x, y):``if has_negative_arguments(x, y):``return 0``return x ** y` | *装饰方法*`def disallow_negative(func):``def inner(*args):``for arg in args:``if arg < 0:``return 0``return func(*args)``return inner``@disallow_negative``def power(x, y):``return x ** y` |

装饰器方法将条件和测试一起放在装饰器中。这种方法意味着装饰器是完全独立的；想要使用它的函数不需要包含任何超出自己实现所需的逻辑。

这两种实现在行为上没有区别；然而，decorator 版本将所有的复杂性转移到了 decorator 定义本身，让用户函数自由。一般来说，decorators 由多个函数使用，所以这种模式允许使用干净、容易理解的代码。

#### 关闭

装饰者依赖于一种叫做闭包的语言特性，这是变量作用域的一个有点复杂的结果。在 Python 中，当一个函数使用内部变量时，这些变量只能在该函数中通过名称获得:尽管它们的值可能会被返回，但是当执行从该函数传递过来时，该变量的内部名称的绑定会丢失。

```py
def example(x, y):
    a = x + y
    b = x * y
    c = b * a
    print(f"a: {a}, b: {b}, c: {c}")
    return c

>>> result = example(1, 2)
a: 3, b: 2, c: 6
>>> print(result)
6

```

在执行`example(...)`函数的过程中，变量`x`和`y`是传递给函数的参数。随着执行的继续，变量`a`、`b`和`c`被逐步定义。一旦执行通过返回函数传递回包含范围，所有这些变量关联都将丢失。仅保留曾经与`c`关联的*值*，然后将其存储在包含范围的结果变量中。

然而，如果我们在这个函数中定义了一个函数并返回它，那么这个内部函数必须仍然可以访问它需要执行的所有变量。只要还需要这些变量，解释器就不会解除它们的关联。在外部函数作用域中定义的、被内部函数使用的任何变量都将把它们的关联传递到这个新函数中， <sup>[6](#Fn6)</sup> ，并且这些变量仍然对内部函数可用，但对任何其他函数都不可用。这个内部函数被称为*闭包*。

```py
def example(x, y):
    a = x + y
    b = x * y
    c = b * a
    print(f"a: {a}, b: {b}, c: {c}")
    def get_value_of_c():
        print(f"Returning c: {c}")
        return c
    return get_value_of_c

>>> getter = example(1, 2)
a: 3, b: 2, c: 6
>>> print(getter)
<function example.<locals>.get_value_of_c at 0x034F96F0>
>>> print(getter())
Returning c: 6
6

```

在这个例子中，变量 c 与`get_value_of_c()`函数相关联，因此在调用该函数时可以返回它。当我们调用`get_value_of_c()`函数时，它可以访问示例中的变量`c`，但不能访问变量`a`或`b`，因为它不使用它们。

##### 修改父范围中的变量

有可能比这更进一步，编写复杂的函数集，对其包含范围内的变量进行操作，可能会改变它们的值。我想不出我什么时候需要过这个功能，但是理解变量作用域是如何工作的是很有帮助的。

为了实现这一点，我们需要使用**非本地**关键字。虽然 Python 可以推断出，如果使用了变量的值，就应该从包含变量的范围中提取变量，但是它不能推断出设置变量是试图修改外部变量还是创建新变量。假设您正在创建一个新变量，它隐藏了外部变量， <sup>[7](#Fn7)</sup> ，就像函数可以隐藏其模块全局范围内的名字一样。

一对函数通过闭包对它们共享的变量进行操作。

```py
def private_variable():
    value = None
    def set(new_value):
        nonlocal value
        value = new_value

    def get():
        return value
    return set, get

>>> a_set, a_get = private_variable()
>>> b_set, b_get = private_variable()

>>> print(a_get, a_set)
<function private_variable.<locals>.get at 0x034F98E8> <function private_variable.<locals>.set at 0x034F9660>
>>> print(b_get, b_set)
<function private_variable.<locals>.get at 0x034F9858> <function private_variable.<locals>.set at 0x034F97C8>

>>> a_set(10)
>>> print(f"a={a_get()} b={b_get()}")
a=10 b=None

>>> b_set(4)
>>> print(f"a={a_get()} b={b_get()}")
a=10 b=4

```

这证明了可以编写一个包含函数的函数，并且内部函数可以使用外部函数中定义的数据。装饰者更进一步，将外部和内部函数共享的数据作为第三个函数，也就是被扩展的函数。

#### 基础装修工

最简单的装饰函数是对它所装饰的函数没有影响的函数。如清单 [5-6](#PC13) 所示。在这个例子中，函数`outer()`将一个用户函数作为参数`func=`，并返回一个名为`inner(...)`的函数作为结果。这使得`@outer`成为装饰函数，其行为由`inner(...)`定义。函数 inner 是一个闭包，所以它可以访问`outer(...)`函数的`func=`参数。这个变量是原始函数，所以`inner(...)`可以用它接收到的相同参数调用它，并将其结果返回给被修饰的函数。

```py
def outer(func):
    print(f"Decorating {func}")
    def inner(*args, **kwargs):
        print(f"Calling {func}(*{args}, **{kwargs})")
        value = func(*args, **kwargs)
        print(f"Returning {value}")
        return value
    return inner

@outer
def add_five(num):
    return num+5

Listing 5-6A decorator that does nothing but prints the variables it uses internally

```

一旦该代码被解释，行`Decorating <function add_five at 0x034F9930>`被打印。如果它存储为一个模块，它会在模块导入后立即显示。这表明装饰器中的`outer(...)`函数的内容是在解析函数时运行的，而不是在执行函数时运行的。

如果我们在一个交互式会话中使用它，我们可以看到,`add_five(...)`函数已经被 inner 函数所取代，但是它仍然以同样的方式工作，尽管增加了额外的打印。

```py
>>> print(add_five)
<function outer.<locals>.inner at 0x034F9A50>
>>> add_five(1)
Calling <function add_five at 0x034F9930>(*(1,), **{})
Returning 6
6

```

`inner`函数使用`*args`、`**kwargs`作为它的参数来接受任意数量的参数，并将它们传递给`func`。我们在这里写的装饰器不会改变参数，所以`inner`和`func`的函数签名需要兼容。如果`inner(...)`定义了不同于`func`的参数，那么这个装饰器就不能使用。

Tip

通常包装函数需要*访问*至少一个传递给内部函数的参数，但是不加改变地传递它们。在这种情况下，我建议尝试精确匹配函数参数，而不是尝试从`*args`或`**kwargs`中提取值。这避免了在从`args`或`kwargs`中寻找正确值时引入的任何错误。

有时我们希望创建一个装饰器来操纵参数，例如，填充一个或多个参数而不需要调用方传递它们，或者删除一个或多个底层函数不期望的参数。通过这种方式，decorators 可以用来改变函数签名。能够更改签名允许我们编写装饰器来为程序员简化 API，同时仍然为应用程序的其他部分匹配更复杂的签名。

例如，`sorted(...)`标准库函数曾经有一个可选的`cmp=`参数和一个`key=`参数。Python 3 中删除了`cmp=`参数，所以移植到 Python 3 的旧代码有时需要更新。

这两种方法完全不同；将编写为 cmp 函数的代码转换为等价的键函数并不容易。标准库中的`functools`模块包含一个`cmp_to_key`函数，它可以用作装饰器并执行这种转换。

#### 有争论的装饰者

还有一种更常见的装饰器形式，它将另一个嵌套函数添加到组合中。这种形式是迄今为止最难以理解的，但它是我们目前所看到的代码的逻辑结果。最后一种形式是一个接受直接参数的装饰器。

使用 decorator 的语法是在函数或类的上一行添加`@decorator`，这相当于在函数被定义后添加行`function = decorator(function)`。

当使用接受参数的装饰器时，提供这些参数的格式是`@decorator(arg)`，可以重写为`function = decorator(arg)(function)`。也就是说，装饰函数不再是`decorator(...)`本身，而是`decorator(arg)`的返回值。如清单 [5-7](#PC15) 所示。

```py
def add_integer_to_all_arguments(offset):
    def decorator(func):
        def inner(*args):
            args = [arg + offset for arg in args]
            return func(*args)
        return inner
    return decorator

@add_integer_to_all_arguments(10)
def power(x, y):
    return x ** y

@add_integer_to_all_arguments(3)
def add(x, y):
    return x + y

Listing 5-7A simple decorator that takes an argument

```

这些修饰函数的所有参数都增加了一个偏移量，但是每种情况下的偏移量都是不同的，因为修饰函数的参数定义了偏移量。

```py
>>> print(power)
<function add_integer_to_all_arguments.<locals>.decorator.<locals>.inner at 0x00B0CBB8>
>>> power(0, 0)
10000000000
>>> print(add)
<function add_integer_to_all_arguments.<locals>.decorator.<locals>.inner at 0x00B0CC48>
>>> add(0,0)
6

```

Tip

有一个装饰器可以帮助编写用户友好的装饰器。用`@functools.wraps(func)`修饰内部函数可以确保，如果用户试图查看文档、帮助，甚至是被修饰函数的名称，他们看到的信息与未修饰版本的相同。

如果我们早些时候在`inner(...)`函数上使用了这个装饰器，那么终端会话应该如下所示:

```py
>>> print(power)
<function power at 0x00B0CCD8>
>>> power(0, 0)
10000000000
>>> print(add)
<function add at 0x00B0CB70>
>>> add(0,0)
6

```

嵌套三个函数可能很难保持头脑清晰，特别是因为有两个层次的闭包，一个提供`offset`变量，另一个提供`func`。这种语法是一种令人困惑的嵌套逻辑，通常应该避免。在极少数需要这种装饰器的情况下，开发人员通常会通过查阅文档来提醒自己正确的语法。

三重嵌套函数的一种替代方法是使用基于类的装饰器(清单 [5-8](#PC18) ，它看起来更像标准 Python，所以一看就更容易理解。这是因为一个类定义了一个`__init__(...)`函数来接受实例化的参数，并且可以提供一个`__call__(...)`方法来允许类被直接调用，就像一个函数一样。它遵循与本章前面的私有变量示例相同的模式；在函数使用一个变量之前，使用一个闭包来长时间存储这个变量是不好的做法。类实例更适合这种情况。

```py
class add_integer_to_all_arguments:
    def __init__(self, offset):
        self.offset = offset

    def __call__(self, func):
        def inner(*args):
            args = [arg + self.offset for arg in args]
            return func(*args)
        return inner

Listing 5-8A class-based version of an offset decorator

```

基于类的装饰器和基于多重嵌套函数的装饰器在功能上是等价的；但我发现基于课堂的方法更自然，也更容易记忆。

#### 基于装饰的安全性

现在我们已经看了装饰者是如何工作的；我们可以用它来检查函数中授权的 API 访问。Flask 视图函数不需要参数；HTTP 请求数据存储在一个全局变量中，所以我们编写的装饰器不需要处理任何参数。我们不必担心参数与函数的匹配，因为很少有 Flask 视图函数接受参数。

但是，我们确实需要确保函数的返回值是类型注释所允许的。Flask 支持从视图函数返回响应的多种不同方式。在 JSON 响应的情况下，响应的主体可以作为字符串或字典返回。这个函数可以返回主体或者一个`(body, status)`元组，或者`(body, headers)`，或者`(body, status, headers)`，等等。这种灵活性使打字变得更加复杂。 <sup>[8](#Fn8)</sup>

清单 [5-9](#PC19) 显示了一个不做任何事情的 flask 视图的类型化装饰器。这是一个泛型函数，就像我们将 Sensor 定义为泛型类一样。装饰器`@outer`将一个不需要参数的函数作为参数，并返回*某个东西*。装饰器的返回值是一个不带参数的函数，返回的内容与参数函数相同。

```py
import functools
import typing as t

ViewFuncReturn = t.TypeVar("ViewFuncReturn")

def outer(func: t.Callable[[], ViewFuncReturn]) -> t.Callable[[], ViewFuncReturn]:

    @functools.wraps(func)
    def wrapped() -> ViewFuncReturn:
        return func()

    return wrapped

Listing 5-9A decorator for a flask function

```

类型变量是被修饰函数的返回值的占位符。如果该函数被声明为返回一个字符串，那么字典将被视为等效于

```py
def outer(func: t.Callable[[], str]) -> t.Callable[[], str]:

    @functools.wraps(func)
    def wrapped() -> str:
        return func()

    return wrapped

```

如果同一个函数正在装饰一个返回元组`(dict, int)`的视图，那么装饰器将会匹配它。

我们想要创建一个装饰器来检查被认证的用户。其代码如清单 [5-10](#PC21) 所示。如果用户通过了身份验证，我们希望正常使用该函数。如果不是，那么装饰器应该返回一个错误值。适当的错误应该是一个 JSON 文档，其中包含错误详细信息和状态 403 禁止。因此，包装函数必须声明为返回底层函数将返回的任何内容或`t.Tuple[t.Dict[str, str], int]`。

```py
from hmac import compare_digest
import functools
import os
import typing as t

import flask

ViewFuncReturn = t.TypeVar("ViewFuncReturn")
ErrorReturn = t.Tuple[t.Dict[str, str], int]  # The type of response we # generate as an error

def require_api_key(
    func: t.Callable[[], ViewFuncReturn]
) -> t.Callable[[], t.Union[ViewFuncReturn, ErrorReturn]]:
    """ Check for the valid API key and return an error if missing. """

    api_key = os.environ.get["APD_SENSORS_API_KEY"]

    @functools.wraps(func)
    def wrapped(*args, **kwargs) -> t.Union[ViewFuncReturn, ErrorReturn]:
        """ Extract the API key from the inbound request and return an error if no match """

        headers = flask.request.headers
        supplied_key = headers.get("X-API-Key", "")

        if not compare_digest(api_key, supplied_key):
            return {"error": "Supply API key in X-API-Key header"}, 403

        # Return the value of the underlying view
        return func(*args, **kwargs)

    return wrapped

Listing 5-10Authentication decorator for flask API methods

```

其结果是，`require_api_key`装饰器改变它所装饰的函数，以返回与`func`返回的 <sup>[9](#Fn9)</sup> *相同的*类型的数据，或者*一个包含字符串到字符串字典和整数的元组。*

 *该函数实现权限检查的方式如下。首先，我们从环境中提取我们正在寻找的 API 密钥，命名为`APD_SENSORS_API_KEY`。这里没有回退到默认值，这部分装饰器代码在启动时执行，所以如果没有设置 API 键，程序会以`KeyError`失败。

接下来是包装了原始`func()`函数的函数定义，称为`wrapped()`。这个包装函数被定义为返回`ViewFuncReturn`或`ErrorReturn`。

EXERCISE 5-1: TYPING

本节中的类型定义非常复杂；很难理解正在发生的事情。我建议您尝试编写一些简单的函数，并用 mypy 检查它们，以便直观地了解这里发生了什么。

你可以从清单 [5-11](#PC22) 中的基础程序开始，尝试改变`hello()`函数的类型、`ErrorReturn`类型以及 hello 函数是否有`@result_or_number`装饰器。这可能是一个更容易的开始，因为返回类型比实际的 Flask 函数要简单得多。

```py
import functools
import random
import typing as t

ViewFuncReturn = t.TypeVar("ViewFuncReturn")
ErrorReturn = int

def result_or_number(
    func: t.Callable[[], ViewFuncReturn]
) -> t.Callable[[], t.Union[ViewFuncReturn, ErrorReturn]]:

    @functools.wraps(func)
    def wrapped() -> t.Union[ViewFuncReturn, ErrorReturn]:

        pass_through = random.choice([True, False])
        if pass_through:
            return func()
        else:
            return random.randint(0, 100)

    return wrapped

@result_or_number
def hello() -> str:
    return "Hello!"

if t.TYPE_CHECKING:
    reveal_type(hello)
else:
    print(hello())

Listing 5-11Sample file for experimenting with decorator typing

```

这个`wrapped`函数的主体是实际工作发生的地方。所提供的 API 键是从 flask 请求头中读取的，这些请求头在 flask 框架中作为全局状态被访问，因此这些函数中不包含请求参数。请求提供的密钥从`X-API-Key`头中读取，如果没有提供头，则默认值为空字符串。

空字符串 default 在这里，因为在下一行中，对`compare_digest`的调用用于比较收到的和预期的 API 键。这是一个字符串比较函数，适用于比较已知长度的身份验证字符串，如 HMAC 摘要。 <sup>[10](#Fn10)</sup> 从理论上讲，使用标准比较可能会通过返回错误所需的时间来泄露关于正确 API 键的信息，所以最好使用恒定时间比较。这个`compare_digest`函数仍然会泄漏关于秘密字符串长度的信息。虽然在这种情况下这不是一个严重的问题，但是这个问题很容易解决，没有理由不使用安全的比较函数。

最后，根据`compare_digest`函数的结果，我们要么委托给原始函数，要么返回股票错误响应。

*传感器端点代码*

```py
@app.route("/sensors/")
@require_api_key
def sensor_values() -> t.Tuple[t.Dict[str, t.Any], int, t.Dict[str, str]]:
    headers = {"Content-Security-Policy": "default-src 'none'"}
    data = {}
    for sensor in get_sensors():
        data[sensor.title] = sensor.value()
    return data, 200, headers

```

这里，我们之前创建的 sensor view 函数用我们新的`@require_api_key` decorator 进行了修饰，API 键检查将自动发生。需要注意的是，这里的装饰者是有序的；它们是自下而上应用的，底部装饰器的输出成为上面那个的输入。

```py
def sensor_values():
    ...
sensor_values = app.route("/sensors/")(require_api_key(sensor_values))

```

装饰器将函数与 flask URL 路由系统联系起来。它所修饰的函数与 URL 相关联；运行时不查找函数。虽然这种差异听起来很学术，但这意味着只有装饰者`app.route(...)`下面的装饰者*会被应用到 Web 上可用的功能中。*

如果以相反的顺序应用这些装饰器，那么在这个视图上就不会有 API 键验证。这是我们回到功能测试的地方；从单元测试中直接调用函数并不能通过 flask 视图注册表找到它，这可能会使程序员认为视图受到了正确的保护。重要的是要端到端地测试安全特性，而不仅仅是孤立地测试。

### 测试视图功能

我们已经有了一个基本的测试来查看传感器数据是否通过使用 WebTest 框架的 API 请求返回，但是我们通过添加 API key validator 打破了这个测试。如果在您的环境中没有设置 API 密匙，并且您运行了`pipenv run pytest,`，那么测试失败，并显示`KeyError`。如果您已经在本地环境中设置了一个 API 键，那么它会失败并出现一个`Forbidden`错误。

谈到可测试性，我们在 decorator 函数中犯了一个小小的判断错误。如前所述，预期的 API 键是在导入时加载的，如果没有设置 API 键，这会导致启动时出错。然而，导入时数据加载会增加测试代码的难度。我们希望使用一个已知的 API 键设置来运行测试，但是要做到这一点，我们需要确保在包含视图函数的模块被导入的第*次*之前，这个键被设置到环境中。

Flask 在应用程序上提供了一个 config 属性，可以用来存储配置数据，这是一个比在 decorator 闭包中存储预期的 API 键更明智的地方。这样，当 web 服务器启动时，配置数据仍然可以被加载，或者测试框架可以为任何特定于测试的配置提供它。

Flask 假设配置数据是从 Python 文件加载的，这可能会诱使我们将`apd.sensors`包的配置系统更改为相同的模式，但是因为我们只需要添加一个配置变量，所以我们将坚持使用现有的环境变量模式。

最好的方法是创建一个设置函数，用来自环境的信息填充烧瓶配置。对 API 关键配置变量的检查在这里显式地发生，因为我们不得不在装饰器中移除对`os.environ`的检查以支持测试。显式检查通常比导致`KeyError`的隐式需求更容易理解，这应该有助于让我们确信这是一种更好的方法。如果这里没有显式的检查，那么在第一次加载受保护的视图之前，不会检查 API 键。

*设置功能*

```py
REQUIRED_CONFIG_KEYS = {"APD_SENSORS_API_KEY"}

def set_up_config(environ: t.Optional[t.Dict[str, str]] = None) -> flask.Flask:
    if environ is None:
        environ = dict(os.environ)
    missing_keys = REQUIRED_CONFIG_KEYS - environ.keys()
    if missing_keys:
        raise ValueError("Missing config variables: {}".format(", ".join(missing_keys)))
    app.config.from_mapping(environ)
    return app

```

Note

这里的`REQUIRED_CONFIG_KEYS`变量被设置为 set 文字，而不是 dict 文字。集合字面量看起来非常类似于字典字面量，集合理解和字典理解也是如此。不同的是缺少`:value`。

然后可以修改测试设置，用适当的测试配置值调用这个设置函数。我们创建一个新的 fixture 来提供测试 API 键，它可以是硬编码的或者随机的， <sup>[11](#Fn11)</sup> 然后将主题 fixture 更改为依赖于这个 API 键 fixture，并将其值作为显式设置传入。

```py
import pytest
from webtest import TestApp

from apd.sensors.wsgi import app, set_up_config
from apd.sensors.sensors import PythonVersion

@pytest.fixture
def api_key():
    return "Test API Key"

@pytest.fixture
def subject(api_key):
    set_up_config({"APD_SENSORS_API_KEY": api_key})
    return app

@pytest.fixture
def api_server(subject):
    return TestApp(subject)

```

如果测试授权访问的行为，单个测试将需要依赖于`api_key` fixture，或者使用 WebTest 框架的`expect_errors`选项来检查错误响应，而不需要用`try` / `except`块包围 get 请求。

*API 端点的示例测试*

```py
@pytest.mark.functional
def test_sensor_values_fails_on_missing_api_key(api_server):
    response = api_server.get("/sensors/", expect_errors=True)
    assert response.status_code == 403
    assert response.json["error"] == "Supply API key in X-API-Key header"

@pytest.mark.functional
def test_sensor_values_returned_as_json(api_server, api_key):
    value = api_server.get("/sensors/", headers={"X-API-Key": api_key}).json
    python_version = PythonVersion().value()

    sensor_names = value.keys()
    assert "Python Version" in sensor_names
    assert value["Python Version"] == list(python_version)

```

这些测试验证了 API 服务器正在按预期工作，所以在这个阶段，可以安全地剪切一个新发布的`apd.sensors`包，它记录了这个新的 API 服务器，这样我们就可以将它安装在我们的 Raspberry Pi 服务器上。

新版本在不破坏向后兼容性的情况下增加了一个新特性，这再次意味着我们增加了次要版本号，这是第一个支持 web API access 1.3.0 的版本。

### 部署

我们现在有了一个可用的 API 端点，我们可以使用`python -m apd.sensors.wsgi`在本地作为测试，或者我们可以通过生产质量的 WSGI 服务器，比如*女服务员*来提供服务。为此，我们需要安装 want，并给它一个我们想要运行的 WSGI 应用程序的引用。还有许多其他的 WSGI 服务器，比如 mod_wsgi，它与 Apache 紧密集成；Gunicorn，这是一个单机应用，对性能的控制很好；Circus 和 Chaussette，包括过程管理和对工人的细粒度控制；还有 uWSGI，以性能好著称。

我们使用的是 waste，因为它有一个简单的接口，并且是用纯 Python 实现的，没有编译扩展，所以它可以安装在各种操作系统上。

```py
> pipenv install waitress
> pipenv run waitress-serve --call apd.sensors.wsgi:set_up_config

```

缺省情况下，API web 服务在端口 8080 上提供服务，但是可以使用任何端口或 UNIX 套接字对其进行配置。如果要在可通过互联网访问的机器上运行，而不是在本地网络上运行，您应该考虑为您的部署设置一个 TLS 终止反向代理，如 apache、nginx 或 HAProxy。默认情况下，现代网络是加密的，用户只希望通过安全连接访问服务。幸运的是，有多种方法可以为您的域名获得免费的 TLS 证书。LetsEncrypt 和 AWS 证书管理器可能是最常见的。

在前面的例子中，`apd.sensors.wsgi:set_up_config`使用了与我们在命令行参数中使用的相同的点路径和冒号语法来定义入口点。我已经将它指向了`set_up_config(...)`函数，它本身不是一个 WSGI 可调用函数。多亏了`--call`选项，这才成为可能，这意味着目标不是一个 WSGI 应用程序，而是一个 WSGI 应用程序*工厂*:一个返回已配置的 WSGI 应用程序的可调用程序。

我们的 flask 应用程序是在模块范围内实例化的；我们可以用`pipenv run waitress-serve apd.sensors.wsgi:app`直接引用它，但是这不会像预期的那样工作，因为配置变量不会被设置。通过从我们的`set_up_config`函数返回模块范围`app`对象，我们使它像一个工厂一样工作，并确保配置变量被加载。

`set_up_config(...)`函数像`app`一样修改全局作用域的值，而不是返回一个独立的应用程序，所以它不是一个真正的工厂。然而，由于它的签名是相同的，我们每次只需要一个`app`，我们可以滥用这个特性。

用户编写一个定制的`wsgi.py`文件来设置他们的 WSGI 应用程序也是很常见的，潜在地将它包装在任何提供额外功能的*中间件*中。如果我们为这个 API 服务器这样做，它看起来会像

*wsgi.py*

```py
from apd.sensors.wsgi import set_up_config
app = set_up_config()

```

*启动服务器*

```py
> pipenv run waitress-serve wsgi:app

```

## 作为第三方扩展软件

我们在本章中所做的一切都不涉及改变`apd.sensors`包的 API，所以我们在核心包中创建的 API 服务器同样可能是由软件的核心维护者之外的人创建的。任何人都可以编写一个 WSGI 服务器来公开传感器值，并创建一个新的包，比如说`apd.apiserver`，它加载传感器并提供一个 API 端点来查询它们的值。

Note

下一节，直到“修复我们代码中的序列化问题”标题，将考虑其他开发人员在尝试扩展我们的代码和他们可以使用的工具时的体验。在此之后，我们将回到我们自己可以改进的地方。

然而，有时我们确实需要改变接口来扩展一个软件。如果我们回头看看我们的`Temperature`传感器，我们很早就做出了一个让 JSON 序列化变得微不足道的决定。value 函数返回一个浮点数，表示以摄氏度为单位的温度。JSON 可以序列化整数、字符串、列表和字典，但不能序列化日期时间或自定义对象。有一个名为 pint 的包，它专门表示物理常数，我们可能会选择使用 <sup>[12](#Fn12)</sup> ，在这种情况下，温度传感器的值将不会是可序列化的。

Pint 没有声明支持类型注释，因为它使用元类和从数据文件动态构造类型，很难提供一组有用的类型给最终用户。可以理解的是，pint 的开发者选择关注终端用户在控制单元集方面的灵活性，而不是针对类型检查进行优化。

*使用品脱值作为其返回类型的传感器*

```py
import os
from typing import Optional, Any

import pint

ureg = pint.UnitRegistry()

class Temperature(Sensor[Optional[Any]]):
    title = "Ambient Temperature"

    def __init__(self, board=None, pin=None):
        self.board = os.environ.get("APD_SENSORS_TEMPERATURE_BOARD", "DHT22")
        self.pin = os.environ.get("APD_SENSORS_TEMPERATURE_PIN", "D4")

    def value(self) -> Optional[Any]:
        try:
            import adafruit_dht
            import board
            sensor_type = getattr(adafruit_dht, self.board)
            pin = getattr(board, self.pin)
        except (ImportError, NotImplementedError, AttributeError):
            # No DHT library results in an ImportError.
            # Running on an unknown platform results in a
            # NotImplementedError when getting the pin
            return None
        try:
            return ureg.Quantity(sensor_type(pin).temperature, ureg.celsius)
        except RuntimeError:
            return None

    @classmethod
    def format(cls, value: Optional[Any]) -> str:
        if value is None:
            return "Unknown"
        else:
            return "{:.3~P} ({:.3~P})".format(value, value.to(ureg.fahrenheit))

    def __str__(self) -> str:
        return self.format(self.value())

```

由于 pint 没有声明支持类型检查，这些函数被定义为返回`Any`，这意味着它们不容易进行类型检查。在搜索类型定义时，我们还需要将 pint 添加到`setup.cfg`中作为一个被忽略的模块，以消除找不到它的警告:

*添加到 setup.cfg 的代码*

```py
[mypy-pint]
ignore_missing_imports = True

```

METACLASSES

我前面提到过，Pint 使用元类和动态类型构造。这是一些相关的技术:它们都是定制类本身行为的方式，而不仅仅是它们的实例。在 pint 中，这些方法用于添加一个额外的钩子`after_init(...)`，它在`__init__(...)`函数之后被自动调用，并用于创建引用不同类变量的某些内置类型的无限数量的子类。

本书的一些读者将期待关于元类使用的广泛讨论，将它们视为高级 Python 特性的缩影。我决定省略它们，因为这本书旨在解释专业 Python 程序员可以从中受益的特性。

在我作为 Python 开发者的全部时间里，我从来没有理由创建一个元类，或者在我编写的类中显式地使用一个元类。我确实经常通过基类隐式地使用它们。虽然只有很少一部分 Python 开发人员需要创建元类，但是大多数开发人员在不知道的情况下与元类进行交互。

Python 标准库模块`enum`和 ORM SQLAlchemy 是我所知道的良好元类使用的最好例子。两者都大量使用了元类，但是他们各自开发人员的技能保持了非常直观的界面，而牺牲了他们自己实现的可读性。如果你把元类做对了，用户甚至不会知道它们的存在。

大多数关于元类的建议是，除非你知道你需要元类，否则你不需要使用它们。这有点绕圈，所以参考图 [5-3](#Fig3) 中的决策树，当我决定是否需要使用元类时，我会使用它。

![../images/481001_1_En_5_Chapter/481001_1_En_5_Fig3_HTML.jpg](../images/481001_1_En_5_Chapter/481001_1_En_5_Fig3_HTML.jpg)

图 5-3

用于决定是否使用元类的决策树

这并不详尽，只是我对何时考虑元类的看法。可能有其他情况下它们是合适的解决方案，但是一般来说，我会认为它们**仅仅是**用于声明性地向框架公开用户数据的结构。元类的大多数其他用途可以更直观地表示为标准 Python。我强烈建议优先编写一看就能理解的代码，而不是聪明的 T2 代码。

float 和基于 pint 的实现之间的第一个实质性区别来自于`value()`函数，它采用温度的浮点表示，并将其标记为摄氏度的`Quantity`。与动态调度允许整数和字符串的加法表现不同的方式一样，它允许开发人员忘记正在使用的温度单位的确切类型，并对所有温度一视同仁。

想象一下，我们也有一个连接到智能家庭恒温器的温度传感器，它只能返回华氏温度。我们很可能想要显示每个温度传感器和这个中央传感器之间的差异。如果我们使用浮点单位，我们必须在收集数据时将所有温度传感器标准化为相同的单位系统，或者在报告时使用外部知识，即一些读数使用不同的温标。Pint 允许我们无缝地处理来自不同测量系统的数字，而不需要显式转换。

我们可以在`format(...)`方法中看到这一点，我们没有调用自定义类方法将摄氏温度转换为华氏温度，而是使用了 pint 本身的转换特性。`cls.celsius_to_fahrenheit(value)`变成了`value.to(ureg.fahrenheit)`，从而将逻辑分为收集和格式化。在原始形式中，format 方法要求其值为摄氏度；在后一种形式中，它可以根据值本身来判断需要进行什么转换(如果有的话)。

{:.3~P} FORMAT SPECIFICATION

Python 中的`"{}".format(value)`样式格式允许值函数的类型定义自己的格式规范。Python 没有内置的`.3~P`规范:这是由 Pint 提供的。

`__format__(self, spec)`方法允许类定义自己的格式规则。Pint 分别为 LaTeX、HTML 和 PrettyPrint 提供了`L`、`H`和 P 格式器，还有一个可选的`~`来使用缩写的单元名和标准的浮点格式选项来指定幅度部分。

您编写的任何类也可以提供这些，因此我们的传感器可以定义一个`__format__(...)`方法来提供不同的格式化选项(如果相关的话)。一般来说，这个特性只对像 Pint 这样提供复杂数据存储类供其他程序员使用的项目有用。

然而，所有这些优势都是有代价的。当我们试图访问 JSON API 时，我们看到一个 HTTP 错误 500 页面，并且在 web 服务器的日志中，我们得到一个以

```py
TypeError: Object of type Quantity is not JSON serializable

```

为了让`value()`方法更加灵活，我们打破了在 flask 应用程序中所做的隐含假设:函数`value()`的结果可以被 JSON 序列化。在任何以前版本的文档中，我们都没有提到 value 方法只能返回 JSON 可序列化的类型。不能保证我们软件的其他用户没有使用插件架构做过类似的事情，所以在没有意识到的情况下，我们已经违反了语义版本化政策。

我们应该创建一对新的方法，在传感器返回值和 JSON 可序列化表示之间进行转换，使`Sensor`类看起来像

*更新传感器类型，包括 JSON 序列化*

```py
class Sensor(Generic[T_value]):
    title: str

    def value(self) -> T_value:
        raise NotImplementedError

    @classmethod
    def format(cls, value: T_value) -> str:
        raise NotImplementedError

    def __str__(self) -> str:
        return self.format(self.value())

    @classmethod
    def to_json_compatible(cls, value: T_value) -> t.Any:
        return json.dumps(value)

    @classmethod
    def from_json_compatible(cls, json_version: t.Any) -> T_value:
        return json.loads(value)

```

一对`to_json_compatible(...)`和`from_json_compatible(...)`方法负责将值转换成可以序列化的表示形式，然后再转换回来。它们是类方法，因为像`format(...)`一样，它们对值进行操作，而不需要那种类型的活动传感器可用。这些方法将用户推向返回 JSON 结构，这与我们的 API 输出非常吻合。

API 的这一更新可以作为标准`Sensor`类的一部分，或者可以创建一个子类(如`SerializableSensor` <sup>[13](#Fn13)</sup> )，允许用户选择只实现传感器 API 的旧版本。

然而，在本节的开始，我们决定考虑如果我们将这个 API 服务器创建为第三方软件，并且无权更改`Sensor`类型的形式，会发生什么。因此，我们不能简单地决定改变传感器接口:如果我们在现实生活中处于这种情况，它将在我们无法控制的包中，其他人将实现该接口。

### 与对等方就临时签名达成一致

作为一名开发人员，如果想用自己不维护的代码来扩展一个接口，首先要确定的是，你觉得这个接口缺少了软件开发者定义的功能。作为一个最终用户，你可以添加任何你喜欢的函数到你的子类中，但是你不能轻易地命令类的其他作者实现相同的函数。

当决定将哪些功能添加到接口时，您应该选择其他开发人员可能认为有用的功能。如果您选择既容易实现又普遍有用的函数，其他类作者更有可能选择实现它们。如果你选择了非常具体的方法，那么他们可能会认为不值得努力。

因此，`to_json_compatible(...)`和`from_json_compatible(...)`，尽管是我们选择的软件维护者，可能会被其他开发人员认为太具体了。我认为一对`serialize(...)`和`deserialize(...)`方法更有可能被实现。

我们可以编写 flask 函数来迭代传感器，如果可能的话，使用`serialize(...)`方法，否则返回到值。我们可以假设传感器的`serialize(...)`方法在传递有效数据时不会引发任何异常，但是我们知道不是所有的传感器都有这个方法，并且`json.dumps(...)`会因为一些传感器数据而失败，所以我们还需要通过三种方法来序列化值。

首先，我们从传感器获取值，并将其传递给`serialize(...)`方法。如果用`AttributeError`失败了，那么很可能没有`serialize(...)`方法，所以用`json.dumps(...)`再试一次。如果这个操作因`TypeError`而失败，那么我们就不能序列化这个传感器，应该返回一个占位符。

*一个如何逐步支持一个* *序列化的例子(...)方法* *:*

```py
for sensor in get_sensors():
    raw_value = sensor.value()
    try:
        value = {"serialized": sensor.serialize(raw_value)}
    except AttributeError:
        try:
            value = {"serialized": json.dumps(raw_value)}
        except TypeError:
            value = {"error": f"Cannot serialize value {raw_value}"}
    data[sensor.title] = value

```

这将允许所有现有的传感器继续运行，而无需任何代码更改，只要它们的值是 JSON serializable，否则将返回一个错误。任何实现`serialize(...)`方法的传感器都将返回该方法的结果。

这种两个嵌套的 try/except 语句的情况有点难看，但很实用。在其他编程语言中，您可能通过检查`serialize(...)`方法的存在来实现相同的逻辑，而不是试图调用它。在 Python 中，尝试和调用方法并捕捉错误比检查它们是否存在更好；然而，有些时候检查是最好的选择。

前面的例子仍然有一个潜在的故障模式。很有可能有人实现了一个`serialize()`方法，但是没有实现`deserialize(...)`方法，这是由于传感器 API 的一些其他流行消费者的要求。在这种情况下，我们最好还是使用`value()`方法，因为我们无法保证能够得到真实的值来进行分析。在这种情况下，我们必须检查这两种方法是否存在，而不是只尝试使用我们现在需要的一种方法。

```py
for sensor in get_sensors():
    raw_value = sensor.value()
    if hasattr(sensor, "serialize") and hasattr(sensor, "deserialize"):
        value = {"serialized": sensor.serialize(raw_value)}
    else:
        try:
            value = {"serialized": json.dumps(raw_value)}
        except TypeError:
            value = {"error": f"Cannot serialize value {raw_value}"}
    data[sensor.title] = value

```

当然，您的代码可能希望查找更复杂的方法和变量集合，以确定特定的功能集合是否存在。比如说`does_sensor_support_serialization(sensor: Sensor[Any]) -> bool`，你可能会试图将这种内省整合成一个函数，并将其作为条件。这两种情况下代码路径出现分歧的次数越多，就越有诱惑力。

Python 有一个称为抽象基类(ABCs)的特性，可以用来使这种类自省在 Python 上下文中感觉更自然。*是*经常使用的一种类型的类内省是检查一个对象是否是一个特定类或其子类的实例；ABCs 允许你用`isinstance(...)`调用代替更复杂的类内省。

### 抽象基类

抽象基类是一种特殊类型的类；它们不能直接实例化，但可以用作代码的父类。他们还可以“声明”其他类，以便将它们视为子类，方法是将它们显式注册为虚拟子类，或者编写一个函数来检查一个类，以确定它是否应该被视为子类。

ABC 是另一个 Python 特性，人们通常认为它特别先进，因为他们以前没有理由使用它们。大多数开发人员没有使用过 ABC 是有道理的，因为它们对于常规的面向对象软件工程实践不实用的情况特别有用。一个有凝聚力的、统一的代码库通常没有理由使用 ABC，但是一个基于多个软件的庞大的应用程序可能会发现 ABC 是恰到好处的魔法，允许应用程序代码最小化技术债务的影响。

ABC 采取的方法是覆盖`isinstance(...)`和`issubclass(...)`的逻辑。Python 中`issubclass(...)`的正常定义是，如果类定义将 B 列为父类，或者如果它列出的任何类本身都是 B 的子类，则类(A)是另一个(B)的子类。ABC 有两个额外的检查:`issubclass(A, B)`将返回 True，如果 A 是 B 的子类，如果在`issubclass`检查之前的任何时候调用了`B.register(A)`，或者如果`B.__subclasshook__(A)`返回`True`。

此外，更熟悉的`isinstance(...)`函数的工作方式类似，但是使用的是一个类的实例，而不是类本身。大多数 Python 开发人员认为`isinstance(...)`在某些情况下是自然的代码行，但是会回避检查特定的方法集，而是更喜欢使用 duck typing，即使以可读性为代价。

这是 ABC 最有用的地方；它们允许复杂的类自省以这样一种方式执行，这种方式对于不经意阅读代码的开发人员来说是自然的，对于熟悉代码的人来说是高度可维护的。

Note

任何从`abc.ABC`类 <sup>[14](#Fn14)</sup> 继承的类都遵循 ABCs 的特殊类规则，包括定制`isinstance(...)`行为的能力，但严格来说，如果一个类至少有一个用`@abc.abstractmethod`装饰器定义的抽象方法，那么它只是一个*抽象*基类。

对于我们来说，为序列化行为创建一个抽象基类是很有用的，这样可以避免在 flask 路径中显式地检查两个相关的方法。将序列化和反序列化所需的方法定义为抽象方法。 <sup>[15](#Fn15)</sup>

```py
class SerializableSensor(ABC):

    @classmethod
    @abstractmethod
    def deserialize(cls, value):
        pass

    @classmethod
    @abstractmethod
    def serialize(cls, value):
        pass

```

然后，我们可以使用它，要么通过子类化这个 ABC，要么通过注册一个实现。这两种方法如表 [5-2](#Tab2) 所示。

表 5-2

创建被视为 SerializableSensor 的子类的 ExampleSensor 的两种方法的示例

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| *子类化方法*`class ExampleSensor(``Sensor[bool],``SerializableSensor``):``def value(self) -> bool:``return True``@classmethod``def format(cls, value: bool) -> str:``return "{}".format(value)``@classmethod``def serialize(cls, value: bool) -> str:``return "1" if value else "0"``@classmethod``def deserialize(cls, serialized: str) -> bool:``return bool(int(serialized))` | *报名方式* <sup>[16](#Fn16)</sup>`class ExampleSensor(Sensor[bool]):``def value(self) -> bool:``return True``@classmethod``def format(cls, value: bool) -> str:``return "{}".format(value)``@classmethod``def serialize(cls, value: bool) -> str:``return "1" if value else "0"``@classmethod``def deserialize(cls, serialized: str) -> bool:``return bool(int(serialized))``SerializableSensor.register(ExampleSensor)` |

每种方法都有优点和缺点。对于子类方法，父类提供助手函数或者默认实现`serialize(...)`和`deserialize(...)`。对于注册方法，碰巧实现正确方法的类可以标记为子类，而不必修改它们。当这些类不在您控制的代码中时，例如依赖关系中的类，这尤其有用。您不需要在使用子类化或注册方法之间进行选择；您可以从 ABC 中创建子类，同时将其他类别注册为虚拟子类。

最后，最后一个可能的方法是子类 hook，其中不需要显式注册。为了实现这一点，我们向`SerializableSensor`类添加了一个新方法，它包含了确定一个类是否是`SerializableSensor`的逻辑。`__subclasshook__`类方法只接受一个参数，即要自省的类。

它可以返回`True`或`False`来指定传递的类是否确实是 ABC 或`NotImplemented`的实例，以遵从正常的 Python 行为。`NotImplemented`选项是必不可少的，因为`__subclasshook__`不仅为`SerializableSensor`调用，也为任何将其声明为超类的类调用。返回`NotImplemented`可以避免为这些情况重新实现默认的 Python 逻辑。 <sup>[17](#Fn17)</sup>

```py
    @classmethod
    def __subclasshook__(cls, C):
        if cls is SerializableSensor:
            has_abstract_methods = [hasattr(C, name) for name in {"value", "serialize", "deserialize"}]
            return all(has_abstract_methods)
        return NotImplemented

```

ABC 也支持类型注释，所以 ABC 的最终版本应该包含适当的注释，以允许直接从基类继承的任何类的静态类型。我们将把`value(...)`函数添加到基类的抽象方法列表中。我们还可以将`SerializableSensor`基类设置为 generic，它必须采用与其配对的传感器的子类型兼容的子类型。这允许我们在静态类型级别确保`serialize`方法支持与`value(...)`函数相同的类型:

```py
from abc import ABC, abstractmethod

import typing as t

T_value = t.TypeVar("T_value")

class SerializableSensor(ABC, t.Generic[T_value]):

    title: str

    @abstractmethod
    def value(self) -> T_value:
        pass

    @classmethod
    @abstractmethod
    def serialize(cls, value: T_value) -> str:
        pass

    @classmethod
    @abstractmethod
    def deserialize(cls, serialized: str) -> T_value:
        pass

    @classmethod

    def __subclasshook__(cls, C: t.Type[t.Any]) -> t.Union[bool, "NotImplemented"]:
        if cls is SerializableSensor:
            has_abstract_methods = [hasattr(C, name) for name in {"value", "serialize", "deserialize"}]
            return all(has_abstract_methods)
        return NotImplemented

```

### 后备策略

使用 ABCs 清理了在传感器能够处理序列化其自身值和需要使用回退实现之间切换的 if 语句，但是它不能帮助我们实现现有的回退逻辑。

我们可以选择的各种序列化方法(包括 JSON)都提供了一对序列化和反序列化函数，通常称为`dumps(...)`和`loads(...)`。如果用户愿意，我们可以提供 mixin <sup>[18](#Fn18)</sup> 类供用户使用。

*一个 JSON 回退 mixin 类的例子*

```py
class JSONSerializedSensor(SerializableSensor[t.Any]):

    @classmethod
    def serialize(cls, value: t.Any) -> str:
        try:
            return json.dumps(value)
        except TypeError:
            return json.dumps(None)

    @classmethod
    def deserialize(cls, serialized: str) -> t.Any:
        return json.loads(serialized)

```

这个类继承自`SerializableSensor` `,`，所以它遵循 ABCs 的特殊类处理规则。`SerializableSensor`类声明`value`、`serialize`和`deserialize`方法是必需的，但是我们只定义了其中的两个方法。这意味着`JSONSerializedSensor`仍然被认为是一个抽象基类，所以它不能被实例化。如果您试图实例化这个类，将会引发下面的`TypeError`:

```py
TypeError: Can't instantiate abstract class JSONSerializedSensor with abstract methods value

```

#### 适配器模式

`JSONSerializedSensor`超类提供了一种将 JSON 序列化方法添加到我们自己的类中的方法，但是如果我们安装了其他传感器，它就没有用了，因为我们不能仅仅编辑它们来使用超类。

解决这个问题的经典方法被称为适配器模式，是著名的四个软件工程模式之一。适配器是包装另一个对象以提供不同接口的对象。在这种情况下，我们可以为给定的传感器创建一个适配器，方法是将该传感器的一个实例存储为包装器实例的一个属性:

*使用 JSONSerializedSensor 从 ExampleSensor 到 SerializableSensor 的适配器示例*

```py
class SerializableExample(JSONSerializedSensor):

    def __init__(self):
        self.wrapped = ExampleSensor()
        self.title = self.wrapped.title

    def value(self) -> bool:
        return self.wrapped.value()

```

`serialize(...)`和`deserialize(...)`方法来自我们已经开发的`JSONSerializedSensor`，所以这个适配器模式允许我们使用 mixin 的实现作为我们的后备策略。对于`SerializedSensor`协议的任何其他部分实现也是如此，可能使用不同的序列化器。

我们可以动态创建传感器类型，而不是为每个类创建一个后备传感器类型。这些动态包装的传感器必须假设底层的值类型是`Any`，因为我们没有具体的保证我们将传递给它什么类型的传感器。

```py
def get_wrapped_sensor(sensor_class: Sensor[t.Any]) -> SerializableSensor:
    class Fallback(JSONSerializedSensor):

        def __init__(self):
            self.wrapped = sensor_class()
            self.title = self.wrapped.title

        def value(self) -> t.Any:
            return self.wrapped.value()

    return Fallback

```

如果传感器不可序列化，我们用来迭代传感器并获取其值的代码现在可以更改为实例化此包装器:

```py
for sensor in get_sensors():
    raw_value = sensor.value()
    sensor_class = type(sensor)
    if not issubclass(sensor, SerializableSensor):
        sensor_class = get_wrapped_sensor(sensor_class)

    value = {"serialized": sensor_class.serialize(raw_value)}
    data[sensor.title] = value

```

#### 动态类生成

这种方法不能精确地映射到经典的设计模式，部分原因是它在编译语言中是不可能的。这个方法动态地定义了一个新类，它继承了原始的`Sensor`类和序列化 mixin，创建了一个具有两者行为的新类。只有当两个类实现之间的方法定义没有重叠时，这种方法才可靠。尽管如此，它的优点是派生类可以被视为一个直接实现序列化的传感器，因为`format(...)`和`__str__()`方法仍然存在，而不是被包装器隐藏。

许多 Python 开发人员发现这是一个很难做出的选择，因为适配器模式更简单、更明确，而动态类生成方法依赖于语言的行为，以一种对最终用户不透明的方式来解析方法，但是对于不经意的观察者来说，动态类生成方法似乎更简单。

*将 JSON 串行器实现合并到任意传感器的函数*

```py
def get_merged_sensor(sensor_class: Sensor[t.Any]) -> SerializableSensor:
    class Fallback(sensor_class, JSONSerializedSensor):
        pass

    return Fallback

```

然后，这个传感器类可以用在任何需要传感器的地方，以及任何需要可序列化传感器的地方。例如，我们可以提供一个`get_serializable_sensors()`方法，它复制了`get_sensors()`的实现，但是去掉了任何不可序列化的传感器。

```py
def get_sensors() -> t.Iterable[Sensor[t.Any]]:
    sensors = []
    for sensor_class in pkg_resources.iter_entry_points("apd.sensors.sensors"):
        class_ = sensor_class.load()
        if not issubclass(class_, SerializableSensor):
            class _ = get_merged_sensor(class_)
        sensors.append(t.cast(Sensor[t.Any], class_()))
    return sensors

```

#### 其他序列化格式

我们前面所有的例子都使用 JSON 协议，所以任何不提供显式序列化*和*的类都不能与 JSON serializable 兼容。为此，我们需要使用更通用的序列化程序，比如 pickle。

Warning

您经常会看到这样的警告:pickle 不应该用于不可信的数据，因为它不安全。这一点至关重要，因为精心编制的 pickle 变量会导致任意代码执行。如果一个传感器不知何故受到损害或恶意，并返回序列化值`c__builtin__\neval\n(V__import__("webbrowser").open("` [`https://advancedpython.dev/pickles`](https://advancedpython.dev/pickles) `")\ntR.`，那么当 API 消费者试图反序列化它时，这本书的网站将在 API 消费者的计算机上打开。

我认为在这种情况下使用 pickles 是不合适的，因为传感器类型很少，而且它们返回的数据相对简单。包含以下讨论是因为序列化是一个常见问题，并且经常建议使用 pickles。

一般来说，最好投入额外的工程努力来避免使用 pickles，但是如果您发现自己处于需要它们的情况下，您应该确保至少使用 HMAC 来认证它们，如表 [5-3](#Tab3) 所示。

表 5-3

签名和验证 pickle 的示例函数

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| *签泡菜*`import hashlib``import hmac``import pickle``secret = bytearray([``0xb2,0x56,0xc4,0x88,0x09,0xa0,0x8a,0x1e,``0x28,0xe3,0xa3,0x25,0xe9,0x2b,0x98,0x6f,``0x13,0x60,0xfb,0x26,0x06,0x9b,0x9d,0x6f,``0x3a,0x01,0x2c,0x3f,0x9d,0x9f,0x72,0xcd``])``untrusted_pickle = pickle.dumps(2)``digest = hmac.digest(``secret,``untrusted_pickle,``hashlib.sha256``)``signed_pickle = digest + b":" + untrusted_pickle` | *验证签名*`import hashlib``import hmac``import pickle``secret = bytearray([``0xb2,0x56,0xc4,0x88,0x09,0xa0,0x8a,0x1e,``0x28,0xe3,0xa3,0x25,0xe9,0x2b,0x98,0x6f,``0x13,0x60,0xfb,0x26,0x06,0x9b,0x9d,0x6f,``0x3a,0x01,0x2c,0x3f,0x9d,0x9f,0x72,0xcd``])``digest, untrusted = received_pickle.split(``b":", 1``)``expected_digest = hmac.digest(``secret,``untrusted,``hashlib.sha256``)``if not hmac.compare_digest(digest, expected_digest):``raise ValueError("Bad Signature")``else:``value = pickle.loads(untrusted)` |

这个方案是对称的；任何可以验证 pickle 的人也可以为任意 pickle 创建一个有效的签名，但这通常对于封闭系统来说已经足够了。因为它是对称的，所以保持秘密不被公众所知是非常重要的。这个秘密通常存储在一个配置文件或环境变量中，因此对于代码的每个用户来说是不同的。使用非对称密钥的更复杂的签名是可能的，但是很少值得花费工程上的努力来创建一个定义好的 JSON(或其他)模式来安全地反序列化数据。

### 将这一切结合在一起

在我们的平行世界中，我们试图将 WSGI 服务器改造到现有的传感器生态系统中，我们现在已经拥有了所需的所有代码(清单 [5-12](#PC48) )。web 服务器代码的大部分与我们真实的集成 Flask 应用程序的代码相同；web 服务器代码中唯一显著的变化是在`sensor_values()`视图中添加了一个 if 语句和匹配的 else 子句，总共添加了三行视图代码。我们已经成功地将类自省和回退逻辑封装到支持代码中，这些代码可以拆分成一个实用的 Python 文件，让它发挥自己的魔力。

```py
from abc import ABC, abstractmethod
import typing as t
import json

import flask

from apd.sensors.sensors import Sensor
from apd.sensors.cli import get_sensors
from apd.sensors.wsgi import require_api_key, set_up_config

app = flask.Flask(__name__)

T_value = t.TypeVar("T_value")

class SerializableSensor(ABC, t.Generic[T_value]):

    title: str

    @abstractmethod
    def value(self) -> T_value:
        pass

    @classmethod
    @abstractmethod
    def serialize(cls, value: T_value) -> str:
        pass

    @classmethod
    @abstractmethod

    def deserialize(cls, serialized: str) -> T_value:
        pass

    @classmethod
    def __subclasshook__(cls, C: t.Type[t.Any]) -> t.Union[bool, "NotImplemented"]:
        if cls is SerializableSensor:
            has_abstract_methods = [
                hasattr(C, name) for name in {"value", "serialize", "deserialize"}
            ]
            return all(has_abstract_methods)
        return NotImplemented

class JSONSerializedSensor(SerializableSensor[t.Any]):
    @classmethod
    def serialize(cls, value: t.Any) -> str:
        try:
            return json.dumps(value)
        except TypeError:
            return json.dumps(None)

    @classmethod
    def deserialize(cls, serialized: str) -> t.Any:
        return json.loads(serialized)

class JSONWrappedSensor(JSONSerializedSensor):
    def __init__(self, sensor: Sensor[t.Any]):
        self.wrapped = sensor
        self.title = sensor.title

    def value(self) -> t.Any:
        return self.wrapped.value()

def get_serializable_sensors() -> t.Iterable[SerializableSensor[t.Any]]:
    sensors = get_sensors()
    found = []
    for sensor in sensors:
        if isinstance(sensor, SerializableSensor):
            found.append(sensor)
        else:
            found.append(JSONWrappedSensor(sensor))
    return found

@app.route("/sensors/")
@require_api_key
def sensor_values() -> t.Tuple[t.Dict[str, t.Any], int, t.Dict[str, str]]:
    headers = {"Content-Security-Policy": "default-src 'none'"}
    data = {}
    for sensor in get_serializable_sensors():
        data[sensor.title] = sensor.serialize(sensor.value())
    return data, 200, headers

if __name__ == "__main__":
    import wsgiref.simple_server

    set_up_config(None, app)

    with wsgiref.simple_server.make_server("", 8000, app) as server:
        server.serve_forever()

Listing 5-12A possible implementation of WSGI server and fallback encoding in a third-party piece of code

```

## 修复代码中的序列化问题

撇开我们如何在第三方代码中解决这个问题不谈，我们也应该在`apd.sensors`的主线代码库中解决这个问题。当我们希望将此作为第三方工具时，我们有强烈的动机选择通常有用的函数签名，因此选择了特定的`serialize`和`deserialize`方法，其他用户可能会使用它们(例如)来记录文件。现在我们回到了我们作为软件维护者的角色，我们在决定界面应该是什么的时候有了更多的灵活性。我们仍然希望代码易于实现，但是我们有更大的权力来规定我们认为最好的功能。

我非常相信，在这里限制我们自己只使用 JSON API 是有益的，因为它使原始数据更容易理解。如果我们的接口有一个`serialize(...)`，那么我们就不能保证输出是人类可读的。因此，我不会创建`serialize(...)`和`deserialize(...)`函数，而是创建将值缩减为 JSON 可序列化的值的函数，并从这些值重新构建它。

我们可以用我们想要的任何默认实现在`Sensor`基类上定义这些。目前还不能保证任何给定的传感器都与 JSON 序列化兼容，所以默认的实现必须是引发异常。

*添加到* *传感器基类*的其他方法

```py
    @classmethod
    def to_json_compatible(cls, value: T_value) -> Any:
        raise NotImplementedError

    @classmethod
    def from_json_compatible(cls, json_version: Any) -> T_value:
        raise NotImplementedError

```

我们现在需要为我们现有的每个传感器提供这两种方法的实现。有三种不同的代码路径需要更新。第一种是针对大多数已经与 JSON 兼容的传感器。为此，我们可以创建一个新的 mixin 类:

```py
class JSONSensor(Sensor[T_value]):
    @classmethod
    def to_json_compatible(cls, value: T_value) -> t.Any:
        return value

    @classmethod
    def from_json_compatible(cls, json_version: t.Any) -> T_value:
        return cast(JSONT_value, json_version)

```

TYPING OF JSON VALUES

在 Python 类型提示中没有简单的方法来表示 JSON 兼容，因为 JSON 兼容的定义本身就是递归的。只有当列表的所有元素都是 JSON 兼容的，例如。我们*可以*通过将 JSON 的类型限制到最大递归级别，来尝试越来越接近 JSON 兼容类型的定义，比如

```py
from typing import *

JSON_0 = Union[str, int, float, bool, None]
JSON_1 = Union[Dict[str, JSON_0], List[JSON_0], JSON_0]
JSON_2 = Union[Dict[str, JSON_1], List[JSON_1], JSON_1]
JSON_3 = Union[Dict[str, JSON_2], List[JSON_2], JSON_2]
JSON_4 = Union[Dict[str, JSON_3], List[JSON_3], JSON_3]
JSON_5 = Union[Dict[str, JSON_4], List[JSON_4], JSON_4]
JSON_like = JSON_5

```

我们用于 Sensor 的 T_ `value`泛型引用可以是任何类型，但是我们希望我们的 JSONSensor 超类只与 JSON 兼容的类型一起工作，因此需要一个不同的带有 bind 参数的 TypeVar:

```py
JSONT_value = TypeVar(“JSONT_value”, bound=JSON_like)

```

在我看来，这种绕过类型检查器的做法是适得其反的。打字是用来帮助开发人员的，而不是让他们跳来跳去。如果有些东西很难用静态类型提示来表达，那么你应该用文档和注释来解释清楚。你应该相信开发者会做正确的事情。因此，我将使用`Any`作为类型提示来表示 JSON 兼容的 Python 对象。

我们编写的大多数传感器都可以透明地使用`JSONSensor`；不过`PythonVersion`传感器的类型很奇怪。它使用无法直接实例化的自定义类。Python 的这个实现细节并不重要，但是我们需要稍微改变一下传感器，以便能够从 JSON 转换回行为类似于实际值的东西。

```py
from typing import NamedTuple

version_info_type = NamedTuple(
    "version_info_type",
    [
        ("major", int),
        ("minor", int),
        ("micro", int),
        ("releaselevel", str),
        ("serial", int),
    ],
)

class PythonVersion(JSONSensor[version_info_type]):
    title = "Python Version"

    def value(self) -> version_info_type:
        return version_info_type(*sys.version_info)

    @classmethod
    def format(cls, value: version_info_type) -> str:
        if value.micro == 0 and value.releaselevel == "alpha":
            return "{0.major}.{0.minor}.{0.micro}a{0.serial}".format(value)
        return "{0.major}.{0.minor}".format(value)

```

这使用了一个类型化的命名元组来模拟真实的`sys.version_info`，否则我们将无法实现`from_json_compatible(...)`来返回与`value()`完全相同的值。

最后，温度和太阳能传感器都使用物理量作为它们的值类型，因此它们将使用 pint 的单位系统作为它们的值，并且需要一对定制的 JSON 方法。

*温度的 JSON 方法对*

```py
class Temperature(Sensor[Optional[Any]]):

    ...

    @classmethod
    def to_json_compatible(cls, value: Optional[Any]) -> Any:
        if value is not None:
            return {"magnitude": value.magnitude, "unit": str(value.units)}
        else:
            return None

    @classmethod
    def from_json_compatible(cls, json_version: Any) -> Optional[Any]:
        if json_version:
            return ureg.Quantity(json_version["magnitude"], ureg[json_version["unit"]])
        else:
            return None

```

在创建这个版本的软件时，我们已经获得了相当数量的传感器支持代码；是时候把它从传感器的实现中移走了，让代码库更容易导航。

### 整理

`sensors.py`文件目前有两个基类和一些实际的传感器。只在这个文件中列出传感器更清楚，所以我将把支持代码移到 base.py。

让 JSON API 使用与传感器入口点相同的键也是一个好主意。这将使反序列化数据变得容易得多，因为我们可以轻松地查找定义它的传感器类。为此，添加了一个新的名称属性。列表 [5-13](#PC55) 显示了`Sensor`基类的完整定义。

```py
import typing as t

T_value = t.TypeVar("T_value")

class Sensor(t.Generic[T_value]):
    name: str
    title: str

    def value(self) -> T_value:
        raise NotImplementedError

    @classmethod
    def format(cls, value: T_value) -> str:
        raise NotImplementedError

    def __str__(self) -> str:
        return self.format(self.value())

    @classmethod
    def to_json_compatible(cls, value: T_value) -> t.Any:
        raise NotImplementedError()

    @classmethod
    def from_json_compatible(cls, json_version: t.Any) -> T_value:
        raise NotImplementedError()

class JSONSensor(Sensor[T_value]):
    @classmethod
    def to_json_compatible(cls, value: T_value) -> t.Any:
        return value

    @classmethod
    def from_json_compatible(cls, json_version: t.Any) -> T_value:
        return t.cast(T_value, json_version)

Listing 5-13Definition of the sensor base class from base.py

```

## 版本控制 API

作为这些变化的一部分，我们已经改变了 API 的行为，尽管是以最小的方式。唯一面向用户的区别是 API 值现在由传感器 ID，而不是人类可读的名称来键入。我们需要创建一个新的面向用户的 API 版本，因为它的行为与以前的版本不同。

新的 API 版本通常是通过在一个稍微不同的 URL 上提供不同的 API，包含版本号。我们可以适当地改变 API，但是任何依赖 API 的人都会突然看到不同的行为。对于个人项目来说，这可能不是问题，但是对公众或公司内部可用的 API 可能会有用户，你不能事先与他们讨论更改。

Tip

有能力支持旧的 API 版本并不意味着你必须支持它们。很有可能你已经有了`/v/1.0`和`/v/1.1`，但是后来决定发布`/v/2.0`，它与其他两个非常不同。在这种情况下，您可能会决定完全删除旧的 API 版本。在 URL 中包含版本号并不强制您维护对旧版本的支持，但是如果您不按版本来确定 API 端点的范围，那么如果您以后选择维护旧版本，就很难维护旧版本。

在对 API 进行版本控制时，您需要决定如何处理 bug。总的来说，有两种策略。要么你可以把 bug 留在原地，坚持让人们升级到最新版本的 API，要么你可以用不引人注目的方式修复 bug。将 bug 留在原处是一个更常见的解决方案，因为修复它们要做的工作要多得多。不过，旧 API 版本中的安全漏洞应该**总是**被修复。

我们在本章中所做的更改是处理温度和湿度传感器的序列化，现在我们已经将它们更改为使用 pint。最初的 API 以摄氏度为单位返回这些值；新函数返回一个包含温度系统的字典。

在本章附带的代码版本中，我应用了一个修复程序，通过捕捉`TypeError`并在需要时跳过传感器，来防止任何无法 JSON 序列化的传感器出现在 v1.0 API 输出中。这意味着温度和湿度传感器将不再出现在那里，只出现在 v2 API 中。是否花费额外的时间和精力在 v1.0 API 中为 pint 对象添加一个特例在很大程度上取决于用户的需求。

为了方便托管多个版本的 API，我们将视图移动到一个以 API 版本命名的新文件中，并针对该 API 版本的`flask.Blueprint`实例注册它们，而不是直接针对`flask.Flask`对象。Flask blueprints 是一组可以添加到应用程序中的相关 URL。使用蓝图允许我们编写在主网站的子路径中工作的视图代码，而不必修改所有单独的 URL 来包含 API 版本号:

*v10.py*

```py
version = flask.Blueprint(__name__, __name__)

@version.route("/sensors/")
@require_api_key
def sensor_values() -> t.Tuple[t.Dict[str, t.Any], int, t.Dict[str, str]]:
    ...

```

*__init__。py*

```py
app = flask.Flask(__name__)
app.register_blueprint(v10.version, url_prefix="/v/1.0")

```

wsgi 目录的文件结构对于每个 API 版本都有不同的文件，目前是`v10.py`和`v20.py`，以及一些支持代码，比如认证函数。

```py
src/apd/sensors/wsgi/
├── __init__.py
├── base.py
├── serve.py
├── v10.py
└── v20.py

```

这里我给了 API 一个简单的版本号，但是许多公共 API 使用日历版本号作为它们的版本号。这可能对用户更友好，但这确实是个人偏好的问题。

### 易测性

当支持 API 的多个版本时，我们还需要测试它们。即使您认为旧版本的正常工作并不重要，您仍然需要确保旧版本的 API 中没有引入安全问题。

我通过为 API 的每个版本创建一个类来实现这一点。这允许设置 fixtures 来避免必须让每个测试指定它所针对的 API 版本。例如，我们已经有了一个测试来检查在访问传感器时丢失 API 键是否会导致 HTTP 禁止错误。它被写成

```py
@pytest.mark.functional
def test_sensor_values_fails_on_missing_api_key(self, api_server):
    response = api_server.get("/sensors/", expect_errors=True)
    assert response.status_code == 403
    assert response.json["error"] == "Supply API key in X-API-Key header"

```

这个测试假设 api_server 是一个 WebTest 应用程序，它在根目录下安装了 api。当我们没有命名空间 API 版本时，这很好，但是似乎我们必须为`/v/1.0/sensors`和`/v/2.0/sensors`编写这个测试。每个 API 版本都有一个支持类，这意味着我们可以将该版本的蓝图安装在 Flask 应用程序的根目录下，而不是针对将蓝图安装在不同前缀上的复合应用程序进行测试。

*将* `/v/1.0` *作为根*的测试类

```py
from apd.sensors.wsgi import v10

class Testv10API:
    @pytest.fixture
    def subject(self, api_key):
        app = flask.Flask("testapp")
        app.register_blueprint(v10.version)
        set_up_config({"APD_SENSORS_API_KEY": api_key}, to_configure=app)
        return app

    @pytest.fixture
    def api_server(self, subject):
        return TestApp(subject)

```

`TestV20API`类做了同样的事情，但是使用了`v20.version`而不是`v10.version`，使得每个类中的测试在它们的 HTTP 名称空间的根中看到合适的 API 版本。然后，前面缺失的 API 关键测试可以被分解到一个 mixin 类中，以及在不同版本的 API 中工作相同的任何其他测试。对我们来说，这将是处理 API 认证的两个测试。

```py
class CommonTests:
    @pytest.mark.functional
    def test_sensor_values_fails_on_missing_api_key(self, api_server):
        response = api_server.get("/sensors/", expect_errors=True)
        assert response.status_code == 403
        assert response.json["error"] == "Supply API key in X-API-Key header"

    @pytest.mark.functional
    def test_sensor_values_require_correct_api_key(self, api_server):
        response = api_server.get(
            "/sensors/", headers={"X-API-Key": "wrong_key"}, expect_errors=True
        )
        assert response.status_code == 403
        assert response.json["error"] == "Supply API key in X-API-Key header"

```

由于测试类名不以`Test`开头，pytest runner 没有将这些测试视为独立的测试，这很好，因为它们依赖于一个名为`api_server`的 fixture，这个 fixture 没有定义。然而，当我们添加`CommonTests`作为`TestV10API`和`TestV20API`的基类时，这些测试函数被两个类继承。pytest 只检查以单词`Test`开头的测试类，所以`CommonTests`类不会被孤立执行。它包含的方法由特定于版本的类继承，这些类有适当的装置来支持它们。

## 摘要

我们在这一章已经讲了很多，介绍了 Flask 的 web APIs，并讲述了我们如何扩展传感器接口来克服 JSON 序列化的限制。Python web 开发的生态系统是巨大的，许多书籍只深入这个世界的一个小方面。

尽管我们确实需要一个 HTTP API 来完成我们的传感器聚合程序，但它从根本上说并不是一个 web 应用程序。我鼓励任何有兴趣在网上学习 Python 的人尝试一些流行的框架(比如 Django、Pyramid 和 Flask ),了解它们的优缺点。Django 被誉为全方位 web 开发的良好框架，这是正确的，但 Flask 的最小风格和 Pyramid 的表达能力使它们成为选择平台时需要注意的有价值的工具。

我们还讨论了作为系统的原始作者和使用抽象基类的第三方来扩展类定义的实用性。最后，我们还介绍了许多 Python 代码的常用方法，比如用于消息认证的 HMAC 和用于扩展函数行为的 decorators。

传感器 API 已经以打破向后兼容性的方式进行了更改，因此软件包的版本号已经更新为 2.0.0，并且文档现在解释了如何访问 API。在下一章中，我们将使用这个新的 HTTP API 开始整理一个中心源中的信息。

### 额外资源

如果您对 web 编程特别感兴趣，下面的资源提供了一些关于我们已经讨论过的主题的附加信息，值得一读:

*   WSGI 规范是针对 web 应用程序的特定于 Python 的标准。很多背景资料可以在 [`http://wsgi.org`](http://wsgi.org) 找到。

*   Flask web 框架的完整文档位于 [`https://flask.palletsprojects.com/`](https://flask.palletsprojects.com/) 。

*   我推荐将 [`www.djangoproject.com/`](http://www.djangoproject.com/) 和 [`https://trypyramid.com/`](https://trypyramid.com/) 作为其他 Python web 框架来特别关注。

*   我用于物理单位的品脱库在 [`https://pint.readthedocs.io/`](https://pint.readthedocs.io/) 有例子和高级用法信息。

*   JWT 项目( [`https://jwt.io/`](https://jwt.io/) )详细介绍了一种使用 HMAC 进行认证的更复杂的方法，并有许多例子和样本代码。

*   一些量产级的 WSGI 服务器有 [`https://gunicorn.org/`](https://gunicorn.org/) 、 [`https://modwsgi.readthedocs.io/en/develop/`](https://modwsgi.readthedocs.io/en/develop/) 、 [`https://pypi.org/project/waitress/`](https://pypi.org/project/waitress/) 。

*   关于 WSGI 应用测试库 WebTest 的信息在 [`https://docs.pylonsproject.org/projects/webtest/`](https://docs.pylonsproject.org/projects/webtest/) 。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

许多浏览器只会整体呈现纯文本数据，但会在等待其余部分时呈现部分 HTML 响应。

  [2](#Fn2_source)

`curl http://localhost:8000/ | jq`在安装了相关程序的 Linux 或 macOS 系统上。您同样可以在浏览器中打开这个 URL，并在那里查看数据。

  [3](#Fn3_source)

授权与认证相对。*授权*是决定一个给定的人是否被允许做某事的过程；*认证*是确定用户是否是他们所声称的那个人的过程。这些通常简称为 authn 和 authz(这可能会让习惯英式拼写的人感到困惑)。

  [4](#Fn4_source)

Flask 提供了类型注释，所以在定义这个函数时的一些错误会被 mypy 捕获。例如，如果您想提供一个状态，它必须是一个整数。返回`t.Tuple[t.Dict, str]`会导致类型检查错误。

  [5](#Fn5_source)

从技术上讲，任何值都可以被返回，但是对于最终用户来说，返回没有兼容调用签名的值是非常令人困惑的。

  [6](#Fn6_source)

此函数的关联作为属性存储在函数及其代码对象上。值的名称存储为`inner_function.__code__.co_freevars`，它们的值存储为`inner_function.__closure__`上的单元格对象，这些单元格对象本身有一个`cell_contents`属性。“自由变量”这个名字指的是“自由变量”——在作用域中使用但没有在作用域中定义的变量。除了好奇 Python 解释器是如何工作的，你不需要看这些。

  [7](#Fn7_source)

*隐藏*是定义一个新变量的名字，这个变量与其他可访问的变量同名。例如，`list = [1, 2,3 ]`隐藏了内置的`list`类型，使得不能在该范围内使用`list(...)`。

  [8](#Fn8_source)

这些还是个人口味的问题；如果你觉得有用，就使用它们。因为这个函数不是公共 API 的一部分，所以对代码的用户没有额外的好处，只是对维护它的人有好处。

  [9](#Fn9_source)

注意，这并不能保证是相同的数据，只是相同的类型。

  [10](#Fn10_source)

HMAC 摘要是一种加密哈希，用于根据共享密钥验证数据。他们几乎不可能伪造，所以他们经常被用在认证系统中。

  [11](#Fn11_source)

如果 API 键是随机生成的，我们还必须确保主题 fixture 获得与单个测试方法相同的值。这是在 pytest 中用 fixture 作用域完成的，在本书的第 [11](11.html) 章中有解释。

  [12](#Fn12_source)

事实上，如果我不是抱着很快就会添加 JSON 支持的想法编写代码，我会这么做的。我经常使用品脱和 Python REPL 或 Jupyter 作为长度、面积和电气值的计算器，例如计算电路中使用的正确电阻:

```py
>>> import pint
>>> ureg = pint.UnitRegistry()
>>> Vs = 3.3 * ureg.volt
>>> Vf = 1.85 * ureg.volt
>>> I = 20 * ureg.milliamp
>>> R = (Vs - Vf) / I
>>> print(R.to(ureg.ohm))
72.49999999999999 ohm

```

  [13](#Fn13_source)

像*授权*一样，serialize 这个词传统上在 API 中使用美国英语惯例拼写，所以用 z 而不是 s。

  [14](#Fn14_source)

任何被定义为`class MyClass(metaclass=abc.ABCMeta)`的都一样，但我不认为这种方法是清晰的。Python 使用元类来实现 ABC，因为它需要能够自省已经定义的方法，以决定一个类是否可以被实例化。

  [15](#Fn15_source)

抽象方法是 ABCs 的另一个有用的特性。它们防止任何超类中包含 ABC 的类被实例化。它们必须被子类覆盖，否则该类将无法实例化。Python 开发人员通常会创建方法`raise NotImplementedError`来传达方法必须被覆盖，但是这种方法通过将错误移到对象被实例化的时候，而不是第一次使用方法的时候，使得错误更容易被发现。

  [16](#Fn16_source)

注册函数`SerializableSensor.register(other_class)`将待注册的类作为单个参数，并返回同一个类，这意味着它符合类装饰器的定义。因此，您也可以直接在类定义前写一行`@SerializableSensor.register`。

  [17](#Fn17_source)

为了演示为什么这很重要，假设我们使用`SerializableSensor`作为`Temperature`传感器的基类。我们希望`isinstance(obj, SerializableSensor)`使用子类 hook，但是如果 obj 是`Temperature`传感器的实例，我们只希望`isinstance(obj, Temperature)`返回 true，而不是任何需要方法成为`SerializableSensor`的实例。

  [18](#Fn18_source)

mixin 类是一个超类的名称，它为类的作者提供了一些相关的继承方法。大多数时候，你看到一个类有多个超类，这是因为它们中的一些是混合的。

 </aside>*