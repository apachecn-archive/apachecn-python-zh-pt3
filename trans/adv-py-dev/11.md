# 11.容错

从乐观的角度来看，开发人员编写代码是很自然的。我们编写不工作的代码，然后我们反复调整它，直到它给出我们想要的结果。希望我们也编写测试，允许我们验证代码在未来仍然工作，并且测试检查我们正在处理我们已经正确意识到的任何边缘情况。我们永远无法编写测试来涵盖我们还没有想到的问题，所以遵守代码如何划分和处理遇到的小问题的规则是我们编写行为符合我们预期的软件的最佳策略。

## 错误处理

从一开始，我们就在本书附带的代码中发现了异常。有些例外是我们知道可以由我们正在使用的代码引发的(例如，DHT 接口代码在无法连接到传感器时引发`RuntimeError`)。其他的是由于对象的不正确使用而导致的异常(例如，如果我们试图从逆变器获得一条输出中不存在的数据，则在太阳能发电传感器中使用`KeyError`)。

我们还提出了`NotImplementedError`作为我们`Sensor`基类的一部分，以表达方法**必须**被传感器开发人员和各种`RuntimeError`和`ValueError`覆盖，作为命令行接口错误处理的一部分。

编程语言通常遵循“三思而后行”或“请求原谅比请求允许更容易”的错误处理哲学。三思而后行的哲学意味着你应该使用条件句来确定某事是否可能，并留下例外来代表*意料之外的*情况。请求原谅的理念意味着你应该编写代码来预测最常见的情况，并为你所知道的边缘情况补充异常处理程序。

Python 很大程度上属于后一种阵营；在许多情况下，在编写 Python 代码时依靠异常处理程序进行控制流被认为是正确的风格。

### 从容器中获取项目

我们用 Python 编写的最常见的表达式之一是从容器类型中获取一个条目，比如从字典中获取一个值或者从列表中获取一个条目。这两个都使用`variable[other]`结构。如果`other`没有指向`variable`中的有效项，那么就会引发一个异常。否则，返回关联的值。

尽管这些操作使用相同的方括号结构，但是底层数据类型和变量的含义却大不相同。当我们编写一个使用这个特性的函数时，我们需要意识到可能的结果是多么的不同。

你有时会看到字典被称为*映射*，但是这些术语是不可互换的。字典是映射的一个例子，映射是将键映射到值并提供某些方法的任何对象的名称。如果`variable`是一个映射(比如字典)，那么`other`应该是一个*可散列的*类型:一个定义了`hash(other)`的类型。

另一方面，如果`variable`是一个列表或元组，那么对于*序列*的条目访问是被使用的。在这种情况下，`other`应该是一个整数，表示我们正在寻找的容器中的索引。我们不能使用方括号语法从生成器中获取一个项目，但可以将其用于列表的原因是因为生成器不是一个序列。所有序列(事实上，所有映射)都是可迭代的，但不是所有可迭代的都是序列。

#### 抽象基类

映射、序列和散列的定义是`collections.abc`模块中对应的`Mapping`、`Sequence`和`Hashable`类。`Mapping`和`Sequence`都是`Collection`的子类。如果一个对象实现了`__len__()`、`__iter__()`和`__contains__(...)`魔法方法，那么它就是一个`Collection`。也就是说，如果一个对象有一个定义的长度，可以被迭代，并且可以被查询以查看一个值是否在对象的迭代结果中，那么它就是一个集合。

虽然`collections.abc.Sized`、`collections.abc.Iterable`、`collections.abc.Container`、<sup>、 [1](#Fn1)</sup> 和`collections.abc.Collection`对象都是提供子类钩子的抽象基类(意味着任何实现所需方法的对象都被认为是抽象基类的子类)，`Mapping`和`Sequence`实现不会被自动检测。映射或序列的实现必须根据适当的基类进行注册。

映射和序列都实现了一个`__getitem__(...)`方法，但是具有非常不同的含义。一个`Sequence`是一个对象，其中`variable[0]`返回底层集合中的第一项，而一个`Mapping`是一个对象，其中`variable[0]`返回附加的值，即键`0`。

当出错时，`__getitem__(...)`方法的两种不同语义会引发不同的异常。当代码试图检索序列末尾之外的项目时，序列版本会引发一个`IndexError`(例如空序列上的`variable[0]`)。相反，当代码在不包含与该键关联的值的映射上使用项目访问时，会引发`KeyError`。

当相应的键不是适当的类型时，调用任一类型的`__getitem__(...)`的代码都会引发一个`TypeError`。例如，一个序列上的`variable[1.2]`或一个映射上的`variable[{}]`都会引发`TypeError`。当被索引的变量没有`__getitem__(...)`方法时，Python 解释器也会抛出一个`TypeError`，例如`None[0]`。

您应该预料到行`variable[other]`可能会引发这三种不同异常中的任何一种。通过更多地了解变量的底层数据类型，我们可以排除一个`TypeError`和`IndexError`或`KeyError`，但是只有通过更多地了解实际数据，我们才能确保不会引发异常。

对于许多简单的任务(例如表 [11-1](#Tab1) 中的函数，该函数包装`__getitem__(...)`以在所请求的项目不可用的情况下返回默认值 <sup>[2](#Fn2)</sup> ),“宽恕”风格明显更加直接。它本身并不简单。完全有可能通过嵌套许多`try` / `except`块来编写控制流混乱的代码，但是这通常会简化代码。也许更重要的是，这是人们期望从 Python 程序中得到的风格。

表 11-1

两种风格中带有默认函数的 get 的详细实现

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| *三思而后行*`from collections.abc import Sequence, Mapping``from collections.abc import Hashable``def get_item(variable, key, default=None):``if isinstance(variable, Sequence):``if isinstance(key, int):``if (0 <= key <  len(variable)):``return variable[key]``else:``# key is too big``return default``else:``# Key isn't an int``return default``elif isinstance(variable, Mapping):``if isinstance(key, Hashable):``if key in variable:``return variable[key]``else:``# key is not known``return default``else:``# Key isn't hashable``return default``else:``# variable isn't a known type``return default` | *请求原谅*`def get_item(variable, key, default=None):``try:``return variable[key]``except TypeError:``# variable has no get item # method``# or key isn't a valid type``return default``except KeyError:``# Variable is a mapping but``# doesn't contain key``return default``except IndexError:``# Variable is a sequence``# shorter than key``return default` |

问题在于决定在哪里捕捉异常，以及在哪里让异常冒出来调用代码。前面提到的两个实现的关键区别在于，左侧有两条成功代码路径和四条失败代码路径，而右侧有一条成功代码路径和三条失败代码路径。如果我们想为特定的条件定制行为，左边比右边容易，但只是因为左边的控制流比右边的代码更复杂。

这种复杂性在这个函数的性能上也很明显，如图[11-1](#Fig1)；虽然某些操作的性能与任一实现大致相同，但异常处理程序路线有时要快得多。根据我的经验，在使用请求原谅方法时，通常更容易避免过于聪明的代码。

![../images/481001_1_En_11_Chapter/481001_1_En_11_Fig1_HTML.jpg](../images/481001_1_En_11_Chapter/481001_1_En_11_Fig1_HTML.jpg)

图 11-1

每种不同情况下两种实现的性能图表

想象一下，如果`variable=`参数的值是一个不支持项目访问的对象，我们希望我们的`get_item(...)`函数引发一个`TypeError`，但是我们仍然希望未知的关键代码路径导致返回一个默认值。这对应的是左边自定义底部条件，而右边`TypeError`的两个来源只有一个。我们可以在`TypeError`异常处理程序中添加一个条件来确定哪个代码路径导致了问题。为了补偿复杂性的增加，我们还可以将`KeyError`和`IndexError`异常处理程序合并到一个块中，因为它们代表相同的行为，如清单 [11-1](#PC1) 所示。

```
def get_item(variable, key, default=None):
    try:
        return variable[key]
    except (KeyError, IndexError):
        # Key is invalid for variable, the error raised depends on the type # of variable
        return default
    except TypeError:
        if hasattr(variable, "__getitem__"):
            return default
        else:
            raise

Listing 11-1A get with default function that raises on noncontainer arguments

```

Tip

在异常处理程序中，您可以使用`raise`而不用显式的异常来重新引发当前正在处理的相同错误。

#### 异常类型

例外是具有自己的类层次结构的类。所有的异常都继承自`BaseException`，但是只有那些继承自`Exception`的异常才是开发者想要使用的。 <sup>[3](#Fn3)</sup> 当我们捕捉异常时，我们需要指定我们想要捕捉哪种类型的异常。没有指定要捕获的异常类型的`except`块被称为 *bare except* 并捕获所有异常，甚至是内部异常。由于`KeyboardInterrupt`是这些内部异常之一，一个裸露的`try` / `except`会抑制用户使用`<CTRL+c>`来停止程序的能力。

Tip

捕捉多种异常类型总比捕捉一个过于宽泛的超类好。您可以在一个块中指定许多异常类型，或者使用多个`except`块来实现这一点。

异常的类层次相对较浅，但是一些超类值得记住。最有用的是`LookupError`，它是`KeyError`和`IndexError`的超类。`LookupError`特指请求的键不存在的情况，所以这个词不太宽泛。这允许我们通过用`except LookupError`替换`except (KeyError, IndexError)`来稍微简化我们的`get_item(...)`功能。

##### 类型错误和值错误

我们经常不得不提出自己的异常，而不仅仅是从调用堆栈的底层重新提出现有的异常。在这种情况下，我们需要确保选择适当的异常类型和有用的消息。如果不清楚哪个异常类最适合，那么`TypeError`和`ValueError`是默认的好的异常类型。

当传递给函数的值是错误的类型时，`TypeError`是合适的，当传递的值是正确的类型但在某些方面不合适时，`ValueError`是合适的，除了`LookupError` s 所涵盖的情况

四个异常`TypeError`、`ValueError`、`KeyError`和`IndexError`一起代表了您将遇到的大多数逻辑类型的异常。如果您需要在自己的代码中引发一个异常，那么很有可能其中一个非常合适。

##### RuntimeError 和 SystemExit

还有针对非特定问题行为的异常类，其中伴随的消息是对问题的描述。`RuntimeError`是一个万不得已的异常类，用来处理不匹配任何其他类别的错误，但是可能需要通过调用函数来捕获。`SystemExit`由`sys.exit(...)`函数调用在内部引发，表示程序应该结束。 <sup>[4](#Fn4)</sup> 在这两种情况下，给出的论点都是至关重要的，因为这是问题所在的唯一信息。

一般来说，`except SystemExit:`块仅适用于定制如何向最终用户显示最终错误消息。代码捕获`RuntimeError`并继续正常操作可能是有意义的，但这很大程度上取决于底层代码的构造方式和`RuntimeError`的含义。创建一个新的异常类通常比依赖`RuntimeError`要好。

##### 断言错误

当一条`assert`语句失败时，解释器自动引发`AssertionError` s。在编写测试时，你经常会遇到这些问题，因为大多数`assert`语句都是在测试中编写的。将`assert`语句添加到任意的 Python 代码中是完全可能的，但是开发人员很少这样做。

Python 并不保证它会为任何失败的`assert`语句引发一个`AssertionError`，所以你不能依靠一个 assert 语句来进行正常的错误处理。在非测试代码中使用`assert`语句的一个可能的用途是添加断言来覆盖你对必须总是为真的事情的假设。例如，您可以使用`assert`行来验证函数参数之间的某种关系，这种关系不能用静态类型声明来表达，或者参数列表排序正确。同样，这并不能代替函数中正确的错误处理，但是拥有`assert`可以帮助跟踪不明显的错误。

使用`assert`语句的好处在于它们并不总是引发错误。如果使用`python -O`或`PYTHONOPTIMIZE=1`环境变量运行程序，那么 assert 语句将被忽略，除了在调试会话期间，可能会禁用代价高昂的健全性检查。

将`assert`语句添加到代码中来实现对程序的正确运行*必要的*检查是不正确的，因为不能保证它们会被运行。这种检查应该用一个 if 语句保护一个`raise`来实现。你应该只对你认为应该总是正确的检查使用 assert，但是你想知道你是否错了。

### 自定义例外

每当您使用新的第三方库时，通常会遇到各种自定义异常。例如，Pint 为 pint 数据库中没有列出的单位提供了`UndefinedUnitError`,为不可能的转换提供了`DimensionalityError`。`UndefinedUnitError`是`AttributeError`的一种，与访问单元的`ureg.watt`方法相匹配。`DimensionalityError`是`TypeError`的子类，意味着库的开发人员希望开发人员将不同单位的数量视为不同的类型。

Click 在处理与我们的代码无关的命令行选项解析时有一系列例外；请求在`requests.exception`模块中提供具体的异常(如`ConnectTimeout`、`ReadTimeout`、`InvalidSchema`、`InvalidURL`等)。)来处理特定的错误情况，或者通过父类(如用于所有超时错误的`requests.exception.Timeout`，甚至是`IOError`，因为它是所有特定于请求的异常的基类。

并不总是清楚第三方代码会引发什么类型的异常；开发人员的意图以及他们如何看待自己的代码是一个重要的影响因素。知道应该从第三方代码中捕捉哪些异常的唯一方法是阅读文档 <sup>[5](#Fn5)</sup> ，并相信它是准确的。

#### 创建新的异常类型

当您编写定义新异常类型的库代码时，您应该站在未来用户的角度考虑问题。确保有足够的多样性来准确地传达发生了哪些错误，但是要以这样的方式安排它们，使它们形成一个内聚的整体，既包括默认的异常类型，也包括彼此。像所有的 API 设计一样，最重要的成功标准是你的最终用户觉得它很直观。

我们的`apd.sensors`包使用`None`作为无法确定传感器值时的信号值。传感器可能由于一系列原因而无法返回值:可能是检索值时出现暂时错误(如太阳能输出传感器中的连接错误)或永久性错误(如没有电池充电电路的机器上的交流状态传感器)。

未能返回数据点的传感器不是任何一种类型的`LookupError`:代码*找到了传感器，它只是不能正常工作。它不是一个`TypeError`或`ValueError`，因为没有参数是错误的类型或不可接受的值。内置异常类型的最接近的匹配是`RuntimeError`，我们最后使用的异常类型。为了避免直接引发`RuntimeError`，我们可以定义一些异常子类并重新编写代码来引发这些异常，而不是将`None`作为一个标记对象返回。*

清单 [11-2](#PC2) 展示了我们可以添加到`apd.sensors`包中的新异常，包括一个用于所有`apd.sensors`异常的基类，一个更具体的用于数据收集问题的基类，以及两个用于数据收集问题类型的子类。这些类别允许代码的用户识别他们的传感器代码中的特定问题，或者寻找与传感器相关的故障的广泛类别。

```
class APDSensorsError(Exception):
    """An exception base class for all exceptions raised by the
    sensor data collection system."""

class DataCollectionError(APDSensorsError, RuntimeError):
    """An error that represents the inability of a Sensor instance
    to retrieve a value"""

class IntermittentSensorFailureError(DataCollectionError):
    """A DataCollectionError that is expected to resolve itself
    in short order"""

class PersistentSensorFailureError(DataCollectionError):
    """A DataCollectionError that is unlikely to resolve itself
    if retried."""

Listing 11-2New exceptions for apd.sensors, stored as exceptions.py

```

这四个异常允许最终用户直观地捕捉错误。用捕获`RuntimeError`、`APDSensorsError`或`DataCollectionError`中任何一个的`try` / `except`来包装`sensor.value()`都将捕获失败。有一个`IntermittentSensorFailureError`的事实也允许下游代码识别该特定情况并重试读取，如清单 [11-3](#PC3) 中的示例函数。

```
from apd.sensors.base import Sensor, T_value
from apd.sensors.exceptions import IntermittentSensorFailureError

def get_value_with_retries(sensor: Sensor[T_value], retries: int=3) -> T_value:
    for i in range(retries):
        try:
            return sensor.value()
        except IntermittentSensorFailureError as err:
            if i == (retries - 1):
                # This is the last retry, reraise the underlying error
                raise
            else:
                continue
    # It shouldn't be

possible to get here, but it's better to
    # fall through with an appropriate exception rather than a
    # None
    raise IntermittentSensorFailureError(f"Could not find a value " f"after {retries} retries")

Listing 11-3Example function to retry a sensor read if there’s an intermittent problem

```

然后，我们可以使用这些误差来代替各种传感器中的返回信号`None`。这允许我们去除各种传感器类型中的`t.Optional[...]`结构。改变这种类型*是否意味着*之前 JSON 编码的传感器值不再有效，因为`None`不再是该传感器的有效传感器值。任何调用`sensor.from_json_compatible(...)`或`sensor.format(...)`的代码都可能引发异常。当编写存储传感器值并在以后恢复它们的代码时，确保捕获任何错误并丢弃数据点是很重要的。如果我们希望确保未来变化的兼容性，我们可以编写迁移函数，并将版本号与传感器数据一起存储。

#### 附加元数据

我们已经在 CLI 界面中引发了`RuntimeError`来传达错误消息。此代码路径是自定义异常的另一个好用途；我们可以在清单 [11-4](#PC4) 中创建一个异常，它不是一个通常被隐藏的类型 <sup>[6](#Fn6)</sup> 并存储额外的元数据，比如所需的退出状态代码。

```
@dataclasses.dataclass(frozen=True)
class UserFacingCLIError(APDSensorsError, SystemExit):
    """A fatal error for the CLI"""
    message: str
    return_code: int

    def __str__(self):
        return f"[{self.return_code}] {self.message}"

Listing 11-4A new exception type with additional metadata

```

通常用一个参数实例化一个异常:一个人类可读的异常解释。这种方法不是异常的唯一格式；例如，`OSError`异常类型有数字错误标识符的参数以及人类可读的字符串。

Note

虽然大多数内置异常接受任意数量的参数，但我建议不要用它来存储关于异常的元数据。对于如何解释元组的参数，具有良好定义的参数的自定义异常类型总是比约定更清晰。

异常类型是 Python 类，因此我们可以使用任何标准技术来存储额外的信息作为异常的一部分。我会推荐一个数据类，就像我们处理任何主要存储数据的 Python 类一样。然后，我们可以在异常处理期间提取这些元数据，从而允许我们将失败的返回代码和可读消息合并到一个对象中。在这里，我们显式地添加了两项元数据。需要自定义的`UserFacingCLIError.__str__()`方法，因为将`Exception`转换为字符串必须只返回面向用户的错误表示，而 dataclasses 的默认实现显示所有参数的元组。

然后，我们可以使用这个异常向用户显示一条消息，并向操作系统返回正确的退出代码。

```
if develop:
    try:
        sensors = [get_sensor_by_path(develop)]
    except UserFacingCLIError as error:
        click.secho(error.message, fg="red", bold=True)
        sys.exit(error.return_code)

```

### 涉及多个异常的回溯

当我们从 Python 代码中抛出一个我们随后没有捕捉到的异常时，解释器打印一个回溯。回溯为最终用户提供了关于引发了什么异常以及代码的哪个部分触发了异常的信息。以下是通过在 IP 地址传感器中故意引入一个错误而获得的回溯示例:

```
Traceback (most recent call last):
  File "...\Scripts\sensors-script.py", line 11, in <module>
    load_entry_point('apd.sensors', 'console_scripts', 'sensors')()
  File "...\site-packages\click\core.py", line 764, in __call__
    return self.main(*args, **kwargs)
  File "...\site-packages\click\core.py", line 717, in main
    rv = self.invoke(ctx)
  File "...\site-packages\click\core.py", line 956, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "...\site-packages\click\core.py", line 555, in invoke
    return callback(*args, **kwargs)
  File "...\src\apd\sensors\cli.py", line 72, in show_sensors
    click.echo(str(sensor))
  File "...\src\apd\sensors\base.py", line 31, in __str__
    return self.format(self.value())
  File "...\src\apd\sensors\sensors.py", line 41, in value
    addresses = socket.getaddrinfo("hostname", None)
  File "...\Lib\socket.py", line 748, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

```

回溯中的每一对`File`和代码行代表调用堆栈中的一个函数。最下面的一行是引发异常的行，上面的每一行都提供了错误发生在软件的哪个部分的上下文。在这种情况下，标准库的`socket.py`中出现了异常，尽管原因并不明显。如果我们回到上一层，我们会看到我们控制的代码对标准库的调用。如果您假设您正在使用的库没有错误(这通常是一个公平的假设)，那么指向我们控制的代码的最低堆栈条目很可能是罪魁祸首。并不总是这一行，有时是堆栈的较高部分负责(例如，由于变量设置不正确)，但这通常是开始调试的最佳位置。

在这种情况下，我们可以从堆栈跟踪中看到，我们传递了一个包含“hostname”的字符串文字，但是`getaddrinfo(...)`的第一个参数应该是一个实际的主机名。在这种情况下，错误是由于意外地将变量名用引号括起来而不是传递变量引起的，这可能是 linter 捕捉到的。

异常通常是 Python 开发人员首先看到的事情之一(无论是在他们的职业生涯中还是在解决某个特定问题时)，所以回溯对于大多数开发人员来说是相当熟悉的；然而，在回溯上有一些不常见但非常有用的小变化。

#### except 或 finally 块中的异常

第一种替代形式表示在处理一个异常的同时引发另一个异常。通常，异常处理程序中唯一的 raise 语句是一个空的`raise`来重新引发被捕获的异常，通常是在自省系统状态以确定异常是否应该被抑制之后。但是，自检代码本身可能包含导致未处理异常的错误。还有一种可能是，`finally:`块中的代码可能会引发一个异常。

当我们通过`"hostname"`而不是`hostname`时导致的错误暴露了一个我们目前没有处理的错误案例。如果我们传递一个无法通过 DNS 系统解析的主机名，那么就会引发一个异常。如果我们想以不同于这里提出的其他潜在的`OSError`的方式处理这个案例，我们需要在处理程序中反思这个异常。

`OSError` s 提供了一个`errno=`属性来获得一个数字代码来识别特定的问题，而不是为每个可能的错误创建子类。在捕捉异常时，如果我们错误地检查了一个`err_no=`属性而不是`errno=`，那么就会引发一个`AttributeError`。原始的`OSError`异常和`AttributeError`异常都是传递给最终用户的有用信息，所以提供了两个回溯。

不正确的条件代码如下所示:

```
41\.        try:
42\.            addresses = socket.getaddrinfo("hostname", None)
43\.        except OSError as err:
44\.            if err.err_no == 11001:
45\.                raise

```

结果是显示了两个堆叠的异常，如下所示:

```
Traceback (most recent call last):
  File "...\src\apd\sensors\sensors.py", line 42, in value
    addresses = socket.getaddrinfo("hostname", None)
  File "...\Lib\socket.py", line 748, in getaddrinfo
    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
socket.gaierror: [Errno 11001] getaddrinfo failed

During handling of the preceding

exception, another exception occurred:

Traceback (most recent call last):
  File "...\Scripts\sensors-script.py", line 11, in <module>
    load_entry_point('apd.sensors', 'console_scripts', 'sensors')()
  File "...\site-packages\click\core.py", line 764, in __call__
    return self.main(*args, **kwargs)
  File "...\site-packages\click\core.py", line 717, in main
    rv = self.invoke(ctx)
  File "...\site-packages\click\core.py", line 956, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "...\site-packages\click\core.py", line 555, in invoke
    return callback(*args, **kwargs)
  File "...\src\apd\sensors\cli.py", line 72, in show_sensors
    click.echo(str(sensor))
  File "...\src\apd\sensors\base.py", line 31, in __str__
    return self.format(self.value())
  File "...\src\apd\sensors\sensors.py", line 44, in value
    if err.err_no == 11001:
AttributeError: 'gaierror' object has no attribute 'err_no'

```

要显示的第一个异常是第一个发生的异常:触发第二个异常时我们正在处理的较低级别的异常。回溯要短得多，因为省略了第二个异常常见的所有回溯行。第一个回溯中上下文行的最顶端(`sensors.py`，第 42 行)指向一个`try` / `except`结构的 try 块。第二个回溯中必须有一行指向与`try`对应的`except`块中的一行。这种情况下是`sensors.py`，44 线。该行以上的所有行也作为上下文应用于第一次回溯。

第一个和第二个回溯用一行“`During handling of the above exception, another exception occurred:`”隔开。这表明第二个异常发生在包含触发第一个异常的代码的`try`块中。解释器以与任何正常异常回溯相同的格式打印第二个异常的完整回溯。

作为这种格式的一部分，可以显示任意数量的回溯，尽管很少会超过两个。这仅仅是因为在 except 或 finally 块中最小化代码量被认为是一种好的风格，所以看到更多代码也不是什么新鲜事。

#### 从...升起

有时我们希望用另一个异常替换我们已经捕获的异常，例如用一个`PersistentSensorFailureError`替换我们的温度传感器中的`adafruit_dht`的`ImportError`，表明传感器不能提供一个值，并且它不希望在短时间内改变。当我们为一个库定义了新的异常类型时，这尤其有用，因为它让我们简化了函数可能引发的异常。

如果我们编写一个直接引发新的`PersistentSensorFailureError`的`try` / `except`构造，那么任何回溯都会将两者分开，说明我们的异常是在处理导入错误时引发的，正如我们前面看到的。这不是对情况的准确描述，因为从用户的角度来看，我们并没有真正地*处理*异常。Python 在这里提供了一个`raise ... from ...`结构，将一个异常标记为另一个异常的替代。

我们应该从 DHT sensor 基类中更新 sensor 属性来使用这种方法，如清单 [11-5](#PC9) 所示。

```
import os
import typing as t

from .exceptions import PersistentSensorFailureError

class DHTSensor:
    def __init__(self) -> None:
        self.board = os.environ.get("APD_SENSORS_TEMPERATURE_BOARD", "DHT22")
        self.pin = os.environ.get("APD_SENSORS_TEMPERATURE_PIN", "D20")

    @property
    def sensor(self) -> t.Any:
        try:
            import adafruit_dht
            import board
            sensor_type = getattr(adafruit_dht, self.board)
            pin = getattr(board, self.pin)
            return sensor_type(pin)
        except (ImportError, NotImplementedError, AttributeError) as err:
            # No DHT library results in an ImportError.
            # Running on an unknown platform results in a
            # NotImplementedError when getting the pin.
            # An unknown sensor type causes an AttributeError
            raise PersistentSensorFailureError("Unable to initialise sensor interface") from err

Listing 11-5New version of DHT base class

```

这导致了与没有`from err`子句时完全相同的输出格式，但是使用了不同的分隔线。不是说在处理第一个异常时发生了第二个异常，而是用“`The above exception was the direct cause of the following exception:`”分隔两个回溯。

作为前一个例子的特例，使用`raise PersistentSensorFailureError("Unable to initialise sensor interface") from None`会导致原来的`ImportError`被完全隐藏。在这种情况下，只有我们的异常会显示给最终用户，并且它会在回溯行中包含完整的上下文。

### 异常处理测试

我们有一些涉及 CLI 测试异常的测试。具体来说，我们尝试用各种无效的传感器路径调用`get_sensor_by_path(...)`函数，并断言`RuntimeError`被引发。Pytest 的`raises(...)`上下文管理器用于断言我们期望代码块引发某个异常。它有两个参数:异常的类型和一个可选的`match=`参数，用于在错误的字符串表示上定义一个正则表达式过滤器。

```
with pytest.raises(RuntimeError, match="Could not import module"):
    subject("apd.nonsense.sensor:FakeSensor")

```

上下文管理器捕获`RuntimeError`并检查字符串表示是否匹配`match=`参数。 <sup>[7](#Fn7)</sup> 如果引发了任何其他异常，包括与字符串不匹配的不同的`RuntimeError`，则上下文管理器会正常地重新引发它们。如果到`with pytest.raises(...):`块结束时还没有出现匹配的异常，那么上下文管理器将出现一个`AssertionError`，这意味着测试失败。

这种方法让我们可以测试代码是否会引发我们期望的异常，因此我们可以确信我们的函数在我们知道数据是坏的情况下会引发异常。这只是成功的一半；测试中异常的另一面是在可能引发异常的地方注入异常，并测试调用代码的行为是否正确。例如，我们可能想要测试引发`IntermittentSensorFailureError(...)`的传感器不会导致整个数据收集运行失败。

#### 新行为

我们已经决定传感器的`value()`函数应该返回泛型`Sensor[type]`声明中指定类型的对象，或者应该引发`DataCollectionError`。我们还没有定义如果传感器出现故障，CLI 或 API 应该做什么。在我们知道我们想要什么行为之前，测试异常行为没有什么意义。

我们将从 CLI 开始。当出现错误时，我希望在命令行界面中显示错误字符串，并继续其余的传感器查找。如果有一个可选的标志来显示整个异常回溯，帮助开发人员准确地调试传感器不工作的原因，这也是非常有用的。实现这个的代码在清单 [11-6](#PC11) 中。

```
@click.command(help="Displays the values of the sensors")
@click.option(
    "--develop", required=False, metavar="path", help="Load a sensor by Python path"
)
@click.option(
    "--verbose", is_flag=True, help="Show additional info"
)
def show_sensors(develop: str, verbose: bool) -> int:
    sensors: t.Iterable[Sensor[t.Any]]
    if develop:
        try:
            sensors = [get_sensor_by_path(develop)]
        except UserFacingCLIError as error:
            if verbose:
                tb = traceback.format_exception(type(error), error, error.__traceback__)
                click.echo("".join(tb))
            click.secho(error.message, fg="red", bold=True)
            return error.return_code
    else:
        sensors = get_sensors()
    for sensor in sensors:
        click.secho(sensor.title, bold=True)
        try:
            click.echo(str(sensor))
        except DataCollectionError as error

:
            if verbose:
                tb = traceback.format_exception(type(error), error, error.__traceback__)
                click.echo("".join(tb))
                continue
            click.echo(error)
        click.echo("")
    return 0

Listing 11-6Updated command-line entrypoint with exception handling

```

Note

我们编写的格式化整个异常的代码相当笨拙。从 Python 1 时代开始，`traceback.format_exception(...)`函数就一直保持着它的特征， <sup>[8](#Fn8)</sup> 尽管增加了一些东西。三个参数是必需的，但是它们都可以从异常对象本身提取。可以用 None 替换 traceback 对象，以指示只应该格式化异常信息，而不是整个 traceback。

我们还应该修改 API 的行为。为了保持向后兼容性，我们应该让 API 用一个`None`代替现有 API 版本中的任何`DataCollectionError`。有可能(尽管不太可能)一些用户会编写代码，通过在 API 响应中寻找`None`值来监控错误发生的频率。展望未来，我们希望创建一个新版本的 API 来智能地处理错误，这样 API 用户就可以获得关于失败的有用信息。

为了测试这个新的行为，我们需要创建一个测试子类(清单 [11-7](#PC12) ),它引发特定的异常，这样我们就可以验证周围的代码行为是否正确。这让我们能够在测试中可靠地触发传感器错误。

```
from apd.sensors.base import JSONSensor
from apd.sensors.exceptions import IntermittentSensorFailureError

class FailingSensor(JSONSensor[bool]):

    title = "Sensor which fails"
    name = "FailingSensor"

    def __init__(self, n: int=3, exception_type: Exception=IntermittentSensorFailureError):
        self.n = n
        self.exception_type = exception_type

    def value(self) -> bool:
        self.n -= 1
        if self.n:
            raise self.exception_type(f"Failing {self.n} more times")
        else

:
            return True

    @classmethod
    def format(cls, value: bool) -> str:
        raise "Yes" if value else "No"

Listing 11-7Definition of FailingSensor test sensor

```

在清单 [11-8](#PC13) 中，我们将测试 v1.0 API 服务器，但是模拟出`get_sensors(...)`方法来返回`FailingSensor`和`PythonVersion`传感器。

```
    @pytest.mark.functional
    def test_erroring_sensor_shows_None(self, api_server, api_key):
        from .test_utils import FailingSensor

        with mock.patch("apd.sensors.cli.get_sensors") as get_sensors:
            # Ensure the failing sensor is first, to test that subsequent
            # sensors are still processed
            get_sensors.return_value = [FailingSensor(10), PythonVersion()]
            value = api_server.get("/sensors/", headers={"X-API-Key": api_key}).json
        assert value['Sensor which fails'] == None
        assert "Python Version" in value.keys()

Listing 11-8Test to verify the 1.0 API remains compatible

```

#### 使用 unittest 进行高级模拟。模拟的

正如我们在第 8 章[中看到的，创建模拟对象的另一种方法是使用标准库的单元测试包中的模拟支持。之前，我们创建了原始的`Mock`对象，但是它们也可以用可选的`spec=`参数来创建。这导致它们只模拟传递的对象的属性，而不是为任何任意的属性访问返回一个新的模拟。这种方法很有帮助，因为任何试图检测对象上属性存在的代码在传递模拟时的行为都与传递真实对象时一样。](08.html)

这使得模拟对象更接近被测试的真实事物，并修复了一整类测试错误。如果您正在使用`isinstance(...)`条件，特别是当与实现子类钩子的抽象基类结合使用时，那么不使用`spec=`参数的`Mock`对象会导致采用错误的代码路径，如下面的控制台会话示例所示:

```
>>> import collections.abc
>>> import unittest.mock
>>> from apd.sensors.base import Sensor

>>> unspecced = unittest.mock.MagicMock()
>>> isinstance(unspecced, Sensor)
False
>>> isinstance(unspecced, collections.abc.Container)
True

>>> specced = unittest.mock.MagicMock(spec=Sensor)
>>> isinstance(specced, Sensor)
True
>>> isinstance(specced, collections.abc.Container)
False

```

我们可以使用这个模拟对象来创建模拟传感器，以触发异常或返回特定的值。这种方法的一个小问题是不涉及真正的`Sensor`基类代码，所以我们不能依赖我们的模拟对象有基类提供的帮助方法。我们需要定制整个面向用户的 API 的行为(比如`__str__()`方法),而不仅仅是实现我们需要定制的功能，就像我们对第一个`FailingSensor`实现所做的那样，如清单 [11-9](#PC15) 所示。

```
from apd.sensors.base import Sensor
from apd.sensors.exceptions import IntermittentSensorFailureError

FailingSensor = mock.MagicMock(spec=Sensor)
FailingSensor.title = "Sensor which fails"
FailingSensor.name = "FailingSensor"
FailingSensor.value.side_effect = IntermittentSensorFailureError("Failing sensor")
FailingSensor.__str__.side_effect = IntermittentSensorFailureError("Failing sensor")

Listing 11-9An alternative way to create a FailingSensor object

```

需要设置`title`和`name`属性，因为传感器基类上没有`title`和`name`属性，只有类型声明暗示它们在子类上可用。如果我们没有在这里设置它们，那么任何访问它们的尝试都会导致一个`AttributeError`。

我们之前已经在一个`Mock`对象上使用了`return_value`属性来定义如果一个对象被调用，应该返回什么值:`FailingSensor.__str__.return_value = "Yes"`将配置 mock 使得`str(FailingSensor) == "Yes"`。但是，我们不能使用这种方法来引发异常。

`side_effect`属性可以包含要引发的异常、要从多次调用中返回的 iterable 项或被调用来确定结果的函数。将副作用设置为 iterable 是指定变化行为的一种便捷方式。例如，在下面的副作用配置中，第一次使用`str(FailingSensor)`时，它会产生一个`IntermittentSensorFailureError`，告诉用户还会有两次失败。如果`str(FailingSensor)`被重复调用，它将通过链表提升下两个`IntermittentSensorFailureErrors`，然后在第四次尝试时返回`"Yes"`。

```
FailingSensor.__str__.side_effect = [
    IntermittentSensorFailureError("Failing 2 more times"),
    IntermittentSensorFailureError("Failing 1 more times"),
    IntermittentSensorFailureError("Failing 0 more times"),
    "Yes"
]

```

不幸的是，任何进一步的调用都会导致`StopIteration`错误，因为指定返回值的`side_effect`方法具有列表项到调用结果的一对一映射。可以使用来自`itertools`模块 <sup>[9](#Fn9)</sup> 的函数来创建一个无限长的可迭代对象，允许任意多次调用`str(FailingSensor)`。

```
FailingSensor.__str__.side_effect = itertools.chain(
    [
        IntermittentSensorFailureError("Failing 2 more times"),
        IntermittentSensorFailureError("Failing 1 more times"),
        IntermittentSensorFailureError("Failing 0 more times"),
    ],
    itertools.cycle(["Yes"])
)

```

这个例子使用了`itertools.cycle(...)`函数来创建一个无限长的 iterable，它重复 iterable 中作为参数给出的项，以及将任意 iterable 追加在一起的。其结果是一个 iterable，它可以作为副作用引发三次异常，然后一致返回`"Yes"`。

## 警告信息

警告的实现方式与异常类似，但行为方式却非常不同。尽管开发人员有时会谈论发出警告，但警告并不与关键字`raise`<sup>[10](#Fn10)</sup>一起使用，而是由`warnings.warn(...)`函数触发。开发人员遇到的最常见的警告是`DeprecationWarning`。在运行本书的示例代码时，您可能已经看到了一些。这是不可避免的，因为底层库可能会随时弃用某些功能，或者它们自己可能会使用弃用的功能来维护对旧版本代码的支持。

例如，在本书写作期间的一个短时间内，aiohttp 模块在 Python 3.8 中运行时触发了一个弃用警告，警告它对`asyncio.shield(...)` <sup>[11](#Fn11)</sup> 使用了一个较旧的签名。

```
   ...\lib\site-packages\aiohttp\connector.py:944: DeprecationWarning: The loop argument is deprecated since Python 3.8, and scheduled for removal in Python 3.10.
    hosts = await asyncio.shield(self._resolve_host(

```

`DeprecationWarning`意在告诉开发人员他们正在使用的模式不再被认为是最佳实践。应该清楚哪里出了问题(在这种情况下，不应该传递`loop=`参数)，并且应该给出一个明确的时间表，说明何时必须修复问题(在升级到 Python 3.10 之前)。

在这种情况下，是 Python 标准库发出了反对警告，目标受众是 aiohttp 的开发人员。作为 aiohttp 的用户，我们不是预期的受众，我们不应该担心看到反对警告，只要它们指定的时间范围不会结束。在这种特殊情况下，aiohttp 开发人员在 Python 3.8 发布后的两周内修复了这个不推荐警告。

aiohttp 的`connector.py`中触发该问题的特定代码位于第 944 行，如警告消息中所述。如果我们查看代码，我们可以看到触发异常的代码。

```
944\.            hosts = await asyncio.shield(self._resolve_host(
945\.                host,
946\.                port,
947\.                traces=traces), loop=self._loop)

```

Python 标准库中实现该警告的代码如下:

```
    if loop is not None:
        warnings.warn("The loop argument is deprecated since Python 3.8, "
                      "and scheduled for removal in Python 3.10.",
                      DeprecationWarning, stacklevel=2)

```

`warn(...)`函数可以将一个字符串和一种警告作为前两个参数，或者将一个警告实例作为第一个参数。如果只传递了一个没有警告类型的字符串，则假定它是一个`UserWarning`。`stacklevel=`参数对应于相关代码从回溯的底部算起有多少行。这一点非常重要，因为警告应该总是暗示用户的代码，而不是检测问题并发出警告的代码。

默认值是`stacklevel=1`，它将弃用警告的来源显示为`warnings.warn(...)`调用。这里，`stacklevel=2`使上下文显示为调用`warnings.warn(...)`所在函数的代码行。类似地，`stacklevel=3`将是进一步移除的一个功能。

当我们添加了对基于地图的图像的支持时，我们对`apd.aggregation`包中的`Config`对象进行了更改。我们有效地弃用了`sensor_name=`参数，取而代之的是另外指定的`get_data=`参数，但是我们没有向用户公开这一点。这是一个很好的`DeprecationWarning`候选，如清单 [11-10](#PC21) 所示。

```
@dataclasses.dataclass
class Config(t.Generic[T_key, T_value]):
    title: str
    clean: CleanerFunc[Cleaned[T_key, T_value]]
    draw: t.Optional[
        t.Callable[
            [t.Any, t.Iterable[T_key], t.Iterable[T_value], t.Optional[str]], None
        ]
    ] = None
    get_data: t.Optional[
        t.Callable[..., t.AsyncIterator[t.Tuple[UUID, t.AsyncIterator[DataPoint]]]]
    ] = None
    ylabel: t.Optional[str] = None
    sensor_name: dataclasses.InitVar[str] = None

    def __post_init__(self, sensor_name: t.Optional[str] = None) -> None:
        if self.draw is None:
            self.draw = draw_date  # type: ignore
        if sensor_name is not None:
            warnings.warn(
                DeprecationWarning(
                    f"The sensor_name parameter is deprecated. Please pass "
                    f"get_data=get_one_sensor_by_deployment('{sensor_name}') "
                    f"to ensure the same behaviour. The sensor_name= f"parameter "
                    f"will be removed in apd.aggregation 3.0."
                ),
                stacklevel=3,
            )
            if self.get_data is None:
                self.get_data = get_one_sensor_by_deployment(sensor_name)
        if self.get_data is None:
            raise ValueError("You must specify a get_data function")

Listing 11-10Updated Config data class that issues a deprecation warning for sensor_name

```

Note

这里的`stacklevel=`参数是 3，不是 2。我们希望当用户实例化一个`Config`对象时显示这个警告。`@dataclass`装饰器生成一个调用`__post_init__(...)`的`__init__(...)`函数。stacklevel 为 2 将显示弃用警告与生成的`__init__(...)`函数相关联，而不是与调用代码相关联。如果您不确定，请尝试引发一个异常并查看堆栈跟踪。

生成的警告显示了错误代码的位置(`analysis.py`，第 287 行)，给出了修复的确切说明，并包含了修复的截止日期。它还显示了有问题的行，在本例中是多行`Config(...)`构造函数调用的第一行。

```
...\src\apd\aggregation\analysis.py:287: DeprecationWarning: The sensor_name parameter is deprecated. Please pass get_data=get_one_sensor_by_deployment('Temperature') to ensure the same behaviour. The sensor_name= parameter will be removed in apd.aggregation 3.0.
    Config(

```

### 警告过滤器

可以定义新的警告类型来补充内置的警告类型，但是这不如子类化异常有用。创建新警告类型的主要原因是允许最终用户更好地利用警告过滤器。警告过滤器改变警告的默认行为，使它们更突出或不突出。

更改过滤器可用于更准确地控制显示给最终用户的警告集。如果您正在维护一个依赖于库的工具，该库会导致多个弃用警告，那么为最终用户抑制这些警告会提高他们对该工具的信心。 <sup>[12](#Fn12)</sup>

```
warnings.simplefilter("ignore", DeprecationWarning)

```

相反，您可以提高警告的严重性，使其成为异常，以帮助您准确地调试它们的原因。警告过滤器的动作`"error"`导致任何警告被视为异常。也就是说，会显示完整的回溯，一旦代码遇到第一个警告，执行就会停止。 <sup>[13](#Fn13)</sup> 结合使用事后调试器和此选项是调查警告原因的有效方法。

```
warnings.simplefilter("error", DeprecationWarning)

```

Tip

当以`python script.py`的身份直接运行 Python 代码时，可以用`-W`命令行选项设置默认的警告行为，如`python -Werror script.py`。设置`PYTHONWARNINGS`环境变量具有相同的效果，但是它适用于不通过解释器直接调用的基于 Python 的可执行文件，比如我们的 sensors 命令行工具。

如果下游组件没有定义自定义警告(大多数都没有)，您还可以按文件、行号、 <sup>[14](#Fn14)</sup> 消息或它们的任意组合来过滤警告。这种灵活性允许您隐藏您知道的特定警告，而不隐藏您可能不知道的任何其他警告。

```
import re, warnings

warnings.filterwarnings(
    "ignore",
    message=re.escape("The sensor_name parameter is deprecated"),
    category=DeprecationWarning,
    module=re.escape("apd.aggregation.analysis"),
    lineno=275
)

```

最后，您可以临时修改警告过滤器，并自动恢复旧的过滤器。如果单个函数引发了许多您想要抑制的不同警告，但在通过不同的代码路径触发时又不隐藏它们，这可能会很有用。

```
import warnings

with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    function_that_warns_a_lot()

```

如果您想断言代码中出现了警告，那么相同的上下文管理器在测试中非常有用。如果您希望确信在某些复杂的情况下会显示警告，这是很有用的，但通常没有必要。`catch_warnings(...)`函数接受一个可选的`record=True`参数，该参数允许访问上下文管理器主体中出现的所有警告的记录。您应该确保警告过滤器没有忽略任何警告，因为只记录向最终用户显示的警告。清单 [11-11](#PC27) 显示了一个利用该功能的示例测试。

```
def test_deprecation_warning_raised_by_config_with_no_getdata():
    with warnings.catch_warnings(record=True) as captured_warnings:
        warnings.simplefilter("always", DeprecationWarning)
        config = analysis.Config(
            sensor_name="Temperature",
            clean=analysis.clean_passthrough,
            title="Temperaure",
            ylabel="Deg C"
        )
        assert len(captured_warnings) == 1
        deprecation_warning = captured_warnings[0]
        assert deprecation_warning.filename == __file__
        assert deprecation_warning.category == DeprecationWarning
        assert str(deprecation_warning.message) == (
            "The sensor_name parameter is deprecated. Please pass "
            "get_data=get_one_sensor_by_deployment('Temperature') "
            "to ensure the same behaviour. The sensor_name= parameter "
            "will be removed in apd.aggregation 3.0."
        )

Listing 11-11A test to ensure a warning is raised

```

## 记录

所有类型的应用程序都广泛使用日志记录。它帮助最终用户调试问题，并允许更详细的错误报告，这反过来又节省了试图重现问题的时间。日志的使用方式与`print(...)`调试的方式非常相似，但是对于大型应用程序和库来说，它有一些显著的优势。

与`print(...)`调试相比，日志记录的最大优势是日志记录框架将每个日志条目与严重性相关联。用户可以选择一个日志级别来控制记录多少日志信息，因此他们可以选择仅在需要时生成调试日志(例如)。

Tip

如果您正在编写有助于调试的日志语句，请为最终用户提供一种获取日志的简单方式。Pipenv 用一个`--support`标志很好地做到了这一点，它以 markdown 格式打印所有相关数据，以便粘贴到 GitHub 问题中。考虑添加一个类似的选项，设置一个较低的日志级别，并将格式化的版本和配置数据与日志文件一起输出，作为界面设计的一部分。但是，不要在没有得到用户明确许可的情况下自动整理用户系统的日志，因为这可能会侵犯他们的隐私。

日志记录的默认级别是调试、信息、警告、错误和严重。 <sup>[15](#Fn15)</sup> 我们可以使用日志模块中的匹配函数来记录消息，比如`logging.warning(...)`，将警告级别的消息记录到*根日志记录器*。

```
>>> logging.warning("This is a warning")
WARNING:root:This is a warning

```

默认情况下，Python 会丢弃调试和信息日志消息，只有警告级别及以上的消息才会以格式`LEVEL:logger:message`记录到终端。记录器从丢弃消息变为显示消息的阈值就是该记录器的级别。用于显示的格式是首次使用 root logger 时设置的，可以通过使用新的格式化程序调用`logging.basicConfig(...)`函数进行调整。 <sup>[16](#Fn16)</sup> 这也允许您更改根日志记录器的过滤器阈值级别，例如在以下示例中将其设置为 debug:

```
logging.basicConfig(format="{asctime}: {levelname} - {message}", style="{", level=logging.DEBUG)

```

多年来，Python 已经有了许多字符串格式语法；要使用现代风格，请将`style="{"`作为另一个参数传递。您可能会看到旧程序中的日志配置使用不同的格式，但可用的键仍然是相同的。这些键列在标准库的文档中的`LogRecord`属性下，但是最有用的是

1.  `asctime`–格式化的日期/时间

2.  `levelname`–日志级别的名称

3.  `pathname`–引发日志消息的文件的路径

4.  `funcName`–产生日志消息的函数的名称

5.  `message`–记录的字符串

### 嵌套记录器

在程序中使用嵌套层次的记录器是很常见的。可以通过调用`logging.getLogger(name)`函数来检索记录器，其中 name 是要检索的记录器的名称。

当一个记录器被检索时，其名称将与由`.`字符分割的现有记录器进行比较。如果现有的日志记录器的名称是新日志记录器的前缀，那么它将成为父日志记录器。那就是:

```
>>> import logging
>>> root_logger = logging.getLogger()
>>> apd_logger = logging.getLogger("apd")
>>> apd_aggregation_logger = logging.getLogger("apd.aggregation")

>>> print(apd_aggregation_logger)
<Logger apd.aggregation (WARNING)>

>>> print(apd_aggregation_logger.parent)
<Logger apd (WARNING)>

>>> print(apd_logger.parent)
<RootLogger root (WARNING)>

```

Caution

如果`apd_aggregation_logger`是在`apd_logger`之前创建的，那么两者都将 root logger 作为它们的父级。确保这种行为正确的最简单方法是在所有模块中添加`logger = logging.getLogger(__name__)`行。这确保了你的日志结构和你的代码结构是一样的，更容易推理。如果您想确保所有的父记录器都设置正确，请确保将它包含在任何`__init__.py`中。

这些记录器均可用于记录消息，所使用的记录器显示为日志消息的一部分(如果记录器名称包含在格式化程序中)。记录器收到的任何消息也会传递给其父级。 <sup>[17](#Fn17)</sup> 正是这种行为允许我们通过配置根记录器来配置所有记录器的格式。

```
>>> apd_aggregation_logger.warning("a warning")
WARNING:apd.aggregation:a warning

>>> apd_logger.warning("a warning")
WARNING:apd:a warning

>>> root_logger.warning("a warning")
WARNING:root:a warning

```

单个记录器可以有一个新的级别集，该级别集会传播到它们的所有子级(除非它们有自己的级别集)。这允许通过设置命名记录器的级别来配置每个包的日志记录。

```
>>> apd_logger.setLevel(logging.DEBUG)

>>> apd_aggregation_logger.debug("debugging")
DEBUG:apd.aggregation:debugging

>>> apd_logger.debug("debugging")
DEBUG:apd:debugging

>>> root_logger.debug("debugging")
(no output)

```

### 自定义操作

到目前为止，我们一直将 loggers 视为一种美化的打印声明，但是它们比这灵活得多。当我们记录一个字符串时，日志框架在内部创建一个`LogRecord`对象，然后将它传递给一个处理程序，该处理程序对它进行格式化并输出到标准错误流上。

记录器也可以有自定义的处理程序，以其他方式记录信息。最常用的处理程序是`StreamHandler`，它格式化日志消息(可能使用自定义格式化程序)并在终端中显示。我们可以用它来定义在`apd.aggregation`包中使用自定义日志格式进行日志记录，但是默认格式用于所有其他日志记录，例如。

#### 额外元数据

我们可以使用日志方法的额外字典向格式化程序添加特定于应用程序的方面。这样做的缺点是，*所有遵循该格式的*日志消息都必须为额外的关键字提供一个值，如果它们是日志格式的一部分。如果您在根日志记录器上设置了一个定制格式，需要一个特定的额外数据，这将导致所有不受您直接控制的日志调用引发一个`KeyError`。这是只将自定义格式化程序应用于您自己的记录器而不是根记录器的一个很好的理由。

为了做到这一点，我们需要用一个新的格式化程序定制一个单独的记录器。我们不能使用`logging.basicConfig(...)`函数，因为它只能操纵根日志记录器；我们需要提供一个新的函数，按照我们希望的那样设置处理程序。清单 [11-12](#PC33) 有一个这个函数的例子。

```
import logging

def set_logger_format(logger, format_str):
    """Set up a new stderr handler for the given logger
    and configure the formatter with the provided string
    """
    logger.propagate = False
    formatter = logging.Formatter(format_str, None, "{")

    std_err_handler = logging.StreamHandler(None)
    std_err_handler.setFormatter(formatter)

    logger.handlers.clear()
    logger.addHandler(std_err_handler)
    return logger

logger = set_logger_format(
    logging.getLogger(__name__),
    format_str="{asctime}: {levelname} - {message}",
)

Listing 11-12Helper function to configure a logger with a specific formatter

```

我们在`set_logger_format(...)`调用中添加的任何附加字段也必须在每个日志记录调用中提供，作为一个`extra=`字典，如下所示:

```
>>> logger = set_logger_format(
...     logging.getLogger(__name__),
...     format_str="[{sensorname}/{levelname}] - {message}",
... )
>>> logger.warn("hi", extra={"sensorname": "Temperature"})
[Temperature/WARNING] – hi

```

我们可以通过在格式化日志记录之前对其进行操作来解决这一限制。有几种不同的方法可以将变量注入日志记录:定制工厂、添加适配器或添加过滤器。当从我们自己的代码进行日志记录时，自动注入数据还允许更方便的接口，因为我们不再需要显式地传递格式化程序可能希望作为关键字参数的所有数据。

##### 测井适配器

日志适配器是一段代码，它包装了一个日志记录器，允许定制它的任何行为。它提供了一个流程函数，可用于将消息和参数转换为底层日志功能，并可如清单 [11-13](#PC35) 所示进行创建。

```
import copy
import logging

class ExtraDefaultAdapter(logging.LoggerAdapter):
    def process(self, msg, kwargs):
        extra = copy.copy(self.extra)
        extra.update(kwargs.pop("extra", {}))
        kwargs["extra"] = extra
        return msg, kwargs

def set_logger_format(logger, format_str):
    """Set up a new stderr handler for the given logger
    and configure the formatter with the provided string
    """
    logger.propagate = False
    formatter = logging.Formatter(format_str, None, "{")

    std_err_handler = logging.StreamHandler(None)
    std_err_handler.setFormatter(formatter)

    logger.handlers.clear()
    logger.addHandler(std_err_handler)
    return logger

Listing 11-13A log adapter that provides defaults for some additional keywords

```

使用这个适配器允许我们省略额外的字典，除非我们有希望添加到这个日志消息中的数据，允许我们在不相关的时候省略它。这也使得向格式字符串添加新项变得更加容易，因为我们不需要改变每个日志记录函数调用来匹配。

```
>>> logger = set_logger_format(
...     logging.getLogger(__name__),
...     format_str=" [{sensorname}/{levelname}] - {message}",
... )
>>> logger = ExtraDefaultAdapter(logger, {"sensorname": "none"})
>>> logger.warn("hi")
[none/WARNING] - hi
>>> logger.warn("hi", extra={"sensorname": "Temperature"})
[Temperature/WARNING] - hi

```

这种方法的缺点是我们需要用适配器包装每个日志记录器。它非常适合在单个模块中自动填充额外的数据，但是它不能帮助我们提供跨多个记录器的缺省值，因为不能保证使用记录器的所有代码也将使用适配器(事实上，对于根记录器，几乎可以保证会有使用日志记录的代码不知道我们的定制适配器)。

我们可以向适配器本身添加任何我们想要的逻辑。例如，我们可以从上下文变量中提取这个值，而不是为`sensorname`提供一个显式的默认值。适配器最适合于只有一个记录器需要定制元数据的情况。如果您已经为一个只有您登录的记录器定义了一个自定义格式化程序，那么很有可能确保所有的日志调用都通过适配器。

##### 日志记录工厂

另一种方法是定制内部日志记录对象本身的创建。定制工厂允许任意数据存储在所有的`LogRecords`上，而记录日志的代码不会意识到任何差异。这允许自定义元数据以第三方代码使用的记录器格式使用，例如根记录器。使这种格式对所有日志记录器通用意味着没有不同日志格式的混合，这对于用户来说可能是一个显著的优势。缺点是这里设置的属性不能在额外的字典中传递。 <sup>[18](#Fn18)</sup>

在前面的例子中，我们可以灵活地将额外的数据传递给日志记录系统。当覆盖`LogRecord`工厂时，我们别无选择，只能使用一个上下文变量来传递额外的数据。这限制了该方法的使用方式，因为我们不能简单地将我们想要的值作为参数传递。

清单 [11-14](#PC37) 显示了定制记录工厂的示例代码，以便在所有记录中包含来自 sensorname_var 上下文变量的值。

```
from contextvars import ContextVar
import functools
import logging

sensorname_var = ContextVar("sensorname", default="none")

def add_sensorname_record_factory(existing_factory, *args, **kwargs):
    record = existing_factory(*args, **kwargs)
    record.sensorname = sensorname_var.get()
    return record

def add_record_factory_wrapper(fn):
    old_factory = logging.getLogRecordFactory()
    wrapped = functools.partial(fn, old_factory)
    logging.setLogRecordFactory(wrapped)

add_record_factory_wrapper(add_sensorname_record_factory)
logging.basicConfig(
    format="[{sensorname}/{levelname}] - {message}", style="{", level=logging.INFO
)

Listing 11-14Customizing a LogRecord factory to add contextual information and include in all logs

```

这种方法与以前的方法有很大不同，因为它在全局级别上更改日志记录配置。适配器示例涉及到对每个模块的更改，以将记录器包装在适当的适配器中，并且每个模块都可以有自己的适配记录器。一次只能有一个唱片工厂处于活动状态。虽然我们可以多次覆盖它以提供额外的数据，但是所有的覆盖都必须以这样一种方式编写，以便不会相互冲突。这种方法可以如下使用:

```
>>> logger = logging.getLogger(__name__)
>>> logger.warning("hi")
[none/WARNING] – hi
>>> token = sensorname_var.set("Temperature")
>>> logging.warning("hi")
[Temperature/WARNING] - hi
>>> sensorname_var.reset(token)

```

##### 日志过滤器

在我看来，日志过滤器在这两种方法之间提供了一个很好的中间地带。名称过滤器可能使这种方法有点违反直觉，因为过滤器旨在用于动态地丢弃日志记录，但这也是改变日志记录的最灵活的方法。

您可以将日志过滤器与记录器相关联，这将导致记录器处理的每个日志消息都调用它，但是您也可以根据处理程序注册它。控制格式的是处理程序，因此将筛选器与处理程序相关联可以确保自定义格式和默认值筛选器紧密关联。无论何时使用该处理程序，您都知道过滤器也是活动的。

这种方法意味着默认传感器名称仅作为格式化过程的一部分来填充。附加信息仍然可以作为额外字典的一部分传递，这是正常的，当显式传递时，所有日志处理程序都可以使用它。清单 [11-15](#PC39) 显示了一个更新的设置函数，它可以选择关联一个过滤器和处理器。

```
import logging

class AddSensorNameDefault(logging.Filter):
    def filter(self, record):
        if not hasattr(record, "sensorname"):
            record.sensorname = "none"
        return True

def set_logger_format(logger, format_str, filters=None):
    """Set up a new stderr handler for the given logger
    and configure the formatter with the provided string
    """
    logger.propagate = False
    formatter = logging.Formatter(format_str, None, "{")

    std_err_handler = logging.StreamHandler(None)
    std_err_handler.setFormatter(formatter)

    logger.handlers.clear()
    logger.addHandler(std_err_handler)
    if filters is not None:
        for filter in filters:
            std_err_handler.addFilter(filter)
    return logger

Listing 11-15Using a handler filter to add a default sensorname

```

设置这个记录器与适配器模式非常相似，但是有一个重要的区别。`set_logger_format(...)`呼叫只需要进行一次。对`logging.getLogger(...)`的任何后续调用都会返回一个正确配置的记录器，而不需要记录器的每个用户都配置过滤器。初始使用如下进行:

```
logger = set_logger_format(
    logging.getLogger(),
    "[{sensorname}/{levelname}] - {message}",
    filters=[AddSensorNameDefault(), ]
)
>>> logger.warning("hi")
[none/WARNING] - hi
>>> logger.warning("hi", extra={"sensorname": "Temperature"})
[Temperature/WARNING] - hi

```

### 日志记录配置

上述代码的缺点是，为了更改格式化程序或添加过滤器，我们必须为日志系统做大量的设置工作。对于除了简单的自包含工具之外的所有应用程序，最终用户可能希望配置他们自己的处理程序或日志格式化程序。对于大型应用程序中使用的库来说尤其如此。

因此，在现实应用程序中很少使用 Python 代码配置日志记录。通常，日志配置是通过某种配置系统提供的，比如配置迁移系统的`alembic.ini`文件的`[logging]`配置部分。`logging.config.fileConfig(...)`助手函数可用于从文件中加载日志配置，少量粘合代码(清单 [11-16](#PC41) )可用于使我们添加的任何过滤器可供最终用户在 ini 风格的日志配置中利用(清单 [11-17](#PC42) )。

```
[loggers]
keys=root

[handlers]
keys=stderr_with_sensorname

[formatters]
keys=sensorname

[logger_root]
level=INFO
handlers=stderr_with_sensorname

[handler_stderr_with_sensorname]
class=apd.aggregation.utils.SensorNameStreamHandler
formatter = sensorname

[formatter_sensorname]
format = {asctime}: [{sensorname}/{levelname}] - {message}
style = {

Listing 11-17A sample logging configuration file that uses a filter to provide default values for the formatter

```

```
import logging

class AddSensorNameDefault(logging.Filter):
    def filter(self, record):
        if not hasattr(record, "sensorname"):
            record.sensorname = "none"
        return True

class SensorNameStreamHandler(logging.StreamHandler):
    def __init__(self, *args, **kwargs):
        super().__init__()
        self.addFilter(AddSensorNameDefault())

Listing 11-16Glue code to provide a handler that has a filter added by default

```

Caution

日志配置文件格式允许嵌入一些逻辑，以简化复杂配置的设置。这使得从配置文件中运行任意代码成为可能。这很少成为问题，但是如果您有由系统管理员运行的工具，那么应该只有管理员能够编辑日志配置。

### 其他处理者

除了我们目前使用的`StreamHandler`之外，还有其他有用的处理程序。最常见的是`FileHandler`，它将日志信息输出到一个命名文件中。将此设置为根日志记录器上的处理程序用于构建持久日志文件。

更复杂的处理程序，如`TimedRotatingFileHandler`、`SysLogHandler`和`HTTPHandler`，不太常用，但非常强大。这些允许将日志集成到任何方式的现有日志管理解决方案中。甚至有商业日志管理系统也以同样的方式集成，比如 Sentry 及其定制的`EventHandler`类。

#### 审计日志

拥有定制的记录器和处理程序允许编写在复杂系统中记录用户操作的审计日志记录系统。审核日志是一种日志，旨在提供有关用户已执行的某些重要操作的信息。它不是用于调试，而是用于验证系统没有被滥用。

为了实现这一点，您通常会获得一个带有`logging.getLogger("audit")`名称的新日志记录器，并将其配置为审计日志记录器。与大多数日志记录器不同，大多数审计日志的命名并不与 Python 模块相匹配。通常，审计记录器使用特殊的日志处理程序，例如将审计日志事件附加到系统日志或通过电子邮件发送的处理程序。我建议将审计日志条目输出到与其他日志条目相同的输出流位置。将审计日志条目与调试信息混合在一起可以增加高级上下文，这在调试问题时非常有用。

日志处理程序可以与多个记录器相关联，因此可以通过为每个文件定义一个处理程序并将其与应该输入到该文件中的每个单独的记录器相关联，来配置自定义日志文件以包含多个记录器的输出。您还可以使用记录器的嵌套结构为应用程序的逻辑组件创建日志文件。

日志处理程序是用提供`emit(record)`函数的 Python 类实现的，因此可以编写定制的处理程序来执行任何适当的特定于应用程序的审计日志记录操作。实际上，大多数常见需求都有可用的处理程序实现。

## 围绕问题进行设计

前面的策略允许我们交流在程序组件中遇到的问题(使用异常)和最终用户(使用警告和日志)。它们让我们更容易理解用户遇到了什么问题(当他们被报告时)。然而，大多数问题都没有被报告，我们永远不可能提前想到每一个可能的边缘情况。

编写可靠软件的一个关键部分是设计能够自动补偿正常运行中遇到的问题的过程。对我们来说，与传感器通信的任何问题都会导致我们正在收集的传感器历史数据出现缺口。

这种失败有两种可能的原因。传感器服务器工作正常，但聚合进程(或网络)出现故障；或者聚合进程(或网络)工作正常，但传感器出现故障。

### 调度传感器查找

聚合器或网络故障的问题是最容易解决的。我们可以修改传感器来定期收集和存储数据，而不是通过聚合过程从传感器获取实时数据。然后，它可以通过 API 提供这些收集的数据。这允许聚合过程检测何时收集了数据但未下载，并通过下载自上次成功同步以来的所有数据来纠正问题。

要实现这一点，需要对聚合过程和传感器本身进行重大更改。所涉及的服务器不仅需要在特定时间触发传感器数据收集，还需要能够存储数据并通过 API 公开存储的数据集。

我们需要像创建聚合流程一样创建一个数据库集成。我们还需要一个新的命令行选项来存储数据，并为 alembic 和 sqlalchemy 添加一组依赖项，以确保我们可以将数据存储到数据库中。这些需要是可选的依赖项:并不是所有的`apd.sensors`包的用户都必须使用聚合器，如果用户只需要命令行工具来检查当前状态，那么要求他们安装完整的数据库系统就太过分了。一旦添加了这个新特性，`setup.cfg`的可选依赖部分将如下所示。

Note

有些要求只有在我们同时安装了 webapp 和 scheduled extras 的情况下才是相关的，因为我们稍后将使用它们来实现数据库查找。我们可以为这些内容创建另一个额外的内容，但这确实会让用户更难理解。您可能更喜欢将这些依赖项添加到其他额外的定义中。当我们使用第三个额外的时候，我们必须记住，在编写代码的时候，并不是所有的依赖项都是可用的。没有任何东西可以阻止用户为这些额外的依赖项安装额外的组件，而没有这两个组件。

```
[options.extras_require]
webapp = flask
scheduled =
  sqlalchemy
  alembic
storedapi =
  flask-sqlalchemy
  python-dateutil

```

然后，我们需要使用`pipenv install`确保我们的本地开发环境被标记为需要这组新的可选依赖项。就像聚合过程一样，我们需要创建一个数据库表定义(清单 [11-18](#PC44) ，将元数据对象连接到 alembic 配置，并生成一个初始的 alembic 迁移。

```
from __future__ import annotations

import datetime
import typing as t

import sqlalchemy
from sqlalchemy.schema import Table
from sqlalchemy.orm.session import Session

from apd.sensors.base import Sensor

metadata = sqlalchemy.MetaData()

sensor_values = Table(
    "recorded_values",
    metadata,
    sqlalchemy.Column("id", sqlalchemy.Integer, primary_key=True),
    sqlalchemy.Column("sensor_name", sqlalchemy.String, index=True),
    sqlalchemy.Column("collected_at", sqlalchemy.TIMESTAMP, index=True),
    sqlalchemy.Column("data", sqlalchemy.JSON),
)

def store_sensor_data(sensor: Sensor[t.Any], data: t.Any, db_session: Session) -> None:
    now = datetime.datetime.now()
    record = sensor_values.insert().values(
        sensor_name=sensor.name, data=sensor.to_json_compatible(data), collected_at=now
    )
    db_session.execute(record)

Listing 11-18Database table for caching sensor values locally

```

清单 [11-19](#PC45) 中的变化是添加了一个命令行选项，用于指定应该连接到哪个数据库，以及一个标志，用于标记应该将数据保存到本地数据库，而不仅仅是输出给用户的信息。有了这个，我们的用户可以设置一个调度任务来调用我们的脚本，并根据调度保存数据。

```
@click.command(help="Displays the values of the sensors")
@click.option(
    "--develop", required=False, metavar="path", help="Load a sensor by Python path"
)
@click.option("--verbose", is_flag=True, help="Show additional info")
@click.option("--save", is_flag=True, help="Store collected data to a database")
@click.option(
    "--db",
    metavar="<CONNECTION_STRING>",
    default="sqlite:///sensor_data.sqlite",
    help="The connection string to a database",
    envvar="APD_SENSORS_DB_URI",
)
def show_sensors(develop: str, verbose: bool, save: bool, db: str) -> None:
    sensors: t.Iterable[Sensor[t.Any]]
    if develop:
        try:
            sensors = [get_sensor_by_path(develop)]
        except UserFacingCLIError as error:
            if verbose:
                tb = traceback.format_exception(type(error), error, error.__traceback__)
                click.echo("".join(tb))
            click.secho(error.message, fg="red", bold=True)
            sys.exit(error.return_code)
    else:
        sensors = get_sensors()

    db_session = None
    if save:
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker

        engine = create_engine(db)
        sm = sessionmaker(engine)
        db_session = sm()

    for sensor in sensors:
        click.secho(sensor.title, bold=True)
        try:
            value = sensor.value()
        except DataCollectionError as error:
            if verbose:
                tb = traceback.format_exception(type(error), error, error.__traceback__)
                click.echo("".join(tb))
                continue
            click.echo(error)
        else:
            click.echo(sensor.format(value))
            if save and db_session is not None:
                store_sensor_data(sensor, value, db_session)
                db_session.commit()

        click.echo("")
    sys.exit(ReturnCodes.OK)

Listing 11-19Updated command-line script to add saving of data

```

这足以确保在出现网络或聚合故障时不会丢失数据；然而，一旦错误条件结束，集成丢失的数据是不够的。

#### API 和过滤

我们需要更新我们的 API，以便提取过去记录的任何数据。同时，我们可以更新 API，将失败的传感器分离到一个独立的错误列表中，补充我们在本章前面添加的异常处理。

复杂的 API 通常为用户提供指定他们需要哪些数据的能力，通过只计算最终用户需要的信息，允许 API 实现更高效。更常见的是，API 提供某种形式的过滤选项来减少传递的数据量。

我们需要一个新的 API 端点来公开已经收集的数据，以便聚合过程可以将其与数据库同步。这个端点的实现如清单 [11-20](#PC46) 所示。

```
@version.route("/historical")
@version.route("/historical/<start>")
@version.route("/historical/<start>/<end>")
@require_api_key
def historical_values(
    start: str = None, end: str = None
) -> t.Tuple[t.Dict[str, t.Any], int, t.Dict[str, str]]:
    try:
        import dateutil.parser
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
        from apd.sensors.database import sensor_values
        from apd.sensors.wsgi import db
    except ImportError:
        return {"error": "Historical data support is not installed"}, 501, {}

    db_session = db.session
    headers = {"Content-Security-Policy": "default-src 'none'"}

    query = db_session.query(sensor_values)
    if start:
        query = query.filter(
            sensor_values.c.collected_at >= dateutil.parser.parse(start)
        )
    if end:
        query = query.filter(
            sensor_values.c.collected_at <= dateutil.parser.parse(end)
        )

    known_sensors = {sensor.name: sensor for sensor in cli.get_sensors()}
    sensors = []
    for data in query:
        if data.sensor_name not in known_sensors:
            continue
        sensor = known_sensors[data.sensor_name]
        sensor_data = {
            "id": sensor.name,
            "title": sensor.title,
            "value": data.data,
            "human_readable": sensor.format(sensor.from_json_compatible(data.data)),
            "collected_at": data.collected_at.isoformat(),
        }
        sensors.append(sensor_data)
    data = {"sensors": sensors}
    return data, 200, headers

Listing 11-20New historical values endpoint for the v3.0 API

```

将此信息导入聚合过程的处理程序与普通传感器收集非常相似，因为数据采用相同的格式。可以通过添加一个新的命令行工具来同步一个时间范围内的任何丢失数据，或者通过检测自上次成功数据收集以来的长时间，并使用`/historical`端点而不是正常端点来实现该过程。

EXERCISE 11-1: Supporting Historical Data Collection

在运行传感器的服务器出现故障的情况下，这一更改不会直接帮助我们。对于我们现有的传感器类型，这是不可能恢复的，但这是我们特定传感器的属性，而不是不可改变的事实。其他传感器可能能够找到某个时间点的值。例如，报告服务器状态的传感器可以从现有的系统日志中提取过去的状态。

考虑需要对代码库进行哪些更改，以支持可以报告它们在过去某个时间点的值的传感器。考虑如何修改现有的类来提供这种额外的功能，使其向后兼容现有的传感器。

和往常一样，本章附带的代码中有一个如何实现这一点的例子。然而，这不会被合并到代码的主分支中，因为它离整理我们当前存储的数据的要求太远了。

## 摘要

当编写您希望其他开发人员使用的库时，包括自定义异常并在相关时发出警告；这是一种比`README.txt`文件更有效的与观众交流的方式。特别是，计划任何不推荐使用的功能，并确保在使用旧功能时显示警告。

自定义异常类型允许下游开发人员为特定的错误条件编写处理程序，就像您使用的库中的自定义异常允许您捕捉依赖项中的错误一样。

即使您没有编写一个供其他人使用的库，日志框架也允许您的用户配置他们想要存储的调试信息以及他们想要如何处理它。如果你不提供日志记录语句或者只使用`print(...)`来记录，它们更有可能被丢弃，而不是作为错误报告返回给你。

虽然这些功能有助于调试和编写代码来处理故障，但编写对错误情况具有鲁棒性的代码的最重要方面是将故障转移设计到流程本身中。

无论您决定使用哪种策略组合，都要确保测试您的代码行为正确。自动化测试能够并且应该验证当事情出错时，而不仅仅是当事情按预期运行时，您的代码以可接受的方式运行。

### 额外资源

以下链接提供了本章所涵盖主题的额外背景信息:

*   如前所述，Python 标准库的`itertools`模块是使用最少的模块之一。值得一读 [`https://docs.python.org/3.8/library/itertools.html`](https://docs.python.org/3.8/library/itertools.html) 的文档，了解它提供的各种工具。

*   同样在标准文档中， [`https://docs.python.org/3.8/library/collections.abc.html`](https://docs.python.org/3.8/library/collections.abc.html) 是实现各种类型的 Python 数据容器所需的方法的有用参考。

*   我对 flask 和 SQLAlchemy 使用的集成记录在 [`https://flask-sqlalchemy.palletsprojects.com/en/2.x/`](https://flask-sqlalchemy.palletsprojects.com/en/2.x/) 。

*   日志配置的 ini 文件格式详见 [`https://docs.python.org/3.8/library/logging.config.html#logging-config-fileformat`](https://docs.python.org/3.8/library/logging.config.html%2523logging-config-fileformat) 。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

这三个类对应于要使对象成为集合必须存在的三个方法。

  [2](#Fn2_source)

映射通过它们的`variable.get(key, default)`方法提供了一些这样的功能，但是这仍然会引发一个`TypeError,`,而且序列没有内置的等价功能。

  [3](#Fn3_source)

不属于这个类别的内置异常有`GeneratorExit`、`KeyboardInterrupt`和`SystemExit`。

  [4](#Fn4_source)

`SystemExit`也用于提前结束程序，即使没有实际问题。不过，通常用`sys.exit(0)`来做这件事，而不是引发`SystemExit`异常。

  [5](#Fn5_source)

通常，不幸的是，代码就是文档。

  [6](#Fn6_source)

直接继承`Exception`在这里也能很好地工作。我们保留`APDSensorsError`主要是出于美观的原因，因为这个代码不太可能被想要消除任何和所有 APD 传感器错误的消费者调用，但它确实使之成为可能。`SystemExit`的意思非常匹配，所以也包括在内，但是我想存储`SystemExit`没有提供的额外元数据。

  [7](#Fn7_source)

匹配参数可以是正则表达式字符串或编译的正则表达式模式。要匹配一个表示不同正则表达式的字符串，使用`re.escape(string_literal)`。

  [8](#Fn8_source)

在 Python 1.x 中，异常不是将消息作为参数的对象。他们被提升为`raise ValueError, “Value is out of range”`(比如)。追溯必须从`sys.exc_traceback`全局变量中提取。要格式化一个异常，您需要它的类型、字符串表示和回溯。Python 2 中合并了类型和字符串表示，但直到 Python 3，异常对象才开始拥有自己的回溯信息。

  [9](#Fn9_source)

我们之前看了`itertools.groupby(...)`，但是整个 itertools 模块是值得学习的。这是标准库中我最喜欢的模块之一，因为它为许多涉及生成器的常见任务提供了帮助函数。

  [10](#Fn10_source)

然而，由于它们是`BaseException`类型层次结构的一部分，从技术上讲，用 raise 关键字发出警告是可能的，但这只是为了支持警告框架的一些内部实现细节。警告应该*永远不要*直接提出；没有意义，很混乱。

  [11](#Fn11_source)

如果调用任务被取消，防止 asyncio 任务被取消的功能。在这种情况下，它用于允许在请求之间共享 DNS 查找，因为即使首先触发它的请求被取消，也需要进行查找。

  [12](#Fn12_source)

只是不要忘记在反对警告过期之前修复任何问题，因为如果工具停止工作，将对用户的信心产生更大的影响。

  [13](#Fn13_source)

这就是警告是一种异常的原因，因此它们可以由该筛选器操作引发。

  [14](#Fn14_source)

请注意，如果发布了新版本的库，文件名和行号可能会改变。

  [15](#Fn15_source)

可以使用`logging.addLevelName(level, levelName)`创建新的级别，其中 level 是一个整数，它与`logging.DEBUG`、`logging.INFO`和其他整数常量进行比较以进行排序。要登录到这个级别，你必须使用`logging.log(level, message)`而不是`logging.info(message)`风格的便利功能。

  [16](#Fn16_source)

最好在生成任何日志消息之前完成此操作。如果已经有一个日志配置，那么这个函数将不会做任何事情，除非已经传递了`force=True`参数。在 Python 3.8 之前，`force=`参数是不可用的。

  [17](#Fn17_source)

除非记录器设置了`logger.propagate=False`属性，在这种情况下，它们不会被设置。如果您曾经看到重复的日志条目，很可能您已经配置了一个带有自定义输出的日志记录器(如本节后面所演示的)，但是却忽略了为该日志记录器禁用日志传播。

  [18](#Fn18_source)

合并额外字典的代码显式地检查冲突，如果发现，就引发一个`KeyError`。

 </aside>