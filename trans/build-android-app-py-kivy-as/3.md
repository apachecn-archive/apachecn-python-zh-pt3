# 3.将安卓相机共享给一个 HTTP 服务器

在前两章中，我们为开发桌面应用程序准备了 Kivy 环境。在确保一切按预期运行之后，我们安装了 Buildozer 来构建 Android 应用程序。我们在书中创建的第一个应用程序非常简单；一个标签小部件显示了一些文本。之后，使用布局将更多的小部件添加到应用程序中。使用`on_press`处理按钮按压动作。创建了一个嵌套的小部件树，这使得调试变得更加复杂。出于这个原因，KV 语言被引入来构建小部件树，并将 GUI 与 Python 逻辑分离开来。

本章讨论如何访问和使用 Android 摄像头来捕捉图像并与 HTTP 服务器共享图像。`Camera`小部件用于访问 Android 摄像头。在确保桌面上的一切都正常工作后，我们使用 Buildozer 来构建 Android 应用程序。适当的权限在`buildozer.init`文件中指定。默认情况下，Android 摄像头旋转 90 度，Kivy 画布用于处理这个问题。将讨论三个画布实例— `canvas`、`canvas.before`和`canvas.after`。为了将一条给定指令的效果限制在某些小部件上，我们讨论了`PushMatrix`和`PopMatrix`指令。

在适当的角度预览相机后，将捕获图像，以便将它们上传到 HTTP 服务器。服务器是使用 Flask 创建的，并在台式计算机上运行。使用服务器的 IPv4 地址和端口号，对 Python 库的请求将使用 Kivy Android 应用程序和 HTTP `POST`消息上传捕获的图像。

本章最后在服务器的网络浏览器中创建一个 Android 摄像头的实时预览。为了节省时间，图像以字节数组的形式保存在设备存储器中，而不是保存在设备存储器中。这样的字节数组然后被上传到服务器。然后，服务器解释这些字节数组，以便在 web 浏览器的 HTML 页面上显示图像。

## 绝望的相机小部件

Python 中有不同的库可以访问相机，比如 OpenCV 和 PyGame。Kivy 还支持一个名为`Camera`的小部件来访问相机。它更简单，因为它不要求使用库。使用小部件的 APK 文件比打包库的 APK 文件小。

清单 [3-1](#PC1) 显示了在`BoxLayout`根小部件中有一个`Camera`小部件的 KV 文件。使用`resolution`属性指定首选分辨率。如果可能，以 1280x720 的分辨率捕捉图像。请注意`Camera`小部件大小和分辨率之间的差异。小部件大小设置应用程序 GUI 上小部件的大小，而分辨率定义捕获图像的像素密度。

`play`属性指定是否在应用程序启动后播放摄像机。如果设置为`True`，相机将在应用程序启动后播放。这个简单的 KV 文件是访问摄像机所需的最少代码。

```py
BoxLayout:
    Camera:
        resolution: 1280,720
        play: True

Listing 3-1Adding the Camera Widget to the Widget Tree

```

与这个 KV 文件相关的 Python 代码也非常简单，如清单 [3-2](#PC2) 所示。只需创建一个扩展了`kivy.app.App`类的类，并覆盖它的`build()`函数。因为这个函数是空的，所以将 Python 代码链接到 KV 文件的唯一方法是将其命名为`test.kv`。

```py
import kivy.app

class TestApp(kivy.app.App):

    def build(self):
        pass

app = TestApp()
app.run()

Listing 3-2Python File Associated with the KV File in Listing 3-1

```

应用程序窗口如图 [3-1](#Fig1) 所示。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig1_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig1_HTML.jpg)

图 3-1

使用相机小部件访问相机

## 访问 Android 摄像头

至此，我们已经创建了一个访问摄像机的桌面应用程序。让我们开始构建 Android 应用程序。

如第 [1](1.html) 章所述，应用程序的 Python 文件必须命名为`main.py`。为了获得访问 Android 摄像头的权限，`android.permissions`字段必须指定如下权限:

```py
android.permissions=Camera

```

之后，可以根据下面的命令使用 Buildozer 构建 Android 应用程序。请记住，该命令在调试模式下构建 APK 文件，将其部署到 USB 连接的 Android 设备，并在安装后运行应用程序。

```py
ahmed-gad@ubuntu:-$buildozer android debug deploy run

```

图 [3-2](#Fig2) 显示了使用 Android 应用程序捕获的图像之一。逆时针旋转 90 度。要解决这个问题，小部件必须顺时针旋转 90 度。因为顺时针旋转使用负角度，所以需要旋转-90 度。Kivy 支持将变换应用于其小部件的画布。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig2_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig2_HTML.jpg)

图 3-2

使用通过相机小部件访问的 Android 相机捕捉图像

## 不鼓励的画布

我们绘制的区域通常被称为*画布*。在 Kivy 中，画布是定义小部件图形表示的指令容器，而不是绘图区域。Kivy 中有三个画布实例— `canvas`、`canvas.before`和`canvas.after`。因此，可以为每个小部件分配这三个不同的实例。

在这三个实例中，画布可以执行两种类型的指令— `context`和`vertex`。顶点指令画在部件上。例如，如果要在一个小部件上绘制一个矩形或一条直线，它就是一个顶点指令。上下文指令不画任何东西，只是改变事物在屏幕上的显示方式。例如，上下文指令可以通过改变小部件的旋转、平移和缩放来变换小部件。

在添加 canvas 指令之前，必须将一个`canvas`实例附加到感兴趣的小部件。之后，我们可以添加说明。例如，清单 [3-3](#PC5) 中的代码将`canvas`实例附加到一个`Label`小部件，并使用`Rectangle`顶点指令绘制一个矩形。

```py
BoxLayout:
    Label:
        canvas:
            Rectangle:
                pos: 0,0
                size: 200, 200

Listing 3-3Adding Canvas to the Label Widget to Draw a Rectangle

```

矩形放置在像素(0，0)处，该像素是左下角对应的 Kivy 坐标系的原点(除了`RelativeLayout`和`ScatterLayout`)。矩形的宽度和高度设置为 200 像素。因此，矩形从左下角开始，在水平和垂直方向延伸 200 个像素。图 [3-3](#Fig3) 为矩形。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig3_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig3_HTML.jpg)

图 3-3

在标签小部件上绘制一个矩形

我们可以使用`Color`上下文指令改变矩形的颜色。该指令使用`rgb`属性接受 RGB 颜色，其中每个通道被赋予一个介于 0 和 1 之间的值。在清单 [3-4](#PC6) 中，红色是指定的颜色。

理解上下文指令应用于窗口小部件和它们下面的顶点指令是非常重要的。如果在上下文指令之前添加了小部件或顶点指令，则不会应用上下文指令。在本例中，如果在`Rectangle`顶点指令之后添加了`Color`顶点指令，矩形将被涂成红色。

```py
BoxLayout:
    Label:
        canvas:
            Color:
                rgb: 1, 0, 0
            Rectangle:
                pos: root.pos
                size: 200,200

Listing 3-4Using the Color Context Instruction to Change the Rectangle Color

```

使用清单 [3-4](#PC6) 中的 KV 文件运行应用程序后，结果如图 [3-4](#Fig4) 所示。矩形根据`Color`指令着色。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig4_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig4_HTML.jpg)

图 3-4

在标签小部件上绘制一个红色矩形

我们可以根据清单 [3-5](#PC7) 为第二个标签小部件重复前面的指令。应用的颜色是绿色而不是红色，矩形位于窗口的中心。

```py
BoxLayout:
    Label:
        canvas:
            Color:
                rgb: 1, 0, 0
            Rectangle:
                pos: root.pos
                size: 200,200
    Label:
        canvas:
            Color:
                rgb: 0, 1, 0
            Rectangle:
                pos: root.width/2-100, root.height/2-100
                size: 200,200

Listing 3-5Two Label Widgets Assigned to Two Canvas Instances to Draw Two Rectangles

```

应用程序窗口如图 [3-5](#Fig5) 所示。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig5_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig5_HTML.jpg)

图 3-5

使用两条矩形指令绘制两个矩形

使用完顶点指令后，我们可以开始使用第二类指令，也就是*上下文*。非常重要的是要注意，在确定应该在哪里应用指令之前，必须应用上下文指令。假设我们旋转一个使用`Rectangle` vertex 指令创建的矩形。在这种情况下，必须在`Rectangle`指令之前添加旋转矩形的上下文指令。如果上下文指令添加在`Rectangle`指令之后，矩形将不会改变。这是因为上下文指令仅在渲染绘图之前有效。渲染绘图后，上下文指令不起作用。

旋转小部件的上下文指令称为`Rotate`。根据清单 [3-6](#PC8) ，这个上下文指令加在`Rectangle`顶点指令之前旋转矩形。使用`Rotate`指令的`angle`属性，旋转到-45，顺时针旋转。旋转轴(或多个轴)可以使用`axis`属性定义。值 **0，0，1** 表示绕 Z 轴旋转。

默认情况下，旋转相对于坐标系的原点(0，0)。在这个例子中，我们对围绕(0，0)点旋转不感兴趣，而是围绕窗口中心点旋转。使用`origin`属性，我们可以改变旋转原点到窗口的中心。

```py
BoxLayout:
    Label:
        canvas:
            Color:
                rgb: 1, 0, 0
            Rectangle:
                pos: root.pos
                size: 200,200
    Label:
        canvas:
            Color:
                rgb: 0, 1, 0
            Rotate:
                angle: -45
                axis: 0,0,1
                origin: root.width/2, root.height/2
            Rectangle:
                pos: root.width/2, root.height/2
                size: 200,200

Listing 3-6Using the Rotation Context Instruction to Rotate the Rectangle

```

图 [3-6](#Fig6) 显示了旋转矩形后的结果。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig6_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig6_HTML.jpg)

图 3-6

使用旋转上下文指令旋转矩形

在前面的例子中，为了影响绘图，上下文指令如`Color`和`Rotate`必须在顶点指令如`Rectangle`之前添加到画布实例中。顶点指令必须写入 KV 文件中放置目标小部件的行之前的一行。例如，如果小部件位于第 5 行，那么顶点指令必须位于第 5 行之前，而不是之后。在前面的例子中，我们能够控制上下文指令在顶点指令之前的位置。在某些情况下，这是不可能的。

让我们考虑清单 [3-7](#PC9) 中所示的应用程序，其中我们想要旋转一个按钮。

```py
BoxLayout:
    Button:
        text: "Rotate this Button"

Listing 3-7A Button To Be Rotated

```

如果根据清单 [3-8](#PC10) 将 canvas 实例添加到`Button`小部件中，那么 canvas 实例中的`Rotate`上下文指令将被添加到我们想要旋转的`Button`小部件之后，而不是之前。因此`Rotate`上下文指令不会影响小部件。我们需要在小部件之前而不是之后添加上下文指令。我们将讨论这个问题的两种解决方案。

```py
BoxLayout:
    Button:
        text: "Rotate this Button"
        canvas:
            Rotate:
                angle: 45
                origin: root.width/2, root.height/2

Listing 3-8The Rotate Context Instruction Has Been Added After the Button Widget and Thus Does Not Affect It

```

对于给定的父部件，添加到 canvas 实例中的指令不仅会应用到父部件，还会应用到子部件。基于这个特征，我们可以找到我们的第一个解决方案。如果我们想在给定的小部件上执行上下文指令，我们可以将该指令添加到其父部件的 canvas 实例中。这样的指令将影响父部件和它的子部件。清单 [3-9](#PC11) 实现了这个解决方案。注意，上下文指令不仅影响使用顶点指令如`Rectangle`绘制的内容，还会影响小部件。

```py
BoxLayout:
    canvas:
        Rotate:
            angle: 45
            origin: root.width/2, root.height/2
    Button:
        text: "Rotate this Button"

Listing 3-9Placing the Canvas Instance Inside the Parent Widget in Order to Affect Its Children

```

结果如图 [3-7](#Fig7) 所示。我们成功地解决了这个问题，但是还有一个问题。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig7_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig7_HTML.jpg)

图 3-7

将画布添加到其父级后，按钮小部件旋转成功

之前的解决方案不仅旋转了按钮，还旋转了它的父按钮。如果有另一个孩子而不是按钮，它也会被旋转。清单 [3-10](#PC12) 中显示的 KV 文件有一个不应该旋转的`Label`小部件。不幸的是，它会被旋转，如图 [3-8](#Fig8) 所示。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig8_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig8_HTML.jpg)

图 3-8

旋转上下文指令影响按钮和标签小部件

```py
BoxLayout:
    canvas:
        Rotate:
            angle: 45
            origin: root.width/2, root.height/2
    Label:
        text: "Do not Rotate this Label"
    Button:
        text: "Rotate this Button"

Listing 3-10Adding the Context Instruction to the Parent Widget Affects All of its Children

```

### 画布.之前

前面的解决方案是将上下文指令添加到父部件，这会影响所有子部件。没有办法只将这种效果应用于特定的孩子。为了解决这个问题，这个解决方案将根据清单 [3-11](#PC13) 中的 KV 文件使用`canvas.before`实例而不是`canvas`。该小部件中的指令将在呈现小部件之前执行。因此，如果在其中添加了`Rotate`内容指令，`Button`小部件将会成功旋转。

```py
BoxLayout:
    Label:
        text: "Do not Rotate this Label"
    Button:
        text: "Rotate this Button"
        canvas.before:
            Rotate:
                angle: 45
                origin: root.width/2, root.height/2

Listing 3-11Using canvas.before Rather Than canvas to Rotate the Button Widget

```

应用窗口如图 [3-9](#Fig9) 所示。仅旋转`Button`小部件；`Label`保持不变。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig9_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig9_HTML.jpg)

图 3-9

使用 canvas.before 实例仅旋转一个子级

在前面的例子中，有一个技巧。我们要旋转的小部件被添加到小部件树的末尾，这就是为什么`Label`不受旋转的影响。如果在`Button`之后添加了`Label`，那么`Button`和`Label`小部件将被旋转。修改后的代码如清单 [3-12](#PC14) 所示，应用窗口如图 [3-10](#Fig10) 所示。为什么`Label` widget 被旋转了？

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig10_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig10_HTML.jpg)

图 3-10

在 canvas.before 被添加到 Label 之前后，按钮和标签小部件被旋转

```py
BoxLayout:
    Button:
        text: "Rotate this Button"
        canvas.before:
            Rotate:
                angle: 45
                origin: root.width/2, root.height/2
    Label:
        text: "Do not Rotate this Label"

Listing 3-12Placing the canvas.before Instruction Before the Label Widget

```

Kivy 中的画布指令不限于它们被添加到的小部件。一旦一个指令被添加到任何一个小部件中，它就会影响到其他的小部件，直到有什么东西取消了这个指令的效果。例如，如果`Button`小部件旋转 45 度，那么它后面的小部件也将旋转 45 度。如果`Label`小部件出现在`Button`之后，我们不希望它被旋转，我们可以将`Label`小部件旋转-45 度，以便将其恢复到初始状态。取消`Label`小部件旋转的 KV 文件如清单 [3-13](#PC15) 所示。应用程序窗口如图 [3-11](#Fig11) 所示。请注意，标签首先旋转 45 度，然后旋转-45 度。如果在`Button`之后有一个以上的小工具，那么将它们全部旋转以返回到它们的初始状态将是令人厌烦的。更好的解决方案是将`Rotate`上下文指令的效果限制在`Button`小部件上。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig11_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig11_HTML.jpg)

图 3-11

向左旋转-45 度后，左侧小部件保持不变

```py
BoxLayout:
    Button:
        text: "Rotate this Button"
        canvas.before:
            Rotate:
                angle: 45
                origin: root.width/2, root.height/2
    Label:
        text: "Do not Rotate this Label"
        canvas.before:
            Rotate:
                angle: -45
                origin: root.width/2, root.height/2

Listing 3-13Rotating the Label by -45 Degrees to Cancel the Effect of the Button Rotation

```

### canvas.after、PushMatrix 和 PopMatrix

为了避免将`Rotate`指令应用到`Button`小部件下面的小部件，并将效果限制到`Button`小部件，Kivy 提供了`PushMatrix`和`PopMatrix`指令。想法是保存由旋转、平移和缩放表示的当前上下文状态。保存状态后，我们可以对`Button`小部件应用旋转。旋转后的`Button`小部件渲染成功后，我们可以恢复保存的上下文状态。因此，只有`Button`小部件将被旋转，所有其他小部件将保留它们的上下文状态。

清单 [3-14](#PC16) 显示了使用`PushMatrix`和`PopMatrix`的 KV 文件。生成的窗口与图 [3-11](#Fig11) 所示的窗口相同。

```py
BoxLayout:
    Button:
        text: "Rotate this Button"
        canvas.before:
            PushMatrix:
            Rotate:
                angle: 45
                origin: root.width/2, root.height/2
        canvas.after:
            PopMatrix:
    Label:
        text: "Do not Rotate this Label"

Listing 3-14Using PushMatrix and PopMatrix to Limit the Effect of the Context Instructions

```

注意，`PushMatrix`指令被插入到`canavs.before`实例中，而`PopMatrix`指令被插入到`canvas.after`实例中。在`canvas.after`内增加了`PopMatrix`指令，确保只有在`Button`旋转成功后才会执行。如果该指令添加到`canvas.before`，则按钮不会旋转。事实上，按钮将根据`Rotate`指令旋转，然后在呈现旋转后的按钮之前恢复上下文状态。因此，我们不会感觉到旋转的影响。

## 相机旋转

在理解了画布和它们的指令是如何工作的之后，我们可以旋转`Camera`小部件，这是我们最初的目标。我们可以使用清单 [3-15](#PC17) 中所示的 KV 文件构建应用程序。该文件使用前面讨论过的指令(`canvas.before`、`canvas.after`、`PushMatrix`和`PopMatrix`)。在进一步发展之前，熟悉它们是很重要的。请注意，我们正在更改 KV 文件，而没有更改 Python 代码。

```py
BoxLayout:
    Camera:
        resolution: 1280, 720
        play: True
        canvas.before:
            PushMatrix:
            Rotate:
                angle: -90
                axis: 0,0,1
                origin: root.width/2, root.height/2
        canvas.after:
            PopMatrix:

Listing 3-15The KV File That Rotates the Camera Widget

```

为了展示完整的想法，清单 [3-2](#PC2) 中使用的 Python 代码在清单 [3-16](#PC18) 中重复出现。

记住将 KV 文件的名称设置为`test.kv`，以便在将它们转换成小写字母后匹配类名中单词`App`之前的字符。还要记得将`CAMERA`添加到`buildozer.spec`文件的`android.permissions`字段，以获得使用相机的权限。

```py
import kivy.app

class TestApp(kivy.app.App):

    def build(self):
        pass

app = TestApp()
app.run()

Listing 3-16Python Code Associated with the KV File in Listing 3-15

```

图 [3-12](#Fig12) 显示了在 Android 设备上运行的应用程序。小部件放置在正确的角度。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig12_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig12_HTML.jpg)

图 3-12

相机部件被正确地放置在 Android 应用程序中

在本章开始之前，让我们快速回顾一下本书到目前为止我们所讨论的内容。我们为构建桌面和 Android 应用程序准备了 Kivy 开发环境。所需的主要工具是 Kivy 和 Buildozer。我们首先创建了一个简单的应用程序，其中只使用了一个小部件。为了向应用程序窗口添加多个 Kivy 小部件，我们讨论了 Kivy `BoxLayout`容器。为了允许用户与应用程序交互，我们讨论了如何设置和获取文本小部件，如`TextInput`和`Label`。使用`on_press`处理按钮按下动作。

`Camera`小工具也用于使用 Kivy 访问相机。因为使用 Android 相机捕获的图像默认是逆时针旋转 90 度，所以我们必须将`Camera`小部件顺时针旋转-90 度。Kivy 中的 canvas 实例允许我们使用上下文指令对小部件进行转换。此外，画布有顶点指令，用于在小部件上绘制形状，如矩形。讨论了其他画布实例，它们是`canvas.before`和`canvas.after`。为了将画布指令的效果限制在选定的小部件上，我们讨论了`PushMatrix`和`PopMatrix`指令。

在本章的下一节，我们将扩展之前创建的应用程序，以便查看摄像机、捕捉图像并将其上传到 HTTP 服务器。我们构建了一个应用程序，不仅可以查看相机，还可以捕捉图像。HTTP 服务器是使用运行在 PC 上的 Flask API 创建的。服务器有一个基于其 IPv4 地址和端口号的开放套接字，它等待请求上传文件的请求。使用`requests` Python 库，Kivy 应用程序使用 HTTP `POST`消息将捕获的图像上传到服务器。一旦服务器收到来自 Kivy 应用程序的 HTTP `POST`消息，它就将文件上传到一个选定的目录。我们开始吧。

## 使用 Kivy 捕捉和保存图像

我们现在想要修改清单 [3-15](#PC17) 和 [3-16](#PC18) 中编写的应用程序，以便在按钮按下时捕获并保存图像。为此，一个`Button`小部件将被添加到窗口的末尾，如清单 [3-17](#PC19) 所示。问题是，我们如何捕捉相机图像？一般来说，当一个 widget 调用`export_to_png()`函数时，就会抓取一个 widget 的图像(即截图)并以 PNG 文件的形式保存到指定的目录下。如果`Camera`小部件调用了这个函数，相机图像将被保存为一个 PNG 文件。

为了更好地理解清单 [3-17](#PC19) 中所示的 KV 文件，有一些注释。`BoxLayout`的方向被设置为`vertical`以确保小部件垂直排列，这样按钮就可以被添加到布局的末尾。在`Button`小部件之前添加了`Camera`小部件，这样按钮就被添加到了窗口的末尾。

当按钮被按下时，`Camera`小部件被赋予一个 ID`camera`以在 Python 代码中访问它，从而调用`export_to_png()`函数。当`on_press`动作被触发时，Python 代码中的`capture()`函数将被调用。

```py
BoxLayout:
    orientation: "vertical"
    Camera:
        id: camera
        size_hint_y: 18
        resolution: (1280, 720)
        play: True
        canvas.before:
            PushMatrix:
            Rotate:
                angle: -90
                origin: root.width/2, root.height/2
        canvas.after:
            PopMatrix:
    Button:
        text: "Capture"
        size_hint_y: 1
        on_press: app.capture()

Listing 3-17Adding a Button that Captures an Image When Pressed

```

最后要注意的是，`size_hint_y`属性被添加到了`Camera`和`Button`小部件中。微件的尺寸根据`BoxLayout`自动计算。该属性提示布局使给定小部件的高度变大、变小或等于另一个小部件的高度。例如，如果相机的`size_hint_y`设置为 2，按钮设置为 1，那么`Camera`小工具的高度将是按钮高度的两倍。如果相机设置为 3，按钮设置为 1，那么相机高度将是按钮高度的三倍。如果两者都设置为相同的数字，那么两个小部件的高度将相等。在这个例子中，我们给`Camera`小部件分配了一个大值，给按钮分配了一个小值，这样就不会在屏幕上隐藏太多的区域。

与`size_hint_ y property`类似，还有一个`size_hint_x property`控制小部件的宽度。

准备好 KV 文件后，我们需要讨论清单 [3-18](#PC20) 中所示的 Python 文件。注意，这个类被命名为`PycamApp`。因此，KV 文件应该被命名为`pycam.kv`，以便隐式地使用它。在`capture()`函数中，`Camera`小部件根据其 ID 被提取到`camera`变量中。该变量调用`export_to_png()`函数，该函数接受保存捕获图像的路径。您可以更改此路径来自定义应用程序。

```py
from kivy.app import App

class PycamApp(App):

    def capture(self):
        camera = self.root.ids["camera"]
        camera.export_to_png("/storage/emulated/0/captured_image_kivy.png")

    def build(self):
        pass

app = PycamApp()
app.run()

Listing 3-18Python File Associated with KV File in Listing 3-17 that Captures an Image on Button Press

```

构建并运行 Android 应用程序后，其窗口如图 [3-13](#Fig13) 所示。按下按钮，摄像机图像将保存在指定的目录中。这个图像将被发送到服务器。所以，让我们开始构建服务器。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig13_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig13_HTML.jpg)

图 3-13

按下按钮时捕捉图像

## 使用 Flask 构建 HTTP 服务器

保存捕获的图像后，我们将其发送到 HTTP 服务器。服务器是使用运行在 PC 上的 Flask API 创建的。因为 Flask 超出了本书的范围，所以我们不会详细讨论它。你可以在我的书《CNN*使用深度学习的实际计算机视觉应用》的第 [7](7.html) 章中阅读更多关于 Flask 的内容(Apress，2018)。*

清单 [3-19](#PC21) 列出了构建 HTTP 服务器的 Flask 代码。让服务器监听文件上传请求。首先，使用`flask.Flask`类创建一个应用程序实例。该类的构造函数接受`import_name`参数，该参数被设置为包含 Flask Python 文件的文件夹名称。

```py
import flask
import werkzeug

app = flask.Flask(import_name="FlaskUpload")

@app.route('/', methods = ['POST'])
def upload_file():
    file_to_upload = flask.request.files['media']
    file_to_upload.save(werkzeug.secure_filename(file_to_upload.filename))
    print('File Uploaded Successfully.')
    return 'SUCCESS'

app.run(host="192.168.43.231", port=6666, debug=True)

Listing 3-19Building the HTTP Server Using Flask

```

在这段代码的结尾，应用程序使用 IPv4 地址 192.168.43.231 和端口号 6666 监听请求。

如果您不知道您的 IPv4 地址，请使用`ifconfig`终端命令。如果没有找到该命令，使用该命令安装`net-tools`:

```py
ahmed-gad@ubuntu:-$sudo apt install net-tools

```

之后，可以执行`ifconfig`命令，如图 [3-14](#Fig14) 所示。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig14_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig14_HTML.jpg)

图 3-14

使用 ifconfig 终端命令确定 IPv4 地址

`debug`参数控制是否激活调试模式。当调试模式打开时，对服务器的更改将自动应用，而无需重新启动它。

装饰器告诉 Flask 当一个 URL 被访问时执行哪个函数。URL 作为参数被添加到装饰器中，函数被添加到装饰器的下面，在这个例子中是`upload_file()`。URL 设置为`/` **，**表示服务器的根目录。因此，当用户访问`http://192.168.43.231/:6666`时，与服务器根目录相关联的`route()`装饰器将接收这个请求并执行`upload_file()`功能。

`route()`装饰器接受一个名为`methods`的参数，该参数接收函数将作为列表响应的 HTTP 消息的类型。因为我们只对`POST` HTTP 消息感兴趣，所以它将被设置为`['POST']`。

要上传的数据作为键和值的字典发送。密钥是文件的 ID，值是文件本身。在`upload_file()`函数中，使用`flask.request.files`字典获取要上传的文件。它接收引用要上传的文件的密钥。使用的钥匙是`media`。这意味着当我们准备 Kivy 应用程序时，要上传的图像的键必须设置为`media`。文件被返回到一个变量中，在我们的例子中是`file_to_upload`。

如果我们对根据文件的原始名称保存文件感兴趣，可以使用`filename`属性返回它的名称。因为一些文件被命名为欺骗服务器并执行非法操作，所以使用`werkzeug.secure_filename()`函数返回安全文件名。返回安全文件名后，使用`save()`功能保存文件。文件保存成功后，控制台上会出现一条打印消息，服务器会向客户端发送一个单词`SUCCESS`作为响应。

请注意，服务器接受任何文件扩展名。你可以阅读更多关于 Flask 的内容，了解如何上传带有特定扩展名的文件。

## 使用将文件上传到 HTTP 服务器的请求

在修改 Android 应用程序来上传文件之前，我们可以构建一个客户端作为桌面应用程序，它使用`requests`库来上传文件。它将比移动应用程序更容易调试。该应用程序不包括 Kivy 代码，因此我们将使用终端命令与服务器交互。客户端代码如清单 [3-20](#PC23) 所示。

```py
import requests

files = {'media': open('/home/ahmedgad/Pictures/test.png', 'rb')}
try:
    requests.post('http://192.168.43.231:6666/', files=files)
except requests.exceptions.ConnectionError:
    print("Connection Error! Make Sure Server is Active.")

Listing 3-20Using Requests to Upload the Captured Image to the Server

```

准备好保存要上传的文件的字典。它只有一个键值对。如前所述，这个键将被设置为`media`，因为服务器正在等待这个键。使用接收其路径的`open()`函数打开文件。`rb`参数指定文件在二进制模式下以只读方式打开。

`requests.post()`函数接收两个参数。第一个是 URL，在指定其套接字详细信息(IPv4 地址和端口)后，将它定向到服务器的根目录。第二个是字典。try and catch 语句用于检查连接建立是否有问题。这确保了即使在建立连接时出现错误，应用程序也不会崩溃。

在构建了服务器和客户机之后，我们可以开始运行服务器了。服务器没有 GUI，因此它的界面是终端。因为服务器是一个常规的 Python 文件，我们可以根据使用的 Python 版本，在关键字`python`或`python3`后键入 Python 文件名来运行它。如果它的名字是`FlaskServer.py`，它将使用下面的命令执行。记住使用正确的路径来定位 Python 文件。

```py
ahmed-gad@ubuntu:~/Desktop/FlaskUpload$python3 FlaskServer.py

```

我们将看到指示服务器正在成功运行的信息性消息，如图 [3-15](#Fig15) 所示。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig15_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig15_HTML.jpg)

图 3-15

运行 Flask HTTP 服务器

运行客户端应用程序并按下按钮后，服务器接收到 HTTP `POST`消息，并根据图 [3-16](#Fig16) 中控制台上显示的消息成功上传文件。响应的 HTTP 状态代码是 200，这意味着请求成功完成。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig16_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig16_HTML.jpg)

图 3-16

Kivy 应用程序捕获的图像被成功上传到 Flask HTTP 服务器

## 使用 Kivy Android 应用程序上传相机拍摄的图像

在确定桌面客户端应用运行良好后，我们就可以准备 Android 应用了。与清单 [3-18](#PC20) 相比，变化将出现在`capture()`函数内部，如清单 [3-21](#PC25) 所示。

```py
import kivy.app
import requests

class PycamApp(kivy.app.App):

    def capture(self):
        camera = self.root.ids['camera']
        im_path = '/storage/emulated/0/'
        im_name = 'captured_image_kivy.png'
        camera.export_to_png(im_path+im_name)
        files = {'media': open(im_path+im_name, 'rb')}

        try:
            self.root.ids['capture'].text = "Trying to Establish a Connection..."
            requests.post('http://192.168.43.231:6666/', files=files)
            self.root.ids['capture'].text = "Capture Again!"
        except requests.exceptions.ConnectionError:
            self.root.ids['capture'].text = "Connection Error! Make Sure Server is Active."

    def build(self):
        pass

app = PycamApp()
app.run()

Listing 3-21Capturing and Uploading Images to the Server Using the Android Application

```

因为服务器可能脱机，我们需要向用户反映这一点。单击 Capture 按钮后，应该会显示一条消息，通知用户连接正在建立。如果出现连接错误，还会显示一条消息来反映这一情况。

为了能够更改按钮的文本，我们必须在 Python 文件中访问它。为了访问小部件，它必须有一个 ID。清单 [3-17](#PC19) 中之前的 KV 文件没有给按钮分配 ID。清单 [3-22](#PC26) 中修改后的 KV 文件为`Button`小部件分配一个 ID。分配的 ID 是`capture`。

```py
BoxLayout:
    orientation: "vertical"
    id: root_widget
    Camera:
        id: camera
        size_hint_y: 18
        resolution: (1280, 720)
        play: True
        canvas.before:
            PushMatrix:
            Rotate:
                angle: -90
                origin: root.width/2, root.height/2
        canvas.after:
            PopMatrix:
    Button:
        id: capture
        text: "Capture"
        size_hint_y: 1
        on_press: app.capture()

Listing 3-22Assigning an ID to the Button to Access it Inside the Python File

```

因为与之前的应用程序相比，小部件的排列没有改变，所以应用程序窗口将与之前的应用程序相同。

## 请求中的动态 IP 地址

现在，应用程序依赖于服务器的静态 IPv4 地址。如果服务器使用动态主机配置协议(DHCP)，服务器的 IPv4 地址可能会改变，因此我们必须用新地址重建应用程序。为了使这个过程动态，我们可以使用一个`TextInput`小部件，其中可以输入服务器的 IPv4 地址。在将字典发送到服务器之前，获取来自小部件的文本以构建 URL。修改后的 KV 文件如清单 [3-23](#PC27) 所示。为了访问这个小部件，它被分配了 ID `ip_address`。

```py
BoxLayout:
    orientation: "vertical"
    id: root_widget
    Camera:
        id: camera
        size_hint_y: 18
        resolution: (1280, 720)
        play: True
        canvas.before:
            PushMatrix:
            Rotate:
                angle: -90
                origin: root.width/2, root.height/2
        canvas.after:
            PopMatrix:
    TextInput:
        text: "192.168.43.231"
        id: ip_address
        size_hint_y: 1
    Button:
        id: capture
        text: "Capture"
        size_hint_y: 1
        on_press: app.capture()

Listing 3-23Adding a TextInput Widget to Enter the IPv4 Address of the Server

```

使用`TextInput`小部件后的 Python 代码如清单 [3-24](#PC28) 所示。

```py
import kivy.app
import requests

class PycamApp(kivy.app.App):

    def capture(self):
        camera = self.root.ids['camera']
        im_path = '/storage/emulated/0/'
        im_name = 'captured_image_kivy.png'
        camera.export_to_png(im_path+im_name)

        ip_addr = self.root.ids['ip_address'].text
        url = 'http://'+ip_addr+':6666/'
        files = {'media': open(im_path+im_name, 'rb')}

        try:
            self.root.ids['capture'].text = "Trying to Establish a Connection..."
            requests.post(url, files=files)
            self.root.ids['capture'].text = "Capture Again!"
        except requests.exceptions.ConnectionError:
            self.root.ids['capture'].text = "Connection Error! Make Sure Server is Active."

    def build(self):
        pass

app = PycamApp()
app.run()

Listing 3-24Fetching the IPv4 Address from the TextInput Widget

```

应用程序窗口如图 [3-17](#Fig17) 所示。请注意，按钮的文本被更改为“再次捕获！”这意味着根据 Python 代码成功上传了文件。记得在按下按钮之前运行服务器。尝试使用不同的 IPv4 地址，并注意按钮文本如何变化以反映存在连接错误。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig17_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig17_HTML.jpg)

图 3-17

使用 TextInput 小部件输入服务器的 IPv4 地址后的图像捕获应用程序

Flask 服务器日志消息也会出现在终端上，如图 [3-18](#Fig18) 所示。这些消息反映了服务器从 IPv4 地址为 192.168.43.1 的客户端收到了类型为`POST`的消息。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig18_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig18_HTML.jpg)

图 3-18

收到文件后记录来自服务器的消息

此时，我们成功地创建了一个 Kivy Android 应用程序，该应用程序将使用相机捕获的单个图像共享到 HTTP 服务器。这是通过将图像保存到设备存储器，然后上传它。

本章的剩余部分通过在服务器的 web 浏览器中实时预览 Android 摄像头来扩展该应用程序。这是通过捕获相机图像并将其作为字节数组存储在设备内存中来实现的。为了节省时间，图像不会作为文件存储在设备存储器中。使用 HTML `POST`消息将字节数组上传到 Flask 服务器，如本章前面所述。服务器接收每个图像，并使用`<img>`元素将其显示在 HTML 页面上。我们通过连续捕捉图像、将图像上传到服务器以及更新和刷新 HTML 页面来创建实时 Android 摄像头预览。

## 捕获相机图像并将其存储到存储器中

在本章前面，使用 Kivy `export_to_png()`函数将`Camera`小部件图像捕获并保存为 PNG 文件。当一个小部件调用这个函数时，会从小部件中截取一个屏幕截图，并以 PNG 文件的形式保存到函数中指定的目录中。使用 HTTP `POST`消息将保存的 PNG 文件上传到服务器。

如果我们希望使用 Android 相机连续预览捕获的图像，我们必须捕获`Camera`小部件，将每个捕获的图像保存为 PNG 文件，并将它们发送到服务器。每次捕获图像时保存文件非常耗时。此外，不需要将文件保存在存储器中。我们只需要将捕获的图像尽快发送到服务器。没有必要延迟传输过程。出于这些原因，我们可以使用工具来捕获图像并将像素保存在内存中，而不是保存在文件中。我们可以使用 OpenGL 中的`glReadPixels()`函数，或者使用`get_region()`函数返回小部件的纹理。这两种功能都可以捕获图像并将其保存到设备内存中，而不是保存为文件。这加快了进程。

`glReadPixels()`功能在`kivy.graphics.opengl`模块中可用。其签名如下:

```py
kivy.graphics.opengl.glReadPixels(x, y, width, height, format, type)

```

该函数的工作原理是从 Kivy 应用程序窗口中捕获一个区域的图像。该区域从使用`x`和`y`参数定位的左下角开始。使用`width`和`height`参数指定区域的宽度和高度。使用前四个参数，成功地指定了区域。该区域从`(x, y)`开始，水平向左延伸等于`width`的值，垂直向上延伸等于`height`的值。因为我们对捕获放置`Camera`小部件的区域感兴趣，所以我们可以返回这个小部件的坐标，并将它们分配给四个参数。

在返回该区域的像素之前，需要指定一些其他参数来控制像素如何保存到内存中。

`format`参数指定像素数据的格式。它有不同的值，如`GL_RED`、`GL_GREEN`、`GL_BLUE`、`GL_RGB`、`GL_RGBA`等等。这些值存在于`kivy.graphics.opengl`模块中。我们对捕捉 RGB 图像感兴趣，因此将使用`GL_RGB`值。

`type`参数指定像素数据的类型。它有不同的值，如`GL_UNSIGNED_BYTE`、`GL_BYTE`、`GL_UNSIGNED_SHORT`、`GL_SHORT`、`GL_UNSIGNED_INT`等等。这些值存在于`kivy.graphics.opengl`模块中。我们对将图像保存为字节数组感兴趣，因此使用了`GL_UNSIGNED_BYTE`参数。

该函数还有另外两个可选参数，名为`array`和`outputType`，我们不想编辑它们。

另一种捕获小部件图像的方法是使用`kivy.graphics.texture.Texture`类的`get_region()`方法。对于任何有纹理的小部件，我们可以调用这个函数来返回它的纹理。它有四个参数，如下所示。它们与`glReadPixels()`函数中的前四个参数相同。

```py
get_region(x, y, width, height)

```

您可以使用这些函数中的任何一个从`Camera`小部件中捕捉图像，并将结果保存在内存中。对于`get_region()`，它与有纹理的部件一起工作。一些小部件没有纹理，比如`TextInput`，因此我们不能使用`get_region()`。另一方面，`glReadPixels()`捕捉图像时不关心小工具是否有纹理。

为了使事情更简单，我们可以使用`get_region()`。清单 [3-25](#PC31) 中显示了使用`get_region()`捕捉图像并将其保存到内存中的完整代码。

我们将开始构建一个桌面应用程序来简化调试。在本章的最后，我们可以构建 Android 应用程序。

使用 KF 文件中的 ID 获取`Camera`小部件，以确定其左下方的位置(`camera.x`、`camera.y`)。这是对其分辨率(`camera.resolution`)的补充，以返回捕获图像的大小，其中`camera.resolution[0]`是宽度，`camera.resolution[1]`是高度。这四个值被分配给`get_region()`方法中的四个参数。

`get_region()`方法返回一个`TextureRegion`类的实例。为了返回纹理的像素，我们可以使用`pixels`属性。它以像素的形式返回小部件的纹理，以无符号字节数组的形式显示`RGBA`格式。这个数组保存在内存中。在这个例子中，字节数组保存在`pixels_data`变量中。这个变量中的数据稍后将被发送到服务器。

```py
import kivy.app
import PIL.Image

class PycamApp(kivy.app.App):

    def capture(self):
        camera = self.root.ids['camera']
        print(camera.x, camera.y)

        pixels_data = camera.texture.get_region(x=camera.x, y=camera.y, width=camera.resolution[0], height=camera.resolution[1]).pixels

        image = PIL.Image.frombytes(mode="RGBA",size=(int(camera.resolution[0]), int(camera.resolution[1])), data=pixels_data)
        image.save('out.png')

    def build(self):
        pass

app = PycamApp()
app.run()

Listing 3-25Capturing a Camera Image Using get_region()

```

现在，我们可以调试应用程序以确保一切按预期运行。这是通过使用 Python 图像库( **PIL** )保存捕获的图像。因为`get_region().pixels`返回一个 RGBA 格式的字节数组，我们需要从该数组中构造图像。PIL 的`frombytes()`函数支持从字节数组构建图像。该函数通过指定图像模式来接受模式参数，在本例中是字符串`“RGBA”`。我们还在`size`参数中将图像大小指定为一个元组，并在**数据**参数中指定原始字节数据。

注意，这个函数接受整数形式的大小。最好将`Camera`小部件的宽度和高度转换成整数。这是因为`Camera`小部件返回的宽度和高度可能是`float`。使用`save()`功能保存`frombytes()`功能返回的图像。

清单 [3-26](#PC32) 中显示了与之前的 Python 代码一起用于构建桌面应用程序的 KV 文件。除了删除了`TextInput`小部件之外，这个文件与上一个例子中最后一个应用程序使用的文件相同，因为我们目前没有兴趣联系服务器。

```py
BoxLayout:
    orientation: "vertical"
    Camera:
        id: camera
        size_hint_y: 18
        resolution: (1280, 720)
        play: True
    Button:
        id: capture
        text: "Capture"
        size_hint_y: 1
        on_press: app.capture()

Listing 3-26KV File for the Application in Listing 3-25

```

运行应用程序后，窗口如图 [3-19](#Fig19) 所示。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig19_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig19_HTML.jpg)

图 3-19

使用 get_region()捕获并保存到设备内存中的图像

如果你点击按钮，`get_region().pixels`将捕获`Camera`小部件的区域并保存在内存中。

到目前为止，我们已经使用`get_region()`方法成功捕获了一幅图像，并将其保存到设备内存中。下一步是将这个图像发送到 Flask 服务器。

## 使用 HTTP POST 消息将捕获的图像发布到 Flask 服务器

在前面的例子中，图像以字节数组的形式保存在内存中，并准备好发送给服务器。清单 [3-27](#PC33) 显示了将数组发送到 Flask 服务器的 Python 代码。

```py
import kivy.app
import requests

class PycamApp(kivy.app.App):

    def capture(self):
        camera = self.root.ids['camera']
        print(camera.x, camera.y)

        pixels_data = camera.texture.get_region(x=camera.x, y=camera.y, width=camera.resolution[0], height=camera.resolution[1]).pixels

        ip_addr = self.root.ids['ip_address'].text
        url = 'http://'+ip_addr+':6666/'
        files = {'media': pixels_data}

        try:
            self.root.ids['capture'].text = "Trying to Establish a Connection..."
            requests.post(url, files=files)
            self.root.ids['capture'].text = "Capture Again!"
        except requests.exceptions.ConnectionError:
            self.root.ids['capture'].text = "Connection Error! Make Sure Server is Active."

    def build(self):
        pass

app = PycamApp()
app.run()

Listing 3-27Uploading the Bytes Array to the Server

```

从`get_region()`方法返回的字节数组被插入到将被发送到服务器的字典中。注意，字典被分配给了`requests.post()`函数的`files`参数。这意味着字节数组将作为文件在服务器上接收。

代码中的其他部分都按照前面的例子中讨论的那样工作。请注意，我们对在客户端使用 PIL 不再感兴趣。

在添加了`TextInput`小部件之后，客户端应用程序的 KV 文件如清单 [3-28](#PC35) 所示。

```py
BoxLayout:
    orientation: "vertical"
    Camera:
        id: camera
        size_hint_y: 18
        resolution: (1280, 720)
        play: True
    TextInput:
        text: "192.168.43.231"
        id: ip_address
        size_hint_y: 1
    Button:
        id: capture
        text: "Capture"
        size_hint_y: 1
        on_press: app.capture()

```

## 在向服务器发送图像之前

在服务器端，我们将接收上传的字节数组文件。该文件将被读取，以便使用`PIL.Image.frombytes()`函数将其内容转换成图像，如前所述。为了使用这个函数将字节数组转换成图像，它在`size`参数中接收返回图像的大小。使用不同的尺寸而不是正确的尺寸可能会降低图像质量。因此，我们需要知道服务器端的图像大小。我们如何做到这一点？

从客户端到服务器的每个`POST`消息都包含要上传的文件。我们还可以在该消息中发送图像大小。不幸的是，这将在每条消息中发送更多的数据，因为每次上传图像时都会发送图像大小。因为图像大小是固定的，所以我们不需要发送多次。

更好的解决方案是在发送任何图像之前向服务器发送一条`POST` HTTP 消息。此消息告诉服务器它将在下一条消息中接收的图像的大小。当服务器在新邮件中收到上传的图像时，它可以使用以前收到的图像大小。由于这些原因，一个新的`Button`小部件被添加到小部件树的末尾。当按下时，`Camera`小部件的大小将被获取并通过`POST` HTTP 消息上传到服务器。

清单 [3-28](#PC35) 显示了客户端 Kivy 应用程序修改后的 KV 文件。新按钮被分配了 ID `cam_size`。当按下此按钮时，将执行 Python 代码中的`cam_size()`函数。

```py
BoxLayout:
    orientation: "vertical"
    Camera:
        id: camera
        size_hint_y: 18
        resolution: (1280, 720)
        play: True
    TextInput:
        text: "192.168.43.231"
        id: ip_address
        size_hint_y: 1
    Button:
        id: capture
        text: "Capture"
        size_hint_y: 1
        on_press: app.capture()
    Button:
        id: cam_size
        text: "Configure Server"
        size_hint_y: 1
        on_press: app.cam_size()

Listing 3-28KV File for the Client-Side Application

```

添加`cam_size()`函数后，客户端 Kivy 应用程序的 Python 代码如清单 [3-29](#PC36) 所示。创建一个字典来保存要上传的图像的宽度和高度(即`Camera`小部件)。这些数据将作为参数发送到服务器的`/camSize`目录中，因此使用了`requests.post()`函数的`params`参数。如果消息成功发送到服务器，那么新添加的`Button` widget 就没用了。因此，将使用`delete_widget()`功能将其从窗口小部件树中删除。

```py
import kivy.app
import requests

class PycamApp(kivy.app.App):

    def cam_size(self):
        camera = self.root.ids['camera']
        cam_width_height = {'width': camera.resolution[0], 'height': camera.resolution[1]}

        ip_addr = self.root.ids['ip_address'].text
        url = 'http://'+ip_addr+':6666/camSize'

        try:
            self.root.ids['cam_size'].text = "Trying to Establish a Connection..."
            requests.post(url, params=cam_width_height)
            self.root.ids['cam_size'].text = "Done."
            self.root.remove_widget(self.root.ids['cam_size'])
        except requests.exceptions.ConnectionError:
            self.root.ids['cam_size'].text = "Connection Error! Make Sure Server is Active."

    def capture(self):
        camera = self.root.ids['camera']
        print(camera.x, camera.y)

        pixels_data = camera.texture.get_region(x=camera.x, y=camera.y, width=camera.resolution[0], height=camera.resolution[1]).pixels

        ip_addr = self.root.ids['ip_address'].text
        url = 'http://'+ip_addr+':6666/'
        files = {'media': pixels_data}

        try:
            self.root.ids['capture'].text = "Trying to Establish a Connection..."
            requests.post(url, files=files)
            self.root.ids['capture'].text = "Capture Again!"
        except requests.exceptions.ConnectionError:
            self.root.ids['capture'].text = "Connection Error! Make Sure Server is Active."

    def build(self):
        pass

app = PycamApp()
app.run()

Listing 3-29Informing the Server by the Width and Height of the Captured Images

```

图 [3-20](#Fig20) 显示了客户端应用程序窗口。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig20_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig20_HTML.jpg)

图 3-20

添加服务器配置按钮后的应用程序窗口

准备好客户端 Kivy 应用程序后，下一步是准备服务器端 Flask 应用程序。

## 在服务器上处理接收到的图像

在客户端成功构建 Kivy 应用程序后，下一步是准备服务器端 Flask 应用程序。它首先接收上传图像的尺寸(宽度和高度)，然后接收上传的图像。应用程序的 Python 代码如清单 [3-30](#PC37) 所示。

有称为`cam_width`和`cam_height`的变量是在任何函数之外定义的。这些变量保存图像的宽度和高度。当 KV 文件中 ID 为`cam_size`的按钮被按下时，URL 为`/camSize`的路由装饰器执行`cam_size()`功能。在这个函数中，使用`flask.request.args`字典从客户端接收`Camera`小部件的宽度和高度作为参数。它们被分配给先前创建的两个变量。为了使用这些变量而不是创建新的变量，我们在函数的开头将它们定义为`global`。

在分配数据之前，记得将接收数据的类型转换为`integer`。`int(float())`变量保证转换没有错误。

```py
import flask
import PIL.Image

app = flask.Flask(import_name="FlaskUpload")

cam_width = 0
cam_height = 0

@app.route('/camSize', methods = ['POST'])
def cam_size():
    global cam_width
    global cam_height

    cam_width = int(float(flask.request.args["width"]))
    cam_height = int(float(flask.request.args["height"]))

    print('Width',cam_width,'& Height',cam_height,'Received Successfully.')

    return "OK"

@app.route('/', methods = ['POST'])
def upload_file():
    global cam_width
    global cam_height

    file_to_upload = flask.request.files['media'].read()

    image = PIL.Image.frombytes(mode="RGBA", size=(cam_width, cam_height), data=file_to_upload)
    image.save('out.png')

    print('File Uploaded Successfully.')

    return 'SUCCESS'

app.run(host="192.168.43.231", port=6666, debug=True)

Listing 3-30Restoring Images from the Received Bytes Arrays at the Server

```

`upload_file()`功能类似于本章前面使用的功能。它使用`flask.request.files`字典接收上传的文件。使用`read()`功能读取上传的文件。使用`PIL.Image.frombytes()`功能将接收到的文件转换成图像。仅出于调试目的，在开发客户端应用程序时，图像将保存到 PNG 文件中。

准备好客户端和服务器应用程序后，我们可以根据图 [3-21](#Fig21) 进行测试。通过运行客户端 Kivy 应用程序并按下 ID 为`cam_size`的按钮，图像大小(宽度和高度)将被发送到服务器，该按钮将被删除。按下另一个按钮后，图像将被捕获并作为字节数组文件发送到服务器。该文件在服务器上被读取，并返回字节数组。使用`PIL.Image.frombytes()`函数将该数组转换成图像。图 [3-21](#Fig21) 显示一切正常。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig21_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig21_HTML.jpg)

图 3-21

上传字节数组后的图像尺寸被发送到服务器

此时，Kivy 客户端和 Flask 服务器应用程序都可以很好地相互协作，以便上传单个图像。为了从客户机向服务器连续发送图像，我们可以构建一个 HTML 页面来显示接收到的图像。

### 使用 HTML 页面保存和显示接收到的图像

到目前为止，我们成功地构建了客户端和服务器端应用程序。客户端应用程序发送图像，其宽度和高度也被发送到服务器。客户端将图像作为字节数组发送给服务器。服务器使用接收到的宽度和高度将数组保存为 PNG 文件。

因为我们对显示接收到的图像感兴趣，所以我们将构建一个非常简单的 HTML 页面，该页面包含一个`<img>`元素，其中要显示的上传图像的路径被分配给了`src`属性。在接收并保存上传的图像为 PNG 文件后，服务器应用程序根据上传图像的路径更新`src`属性后创建 HTML 文件。然后，使用`webbrowser`模块的`open()`功能在网络浏览器中打开 HTML 页面。该函数接受页面 URL 作为参数。更新后的服务器应用程序如清单 [3-31](#PC38) 所示。

```py
import flask
import PIL.Image
import webbrowser

app = flask.Flask(import_name="FlaskUpload")

cam_width = 0
cam_height = 0

@app.route('/camSize', methods = ['POST'])
def cam_size():
    global cam_width
    global cam_height

    cam_width = int(float(flask.request.args["width"]))
    cam_height = int(float(flask.request.args["height"]))

    print('Width',cam_width,'& Height',cam_height,'Received Successfully.')

    return "OK"

@app.route('/', methods = ['POST'])
def upload_file():
    global cam_width
    global cam_height

    file_to_upload = flask.request.files['media'].read()

    image = PIL.Image.frombytes(mode="RGBA", size=(cam_width, cam_height), data=file_to_upload)
    image.save('out.png')

    print('File Uploaded Successfully.')

    html_code = '<html><head><title>Displaying Uploaded Image</title></head><body><h1>Displaying Uploaded Image</h1><img src="out.png" alt="Uploaded Image at the Flask Server"/></body></html>'

    html_url = "/home/ahmedgad/Desktop/FlaskUpload/test.html"
    f = open(html_url,'w')
    f.write(html_code)
    f.close()

    webbrowser.open(html_url)

    return 'SUCCESS'

app.run(host="192.168.43.231", port=6666, debug=True)

Listing 3-31Displaying the Restored Images on the Server on an HTML Page

```

HTML 代码作为文本写在`html_code`变量中。清单 [3-32](#PC39) 中显示了更好的可视化格式代码。除了`<img>`元素之外，`<h1>`元素在它上面打印一个标题。HTML 代码根据`html_url`变量中指定的路径写入 HTML 文件。

```py
<html>
<head>
<title>Displaying Uploaded Image</title>
</head>
<body>
<h1>Uploaded Image to the Flask Server</h1>
<img src="out.png" alt="Uploaded Image at the Flask Server"/>
</body>
</html>

Listing 3-32HTML Page to Display the Images

```

在客户端捕获图像，上传到服务器，更新并显示 HTML 页面后，结果如图 [3-22](#Fig22) 所示。请注意，应用程序会在浏览器中为每个上传的图像打开一个新的选项卡。这将是一个麻烦，当我们试图不断上传图像。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig22_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig22_HTML.jpg)

图 3-22

将上传的图像显示到服务器上的 HTML 页面

### 显示接收的图像而不保存

在客户端应用程序中，为了避免保存每个上传的图像，我们使用了`get_region()`方法。我们需要对服务器端应用程序做同样的事情。

目前，服务器接收字节数组，使用 PIL 将其保存到 PNG 文件，并在 web 浏览器中显示。我们需要删除将图像保存为 PNG 文件的中间步骤。因此，我们需要将上传的图像以字节数组的形式直接显示在 web 浏览器上。这是通过将图像的字节数组内联到作为 base64 编码图像的`<img>` HTML 元素的`src`属性中来实现的。

为了将字节数组编码为 base64，使用 base64 Python 模块。确保它安装在您的机器上。清单 [3-33](#PC40) 显示了更新后的服务器端应用程序。

请注意，我们不再需要使用 PIL。这是因为我们对将字节数组转换成图像或保存图像都不感兴趣。

```py
import flask
import webbrowser
import base64

app = flask.Flask(import_name="FlaskUpload")

cam_width = 0
cam_height = 0

@app.route('/camSize', methods = ['POST'])
def cam_size():
    global cam_width
    global cam_height

    cam_width = int(float(flask.request.args["width"]))
    cam_height = int(float(flask.request.args["height"]))

    print('Width',cam_width,'& Height',cam_height,'Received Successfully.')

    return "OK"

@app.route('/', methods = ['POST'])
def upload_file():
    global cam_width
    global cam_height

    file_to_upload = flask.request.files['media'].read()

    print('File Uploaded Successfully.')

    im_base64 = base64.b64encode(file_to_upload)

    html_code = '<html><head><meta http-equiv="refresh" content="1"><title>Displaying Uploaded Image</title></head><body><h1>Uploaded Image to the Flask Server</h1><img src="data:;base64,' + im_base64.decode(
    'utf8') + '" alt="Uploaded Image at the Flask Server"/></body></html>'

    html_url = "/home/ahmedgad/Desktop/FlaskUpload/test.html"
    f = open(html_url,'w')
    f.write(html_code)
    f.close()

    webbrowser.open(html_url)

    return 'SUCCESS'

app.run(host="192.168.43.231", port=6666, debug=True)

Listing 3-33Inlining the Bytes Array Into the src Attribute of the <img> HTML Tag

```

下面显示了使用`b64encode()`函数将图像转换为 base64 编码的代码行。该函数接受一个字节数组，因此它由`file_to_upload`变量中上传的数据提供。

```py
im_base64 = base64.b64encode(file_to_upload)

```

`im_base64`变量保存 base64 编码的图像。这个变量中的值作为一个数据 URL 被分配给`<img>`元素的`src`属性。使用的网址是`data:;base64,`。注意，URL 不直接接受字节数组，而是在使用`encode('utf8')`函数将其转换成字符串之后接受。你可以阅读更多关于数据 URL 的内容。

记住，我们必须将上传的字节数组图像转换成 PIL 图像，以便旋转它。然后，PIL 图像被转换回字节数组，以便使用 base64 进行编码。通过这样做，我们不必将图像保存为外部文件。

## 不断上传图像到服务器

以前，单个图像被上传到服务器。现在，我们想不断上传图像到服务器。要做到这一点，客户端和服务器端的应用程序都将发生变化。

点击客户端 Kivy 应用程序的捕获按钮后，应用程序进入一个无限的`while`循环。在每次迭代中，一个摄像机图像被捕获并通过`POST` HTTP 消息发送到服务器。更新后的 Kivy 应用程序如列表 [3-34](#PC42) 所示。

```py
import kivy.app
import requests

class PycamApp(kivy.app.App):

    def cam_size(self):
        camera = self.root.ids['camera']
        cam_width_height = {'width': camera.resolution[0], 'height': camera.resolution[1]}

        ip_addr = self.root.ids['ip_address'].text
        url = 'http://'+ip_addr+':6666/camSize'

        try:
            self.root.ids['cam_size'].text = "Trying to Establish a Connection..."
            requests.post(url, params=cam_width_height)
            self.root.ids['cam_size'].text = "Done."
            self.root.remove_widget(self.root.ids['cam_size'])
        except requests.exceptions.ConnectionError:
            self.root.ids['cam_size'].text = "Connection Error! Make Sure Server is Active."

    def capture(self):
        while True:
            camera = self.root.ids['camera']

            pixels_data = camera.texture.get_region(x=camera.x, y=camera.y, width=camera.resolution[0], height=camera.resolution[1).pixels

            ip_addr = self.root.ids['ip_address'].text
            url = 'http://'+ip_addr+':6666/'
            files = {'media': pixels_data}

            try:
                self.root.ids['capture'].text = "Trying to Establish a Connection..."
                requests.post(url, files=files)
                self.root.ids['capture].text = "Capture Again!"
            except requests.exceptions.ConnectionError:
                self.root.ids['capture'].text = "Connection Error! Make Sure Server is Active."

    def build(self):
        pass

app = PycamApp()
app.run()

Listing 3-34Client-Side Application for Continuously Capturing and Uploading Images to the Server

```

在服务器端 Flask 应用程序中，为每个上传的图像打开一个新的浏览器选项卡。当我们想要持续上传图像时，这是一个问题。为了解决这个问题，我们使用一个名为`html_opened`的标志变量。默认设置为`False`，表示不打开标签页。上传第一张图片后，它将被设置为`True`，因此应用程序将不会打开任何其他标签。清单 [3-35](#PC43) 中显示了更新后的 Flask 应用程序。

```py
import flask
import base64
import webbrowser

app = flask.Flask(import_name="FlaskUpload")

cam_width = 0
cam_height = 0

html_opened = False

@app.route('/camSize', methods = ['GET', 'POST'])
def cam_size():
    global cam_width
    global cam_height

    cam_width = int(float(flask.request.args["width"]))
    cam_height = int(float(flask.request.args["height"]))

    print('Width',cam_width,'& Height',cam_height,'Received Successfully.')

    return "OK"

@app.route('/', methods = ['POST'])
def upload_file():
    global cam_width
    global cam_height
    global html_opened

    file_to_upload = flask.request.files['media'].read()

    print('File Uploaded Successfully.')

    im_base64 = base64.b64encode(file_to_upload)

    html_code = '<html><head><meta http-equiv="refresh" content="0.5"><title>Displaying Uploaded Image</title></head><body><h1>Uploaded Image to the Flask Server</h1><img src="data:;base64,'+im_base64.decode('utf8')+'" alt="Uploaded Image at the Flask Server"/></body></html>'

    html_url = "/home/ahmedgad/Desktop/FlaskUpload/templates/test.html"
    f = open(html_url,'w')
    f.write(html_code)
    f.close()

    if html_opened == False:
        webbrowser.open(html_url)
        html_opened = True

    return "SUCCESS"

app.run(host="192.168.43.231", port=6666, debug=True)

Listing 3-35Server-Side Application for Continuously Receiving the Uploaded Images and Displaying Them in the Web Browser

```

服务器应用程序的另一个变化是使用了一个`<meta>`标签，每 0.5 秒刷新一次 HTML 页面。

### 使用时钟控制图像上传速率

前面的应用程序使用 UI 线程将图像上传到服务器。这会挂起应用程序，并阻止用户与其小部件进行交互。

最好在另一个线程中而不是 UI 线程中执行耗时的操作。在我们的应用中，这种解决方案是不可行的。这是因为如果我们创建了一个新的线程，它仍然需要在每次捕获图像时从 UI 线程访问`Camera`小部件。

另一个解决方案是在一个新的线程而不是 UI 线程中将图像上传到服务器。这使得应用程序的 UI 比以前响应更快。此外，我们可以通过控制上传图像到服务器的速度来减缓这个过程。

使用`kivy.clock.Clock`对象，我们可以安排一个函数调用在将来执行。因为我们对将来多次执行该函数感兴趣，所以`kivy.clock.Clock.schedule_interval()`函数是一个不错的选择。它接受要执行的函数以及两次执行之间的秒数。Kivy 应用程序的修改代码如清单 [3-36](#PC44) 所示。间隔设置为 0.5 秒。记得匹配`schedule_interval()`函数中上传图片和`<meta>`标签中刷新 HTML 页面的秒数。

```py
import kivy.app
import requests
import kivy.clock
import kivy.uix.screenmanager
import threading

class Configure(kivy.uix.screenmanager.Screen):
    pass

class Capture(kivy.uix.screenmanager.Screen):
    pass

class PycamApp(kivy.app.App):
    num_images = 0

    def cam_size(self):
        camera = self.root.ids['camera']
        cam_width_height = {'width': camera.resolution[0], 'height': camera.resolution[1]}

        ip_addr = self.root.ids['ip_address'].text
        port_number = self.root.ids['port_number'].text
        url = 'http://' + ip_addr + ':' + port_number + '/camSize'

        try:
            self.root.ids['cam_size'].text = "Trying to Establish a Connection..."
            requests.post(url, params=cam_width_height)
            self.root.ids['cam_size'].text = "Done."
            self.root.current = "capture"
        except requests.exceptions.ConnectionError:
            self.root.ids['cam_size'].text = "Connection Error! Make Sure Server is Active."

    def capture(self):
        kivy.clock.Clock.schedule_interval(self.upload_images, 0.5)

    def upload_images(self, ∗args):
        self.num_images = self.num_images + 1
        print("Uploading image", self.num_images)

        camera = self.root.ids['camera']

        print("Image Size ", camera.resolution[0], camera.resolution[1])
        print("Image corner ", camera.x, camera.y)

        pixels_data = camera.texture.get_region(x=camera.x, y=camera.y, width=camera.resolution[0], height=camera.resolution[1]).pixels

        ip_addr = self.root.ids['ip_address'].text
        port_number = self.root.ids['port_number'].text
        url = 'http://' + ip_addr + ':' + port_number + '/'
        files = {'media': pixels_data}

        t = threading.Thread(target=self.send_files_server, args=(files, url))
        t.start()

    def build(self):
        pass

    def send_files_server(self, files, url):
        try:
            requests.post(url, files=files)
        except requests.exceptions.ConnectionError:
            self.root.ids['capture'].text = "Connection Error! Make Sure Server is Active."

app = PycamApp()
app.run()

Listing 3-36Uploading the Images in a New Thread

```

在这个例子中，创建了一个名为`upload_images()`的新函数来保存负责捕获和上传每张图片的代码。该函数为每个上传的图像增加一个名为`num_images`的变量。在该功能中，仅使用`camera.texture.get_region()`捕捉图像。为了上传它，在这个函数的末尾创建了一个新线程。

使用`threading`模块中的`Thread`类，我们可以创建新的线程。在该类的构造函数中，指定了线程`target`，它可以是线程运行后调用的函数。如果该函数接受参数，我们可以使用构造函数的`args`参数传递它们。

在我们的应用程序中，创建了一个名为`send_files_server()`的回调函数，它接受上传到服务器的图像以及服务器 URL。

运行 Kivy 和 Flask 应用程序后，打印到终端的消息表明执行成功。

Kivy 应用程序的终端执行如图 [3-23](#Fig23) 所示。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig23_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig23_HTML.jpg)

图 3-23

客户端应用程序的终端执行

图 [3-24](#Fig24) 显示了烧瓶应用程序的输出。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig24_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig24_HTML.jpg)

图 3-24

服务器端 Flask 应用程序的终端执行

我们现在已经创建了一个桌面 Kivy 应用程序，它访问相机，连续捕获图像，将它们上传到 Flask 服务器，并在 web 浏览器中显示捕获的图像。下一步是构建 Android 应用程序。

## 构建实时摄像头预览 Android 应用程序

我们需要对客户端桌面 Kivy 应用程序进行一些更改，以使其适合作为 Android 应用程序。

我们必须使用`Rotate`上下文指令将`Camera`小部件旋转-90 度，因为 Android 摄像头默认旋转 90 度。这在本章前面已经讨论过了。旋转小部件的 KV 文件如清单 [3-37](#PC45) 所示。

```py
BoxLayout:
    orientation: "vertical"
    Camera:
        id: camera
        size_hint_y: 18
        resolution: (1280, 720)
        play: True
        canvas.before:
            PushMatrix:
            Rotate:
                angle: -90
                origin: root.width/2, root.height/2
        canvas.after:
            PopMatrix:
    TextInput:
        text: "192.168.43.231"
        id: ip_address
        size_hint_y: 1
    Button:
        id: capture
        text: "Capture"
        size_hint_y: 1
        on_press: app.capture()
    Button:
        id: cam_size
        text: "Configure Server"
        size_hint_y: 1
        on_press: app.cam_size()

Listing 3-37Rotating the Image 90 Degrees for the Android Application

```

请注意，旋转`Camera`小部件并不意味着上传到服务器的图像也会被旋转。这个操作只是旋转显示摄像机图像的`Camera`小部件。捕获的图像仍然旋转 90 度。因此，我们需要修改 Flask 应用程序，以便在 web 浏览器中显示之前将每个捕获的图像旋转-90°。如清单 [3-38](#PC46) 所示。字节数组被转换成旋转 90 度的 PIL 图像。最后，旋转后的图像被转换回字节数组，以便根据 base64 进行编码。

```py
import flask
import base64
import PIL.Image
import webbrowser

app = flask.Flask(import_name="FlaskUpload")

cam_width = 0
cam_height = 0

html_opened = False

@app.route('/camSize', methods = ['GET', 'POST'])
def cam_size():
    global cam_width
    global cam_height

    cam_width = int(float(flask.request.args["width"]))
    cam_height = int(float(flask.request.args["height"]))

    print('Width',cam_width,'& Height',cam_height,'Received Successfully.')

    return "OK"

@app.route('/', methods = ['POST'])
def upload_file():
    global cam_width
    global cam_height
    global html_opened

    file_to_upload = flask.request.files['media'].read()

    image = PIL.Image.frombytes(mode="RGBA", size=(cam_width, cam_height), data=file_to_upload)
    image = image.rotate(-90)

    print('File Uploaded Successfully.')

    im_base64 = base64.b64encode(image.tobytes())

    html_code = '<html><head><meta http-equiv="refresh" content="0.5"><title>Displaying Uploaded Image</title></head><body><h1>Uploaded Image to the Flask Server</h1><img src="data:;base64,'+im_base64.decode('utf8')+'" alt="Uploaded Image at the Flask Server"/></body></html>'

    html_url = "/home/ahmedgad/Desktop/FlaskUpload/templates/test.html"
    f = open(html_url,'w')
    f.write(html_code)
    f.close()

    if html_opened == False:
        webbrowser.open(html_url)
        html_opened = True

    return "SUCCESS"

app.run(host="192.168.43.231", port=6666, debug=True)

Listing 3-38Rotating the Captured Images at the Server by 90 Degrees

```

准备好客户端和服务器端应用程序后，我们可以根据下面的终端命令构建 Android 应用程序。

```py
ahmedgad@ubuntu:~/Desktop/NewApp$ buildozer android debug deploy run logcat

```

确保将路径更改为应用程序根目录，其中存在`buildozer.spec`文件，并激活虚拟环境(如果您在虚拟环境中准备了开发环境)。

Android 应用程序的窗口如图 [3-25](#Fig25) 所示。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig25_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig25_HTML.jpg)

图 3-25

Android 应用程序的窗口，用于持续上传图像

点击捕获按钮后，Android 应用程序会连续捕获图像并上传到服务器，在服务器上以 HTML 页面显示。图 [3-26](#Fig26) 显示了显示的图像之一。

![../images/481739_1_En_3_Chapter/481739_1_En_3_Fig26_HTML.jpg](../images/481739_1_En_3_Chapter/481739_1_En_3_Fig26_HTML.jpg)

图 3-26

在服务器的网络浏览器中显示的上传图像

## 摘要

本章讨论了通过`Camera`小部件访问 Android 摄像头。在构建 Android 应用程序之前，我们创建了一个桌面应用程序来确保一切按预期运行。我们使用 Buildozer 构建了 Android 应用程序。为了获得访问 Android 摄像头的许可，我们必须更新`buildozer.init`文件中的`android.permissions`字段。因为安卓摄像头默认旋转 90 度，所以必须旋转回来。这是使用基维画布完成的。讨论了三个画布实例— `canvas`、`canvas.before`和`canvas.after`。为了将给定指令的效果限制在某些小部件上，我们讨论了`PushMatrix`和`PopMatrix`指令。

在适当的角度预览相机后，图像被捕获，以便上传到 HTTP 服务器。服务器是使用 Flask 创建的，并在台式计算机上运行。使用服务器的 IPv4 地址和端口号，`requests` Python 库将使用 Kivy Android 应用程序和 HTTP `POST`消息上传捕获的图像。

在本章的最后，我们在服务器的网络浏览器中预览了 Android 摄像头。为了节省时间，图像以字节数组的形式保存在设备存储器中，而不是保存在设备存储器中。这样的字节数组然后被上传到服务器。然后，服务器解释这些字节数组，并通过网页浏览器中的 HTML 页面显示图像。

在下一章中，通过将按钮分离到不同的屏幕中，为实时预览项目创建了一个更方便的设计。Kivy 支持用于构建屏幕的`Screen`类和用于管理此类屏幕的`ScreenManager`类。我们可以从一个屏幕导航到另一个屏幕。为了理解如何创建一个有多个屏幕的应用程序，下一章从讨论如何创建定制的小部件开始。