# 6.将外壳与文档存储一起使用

到目前为止，在本书中，我们已经发现了 MySQL Shell，并了解了如何使用它来取代旧的 MySQL 客户端(MySQL ),以及如何使用 Shell 通过传统的 SQL 命令来管理我们的数据库。我们还学习了如何使用 X DevAPI 使用 shell 来开发我们的关系数据库代码，甚至进行测试！

现在是时候了解什么是文档存储以及我们如何开始使用它了。是的，你也可以用贝壳做同样的事情。核心概念是 JavaScript 对象符号(JSON)文档。我们将了解更多关于 JSON 是什么以及 MySQL 文档存储是如何工作的。我们还将看到几个如何将 JSON 与关系数据库结合的例子。在下一章，我们将着手用 JSON 文档构建一个 NoSQL 解决方案。

让我们简短地了解一下术语和技术概述。

## 概观

MySQL 文档存储库的起源在于几种技术，它们被结合在一起形成了文档存储库。具体来说，Oracle 将键、值机制与新的数据类型、新的编程库和新的访问机制结合起来，创建了现在的文档存储。这不仅允许我们使用带有 NoSQL 接口的 MySQL，还允许我们构建混合解决方案，利用关系数据的稳定性和结构，同时增加 JSON 文档的灵活性。

在本章中，我们将了解 MySQL 如何支持 JSON 文档，包括如何添加、查找、更新和删除数据(通常分别称为创建、读取、更新和删除或简称为 CRUD)。我们从本章和下一章中你将会遇到的概念和技术的更多信息开始。然后我们将继续学习更多关于 MySQL 服务器中 JSON 数据类型和 JSON 函数的知识。虽然这一章的重点是在关系数据中使用 JSON，但是掌握 MySQL 文档存储 NoSQL 接口(X DevAPI)需要一个关于如何使用 JSON 的坚实基础。

在 MySQL 中使用文档存储和 JSON 时，我们会遇到一些新概念、新技术和相关术语。在这一节中，我们将看到这些概念和技术如何解释 JSON 数据类型和文档存储接口的组成。让我们从 JSON 使用的最基本的概念开始:键、价值机制。

### 起源:关键，价值机制

像这个世界上的大多数东西一样，没有什么东西是真正新的，因为它是完全原创的，没有以前出现过的某种形式，因此通常是以新的方式应用现有技术构建的。*键、值*机制是基础技术的一个典型例子。我们使用术语“机制”,因为键的使用允许您访问值。

当我们说 key，value 时，我们的意思是存在一些标签(通常是一个字符串)构成了键，并且每个键都与一个值相关联。例如，`"name":"Charlie"`是一个示例，其中 key ( `name`)具有一个值(`Charlie`)。虽然键值存储中的值通常是短字符串，但是值可以是复杂的；数字、字母数字、列表，甚至嵌套键、值集。

Key，value 机制最出名的是易于编程使用，同时仍然保持可读性。也就是说，通过大量使用空格，一个复杂的嵌套键，值数据结构可以被人类读取。下面显示了一个示例，其格式类似于一些开发人员格式化代码的方式。 <sup>[1](#Fn1)</sup> 可以看出，很容易看出这一组键、值都存储了什么；姓名、地址和电话号码。

```
{ "name": {
    "first":"Charlie",
    "last":"Harrington"
  },
  "address": {
    "street":"123 Main Street",
    "city":"melborne",
    "state":"California",
    "zip":"90125"
  }
  "phone_numbers": [
      "800-555-1212",
      "888-212-1234"
    ]
  }
}

```

键、值机制(或存储)的一个例子是可扩展标记语言(XML)，它已经存在了一段时间。下面是一个使用上述数据的简单 XML 示例。它是 SQL `SELECT`查询的结果，输出(行)以 XML 格式显示。注意 XML 是如何使用 HTML 这样的标签(因为它是从 HTML 派生出来的)以及数据的键、值存储的。这里，键是`<row>`、`<field>`，值是开始和结束标记符号之间的内容(`<field> </field>`)。

```
<?xml version="1.0"?>
<resultset statement="select ∗ from thermostat_model limit 1;" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <row>
    <field name="model_id">acme123</field>
    <field name="brand">WeMakeItSoCo</field>
  </row>
</resultset>

```

有些系统是围绕键、值机制(称为键、值或关系存储)设计的，比如语义网。简而言之，语义网试图利用数据的关联来描述事物、事件等。有时，术语“关系存储”或“三重存储”被用来描述所采用的存储系统的类型。语义 Web 中使用了几种形式的关键值机制，包括资源描述框架(RDF)、Web 本体语言(OWL)和可扩展标记语言(XML)。还有其他一些关键值机制的例子，但是与文档存储最相关的是 JSON。

现在让我们看看文档库的另一个关键组件——从编程库开始的 NoSQL 接口。

### 应用程序界面

回想一下，应用程序编程接口(API)，有时简称为库或编程库，是一组支持一个或多个功能的操作的类和方法。通过这些类和方法，这些功能允许程序员使用这些类和方法来执行各种任务。

在 MySQL 文档存储的情况下，我们使用 X Developer API (X DevAPI)通过一组类和方法来访问服务器，这些类和方法提供了到服务器的连接，以及集合、表、SQL 操作等概念的抽象。这些结合起来允许一个 NoSQL 接口到 MySQL 服务器。

### NoSQL 接口

关于 NoSQL，有几个有时相互矛盾的定义(如果不是例子的话)。出于本书和 MySQL 的目的，NoSQL 接口是一种不需要使用 SQL 语句来访问数据的 API。API 本身提供了到服务器的连接，以及创建、检索、更新和删除数据的类和方法。在上一章中，我们已经看到了这个范例的作用。

此时，您可能想知道 MySQL 如何处理将 JSON 文档与关系数据结合使用的混合选项。简单地说，MySQL 被设计成允许在关系数据中存储和检索 JSON 文档(通过 SQL 接口)。也就是说，服务器已经被修改来处理 JSON 文档。还有一组函数允许您对 JSON 数据做各种各样的事情，使得通过 SQL 接口使用 JSON 变得很容易。

然而，您也可以通过 NoSQL X DevAPI 使用 JSON 文档，或者通过 SQL 命令，或者使用 X DevAPI 的特殊类和方法作为纯文档存储。我们将在本章中看到使用 JSON 的两种方式的概述，并在下一章深入探讨通过 NoSQL 接口使用 JSON 文档。

### 文档存储

文档存储(也称为面向文档的数据库)是一个用于管理半结构化数据(即文档)的存储和检索系统。现代文档存储系统支持 XML 和 JSON 中的键、值结构。因此，文档存储系统有时被认为是关键值存储系统的一个子类。

文档存储系统也通常由实现为编程接口(API)的 NoSQL 接口来访问，该 API 允许开发者将文档的存储和检索合并到他们的程序中，而不需要第三方访问机制(API 实现访问机制)。

事实上，描述数据的元数据嵌入在数据本身中。粗略地说，这意味着键和键的布局(排列或嵌套)形成元数据，并且元数据对于存储机制变得不透明。更具体地说，数据如何排列(文档如何形成或描述数据)不反映在存储机制中，也不由存储机制管理。对半结构化数据的访问需要使用 NoSQL 接口访问为处理文档本身而设计的机制。

这两种特性，半结构化数据和 NoSQL 接口，是文档存储与关系数据的区别。关系数据需要不灵活的结构，迫使所有数据符合特定的结构。数据也以相同的结构分组在一起，通常很少考虑内容可能不同的数据。因此，我们通常不会看到通过传统关系数据机制访问文档存储。也就是说，直到现在。

使用文档存储有趣的一点是，学习如何使用文档存储并不需要成为 JavaScript 或 Python 专家。事实上，你要做的大部分事情并不需要掌握任何编程语言。也就是说，有很多关于如何做事的例子，所以你不需要学习所有关于这门语言的知识。事实上，你可以很快找到你需要的东西，然后随着你的需求的成熟，学习更多的语言知识。

### 数据

JSON 是一种人类和机器可读的基于文本的数据交换格式。它也是独立于平台的，这意味着不存在禁止它在几乎任何编程语言中使用的格式概念。此外，JSON 是互联网上广泛使用的一种格式。

JSON 允许您在不违反任何结构的情况下以任何方式描述数据。事实上，您可以按照自己的意愿设置数据的格式(布局)。唯一真正的限制是描述符(花括号、方括号、引号、逗号等)的正确使用，这些描述符必须对齐，在某些情况下必须正确配对。下面是一个有效 JSON 字符串的示例。

```
{
    "address": {
        "street": "123 First Street",
        "city": "Oxnard",
        "state": "CA",
        "zip": "90122"
    }
}

```

如果您认为这看起来很像之前的关键价值示例，那么您是对的，就是它！鉴于 JSON 是如何形成的，这并不是错误。然而，我们经常使用术语 string 来谈论 JSON，实际上有时我们看到 JSON 没有空格和换行符，如下所示。事实证明，大多数编程语言 JSON 机制可以正确解释空格和换行符。我们将在后面的章节中看到更多相关内容。

```
{"address": {"street": "123 First Street","city": "Oxnard","state": "CA","zip": "90122"}}

```

当编程语言支持时，开发人员可以通过键访问数据来轻松读取数据。更好的是，开发人员不需要知道键是什么(但这很有帮助！)因为它们可以使用语言支持机制来获取键并对它们进行迭代。这样，像 XML 一样，数据是自描述的。

现在，让我们深入了解什么是 JSON 文档，以及如何在 MySQL 中使用它们。

## MySQL 中的 JSON 文档介绍

在 MySQL 5.7.8 和更高版本中，我们可以使用 JSON 数据类型将 JSON 文档存储在传统关系数据库表中存储的行的字段(列)中。有些人可能尝试(并成功)在 blob 或文本字段中存储 JSON。虽然这是可能的，但有几个很好的理由不这样做。最令人信服的原因是，它要求应用程序完成所有读取和写入 JSON 文档的繁重工作，从而使它变得更加复杂，并且可能容易出错。JSON 数据类型以两种方式克服了这个问题。

*   *验证*:JSON 数据类型提供文档验证。也就是说，只有有效的 JSON 才能存储在 JSON 列中。

*   *高效访问*:当一个 JSON 文档存储在一个表中时，存储引擎将数据打包成一种特殊的优化二进制格式，允许服务器快速访问数据元素，而不是每次访问数据时都解析数据。

这为以结构化形式(关系数据)存储非结构化数据开辟了一条全新的途径。然而，Oracle 并没有止步于简单地向 MySQL 添加 JSON 数据类型。Oracle 还增加了一个复杂的编程接口，以及将文档作为集合存储在数据库中的概念。我们将在下一章更多地讨论这些方面。在这一章中，我们将看到如何将 JSON 用于关系数据。

## 快速启动

如果您以前从未使用过 JSON，本节将帮助您入门。关于 JSON 及其在 MySQL 中的使用，您只需要了解一些东西，但最重要的是 JSON 格式化规则。

JSON 是由用括号括起来的字符串组成的，或者是用某些符号组织起来的。虽然我们已经讨论了与 JSON 相关的键、值机制，但是 JSON 属性有两种类型:由逗号分隔的列表形成的数组和由一组键、值对形成的对象。也可以嵌套 JSON 属性。例如，数组可以包含对象，对象键中的值可以包含数组或其他对象。JSON 数组和对象的组合称为 JSON 文档。

JSON 数组包含一个由逗号分隔并括在方括号(`[ ]`)中的值列表。例如，以下是有效的 JSON 数组。

```
["Cub Cadet", "Troy-Bilt", "John Deere", "Craftsman"]
[33,67,1,55,909]
[True, True, False, False]

```

注意，我们用方括号开始和结束数组，并用逗号分隔值。虽然我们没有使用空白，但是您可以使用空白，并且根据您的编程语言，您还可以使用换行符、制表符和回车符。例如，下面仍然是一个有效的 JSON 数组。

```
[
True,
12,
False,
33
]

```

JSON 对象是一组键/值对，其中每个键/值对都包含在左花括号和右花括号(`{ }`)中，并用逗号分隔。例如，以下是有效的 JSON 对象。注意，键地址有一个 JSON 对象作为它的值。

```
{"address": {
   "street": "123 First Street",
   "city": "Oxnard",
   "state": "CA",
   "zip": "90122"
}}

{"address": {
    "street":"4 Main Street",
    "city":"Melborne",
    "state":"California",
    "zip":"90125"
}}

```

JSON 数组通常用于包含相关(嗯，有时)事物的列表，JSON 对象用于描述复杂的数据。JSON 数组和对象可以包含标量值，比如字符串或数字、`null`文字(就像在关系数据中一样)，或者布尔文字`true`和`false`。请记住，键必须始终是字符串，并且通常用引号括起来。最后，JSON 值还可以包含时间信息(日期、时间或日期时间)。例如，下面显示了一个带有时间值的 JSON 数组。

```
["15:10:22.021100", "2019-03-23", "2019-03-23 08:51:29.012310"]

```

下一节将描述我们如何在 MySQL 中使用 JSON。在这种情况下，我们指的是关系数据，但是 JSON 文档的格式在文档存储中是相同的。

## 结合 SQL 和 JSON

对关系数据使用 JSON 可能看起来有点不寻常或反直觉。也就是说，为什么要在列中使用非结构化数据？这难道不违反一些关系数据库理论定律之类的吗？ <sup>[2](#Fn2)</sup> 虽然在某种程度上这可能是真的，但在我们的关系数据中添加非结构化数据的能力打开了以前关闭的几扇门。

例如，假设您需要为已经部署了一段时间的应用程序向现有表中添加更多数据。如果添加一个新列，就有可能需要修改所有使用该数据的应用程序。 <sup>[3](#Fn3) 目前为止没什么大不了的，对吧？但是，如果这些数据在类型和范围上都不同，也就是说，对于任何给定的一组行，添加的数据不能以相同的方式描述，或者每一行的数据都不同，该怎么办呢？这是非结构化数据的本质，它没有预定义的结构。因此，您不能轻松地扩展表，甚至不能创建新的引用(子)表。</sup>

这就是拥有 JSON 专栏有所帮助的地方。您只需添加一个新列，并将非结构化数据存储为 JSON。当然，这不会改变您必须更改应用程序的可能性，但是这确实意味着您不必重新调整数据库本身(除了添加 JSON 列之外)或者将数据强行放入一组类型化的列中。

在本节中，我们将了解如何在 MySQL 中使用 JSON，包括在 SQL 语句中包含 JSON 字符串的机制、MySQL 中可用于 JSON 的一些特殊函数、如何在 SQL 语句中访问 JSON 文档的部分内容，以及如何在关系数据中使用 JSON 列。我们将使用 shell 来演示这些主题。我们把使用纯 JSON 文档的工作留到下一章。

### 小费

MySQL Shell 在使用 JSON 方面有一些增强，包括以人类可读的形式显示 JSON 的能力。我们可以看到原始 JSON (json/raw)或打印精美的 JSON (json)的结果。对漂亮打印的 JSON 使用`--result-format=json`命令行选项，或者对无格式的 JSON 输出使用`--result-format=json/raw`命令行选项。

### 在 MySQL 中格式化 JSON 字符串

在 MySQL 中使用时，JSON 文档被写成字符串。MySQL 解析 JSON 数据类型中使用的任何字符串来验证文档。如果文档无效(不是格式正确的 JSON 文档)，您将得到一个错误。您可以在任何合适的 SQL 语句中使用 JSON 文档，比如`INSERT`和`UPDATE`语句以及像`WHERE`子句这样的子句。

### 小费

正确格式化 JSON 文档可能有点困难。最需要记住的是平衡你的引号，正确使用逗号，平衡所有的花括号和方括号。

当您将键和值指定为字符串时，必须使用双引号字符(`"`)，而不是单引号(`'`)。因为 MySQL 期望 JSON 文档是字符串，所以您可以在整个 JSON 文档中使用单引号，而不是在文档中使用单引号。幸运的是，MySQL 提供了许多特殊的函数，您可以在 JSON 文档中使用，其中一个是`JSON_VALID()`函数，它允许您检查 JSON 文档的有效性。如果文档有效，则返回 1，否则返回 0。下面显示了使用单引号验证键和值的 JSON 文档与使用双引号验证格式正确的 JSON 文档的结果。

### 注意

此后，为了简洁起见，我们将省略 shell SQL 提示符。

```
> SELECT JSON_VALID("{'vendor': {'name': 'Craftsman','URL': 'http://www.craftsman.com','sources': 'Lowes'}}") AS IS_VALID \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
IS_VALID: 0
1 row in set (0.0005 sec)

> SELECT JSON_VALID('{"vendor": {"name": "Craftsman","URL": "http://www.craftsman.com","sources": "Lowes"}}') AS IS_VALID \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
IS_VALID: 1
1 row in set (0.0040 sec)

```

请注意，带双引号的字符串是有效的(函数返回 1)，而带单引号的字符串是无效的(函数返回 0)。这是大多数人第一次使用 JSON 时最容易犯的错误。

### 在 SQL 语句中使用 JSON 字符串

让我们看看如何在 SQL 语句中使用 JSON 文档。假设我们想在一个表中存储地址。对于这个例子，我们将保持简单，将数据插入一个非常简单的表中。清单 [6-1](#PC10) 显示了从创建一个测试表开始，然后插入前两个地址的练习的抄本。

```
C:\Users\cbell> mysqlsh --uri root@localhost:33060 --sql
MySQL Shell 8.0.16
...
> CREATE DATABASE `testdb_6`;
Query OK, 1 row affected (0.0098 sec)

> USE `testdb_6`;
Query OK, 0 rows affected (0.0010 sec)

> CREATE TABLE `testdb_6`.`addresses` (`id` int(11) NOT NULL AUTO_INCREMENT, `address` json DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;
Query OK, 0 rows affected (0.0310 sec)

> INSERT INTO `testdb_6`.`addresses` VALUES (NULL, '{"address": {"street": "123 Second St","city": "Maynard","state": "CT","zip": "19023"}}');
Query OK, 1 row affected (0.0042 sec)

> INSERT INTO `testdb_6`.`addresses` VALUES (NULL, '{"address": {"street":"41 West Hanover","city":"Frederick","state":"Maryland","zip":"20445"}}');
Query OK, 1 row affected (0.0030 sec)

> SELECT ∗ FROM `testdb_6`.`addresses` \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
     id: 1
address: {"address": {"zip": "19023", "city": "Maynard", "state": "CT", "street": "123 Second St"}}
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 2\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
     id: 2
address: {"address": {"zip": "20445", "city": "Frederick", "state": "Maryland", "street": "41 West Hanover"}}
2 rows in set (0.0005 sec)

> DROP DATABASE `testdb_6`;
Query OK, 1 row affected (0.0132 sec)

Listing 6-1Using JSON with SQL Statements

```

注意，在`CREATE`语句中，我们使用了数据类型`JSON`。这通知 MySQL 在存储引擎中分配特殊的存储机制来处理 JSON。与一些报告相反，JSON 数据类型不仅仅是字符串的直接存储。相反，它是在内部组织的，以优化元素的检索。因此，正确格式化 JSON 非常重要。一个表中可以有多个 JSON 列。然而，一个表行中 JSON 文档的总和被限制为变量`max_allowed_packet`的值。

### 注意

JSON 列不能像其他列一样有默认值。

现在，让我们看看如果在 SQL 语句中使用无效的 JSON 文档(字符串)会发生什么。下面显示了插入上一个示例中的最后一个地址的尝试，只是没有在关键字周围加上正确的引号。请注意抛出的错误。

```
> INSERT INTO testdb_6.addresses VALUES (NULL, '{"address": {street:"173 Caroline Ave",city:"Monstrose",state:"Georgia",zip:31505}}');
ERROR: 3140: Invalid JSON text: "Missing a name for object member." at position 13 in value for column 'addresses.address'.

```

对于任何格式不正确的 JSON 文档，您都可能会看到这样或那样的错误。如果你想先测试你的 JSON，使用`JSON_VALID()`函数。然而，在构建 JSON 文档时，还有另外两个函数可能会有所帮助；`JSON_ARRAY()`和`JSON_OBJECT()`。

`JSON_ARRAY()`函数接受一个值列表，并返回一个有效的格式化 JSON 数组。下面显示了一个示例。注意，它返回了一个格式正确的 JSON 数组，带有正确的引号(双引号而不是单引号)和方括号。

```
> SELECT JSON_ARRAY(1, true, 'test', 2.4);
+----------------------------------------+
| JSON_ARRAY(1, true, 'test', 2.4) ------|
+----------------------------------------+
| [1, true, "test", 2.4]    ------       |
+----------------------------------------+
1 row in set (0.00 sec)

```

`JSON_OBJECT()`函数接受一个键、值对列表，并返回一个有效的 JSON 对象。下面显示了一个示例。注意这里我在调用函数时使用了单引号。这只是一个例子，我们可能会对使用哪种引语感到困惑。在这种情况下，函数的参数不是 JSON 文档；它们是普通的 SQL 字符串，可以使用单引号或双引号。

```
> SELECT JSON_OBJECT("street","4 Main Street","city","Melborne",'state','California','zip',90125) \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_OBJECT("street","4 Main Street","city","Melborne",'state','California','zip',90125): {"zip": 90125, "city": "Melborne", "state": "California", "street": "4 Main Street"}
1 row in set (0.0040 sec)

```

再次注意函数结果中引号的自动转换。如果您需要动态构建 JSON，这可能会很有帮助。

还有一个用于构造 JSON 文档的有用函数；`JSON_TYPE()`功能。这个函数获取一个 JSON 文档，并将其解析成一个 JSON 值。如果值有效，它将返回该值的 JSON 类型，如果无效，它将抛出一个错误。下面显示了该函数与前面语句的用法。

```
> SELECT JSON_TYPE('[1, true, "test", 2.4]');
+-------------------------------------------+
| JSON_TYPE('[1, true, "test", 2.4]')       |
+-------------------------------------------+
| ARRAY                                     |
+-------------------------------------------+
1 row in set (0.00 sec)

> SELECT JSON_TYPE('{"zip": 90125, "city": "Melborne", "state": "California", "street": "4 Main Street"}') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_TYPE('{"zip": 90125, "city": "Melborne", "state": "California", "street": "4 Main Street"}'): OBJECT
1 row in set (0.00 sec)

```

MySQL 提供了更多的函数来处理 JSON 数据类型。我们将在后面的章节中看到更多关于这些的内容。

本节只描述了在 SQL 语句中使用 JSON 和 MySQL 的基础知识。事实上，JSON 文档的格式化也适用于文档存储。然而，有一件事我们还没有谈到——如何访问 JSON 文档中的元素。

### 路径表达式

为了访问一个元素——通过它的键——我们使用一种叫做路径表达式的特殊符号。下面是一个简单的例子。请注意 WHERE 子句。这显示了一个路径表达式，其中我检查 address 列是否包含用特殊符号`address->'$.address.city'`引用的 JSON 键“city”。我们将在下一节看到更多关于路径表达式的细节。

```
> SELECT id, address->'$.address.city' FROM test.addresses
  WHERE address->'$.address.zip' = '90125';
+----+---------------------------+
| id | address->'$.address.city' |
+----+---------------------------+
|  2 | "Melborne"                |
+----+---------------------------+
1 row in set (0.00 sec)

```

如果您认为 JSON 文档可能是一组复杂的半结构化数据，并且在某些时候您需要访问文档中的某些元素，那么您可能还想知道如何从 JSON 文档中获得您想要的东西。幸运的是，有一种机制可以做到这一点，它被称为路径表达式。更具体地说，它是一种快捷表示法，您可以在 SQL 命令中使用它来获取元素，而无需额外的编程或脚本。

正如您将看到的，这是一种非常特殊的语法，虽然表达性不是很好(用英语读起来不是很好)，但这种符号可以让您无需大量额外输入就能得到您需要的东西。路径表达式以包含在字符串中的美元符号(`$`)开始。但是这个符号必须有一个上下文。在 SQL 语句中使用路径表达式时，必须使用`JSON_EXTRACT()`函数，它允许您使用路径表达式从 JSON 文档中提取数据。这是因为，与 X DevAPI 类和方法不同，并非所有 SQL 语句都直接支持路径表达式(但是我们将看到有些语句支持路径表达式)。例如，如果您想要数组中的第三个项目(在本例中是数字 3)，您可以如下使用该函数。

```
> SELECT JSON_EXTRACT('[1,2,3,4,5,6]', '$[2]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT('[1,2,3,4,5,6]', '$[2]'): 3
1 row in set (0.0049 sec)

```

注意这是访问 JSON 数组中的数据。在这里，我们使用一个数组下标，并在索引周围加上方括号(元素从 0 开始)，就像在许多编程语言中使用数组一样。

### 小费

SQL 接口中路径表达式的使用仅限于其中一个 JSON 函数，或者仅用于已被修改为接受路径表达式的特定子句，如`SELECT`列列表或`WHERE`、`HAVING`、`ORDER BY`或`GROUP BY`子句。

现在假设你想通过键访问一个元素。你也可以这样做。在这种情况下，我们使用美元符号后跟一个句点，然后是键名。下面显示了如何检索包含个人姓名和地址的 JSON 对象的姓氏。

```
> SELECT JSON_EXTRACT('{"name": {"first":"Billy-bob","last":"Throckmutton"},"address": {"street":"4 Main Street","city":"Melborne","state":"California","zip":"90125"}}', '$.name.first') AS Name \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
Name: "Billy-bob"
1 row in set (0.0008 sec)

```

请注意，我必须使用两个级别的访问权限。也就是说，我想要名为 name 的对象中名为 first 的键的值。于是，我用了“`$.name.first`”。这演示了如何使用路径表达式深入 JSON 文档。这也是为什么我们称之为路径表达式，因为我们形成表达式的方式给了我们到元素的“路径”。

现在我们已经看到了一些例子，让我们回顾一下路径表达式的完整语法；两者都在 SQL 和 NoSQL 接口中使用。除非另有说明，否则语法方面适用于两种接口。

再说一次，路径表达式以美元符号开始，后面可以有几种叫做选择器的语法形式，允许我们请求文档的一部分。这些选择器包括以下内容。

*   一个句点后跟一个键名，引用该键的值。如果不带引号的名称无效(要求引号是有效的标识符，如带空格的键名)，则必须在双引号内指定键名。

*   使用带有整数索引(`[n]`)的方括号来选择数组中的元素。索引从 0 开始。

*   路径可以包含通配符`*`或`**`，如下所示。
    *   `.[*]`计算 JSON 对象中所有成员的值。

    *   `[*]`计算 JSON 数组中所有元素的值。

    *   前缀∫后缀之类的序列计算以指定前缀开始并以指定后缀结束的所有路径。

*   可以使用句点作为分隔符来嵌套路径。在这种情况下，句点之后的路径在父路径上下文的上下文中进行评估。例如，`$.name.first`将名为 first 的键的搜索限制在名称 JSON 对象。

如果路径表达式被评估为 false 或无法定位数据项，服务器将返回 null。例如，以下返回 null，因为数组中只有 6 项。你能看出为什么吗？记住，计数从 0 开始。对于那些不熟悉使用路径表达式(或者编程语言中的数组)的人来说，这是一个常见的错误。

```
> SELECT JSON_EXTRACT('[1,2,3,4,5,6]', '$[6]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT('[1,2,3,4,5,6]', '$[6]'): NULL
1 row in set (0.0008 sec)

```

但是等等，路径表达式还有一个更好的选择。我们可以走捷径！也就是说，当按列访问 SQL 语句中的数据时，可以使用破折号和大于号(`->`)来代替`JSON_EXTRACT()`函数。多酷啊。使用`->`操作有时被称为“内嵌路径表达式”。例如，我们可以编写前面的示例，从一个表中查找 JSON 数组中的第三个项目，如下所示。

```
> CREATE TABLE testdb_6.ex1 (id int AUTO_INCREMENT PRIMARY KEY, recorded_data JSON);
Query OK, 0 rows affected (0.0405 sec)
> INSERT INTO testdb_6.ex1 VALUES (NULL, JSON_ARRAY(1,2,3,4,5,6));
Query OK, 1 row affected (0.0052 sec)
> INSERT INTO testdb_6.ex1 VALUES (NULL, JSON_ARRAY(7,8,9));
> SELECT ∗ FROM testdb_6.ex1 WHERE recorded_data->'$[2]' = 3 \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
           id: 1
recorded_data: [1, 2, 3, 4, 5, 6]
1 row in set (0.0045 sec)

```

注意，我只是使用了列名`recorded_data`，并在末尾添加了`->`，然后列出了路径表达式。太棒了！

但是等等，还有更多。这种捷径还有一种形式。如果`->`操作(`JSON_EXTRACT`)的结果是一个带引号的字符串，我们可以使用`->>`符号(称为内嵌路径操作符)来检索不带引号的值。这在处理数值时很有帮助。下面给出了两个例子。一个与`->`操作相同，一个与`->>`操作相同。

```
> INSERT INTO testdb_6.ex1 VALUES (NULL, '{"name":"will","age":"43"}');
Query OK, 1 row affected (0.00 sec)
> INSERT INTO testdb_6.ex1 VALUES (NULL, '{"name":"joseph","age":"11"}');
Query OK, 1 row affected (0.00 sec)
> SELECT ∗ FROM testdb_6.ex1 WHERE recorded_data->>'$.age' = 43 \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
           id: 3
recorded_data: {"age": "43", "name": "will"}
1 row in set (0.0014 sec)
> SELECT ∗ FROM testdb_6.ex1 WHERE recorded_data->'$.age' = '43' \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
           id: 3
recorded_data: {"age": "43", "name": "will"}
1 row in set (0.0009 sec)

```

注意，`recorded_data`值(年龄和姓名)被存储为一个字符串。但是如果数据存储为整数会怎么样呢？观察。

```
> INSERT INTO testdb_6.ex1 VALUES (NULL, '{"name":"amy","age":22}');
Query OK, 1 row affected (0.0075 sec)
> SELECT ∗ FROM testdb_6.ex1 WHERE recorded_data->'$.age' = 22 \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
           id: 5
recorded_data: {"age": 22, "name": "amy"}
1 row in set (0.0010 sec)
> SELECT ∗ FROM testdb_6.ex1 WHERE recorded_data->>'$.age' = 22 \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
           id: 5
recorded_data: {"age": 22, "name": "amy"}
1 row in set (0.0009 sec)

```

啊哈！因此，当值必须不加引号时，`->>`操作最有用。如果它们已经被取消引用(比如一个整数)，那么`->>`操作将返回与`->`操作相同的结果。

请注意，快捷方式(内嵌路径表达式)的使用并不能直接替代`JSON_EXTRACT()`功能。下面总结了这些限制。

*   *数据源*:在 SQL 语句中使用时，内嵌路径表达式只使用指定的字段(列)。该函数可以使用任何 JSON 类型的值。

*   *路径表达式字符串*:内嵌路径表达式必须使用普通字符串。该函数可以使用任何字符串类型的值。

*   *表达式数量*:内联路径表达式只能对单个字段(列)使用一个路径表达式。该函数可以对一个 JSON 文档使用多个路径表达式。

现在让我们看看可以用来处理 JSON 文档的各种 JSON 函数。

### JSON 函数

在 MySQL 中有许多使用 JSON 的函数。我们不会列出所有的功能和过时的风险(似乎每个版本都会添加新的功能)，而是列出一些最常用的功能，让您了解哪些功能可用。虽然我们不会探究每个函数的细微差别，但我们会在后面的章节中看到其中一些函数的使用。表 [6-1](#Tab1) 列出了 MySQL 8 中可用的 JSON 函数。

掌握这些函数对于使用文档存储来说并不重要，但是在开发混合解决方案(在 SQL 语句中使用 JSON)时会有很大帮助。

这些功能可以根据它们的使用方式进行分类。我们将看到对添加数据有用的函数，检索(搜索)数据的函数，等等。下面用简单的例子说明如何使用这些功能。

表 6-1

MySQL 中常用的 JSON 函数

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

功能

 | 

描述和使用

 |
| --- | --- |
| `JSON_ARRAY()` | 评估值列表并返回包含这些值的 JSON 数组。 |
| `JSON_ARRAYAGG()` | 将结果集聚合为一个 JSON 数组，其元素由行组成。 |
| `JSON_ARRAY_APPEND()` | 将值追加到 JSON 文档中指定数组的末尾，并返回结果。 |
| `JSON_ARRAY_INSERT()` | 更新一个 JSON 文档，插入到文档内的一个数组中，并返回修改后的文档。 |
| `JSON_CONTAINS()` | 返回 0 或 1 以指示特定值是否包含在目标 JSON 文档中，或者，如果给定了路径参数，则返回目标文档中特定路径的值。 |
| `JSON_CONTAINS_PATH()` | 返回 0 或 1，以指示 JSON 文档是否包含给定路径中的数据。 |
| `JSON_DEPTH()` | 返回 JSON 文档的最大深度。 |
| `JSON_EXTRACT()` | 从 JSON 文档中返回数据，这些数据是从与路径参数匹配的文档部分中选择的。 |
| `JSON_INSERT()` | 将数据插入 JSON 文档并返回结果。 |
| `JSON_KEYS()` | 以 JSON 数组的形式返回 JSON 对象的顶级值的键，或者，如果给定了路径参数，则返回所选路径的顶级键。 |
| `JSON_LENGTH()` | 返回 JSON 文档的长度，或者，如果给定了路径参数，则返回由路径标识的文档中的值的长度。 |
| `JSON_OBJECT()` | 评估键/值对列表，并返回包含这些对的 JSON 对象。 |
| `JSON_OBJECTAGG()` | 接受两个列名或表达式作为参数，第一个用作键，第二个用作值，并返回包含键/值对的 JSON 对象。 |
| `JSON_PRETTY()` | 打印一个更好看的 JSON 文档布局。 |
| `JSON_QUOTE()` | 通过用双引号字符将字符串括起来并转义内部引号和其他字符，将字符串作为 JSON 值引用，然后将结果作为 utf8mb4 字符串返回。 |
| `JSON_REMOVE()` | 从 JSON 文档中移除数据并返回结果。 |
| `JSON_REPLACE()` | 替换 JSON 文档中的现有值并返回结果。 |
| `JSON_SEARCH()` | 返回 JSON 文档中给定字符串的路径。 |
| `JSON_SET()` | 在 JSON 文档中插入或更新数据，并返回结果。 |
| `JSON_TABLE()` | 从 JSON 文档中提取数据，并将其作为关系表返回。 |
| `JSON_TYPE()` | 返回一个 utf8mb4 字符串，指示 JSON 值的类型。 |
| `JSON_VALID()` | 返回 0 或 1 以指示值是否是有效的 JSON 文档。 |

#### 创建 JSON 数据

创建 JSON 数据有几个有用的函数。我们已经看到了两个重要的函数:`JSON_ARRAY()`构建 JSON 数组类型，而`JSON_OBJECT()`构建 JSON 对象类型。本节讨论一些其他函数，这些函数可以用来帮助创建 JSON 文档，包括在 JSON 数组中聚合、追加和插入数据的函数。

`JSON_ARRAYAGG()`函数用于从几行中创建一个 JSON 文档数组。当您想要汇总数据或合并多行数据时，它会很有帮助。该函数接受一个列名，并将行中的 JSON 数据组合到一个新数组中。清单 [6-2](#PC22) 展示了使用该函数的例子。这个示例获取表中的行，并将它们组合起来形成一个新的 JSON 对象数组。

```
> CREATE TABLE testdb_6.favorites (id int(11) NOT NULL AUTO_INCREMENT, preferences JSON, PRIMARY KEY (`id`));
> INSERT INTO testdb_6.favorites VALUES (NULL, '{"color": "red"}');
Query OK, 1 row affected (0.0077 sec)
> INSERT INTO testdb_6.favorites VALUES (NULL, '{"color": "blue"}');
Query OK, 1 row affected (0.0050 sec)
> INSERT INTO testdb_6.favorites VALUES (NULL, '{"color": "purple"}');
Query OK, 1 row affected (0.0034 sec)
> SELECT ∗ FROM testdb_6.favorites \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
         id: 1
preferences: {"color": "red"}
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 2\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
         id: 2
preferences: {"color": "blue"}
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 3\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
         id: 3
preferences: {"color": "purple"}
3 rows in set (0.0012 sec)
> SELECT JSON_ARRAYAGG(preferences) FROM testdb_6.favorites \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_ARRAYAGG(preferences): [{"color": "red"}, {"color": "blue"}, {"color": "purple"}]
1 row in set (0.0049 sec)

Listing 6-2Using the JSON_ARRAYARG Function

```

`JSON_ARRAY_APPEND()`是一个有趣的函数，它允许您将数据附加到 JSON 数组的末尾或紧接在给定路径表达式之后。该函数将 JSON 数组、路径表达式和要插入的值(包括 JSON 文档)作为参数。清单 [6-3](#PC23) 展示了几个例子。

```
> SET @base = '["apple","pear",{"grape":"red"},"strawberry"]';
Query OK, 0 rows affected (0.0045 sec)
> SELECT JSON_ARRAY_APPEND(@base, '$', "banana") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_ARRAY_APPEND(@base, '$', "banana"): ["apple", "pear", {"grape": "red"}, "strawberry", "banana"]
1 row in set (0.0009 sec)
> SELECT JSON_ARRAY_APPEND(@base, '$[2].grape', "green") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_ARRAY_APPEND(@base, '$[2].grape', "green"): ["apple", "pear", {"grape": ["red", "green"]}, "strawberry"]
1 row in set (0.0012 sec)
> SET @base = '{"grape":"red"}';
Query OK, 0 rows affected (0.0004 sec)
> SELECT JSON_ARRAY_APPEND(@base, '$', '{"grape":"red"}') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_ARRAY_APPEND(@base, '$', '{"grape":"red"}'): [{"grape": "red"}, "{\"grape\":\"red\"}"]
1 row in set (0.0007 sec)

Listing 6-3Using the JSON_ARRAY_APPEND Function

```

请注意，第一个示例只是在数组末尾添加了一个新值。第二个示例将第三个索引中 JSON 对象的键值更改为一个数组，并添加一个新值。这是这个函数的一个有趣的副产品。在第三个例子中，我们再次看到了这一点，我们将一个基本的 JSON 对象更改为一个 JSON 对象的 JSON 数组。

`JSON_ARRAY_INSERT()`函数类似，只是它在路径表达式前插入值。该函数将 JSON 数组、路径表达式和要插入的值(包括 JSON 文档)作为参数。当包含多个路径表达式和值对时，当函数计算第一个路径表达式和值并将下一个对应用于结果时，效果是累积的，依此类推。清单 [6-4](#PC24) 展示了一些使用新函数的例子，和前面的例子很相似。请注意，插入数据的位置在路径表达式之前。

```
> SET @base = '["apple","pear",{"grape":["red","green"]},"strawberry"]';
Query OK, 0 rows affected (0.0007 sec)
> SELECT JSON_ARRAY_INSERT(@base, '$[0]', "banana") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_ARRAY_INSERT(@base, '$[0]', "banana"): ["banana", "apple", "pear", {"grape": ["red", "green"]}, "strawberry"]
1 row in set (0.0008 sec)
> SELECT JSON_ARRAY_INSERT(@base, '$[2].grape[0]', "white") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_ARRAY_INSERT(@base, '$[2].grape[0]', "white"): ["apple", "pear", {"grape": ["white", "red", "green"]}, "strawberry"]
1 row in set (0.0009 sec)
> SET @base = '[{"grape":"red"}]';
Query OK, 0 rows affected (0.0004 sec)
> SELECT JSON_ARRAY_INSERT(@base, '$[0]', '{"grape":"red"}') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_ARRAY_INSERT(@base, '$[0]', '{"grape":"red"}'): ["{\"grape\":\"red\"}", {"grape": "red"}]
1 row in set (0.0007 sec)

Listing 6-4Using the JSON_ARRAY_INSERT Function

```

`JSON_INSERT()`函数被设计成获取一个 JSON 文档，并在指定的路径表达式中插入一个或多个值。也就是说，您可以一次传递成对的路径表达式和值。但是有一个问题。在这种情况下，路径表达式不能计算为文档中的元素。像上一个函数一样，当包含多个路径表达式时，效果是累积的，其中函数计算第一个路径表达式，将下一个路径表达式应用于结果，依此类推。清单 [6-5](#PC25) 给出了一个例子。请注意，没有插入第三个路径表达式和值，因为路径表达式`$[0]`的计算结果是第一个元素 apple。

```
> SET @base = '["apple","pear",{"grape":["red","green"]},"strawberry"]';
Query OK, 0 rows affected (0.0007 sec)
> SELECT JSON_INSERT(@base, '$[9]', "banana", '$[2].grape[3]', "white", '$[0]', "orange") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_INSERT(@base, '$[9]', "banana", '$[2].grape[3]', "white", '$[0]', "orange"): ["apple", "pear", {"grape": ["red", "green", "white"]}, "strawberry", "banana"]
1 row in set (0.0008 sec)

Listing 6-5Using the JSON_INSERT Function

```

`JSON_MERGE_PATCH()`和`JSON_MERGE_PRESERVE()`函数被设计成获取两个或更多的 JSON 文档并将它们组合起来。`JSON_MERGE_PATH()`功能替换重复键的值，而`JSON_MERGE_PRESERVE()`保留重复键的值。像最后一个函数一样，您可以包含任意多的 JSON 文档。注意我是如何使用这个函数从前面的例子中构建示例 JSON 文档的。清单 [6-6](#PC26) 展示了一个使用这些方法的例子。

```
> SELECT JSON_MERGE_PATCH('["apple","pear"]', '{"grape":["red","green"]}', '["strawberry"]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_MERGE_PATCH('["apple","pear"]', '{"grape":["red","green"]}', '["strawberry"]'): ["strawberry"]
1 row in set (0.0041 sec)
> SELECT JSON_MERGE_PRESERVE('{"grape":["red","green"]}', '{"grape":["white"]}') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_MERGE_PRESERVE('{"grape":["red","green"]}', '{"grape":["white"]}'): {"grape": ["red", "green", "white"]}
1 row in set (0.0008 sec)

Listing 6-6Using the JSON_MERGE_PATCH and JSON_MERGE_PRESERVE Functions

```

如果向任何 JSON 函数传递了无效的参数、无效的 JSON 文档，或者路径表达式没有找到元素，则一些函数会返回 null，而其他函数可能会返回原始的 JSON 文档。清单 [6-7](#PC27) 给出了一个例子。在这种情况下，位置 8 没有元素，因为数组只有 4 个元素。

```
> SET @base = '["apple","pear",{"grape":"red"},"strawberry"]' \G
Query OK, 0 rows affected (0.0007 sec)
> SELECT JSON_ARRAY_APPEND(@base, '$[7]', "flesh") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_ARRAY_APPEND(@base, '$[7]', "flesh"): ["apple", "pear", {"grape": "red"}, "strawberry"]
1 row in set (0.0007 sec)

Listing 6-7Using the JSON_ARRAY_APPEND Function

```

现在让我们看看可以用来修改 JSON 数据的函数。

#### 修改 JSON 数据

修改 JSON 数据有几个有用的函数。本节讨论了通过删除、替换和更新 JSON 文档中的元素来帮助修改 JSON 文档的函数。

`JSON_REMOVE()`函数用于删除匹配路径表达式的元素。您必须提供要操作的 JSON 文档以及一个或多个路径表达式，结果将是删除了元素的 JSON 文档。当包含多个路径表达式时，当函数计算第一个路径表达式并将下一个路径表达式应用于结果时，效果是累积的，依此类推。清单 [6-8](#PC28) 给出了一个例子。注意，我必须想象中间结果是什么——也就是说，我使用了$[0]三次，因为该函数删除了第一个元素两次，留下 JSON 对象作为第一个元素。

```
 > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.0008 sec)
> SELECT JSON_REMOVE(@base, '$[0]', '$[0]', '$[0].grape[1]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_REMOVE(@base, '$[0]', '$[0]', '$[0].grape[1]'): [{"grape": ["red"]}, "strawberry"]
1 row in set (0.0009 sec)

Listing 6-8Using the JSON_REMOVE Function (single)

```

这可能需要一点时间来适应，但您可以多次使用该函数或嵌套使用，如清单 [6-9](#PC29) 中的示例所示。

```
 > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.0007 sec)
> SET @base = JSON_REMOVE(@base, '$[0]');
Query OK, 0 rows affected (0.0009 sec)
> SET @base = JSON_REMOVE(@base, '$[0]');
Query OK, 0 rows affected (0.0006 sec)
> SELECT JSON_REMOVE(@base, '$[0].grape[1]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_REMOVE(@base, '$[0].grape[1]'): [{"grape": ["red"]}, "strawberry"]
1 row in set (0.0007 sec)
> SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.0004 sec)
> SELECT JSON_REMOVE(JSON_REMOVE(JSON_REMOVE(@base, '$[0]'), '$[0]'), '$[0].grape[1]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_REMOVE(JSON_REMOVE(JSON_REMOVE(@base, '$[0]'), '$[0]'), '$[0].grape[1]'): [{"grape": ["red"]}, "strawberry"]
1 row in set (0.0005 sec)

Listing 6-9Using the JSON_REMOVE Function (nested)

```

`JSON_REPLACE()`函数接受一个 JSON 文档和一对路径表达式和值，用新值替换匹配路径表达式的元素。同样，结果是累积的，并且从左到右按顺序工作。这个函数也有一个问题。它会忽略任何新值或评估为新值的路径表达式。清单 [6-10](#PC30) 给出了一个例子。请注意，第三对没有被删除，因为没有第十个元素。

```
 > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.0008 sec)
> SELECT JSON_REPLACE(@base, '$[0]', "orange", '$[2].grape[0]', "green", '$[9]', "waffles") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_REPLACE(@base, '$[0]', "orange", '$[2].grape[0]', "green", '$[9]', "waffles"): ["orange", "pear", {"grape": ["green", "white"]}, "strawberry"]
1 row in set (0.0040 sec)

Listing 6-10Using the JSON_REPLACE Function

```

`JSON_SET()`函数用于修改 JSON 文档元素。像其他函数一样，您传递一个 JSON 文档作为第一个参数，然后传递一对或多对要替换的路径表达式和值。但是，该函数还会插入文档中不存在的任何元素(找不到路径表达式)。清单 [6-11](#PC31) 给出了一个例子。注意，最后一个元素并不存在，所以它将它添加到文档中。

```
 > SET @base = '["apple","pear",{"grape":["red","white"]},"strawberry"]';
Query OK, 0 rows affected (0.0007 sec)
> SELECT JSON_SET(@base, '$[0]', "orange", '$[2].grape[1]', "green", '$[9]', "123") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_SET(@base, '$[0]', "orange", '$[2].grape[1]', "green", '$[9]', "123"): ["orange", "pear", {"grape": ["red", "green"]}, "strawberry", "123"]
1 row in set (0.0009 sec)

Listing 6-11Using the JSON_SET Function

```

现在让我们看看可以用来在文档中查找元素的 JSON 函数。

#### 搜索 JSON 数据

处理 SQL 和 JSON 数据的另一个重要操作是在 JSON 文档中搜索数据。在本章的前面，我们发现了如何用特殊符号(路径表达式)引用文档中的数据，我们还了解到可以使用 JSON 函数来搜索数据。事实上，我们在上一节中看到了这两个概念一起使用。在这一节中，我们将回顾 JSON 数据搜索机制，因为您可能会比其他任何函数更多地使用这些函数，尤其是在查询中。

有四个 JSON 函数允许您搜索 JSON 文档。与前面的函数一样，这些函数使用一个或多个参数对 JSON 文档进行操作。我称它们为搜索函数，不是因为它们允许您在数据库或表格中搜索 JSON 数据，而是因为它们允许您在 JSON 文档中查找东西。这些函数包括检查文档中是否存在值或元素、路径表达式是否有效(使用它可以找到一些东西)以及从文档中检索信息的函数。

`JSON_CONTAINS()`函数有两个选项:您可以使用它来返回一个值是否存在于文档中的任何地方，或者是否存在使用路径表达式的值(路径表达式是一个可选参数)。该函数返回 0 或 1，其中 0 表示未找到该值。如果文档参数不是有效的 JSON 文档，或者路径参数不是有效的路径表达式，或者包含`∗`或`∗∗`通配符，则会出现错误。还有一个问题。传入的值必须是有效的 JSON 字符串或文档。清单 [6-12](#PC32) 展示了使用该函数搜索 JSON 文档的几个例子。

```
> SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberry"]}';
Query OK, 0 rows affected (0.0007 sec)
> SELECT JSON_CONTAINS(@base,'["red","white","green"]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS(@base,'["red","white","green"]'): 0
1 row in set (0.0010 sec)
> SELECT JSON_CONTAINS(@base,'{"grapes":["red","white","green"]}') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS(@base,'{"grapes":["red","white","green"]}'): 1
1 row in set (0.0006 sec)
> SELECT JSON_CONTAINS(@base,'["red","white","green"]','$.grapes') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS(@base,'["red","white","green"]','$.grapes'): 1
1 row in set (0.0004 sec)
> SELECT JSON_CONTAINS(@base,'"blackberry"','$.berries') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS(@base,'"blackberry"','$.berries'): 0
1 row in set (0.0004 sec)
> SELECT JSON_CONTAINS(@base,'blackberry','$.berries') \G
ERROR: 3141: Invalid JSON text in argument 2 to function json_contains: "Invalid value." at position 0.
> SELECT JSON_CONTAINS(@base,'"red"','$.grapes') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS(@base,'"red"','$.grapes'): 1
1 row in set (0.0004 sec)

Listing 6-12Using the JSON_CONTAINS Function

```

正如你所看到的，这是一个非常有用的函数，但是要正确使用它需要一点小心。也就是说，您必须确保该值是有效的字符串。在所有的例子中，除了一个例子，我使用路径表达式在 JSON 文档中搜索 JSON 文档(这样可以更容易地搜索嵌套数据)或单个值。记住，函数搜索的是值，而不是键。

注意倒数第二个例子。这将返回一个错误，因为该值不是有效的 JSON 字符串。您必须用双引号将它括起来，如下例所示。

`JSON_CONTAINS_PATH()`函数使用的参数策略略有不同。该函数搜索 JSON 文档以查看路径表达式是否存在，但它也允许您查找第一个或所有的匹配项。它还可以采用多个路径，并根据您作为第二个参数传递的值，将它们作为“或”或“与”条件进行计算，如下所示。

*   如果您传递一个，如果至少找到一个路径表达式(或)，函数将返回 1。

*   如果传递 all，则只有找到所有路径表达式时，函数才会返回 1(和)。

该函数返回 0 或 1，以指示 JSON 文档在给定的一个或多个路径中是否包含数据。请注意，如果任何路径表达式或文档为 null，它可能会返回 null。如果 JSON 文档或任何路径表达式无效，或者第二个参数不是 one 或 all，则会发生错误。清单 [6-13](#PC33) 展示了使用该函数的几个例子。

```
> SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.0004 sec)
> SELECT JSON_CONTAINS_PATH(@base,'one','$') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'one','$'): 1
1 row in set (0.0005 sec)
> SELECT JSON_CONTAINS_PATH(@base,'all','$') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'all','$'): 1
1 row in set (0.0005 sec)
> SELECT JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries'): 1
1 row in set (0.0004 sec)
> SELECT JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries','$.numbers')\G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries','$.numbers'): 1
1 row in set (0.0004 sec)
> SELECT JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries','$.num') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'all','$.grapes','$.berries','$.num'): 0
1 row in set (0.0005 sec)
> SELECT JSON_CONTAINS_PATH(@base,'one','$.grapes','$.berries','$.num') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'one','$.grapes','$.berries','$.num'): 1
1 row in set (0.0005 sec)
> SELECT JSON_CONTAINS_PATH(@base,'one','$.grapes') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'one','$.grapes'): 1
1 row in set (0.0004 sec)
> SELECT JSON_CONTAINS_PATH(@base,'all','$.grape') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'all','$.grape'): 0
1 row in set (0.0004 sec)
> SELECT JSON_CONTAINS_PATH(@base,'one','$.berries') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'one','$.berries'): 1
1 row in set (0.0004 sec)
> SELECT JSON_CONTAINS_PATH(@base,'all','$.berries') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_CONTAINS_PATH(@base,'all','$.berries'): 1
1 row in set (0.0005 sec)

Listing 6-13Using the JSON_CONTAINS_PATH Function

```

花些时间浏览这些例子，这样你就能明白它们是如何工作的。注意在前两个例子中，我使用了一个美元符号的路径表达式。这只是整个文档的路径表达式，所以它自然存在。还要注意最后两个例子中使用 one 或 all 的区别。

`JSON_EXTRACT()`功能是最常用的功能之一。它允许你提取一个值或 JSON 数组或 JSON 对象等。使用一个或多个路径表达式从 JSON 文档中。我们已经看到了几个例子。Recall 函数返回 JSON 文档中与路径表达式匹配的部分。清单 [6-14](#PC34) 展示了更多使用复杂路径表达式的例子。

```
> SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.0004 sec)
> SELECT JSON_EXTRACT(@base,'$') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT(@base,'$'): {"grapes": ["red", "white", "green"], "berries": ["strawberry", "raspberry", "boysenberry", "blackberry"], "numbers": ["1", "2", "3", "4", "5"]}
1 row in set (0.0006 sec)
> SELECT JSON_EXTRACT(@base,'$.grapes') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT(@base,'$.grapes'): ["red", "white", "green"]
1 row in set (0.0005 sec)
> SELECT JSON_EXTRACT(@base,'$.grapes[∗]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT(@base,'$.grapes[∗]'): ["red", "white", "green"]
1 row in set (0.0005 sec)
> SELECT JSON_EXTRACT(@base,'$.grapes[1]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT(@base,'$.grapes[1]'): "white"
1 row in set (0.0005 sec)
> SELECT JSON_EXTRACT(@base,'$.grapes[4]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT(@base,'$.grapes[4]'): NULL
1 row in set (0.0006 sec)
> SELECT JSON_EXTRACT(@base,'$.berries') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT(@base,'$.berries'): ["strawberry", "raspberry", "boysenberry", "blackberry"]
1 row in set (0.0009 sec)
> SELECT JSON_EXTRACT(@base,'$.berries[2]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT(@base,'$.berries[2]'): "boysenberry"
1 row in set (0.0005 sec)
> SELECT JSON_EXTRACT(@base,'$.berries[2]','$.berries[3]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_EXTRACT(@base,'$.berries[2]','$.berries[3]'): ["boysenberry", "blackberry"]
1 row in set (0.0006 sec)

Listing 6-14Using the JSON_EXTRACT Function

```

注意当我们使用一元符号时会发生什么。该函数返回整个文档。另外，注意当我们使用一个路径表达式时会发生什么，尽管它的语法是有效的，但它并不等于文档中的一个元素(参见第五个例子)。

还要注意最后一个例子，我们传入了两个路径表达式。注意它是如何返回一个 JSON 数组的，而之前只有一个路径表达式的例子返回一个 JSON 字符串值。这是该函数的一个更棘手的方面。只要您记得它返回一个有效的 JSON 字符串、数组或对象，您就可以毫无问题地使用该函数。

`JSON_SEARCH()`函数很有趣，因为它与`JSON_EXTRACT()`函数相反。更具体地说，它接受一个或多个值，如果在文档中找到这些值，则返回这些值的路径表达式。这使得验证路径表达式或动态构建路径表达式变得更加容易。

像`JSON_CONTAINS_PATH()`函数一样，`JSON_SEARCH()`函数也允许您根据作为第二个参数传递的值来查找返回路径表达式的第一个或所有匹配项，如下所示。

*   如果传递一个，函数将返回第一个匹配。

*   如果通过 all，该函数将返回所有匹配项。

但是这里也有一个技巧。该函数接受第三个参数，该参数构成一个特殊的搜索字符串，其工作方式类似于 SQL 语句中的`LIKE`操作符。也就是说，搜索字符串参数可以像使用`LIKE`操作符一样使用`%`和`_`字符。注意，要将`%`或`_`用作文字，必须在它前面加上`\`(转义)字符。

该函数返回 0 或 1，以指示 JSON 文档是否包含这些值。请注意，如果任何路径表达式或文档为 null，它可能会返回 null。如果 JSON 文档或任何路径表达式无效，或者第二个参数不是 one 或 all，则会发生错误。清单 [6-15](#PC35) 展示了使用该函数的几个例子。

```
> SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.0011 sec)
> SELECT JSON_SEARCH(@base,'all','red') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_SEARCH(@base,'all','red'): "$.grapes[0]"
1 row in set (0.0006 sec)
> SELECT JSON_SEARCH(@base,'all','gr____') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_SEARCH(@base,'all','gr____'): NULL
1 row in set (0.0004 sec)
> SELECT JSON_SEARCH(@base,'one','%berry') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_SEARCH(@base,'one','%berry'): "$.berries[0]"
1 row in set (0.0005 sec)
> SELECT JSON_SEARCH(@base,'all','%berry') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_SEARCH(@base,'all','%berry'): ["$.berries[0]", "$.berries[1]", "$.berries[2]", "$.berries[3]"]
1 row in set (0.0006 sec)

Listing 6-15Using the JSON_SEARCH Function

```

现在我们来看最后一组 JSON 函数；这些工具本质上是实用的，允许您获得关于 JSON 文档的信息，并执行简单的操作来帮助处理 JSON 文档。

#### 效用函数

最后，有几个函数可以返回关于 JSON 文档的信息，帮助添加或删除引号，甚至查找文档中的键。我们已经看到了几个实用程序`JSON_TYPE()`和`JSON_VALID()`函数。以下是在使用 JSON 文档时可能会发现有用的其他实用函数。

`JSON_DEPTH()`函数返回 JSON 文档的最大深度。如果文档是空数组、对象或标量值，则该函数返回深度 1。仅包含深度为 1 的元素的数组或仅包含深度为 1 的成员值的非空对象返回深度为 2 的值。清单 [6-16](#PC36) 展示了几个例子。

```
> SELECT JSON_DEPTH('8') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_DEPTH('8'): 1
1 row in set (0.0017 sec)
> SELECT JSON_DEPTH('[]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_DEPTH('[]'): 1
1 row in set (0.0007 sec)
> SELECT JSON_DEPTH('{}') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_DEPTH('{}'): 1
1 row in set (0.0007 sec)
> SELECT JSON_DEPTH('[12,3,4,5,6]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_DEPTH('[12,3,4,5,6]'): 2
1 row in set (0.0008 sec)
> SELECT JSON_DEPTH('[[], {}]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_DEPTH('[[], {}]'): 2
1 row in set (0.0004 sec)
> SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.0004 sec)
> SELECT JSON_DEPTH(@base) \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_DEPTH(@base): 3
1 row in set (0.0004 sec) 

> SELECT JSON_DEPTH(JSON_EXTRACT(@base, '$.grapes')) \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_DEPTH(JSON_EXTRACT(@base, '$.grapes')): 2
1 row in set (0.0005 sec)

Listing 6-16Using the JSON_DEPTH Function

```

`JSON_KEYS()`函数用于以 JSON 数组的形式从 JSON 对象的顶层值返回一个键列表。该函数还允许您传递路径表达式，这将产生所选路径表达式值的顶级键列表。如果`json_doc`参数不是有效的 JSON 文档，或者路径参数不是有效的路径表达式，或者包含`∗`或`∗∗`通配符，则会出现错误。如果所选对象为空，则结果数组为空。

有一个限制。如果顶层值有嵌套的 JSON 对象，则返回的数组不包括这些嵌套对象的键。清单 [6-17](#PC37) 显示了使用该功能的几个例子。

```
> SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.0004 sec)
> SELECT JSON_KEYS(@base) \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_KEYS(@base): ["grapes", "berries", "numbers"]
1 row in set (0.0039 sec)
> SELECT JSON_KEYS(@base,'$') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_KEYS(@base,'$'): ["grapes", "berries", "numbers"]
1 row in set (0.0005 sec)
> SELECT JSON_KEYS('{"z":123,"x":{"albedo":50}}') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_KEYS('{"z":123,"x":{"albedo":50}}'): ["x", "z"]
1 row in set (0.0004 sec)
> SELECT JSON_KEYS('{"z":123,"x":{"albedo":50}}', '$.x') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_KEYS('{"z":123,"x":{"albedo":50}}', '$.x'): ["albedo"]
1 row in set (0.0004 sec)

Listing 6-17Using the JSON_KEYS Function

```

`JSON_LENGTH()`函数返回传递的 JSON 文档的长度。它还允许您传入路径表达式，如果提供了路径表达式，将返回与路径表达式匹配的值的长度。如果`json_doc`参数不是有效的 JSON 文档，或者路径参数不是有效的路径表达式，或者包含`*`或`**`通配符，则会出现错误。但是，返回值有如下几个约束。

*   标量的长度为 1。

*   数组的长度等于数组元素的数量。

*   对象的长度等于对象成员的数量。

然而，有一个令人惊讶的限制:返回的长度不包括嵌套数组或对象的长度。因此，使用嵌套文档的路径表达式时，必须小心使用该函数。清单 [6-18](#PC38) 显示了使用该函数的几个例子。

```
> SET @base = '{"grapes":["red","white","green"],"berries":["strawberry","raspberry","boysenberry","blackberry"],"numbers":["1","2","3","4","5"]}';
Query OK, 0 rows affected (0.0006 sec)
> SELECT JSON_LENGTH(@base,'$') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_LENGTH(@base,'$'): 3
1 row in set (0.0005 sec)
> SELECT JSON_LENGTH(@base,'$.grapes') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_LENGTH(@base,'$.grapes'): 3
1 row in set (0.0005 sec)
> SELECT JSON_LENGTH(@base,'$.grapes[1]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_LENGTH(@base,'$.grapes[1]'): 1
1 row in set (0.0005 sec)
> SELECT JSON_LENGTH(@base,'$.grapes[4]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_LENGTH(@base,'$.grapes[4]'): NULL
1 row in set (0.0004 sec)
> SELECT JSON_LENGTH(@base,'$.berries') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_LENGTH(@base,'$.berries'): 4
1 row in set (0.0004 sec)
> SELECT JSON_LENGTH(@base,'$.numbers') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_LENGTH(@base,'$.numbers'): 5
1 row in set (0.0005 sec)

Listing 6-18Using the JSON_LENGTH Function

```

请注意，第四个示例返回 null，因为路径表达式虽然是有效的语法，但并不等于值或嵌套的 JSON 数组或对象。

`JSON_QUOTE()`函数是一个方便的函数，可以帮助你在适当的地方添加引号。也就是说，该函数通过用双引号字符将字符串括起来并转义内部引号和其他字符来将字符串作为 JSON 字符串引用，并返回结果。注意，这个函数并不对 JSON 文档进行操作，而是只对一个字符串进行操作。

您可以使用这个函数生成一个有效的 JSON 字符串文字，以包含在 JSON 文档中。清单 [6-19](#PC39) 展示了几个使用函数引用 JSON 字符串的简短例子。

```
> SELECT JSON_QUOTE("test") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_QUOTE("test"): "test"
1 row in set (0.0012 sec)
> SELECT JSON_QUOTE('[true]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_QUOTE('[true]'): "[true]"
1 row in set (0.0007 sec)
> SELECT JSON_QUOTE('90125') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_QUOTE('90125'): "90125"
1 row in set (0.0008 sec)
> SELECT JSON_QUOTE('["red","white","green"]') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_QUOTE('["red","white","green"]'): "[\"red\",\"white\",\"green\"]"
1 row in set (0.0007 sec)

Listing 6-19Using the JSON_QUOTE Function

```

注意最后一个例子。这里，函数添加了转义符(\)，因为传递的字符串包含引号。为什么会这样？记住，这个函数接受一个字符串，而不是一个 JSON 数组作为参数。

`JSON_UNQUOTE()`功能与`JSON_QUOTE()`功能相反。`JSON_UNQUOTE()`函数删除引号中的 JSON 值，并将结果作为 utf8mb4 字符串返回。该函数旨在识别而不是改变标记序列，如下所示。

*   `\"`:双引号(`"`)字符

*   `\b`:退格字符

*   `\f`:换页符

*   `\n`:换行符

*   `\r`:回车符

*   `\t`:制表符

*   `\\`:反斜杠(`\`)字符

清单 [6-20](#PC40) 显示了使用该函数的例子。

```
> SELECT JSON_UNQUOTE("test 123") \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_UNQUOTE("test 123"): test 123
1 row in set (0.0005 sec)
> SELECT JSON_UNQUOTE('"true"') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_UNQUOTE('"true"'): true
1 row in set (0.0007 sec)
> SELECT JSON_UNQUOTE('\"true\"') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_UNQUOTE('\"true\"'): true
1 row in set (0.0007 sec)
> SELECT JSON_UNQUOTE('9\t0\t125\\') \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_UNQUOTE('9\t0\t125\\'): 9  0       125\
1 row in set (0.0006 sec)

Listing 6-20Using the JSON_UNQUOTE Function

```

`JSON_PRETTY()`函数格式化 JSON 文档以便于查看。您可以用它来生成一个输出发送给用户，或者让 JSON 在 shell 中看起来更好一些。清单 [6-21](#PC41) 显示了一个不带功能和带功能的例子。注意当使用`JSON_PRETTY()`时，阅读变得容易多了。

```
> SET @base = '{"name": {"last": "Throckmutton", "first": "Billy-bob"}, "address": {"zip": "90125", "city": "Melborne", "state": "California", "street": "4 Main Street"}}';
Query OK, 0 rows affected (0.0005 sec)
> SELECT @base \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
@base: {"name": {"last": "Throckmutton", "first": "Billy-bob"}, "address": {"zip": "90125", "city": "Melborne", "state": "California", "street": "4 Main Street"}}
1 row in set (0.0005 sec)
> SELECT JSON_PRETTY(@base) \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
JSON_PRETTY(@base): {
  "name": {
    "last": "Throckmutton",
    "first": "Billy-bob"
  },
  "address": {
    "zip": "90125",
    "city": "Melborne",
    "state": "California",
    "street": "4 Main Street"
  }
}
1 row in set (0.0004 sec)

Listing 6-21Using the JSON_PRETTY Function

```

然而，有一件事这个例子没有涉及到。如果 JSON 数据元素是一个字符串，您必须使用`JSON_UNQUOTE()`函数从字符串中删除引号。假设我们想要为颜色数据元素添加一个生成的列。如果我们添加带有`ALTER TABLE`语句的列和索引而不删除引号，我们将得到一些不寻常的结果，如清单 [6-22](#PC42) 所示。

```
> CREATE TABLE `testdb_6`.`thermostats` (`model_number` char(20) NOT NULL,`manufacturer` char(30) DEFAULT NULL,`capabilities` json DEFAULT NULL,PRIMARY KEY (`model_number`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;
Query OK, 0 rows affected (0.0225 sec)
> INSERT INTO `testdb_6`.`thermostats` VALUES ('ODX-123','Genie','{"rpm": 3000, "color": "white", "modes": ["ac", "furnace"], "voltage": 220, "capability": "fan"}') \G
Query OK, 1 row affected (0.0037 sec)
> INSERT INTO `testdb_6`.`thermostats` VALUES ('AB-90125-C1', 'Jasper', '{"rpm": 1500, "color": "beige", "modes": ["ac"], "voltage": 110, "capability": "auto fan"}') \G
Query OK, 1 row affected (0.0041 sec)
> ALTER TABLE `testdb_6`.`thermostats` ADD COLUMN color char(20) GENERATED ALWAYS AS (capabilities->'$.color') VIRTUAL;
Query OK, 0 rows affected (0.0218 sec)
Records: 0  Duplicates: 0  Warnings: 0
> SELECT model_number, color FROM `testdb_6`.`thermostats` WHERE color = "beige" \G
Empty set (0.0006 sec)
> SELECT model_number, color FROM `testdb_6`.`thermostats` LIMIT 2 \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
model_number: AB-90125-C1
       color: "beige"
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 2\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
model_number: ODX-123
       color: "white"
2 rows in set (0.0006 sec)
> ALTER TABLE `testdb_6`.`thermostats` DROP COLUMN color;
Query OK, 0 rows affected (0.0206 sec)
Records: 0  Duplicates: 0  Warnings: 0
> ALTER TABLE `testdb_6`.`thermostats` ADD COLUMN color char(20) GENERATED ALWAYS AS (JSON_UNQUOTE(capabilities->'$.color')) VIRTUAL;
Query OK, 0 rows affected (0.0172 sec)
Records: 0  Duplicates: 0  Warnings: 0
> SELECT model_number, color FROM `testdb_6`.`thermostats` WHERE color = 'beige' LIMIT 1 \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
model_number: AB-90125-C1
       color: beige
1 row in set (0.0006 sec)

Listing 6-22Removing Quotes for Generated Columns on JSON Strings

```

注意，在第一个`SELECT`语句中，没有返回任何内容。这是因为虚拟生成的列使用了带引号的 JSON 字符串。当混合 SQL 和 JSON 数据时，这通常是混淆的来源。注意在第二个`SELECT`语句中，我们看到应该有几行被返回。还要注意，在我们删除该列并用`JSON_UNQUOTE()`函数再次添加它之后，`SELECT`返回正确的数据。

### 小费

有关使用 JSON 函数的更多信息，请参见在线 MySQL 参考手册( [`https://dev.mysql.com/doc/refman/8.0/en/json-functions.html`](https://dev.mysql.com/doc/refman/8.0/en/json-functions.html) )中的“JSON 函数”一节。

## 摘要

MySQL 增加了 JSON 数据类型，这为我们如何使用 MySQL 带来了一个范式转变。第一次，我们可以在关系数据(表)中存储半结构化数据。这不仅为我们提供了前所未有的灵活性，还意味着我们可以利用现代编程技术来访问我们应用程序中的数据，而无需付出巨大努力和增加复杂性。JSON 是一种众所周知的格式，在许多应用程序中广泛使用。

理解 JSON 数据类型是理解文档存储的关键。这是因为 JSON 数据类型虽然是为处理关系数据而设计的，但却形成了我们在文档存储中存储数据的模式——在 JSON 文档中！

在本章中，我们更详细地探讨了 JSON 数据类型。我们看到了如何通过 MySQL 中提供的大量内置 JSON 函数来处理关系表中的 JSON 数据的例子。

在下一章中，我们将通过 garage 示例应用程序并将其转换为文档存储来更详细地探索 MySQL 文档存储。也就是说，我们将看到如何通过使用 MySQL Shell 迁移数据和开发代码来构建带有 JSON 文档的 NoSQL 解决方案，从而将关系数据库解决方案迁移到文档存储中。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

众所周知，关于如何格式化代码的辩论变成了关于间距的宗教狂热，但大多数人都同意不同意第一个花括号应该出现在哪里——在第一行单独出现，在同一行，还是在下一行。

  [2](#Fn2_source)

有些人会说是的。

  [3](#Fn3_source)

有聪明的方法可以避免这一点，但是对于这个论点，假设这是不可能的。

 </aside>