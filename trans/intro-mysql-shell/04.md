# 四、对 SQL 数据库使用 Shell

大多数使用 MySQL 的人使用结构化查询语言(SQL)接口来利用关系数据库功能与他们的数据进行交互。正如我们所见，MySQL Shell 是一个非常强大的客户端，您可以使用结构化查询语言(SQL)语句来处理您的数据。然而，MySQL Shell 也是一个强大的脚本语言编辑器和执行引擎。

在本章中，我们将简要了解什么是 SQL 数据库以及如何在 shell 中使用它们，包括使用 SQL 的简要概述。然而，我们不会在这里花太多时间，因为很多人都熟悉 SQL。无论你是否是 MySQL 和 SQL 的新手，我建议你阅读这些章节，这样你就能理解我们将在本章后面使用的访问方法。

虽然我们会看到一些简短的例子，但第 [5](05.html) 章包含了一个更详细的例子，展示了如何将 MySQL Shell 用于 SQL 数据库，包括如何使用新的 X DevAPI for SQL 数据库。

让我们先简单介绍一下 MySQL 的 SQL 接口。

## 重温关系数据库

如你所知，MySQL 是作为后台进程(Windows 中的一项服务)运行的。如果您从命令行启动它，也可以将其作为前台进程运行。像大多数数据库系统一样，MySQL 支持 SQL。您可以使用 SQL 创建数据库和对象(使用数据定义语言[DDL])，写入或更改数据(使用数据操作语言[DML])，以及执行各种命令来管理服务器。

DDL 语句是我们用来在数据库中创建存储机制(对象，如表)的语句——包括数据库本身。另一方面，DML 语句是为存储和检索数据(行)而设计的。MySQL 还支持其他实用的 SQL 命令，比如显示系统状态、变量和类似元数据的命令。清单 [4-1](#PC1) 展示了每种形式(DDL 和 DML)的一个例子，以及一些实用的 SQL 命令。 <sup>[1](#Fn1)</sup>

```py
C:\Users\cbell>mysqlsh --sql --uri root@localhost:3306
...
SQL > CREATE DATABASE test_db;
Query OK, 1 row affected (0.0586 sec)

SQL > USE test_db;
Query OK, 0 rows affected (0.0003 sec)

SQL > CREATE TABLE test_tbl (id int auto_increment, name char(20), primary key(id));
Query OK, 0 rows affected (0.0356 sec)

SQL > INSERT INTO test_tbl VALUES (NULL, 'one');
Query OK, 1 row affected (0.1117 sec)

SQL > INSERT INTO test_tbl VALUES (NULL, 'two');
Query OK, 1 row affected (0.0078 sec)

SQL > INSERT INTO test_tbl VALUES (NULL, 'three');
Query OK, 1 row affected (0.0109 sec)

SQL > SELECT ∗ FROM test_tbl;
+----+-------+
| id | name  |
+----+-------+
|  1 | one   |
|  3 | three |
|  4 | one   |
|  5 | two   |
|  6 | three |
+----+-------+
5 rows in set (0.0011 sec)

SQL > DELETE FROM test_tbl WHERE id = 2;
Query OK, 0 rows affected (0.0005 sec)

SQL > SELECT ∗ FROM test_tbl;
+----+-------+
| id | name  |
+----+-------+
|  1 | one   |
|  3 | three |
|  4 | one   |
|  5 | two   |
|  6 | three |
+----+-------+
5 rows in set (0.0005 sec)

SQL > SHOW TABLES;
+-------------------+
| Tables_in_test_db |
+-------------------+
| test_tbl          |
+-------------------+
1 row in set (0.0015 sec)

SQL > SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
| test_db            |
| world              |
| world_x            |
+--------------------+
8 rows in set (0.0009 sec))

SQL > SELECT @@version;
+-----------+
| @@version |
+-----------+
| 8.0.16    |
+-----------+
1 row in set (0.0004 sec)

SQL > DROP DATABASE test_db;
Query OK, 1 row affected (0.2659 sec)

Listing 4-1Example DDL and DML Statements

```

### 注意

您必须用分号(`;`或`\G`来结束每个 SQL 命令。

这个例子演示了以`CREATE DATABASE`和`CREATE TABLE`语句形式的 DDL 语句，以`INSERT`、`DELETE`和`SELECT`语句形式的 DML 语句，以及几个实用程序语句，包括一个简单的管理命令来检索全局服务器变量(`@@version`)。

请注意创建数据库和表来存储数据，在表中添加几行，删除一行，最后检索表中的数据。注意我是如何用大写字母表示 SQL 命令关键字的。这是一种常见的做法，有助于使 SQL 命令更容易阅读，更容易找到用户提供的选项或数据(小写)。

MySQL 中有很多可用的命令。幸运的是，你只需要掌握几个比较常见的。以下是您最常使用的命令。`<>`中包含的部分表示用户提供的命令组件，而`[...]`表示需要额外的选项。

*   `CREATE DATABASE <database_name>`:创建数据库

*   `USE <database>`:设置默认数据库(不是 SQL 命令)

*   `CREATE TABLE <table_name> [...]`:创建一个表格或结构来存储数据

*   `INSERT INTO <table_name> [...]`:向表格中添加数据

*   `UPDATE [...]`:更改特定行的一个或多个值

*   `DELETE FROM <table_name> [...]`:从表格中删除数据

*   `SELECT [...]`:从表格中检索数据(行)

*   `SHOW [...]`:显示对象、系统变量等的列表

虽然这个列表只是一个简短的介绍，并不像一个完整的语法指南，但有一个很好的在线参考手册详细解释了每个命令(以及更多)。当你对 MySQL 有任何疑问时，你应该参考在线参考手册。你可以在 [`https://dev.mysql.com/doc/refman/8.0/en/sql-syntax.html`](https://dev.mysql.com/doc/refman/8.0/en/sql-syntax.html) 找到 MySQL 支持的每个 SQL 命令的解释和细节。

显示的一个更有趣的命令允许您查看对象列表。例如，您可以看到带有`SHOW DATABASES`的数据库，带有`SHOW TABLES`的表列表(一旦您用`USE`命令设置了默认数据库)，甚至带有`SHOW GRANTS`的用户权限。我发现自己经常使用这些命令。

如果你认为 MySQL 不仅仅是几个简单的命令，那你就错了。尽管 MySQL 易于使用且启动时间快，但它是一个成熟的关系数据库管理系统(RDBMS)。比你在这里看到的要多得多。有关 MySQL 的更多信息，包括所有高级特性，请参见在线参考手册。

### 什么是关系数据库管理系统？

RDBMS 是一种基于数据关系模型的数据存储和检索服务，由 E. F. Codd 于 1970 年提出。这些系统是结构化数据的标准存储机制。大量的研究致力于改进 Codd 提出的基本模型，正如 C. J. Date 在《数据库关系模型:回顾和分析》中所讨论的那样。这种理论和实践的演变最好地记录在 Date 的第三宣言中。

关系模型是存储库(数据库)的直观概念，可以通过使用一种称为查询语言的机制来检索、更新和插入数据，从而方便地查询存储库。许多供应商已经实现了关系模型，因为它具有完善的系统理论、坚实的数学基础和简单的结构。最常用的查询机制是 SQL，它类似于自然语言。虽然关系模型中不包括 SQL，但它提供了关系模型在 RDBMSs 中的实际应用的一个组成部分。

现在，您已经知道了什么是 MySQL，并且已经看到了一个用于处理数据的 SQL 命令的简洁示例，让我们来探索一些成功部署和使用 MySQL 来存储和检索数据所需的更常见的概念和操作。

## 使用 MySQL 命令和函数

学习和掌握数据库系统需要训练、经验和极大的毅力。精通所需的主要知识是如何使用常见的 SQL 命令和概念。本节通过介绍最常见的命令和概念来完成 MySQL 和 SQL 入门。

本节介绍了高级命令和概念，而不是重复参考手册。如果您决定使用任何命令或概念，并需要更多信息，请参考在线参考手册，了解更多详细信息、完整的命令语法和其他示例。但首先，让我们澄清一些我们在使用传统关系数据库(SQL)处理 MySQL 时使用的术语。

### 术语

在 MySQL 中，像其他关系数据库系统一样，我们以固定的方式存储数据，我们使用*数据库*来存储给定任务、工作、应用、域等的数据。我们使用*表*来存储相似的数据(具有相同格式的数据)。在一个*表*中，数据被表示为*行*，每一行都具有相同的格式(或模式)。

如果您以前从未使用过数据库，您可以松散地关联一个关系数据库表，如电子表格 <sup>[2](#Fn2)</sup> ，其中定义了列，每一行包含每一列的值。因此，插入数据或检索数据需要将数据作为表中的行来形成或查看。

### 创建用户和授予访问权限

要开始处理数据，您需要在使用 MySQL 之前了解两个管理操作:创建用户帐户和授予对数据库的访问权限。MySQL 可以用`CREATE USER`和`GRANT`语句来执行这些操作。要创建一个用户，您可以发出一个`CREATE USER`命令，后跟一个或多个`GRANT`命令。例如，下面显示了名为*简*的用户的创建，并授予该用户对名为 *store_inventory* 的数据库的访问权限:

```py
CREATE USER 'jane'@'%' IDENTIFIED BY 'secret';
GRANT SELECT, INSERT, UPDATE ON store_inventory.∗ TO 'jane'@'%';

```

第一个命令创建名为 *jane* 的用户，但是该名称也有一个`@`后跟另一个字符串。第二个字符串是与用户相关联的机器的主机名。也就是说，MySQL 中的每个用户都有一个用户名和一个主机名，以`user@host`的形式来惟一地标识他们。这意味着用户和主机`jane@10.0.1.16`和用户和主机`jane@10.0.1.17`是不同的。但是，`%`符号可以用作通配符，将用户与任何主机关联起来。`IDENTIFIED BY`子句为用户设置密码。

### 警告

为您的应用创建没有 MySQL 系统完全访问权限的用户帐户并为管理员保留完全访问权限总是一个好主意。此外，您应该避免对主机使用通配符，这样您就可以将用户限制到已知的机器(IP 地址)、子网等。这是为了最大限度地减少任何意外更改，并防止被利用。

对主机使用通配符`%`时要小心。虽然创建单个用户并让用户从任何主机访问数据库服务器变得更加容易，但这也使得一些怀有恶意的人更容易从任何地方访问您的服务器(一旦他们发现了密码)。

第二个命令允许访问数据库。您可以授予用户许多权限。这个例子展示了您最有可能给数据库用户的集合:read ( `SELECT`)、add data ( `INSERT`)和 change data ( `UPDATE`)。有关安全性和帐户访问权限的更多信息，请参见在线参考手册。 <sup>[3](#Fn3)</sup>

该命令还指定要授予权限的数据库和对象。因此，可以给用户一些表的读(`SELECT`)权限，给另一些表的写(`INSERT`、`UPDATE`)权限。这个例子给了用户访问所有对象(表、视图等)的权限。)在*商店 _ 库存*数据库中。

### 小费

MySQL 的新版本不再允许你用`GRANT`语句创建用户。您必须首先显式创建用户。

### 创建数据库和表

您需要学习和掌握的最基本的命令是`CREATE DATABASE`和`CREATE TABLE`命令。回想一下，MySQL 之类的数据库服务器允许您创建任意数量的数据库，您可以用逻辑方式添加表和存储数据。

#### 创建数据库

要创建一个数据库，使用`CREATE DATABASE`后跟一个数据库名称。发出命令后，shell 不会将上下文“切换”到该数据库(像其他一些客户端一样)。相反，如果您想要设置默认数据库，您必须使用`USE <database>`命令。每当您决定在 SQL 命令的名称限定符中省略使用数据库时，这是需要的。

例如，通过以`<database>.<table>`的形式指定数据库和表，您可以使用`SELECT`命令从任何数据库的任何表中选择行。请注意，我们用句点分隔名称。此外，`SELECT ∗ FROM db1.table1`将执行，不管默认的数据库设置。您应该养成在命令中指定数据库的习惯。下面显示了创建和更改数据库焦点的两个命令:

```py
CREATE DATABASE factory_sensors;
USE factory_sensors;

```

#### 创建表格

要创建一个表格，使用`CREATE TABLE`命令。该命令有许多选项，不仅允许您指定列及其数据类型，还允许您指定附加选项，如索引、外键等。下面显示了如何创建一个简单的表来存储装配线的传感器数据。

```py
CREATE TABLE `factory_sensors`.`trailer_assembly` (
  `id` int auto_increment,
  `sensor_name` char(30) NOT NULL,
  `sensor_value` float DEFAULT NULL,
  `sensor_event` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sensor_units` char(15) DEFAULT NULL,
  PRIMARY KEY `sensor_id` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

```

注意，我在这里指定了表名( *trailer_assembly* )和四列( *sensor_name* 、 *sensor_value* 、 *sensor_event* 和 *sensor_units* )。我使用了几种数据类型。对于 *sensor_name* ，我使用了一个最多 30 个字符的字符字段，一个浮点数据类型用于 *sensor_value* ，一个时间戳值用于 *sensor_event* ，另一个字符字段用于 15 个字符的 *sensor_units* 。

我还添加了一个带有自动增量列的索引，以确保我们可以用相同的名称存储传感器值。也就是说，我们可能会在一段时间内对相同的传感器进行多次采样。也可以使用`CREATE INDEX`命令创建索引。

### 注意

这个虚构的表来自一个工作概念，在这个概念中，传感器数据在一个给定的时间段(比如 24 小时)内放在一个表中，然后移动到另一个系统进行分析。因此，该表不是为长时间存储传感器数据而设计的。

注意`TIMESTAMP`栏。这种数据类型的列在传感器网络或物联网(IOT)解决方案中，或者在您想要记录事件或操作的日期和时间的任何时候特别有用。例如，知道何时读取传感器值通常是有帮助的。通过向表中添加一个`TIMESTAMP`列，您不需要在数据收集时计算、读取或格式化日期和时间。

还要注意，我指定将 *sensor_name* 列定义为一个键，这将创建一个索引。在这种情况下，它也是主键。`PRIMARY KEY`短语告诉服务器确保表中存在且只有一行匹配列的值。通过重复关键字，可以指定几个要在主键中使用的列。注意，所有主键列都不允许空值(`NOT NULL`)。

### 注意

此示例是工厂设置中典型传感器网络的高级概念，具有代表性，用于教学目的。

如果您不能确定唯一标识一行的一组列(您希望这样做——有些人喜欢没有这种限制的表，但是一个好的数据库管理员(DBA)不会这样做),那么您可以为整数字段使用一个称为`AUTO INCREMENT`的人工数据类型选项。当用于某一列(必须是第一列)时，服务器会为插入的每一行自动增加该值。这样，它就创建了一个默认主键。有关自动递增列的更多信息，请参见联机参考手册。

但是，最佳实践表明，在某些情况下，在字符字段上使用主键并不是最佳选择，例如表中的每一列都有很大的值或者有许多唯一值。这可能会降低搜索和索引的速度。在这种情况下，您可以使用 auto increment 字段来人工添加一个更小的主键(但有点神秘)。

可用的数据类型比上一个示例中显示的多得多。您应该查阅联机参考手册，以获得数据类型的完整列表。参见“数据类型*一节。*"如果你想知道一个表格的布局或“模式”，使用如下所示的`SHOW CREATE TABLE`命令。

```py
SQL > SHOW CREATE TABLE factory_sensors.trailer_assembly \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
       Table: trailer_assembly
Create Table: CREATE TABLE `trailer_assembly` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `sensor_name` char(30) NOT NULL,
  `sensor_value` float DEFAULT NULL,
  `sensor_event` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sensor_units` char(15) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=latin1
1 row in set (0.0009 sec)

```

像数据库一样，您也可以使用`SHOW TABLES`命令获得数据库中所有表的列表。

### 存储数据

现在您已经创建了一个数据库和表，您将希望向表中加载或插入数据。您可以使用`INSERT INTO`语句来实现。这里，我们为行指定表和数据。下面是一个简单的例子:

```py
INSERT INTO factory_sensors.trailer_assembly (sensor_name, sensor_value, sensor_units) VALUES ('paint_vat_temp', 32.815, 'Celsius');

```

在本例中，我为拖车装配线上的一个传感器手动插入数据。你想知道其他的柱子呢？在这种情况下，其他列包括一个时间戳列，它将由数据库服务器填充。所有其他列(只有一列)将被设置为 NULL，这意味着没有值可用、缺少值、值不为零或值为空。对于自动增量和时间戳列，NULL 触发它们的行为，例如将值设置为下一个唯一的整数或捕获当前日期和时间。下面显示了在表中插入这一行的示例。

```py
SQL > SELECT ∗ FROM factory_sensors.trailer_assembly \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
sensor_name: paint_vat_temp
sensor_value: 32.815
sensor_event: 2019-02-01 14:59:35
sensor_units: Celsius
1 row in set (0.0005 sec)

```

请注意，我在该行的数据之前指定了列。当您希望插入的列数少于表中包含的列数时，这是必要的。更具体地说，关闭列列表意味着您必须为表中的所有列提供数据(或`NULL`)。此外，列出的列的顺序可以不同于它们在表中的定义顺序。关闭列列表将导致列数据根据它们在表中的显示方式进行排序。

您也可以使用逗号分隔的行值列表，使用相同的命令插入几行，如下所示:

```py
INSERT INTO factory_sensors.trailer_assembly (sensor_name, sensor_value, sensor_units) VALUES ('tongue_height_variance', 1.52, 'mm'), ('ambient_temperature', 24.5, 'Celsius'), ('gross_weight', 1241.01, 'pounds');

```

这里我用相同的命令插入了几行。请注意，这只是一种简化机制，除了自动提交之外，与发出单独的命令没有什么不同。

### 更新数据

有时，您需要更改或更新数据。您可能需要更改一列或多列的值，替换多行的值，或者更正数字数据的格式甚至比例。为了更新数据，我们使用`UPDATE`命令。

您可以更新一列、更新一组列、对一列或多列执行计算等等。本节中使用的示例—工厂传感器网络—不太可能需要更改数据(IOT 就是按照记录存储数据，只要数据相关就存储)，但有时在传感器读取代码出错或类似数据输入问题的情况下，这可能是必要的。

更有可能的是，您或您的用户想要重命名数据库中的对象。例如，假设我们确定甲板上的植物实际上不是蕨类植物，而是一种外来开花植物。在这种情况下，我们希望将工厂名称为 *gross_weight* 的所有行更改为 *trailer_weight* 。以下命令执行更改。注意这里的关键操作符是`SET`操作符。这告诉数据库为指定的列分配一个新值。您可以在命令中列出多个 set 操作。

```py
UPDATE factory_sensors.trailer_assembly SET sensor_name = 'trailer_weight' WHERE sensor_name = 'gross_weight';

```

还要注意，我在这里使用了一个`WHERE`子句将`UPDATE`限制为一组行。这就是你在`SELECT`语句中看到的同一个`WHERE`子句，它做同样的事情；它允许您指定限制受影响的行的条件。如果不使用`WHERE`子句，更新将应用于所有行。

### 删除数据

有时，您最终会得到需要删除的表中的数据。也许您使用了测试数据，并希望去除虚假的行，或者也许您希望压缩或清除您的表，或者希望消除不再适用的行。要删除行，使用`DELETE FROM`命令。

我们来看一个例子。假设您有一个正在开发的工厂监控解决方案，您发现您的一个传感器或传感器节点读取的值太低，原因是编码、布线或校准错误。在这种情况下，我们希望删除传感器值小于 0.001 的所有行(可能是虚假数据)。以下命令可以做到这一点:

```py
DELETE FROM factory_sensors.trailer_assembly WHERE sensor_value < 0.001;

```

当形成从句时，你应该小心。我喜欢使用带有`SELECT`的`WHERE`子句来确保我对我想要的行进行操作。使用`SELECT`以这种方式测试潜在受影响的行比简单地盲目发出命令要安全得多。例如，我将首先发出下面的命令来检查我是否要删除我想要的行，并且只删除那些行。注意这是同一个`WHERE`条款。

```py
SELECT ∗ FROM factory_sensors.trailer_assembly WHERE sensor_value < 0.001;

```

### 警告

发出不带`WHERE`子句的`UPDATE`或`DELETE`命令将影响表中的所有行！

### 选择数据(结果)

您需要知道的最常用的基本命令是从表中返回数据的命令(也称为结果集或行)。为此，您可以使用`SELECT`语句。这个 SQL 语句是数据库系统的核心。所有对数据的查询都将使用该命令执行。因此，我们将花更多的时间来看看可以使用的各种子句(部分)，从列列表开始。

`SELECT`语句允许您指定想要从数据中选择哪些列。该列表作为语句的第一部分出现。第二部分是`FROM`子句，它指定了要从中检索行的表。`FROM`子句还允许您合并两个或多个表中的数据。这被称为连接，并使用`JOIN`操作符来链接表。在后面的小节中，您将看到一个简单的连接示例。

指定列的顺序决定了结果集中的显示顺序。如果需要所有列，请使用星号(`∗`)代替。清单 [4-2](#PC12) 展示了生成相同结果集的三条语句。也就是说，在每个的输出中将显示相同的行。事实上，为了简单起见，我使用了一个只有四行的表。

```py
SQL > SELECT sensor_name FROM factory_sensors.trailer_assembly;
+------------------------+
| sensor_name            |
+------------------------+
| ambient_temperature    |
| paint_vat_temp         |
| tongue_height_variance |
| trailer_weight         |
+------------------------+
4 rows in set (0.0006 sec)

SQL > SELECT sensor_name, sensor_value, sensor_event, sensor_units FROM factory_sensors.trailer_assembly \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
 sensor_name: ambient_temperature
sensor_value: 24.5
sensor_event: 2019-02-01 15:04:08
sensor_units: Celsius
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 2\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
 sensor_name: paint_vat_temp
sensor_value: 32.815
sensor_event: 2019-02-01 14:59:35
sensor_units: Celsius
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 3\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
 sensor_name: tongue_height_variance
sensor_value: 1.52
sensor_event: 2019-02-01 15:04:08
sensor_units: mm
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 4\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
 sensor_name: trailer_weight
sensor_value: 1241.01
sensor_event: 2019-02-01 15:06:17
sensor_units: pounds
4 rows in set (0.0004 sec)

SQL > SELECT ∗ FROM factory_sensors.trailer_assembly \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
 sensor_name: ambient_temperature
sensor_value: 24.5
sensor_event: 2019-02-01 15:04:08
sensor_units: Celsius
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 2\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
 sensor_name: paint_vat_temp
sensor_value: 32.815
sensor_event: 2019-02-01 14:59:35
sensor_units: Celsius
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 3\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
 sensor_name: tongue_height_variance
sensor_value: 1.52
sensor_event: 2019-02-01 15:04:08
sensor_units: mm
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 4\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
 sensor_name: trailer_weight
sensor_value: 1241.01
sensor_event: 2019-02-01 15:06:17
sensor_units: pounds
4 rows in set (0.0005 sec)

SQL > SELECT sensor_value, sensor_name, sensor_units FROM factory_sensors.trailer_assembly;
+--------------+------------------------+--------------+
| sensor_value | sensor_name            | sensor_units |
+--------------+------------------------+--------------+
|         24.5 | ambient_temperature    | Celsius      |
|       32.815 | paint_vat_temp         | Celsius      |
|         1.52 | tongue_height_variance | mm           |
|      1242.00 | trailer_weight         | pounds       |
+--------------+------------------------+--------------+
4 rows in set (0.0005 sec)

Listing 4-2Example SELECT Statements

```

请注意，第一条语句列出了表中的传感器名称。接下来的两个语句以相同的顺序生成相同的行和相同的列，但是第三个语句虽然生成相同的行但没有传感器事件，却以不同的顺序显示列。

您还可以使用列列表中的函数来执行计算和类似操作。一个特殊的例子是使用`COUNT()`函数来确定结果集中的行数，如下所示。注意，我们传入通配符(`∗`)来计算所有行。关于 MySQL 提供的函数的更多例子，请参阅在线参考手册。 <sup>[4](#Fn4)</sup>

```py
SELECT COUNT(∗) FROM factory_sensors.trailer_assembly;

```

`SELECT`语句中的下一个子句是`WHERE`子句。就像我们在更新和删除行中看到的那样，这是您指定想要用来限制结果集中的行数的条件的地方。也就是说，只有那些符合条件的行。这些条件基于列，可能相当复杂。也就是说，您可以基于计算、连接结果等来指定条件。但是为了回答一个问题，大多数条件将是一列或多列上的简单等式或不等式。例如，假设您想要查看传感器读数小于 10.00 的植物。在这种情况下，我们发出以下查询并接收结果。注意，我只指定了两列:传感器名称和从传感器读取的值。

```py
SQL > SELECT sensor_name, sensor_value FROM factory_sensors.trailer_assembly WHERE sensor_value < 10.00;
+------------------------+--------------+
| sensor_name            | sensor_value |
+------------------------+--------------+
| tongue_height_variance |         1.52 |
+------------------------+--------------+
1 row in set (0.0008 sec)

```

您还可以使用其他子句，包括用于对行进行分组以进行聚合或计数的`GROUP BY`子句，以及用于对结果集进行排序的`ORDER BY`子句。让我们从聚合开始，快速地看一下每一个。

假设您想要计算每个传感器在表中读取的传感器值的平均值。在这种情况下，我们有一个包含各种传感器随时间变化的传感器读数的表。虽然该示例只包含四行(因此可能没有统计信息)，但是该示例非常清楚地展示了聚合的概念，如清单 [4-3](#PC15) 所示。请注意，我们收到的只是四个传感器读数的平均值。

```py
SQL > SELECT sensor_name, sensor_value FROM factory_sensors.trailer_assembly WHERE sensor_name = 'gross_weight';
+--------------+--------------+
| sensor_name  | sensor_value |
+--------------+--------------+
| gross_weight |         1250 |
| gross_weight |         1235 |
| gross_weight |         1266 |
| gross_weight |         1242 |
+--------------+--------------+
4 rows in set (0.0040 sec)

SQL > SELECT sensor_name, AVG(sensor_value) as avg_value FROM factory_sensors.trailer_assembly WHERE sensor_name = 'gross_weight' GROUP BY sensor_name;
+--------------+-----------+
| sensor_name  | avg_value |
+--------------+-----------+
| gross_weight |   1248.25 |
+--------------+-----------+
1 row in set (0.0006 sec)

SQL > SELECT sensor_name, sensor_value FROM factory_sensors.trailer_assembly WHERE sensor_name = 'gross_weight' ORDER BY sensor_value ASC;
+--------------+--------------+
| sensor_name  | sensor_value |
+--------------+--------------+
| gross_weight |         1235 |
| gross_weight |         1242 |
| gross_weight |         1250 |
| gross_weight |         1266 |
+--------------+--------------+
4 rows in set (0.0007 sec)

SQL > SELECT sensor_name, sensor_value FROM factory_sensors.trailer_assembly WHERE sensor_name = 'gross_weight' ORDER BY sensor_value DESC;
+--------------+--------------+
| sensor_name  | sensor_value |
+--------------+--------------+
| gross_weight |         1266 |
| gross_weight |         1250 |
| gross_weight |         1242 |
| gross_weight |         1235 |
+--------------+--------------+
4 rows in set (0.0009 sec)

Listing 4-3GROUP BY Example

```

请注意，在第二个示例中，我在列列表中指定了 average 函数`AVG()`，并传入了我想要求平均值的列的名称。MySQL 中有许多这样的函数可以用来执行一些强大的计算。显然，这是另一个例子，说明数据库服务器中存在的能力需要客户机上更多的资源(更不用说对于大型数据集，这意味着在操作之前将数据传输到客户机)。

还要注意，我用关键字`AS`重命名了平均值列。您可以使用它来重命名任何指定的列，这将更改结果集中的名称，如清单所示。

最后两个示例展示了如何查看按传感器值排序的结果集的结果。我们使用`ORDER BY`子句按照传感器值的升序和降序对行进行排序。如果将它与 LIMIT 子句结合使用，可以看到最大值(max)和最小值(min ),如下所示。但是最好使用`MIN()`和`MAX()`函数——参见 [`https://dev.mysql.com/doc/refman/8.0/en/func-op-summary-ref.html`](https://dev.mysql.com/doc/refman/8.0/en/func-op-summary-ref.html) 获得 MySQL 中可用函数的完整列表。

```py
SQL > SELECT sensor_value AS min FROM factory_sensors.trailer_assembly WHERE sensor_name = 'gross_weight' ORDER BY sensor_value ASC LIMIT 1;
+------+
| min  |
+------+
| 1235 |
+------+
1 row in set (0.0008 sec)
SQL > SELECT sensor_value as max FROM factory_sensors.trailer_assembly WHERE sensor_name = 'gross_weight' ORDER BY sensor_value DESC LIMIT 1;
+------+
| max  |
+------+
| 1266 |
+------+
1 row in set (0.0005 sec)

```

子句的另一个用途是计数。在这种情况下，我们用`COUNT()`替换了`AVG()`，得到了与`WHERE`子句匹配的行数。更具体地说，我们想知道为每个传感器存储了多少个传感器值。

```py
SQL > SELECT sensor_name, COUNT(sensor_value) as num_values FROM factory_sensors.trailer_assembly GROUP BY sensor_name;
+------------------------+------------+
| sensor_name            | num_values |
+------------------------+------------+
| paint_vat_temp         |          1 |
| tongue_height_variance |          1 |
| ambient_temperature    |          1 |
| trailer_weight         |          1 |
| gross_weight           |          4 |
+------------------------+------------+
5 rows in set (0.0008 sec)

```

正如我提到的,`SELECT`语句比这里显示的要多得多，但是我们在这里看到的会让你走得更远，尤其是在处理大多数中小型解决方案的典型数据时。

### 创建索引

创建表时不使用任何排序。也就是说，表是无序的。虽然 MySQL 每次都会以相同的顺序返回数据，但是没有隐含的(或可靠的)顺序，除非您创建一个索引。 <sup>[5](#Fn5)</sup> 我这里指的排序并不是你在排序时想的那样(用`SELECT`语句中的`ORDER BY`子句就有可能)。

相反，索引是服务器在执行查询时用来读取数据的映射。例如，如果一个表上没有索引，并且希望选择某列中值大于某个值的所有行，则服务器必须读取所有行来查找所有匹配项。但是，如果我们在该列上添加了一个索引，服务器将只能读取那些符合标准的行。

要创建索引，您可以在`CREATE TABLE`语句中指定索引，或者发出一个`CREATE INDEX`命令。我们可以使用这个命令在`sensor_name`列上添加一个索引。清单 [4-4](#PC18) 展示了添加索引前后对表结构(模式)的影响。回想一下，我们在前面创建表时添加了主键索引。

```py
SQL > SHOW CREATE TABLE factory_sensors.trailer_assembly \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
       Table: trailer_assembly
Create Table: CREATE TABLE `trailer_assembly` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `sensor_name` char(30) NOT NULL,
  `sensor_value` float DEFAULT NULL,
  `sensor_event` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sensor_units` char(15) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=latin1
1 row in set (0.0005 sec)

SQL > CREATE INDEX sensor_name ON factory_sensors.trailer_assembly (sensor_name);
Query OK, 0 rows affected (0.2367 sec)

Records: 0  Duplicates: 0  Warnings: 0

SQL > SHOW CREATE TABLE factory_sensors.trailer_assembly \G
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1\. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
       Table: trailer_assembly
Create Table: CREATE TABLE `trailer_assembly` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `sensor_name` char(30) NOT NULL,
  `sensor_value` float DEFAULT NULL,
  `sensor_event` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sensor_units` char(15) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `sensor_name` (`sensor_name`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=latin1
1 row in set (0.0009 sec)

Listing 4-4Adding Indexes

```

像这样创建的索引不会影响表中行的唯一性，换句话说，确保存在且只有一行可以被特定列的特定值访问。我所指的是主键(或主索引)的概念，这是在创建表时使用的一个特殊选项，如前所述。

您可以使用如下所示的`DROP INDEX`命令删除索引。

```py
DROP INDEX sensor_name ON factory_sensors.trailer_assembly;

```

### 创建视图

视图是一个或多个表的结果的逻辑映射。它们可以像查询中的表一样被引用，这使它们成为创建数据子集的强大工具。您用`CREATE VIEW`创建一个视图，并给它起一个类似表格的名字。下面显示了一个简单的例子，其中我们创建了一个测试视图来从表中读取值。在这种情况下，我们限制了视图的大小(行数)，但是您可以为视图使用各种各样的条件，包括组合来自不同表的数据。因此，视图可以像表一样用于查询。它们是处理数据子集的便捷方式(当构造正确时)。

```py
SQL > CREATE VIEW list_weights AS SELECT ∗ FROM factory_sensors.trailer_assembly WHERE sensor_units = 'pounds' LIMIT 3;
Query OK, 0 rows affected (0.0525 sec)

SQL > SELECT ∗ FROM factory_sensors.list_weights;
+----+----------------+--------------+---------------------+--------------+
| id | sensor_name    | sensor_value | sensor_event        | sensor_units |
+----+----------------+--------------+---------------------+--------------+
|  4 | trailer_weight |      1241.01 | 2019-02-01 15:40:35 | pounds       |
|  5 | gross_weight   |         1250 | 2019-02-01 15:40:35 | pounds       |
|  6 | gross_weight   |         1235 | 2019-02-01 15:40:35 | pounds       |
+----+----------------+--------------+---------------------+--------------+
3 rows in set (0.0047 sec)

```

在中小型数据库解决方案中通常不会遇到视图，但是我将它们包括在内是为了在您决定进行额外的分析并希望将数据组织成更小的组以便于阅读时让您了解它们。

### 简单连接

数据库系统最强大的概念之一是在数据之间建立关系的能力(因此得名关系型)。也就是说，一个表中的数据可以引用另一个(或多个)表中的数据。最简单的形式称为主从关系，其中一个表中的一行引用或关联到另一个表中的一行或多行。

一个常见的(也是经典的)主从关系的例子来自订单跟踪系统，其中一个表包含订单的数据，另一个表包含订单的行项目。因此，我们只存储一次订单信息，如客户号和发货信息，并在检索订单时合并或“连接”这些表。

让我们来看一个名为 world_x 的示例数据库。您可以在 MySQL 网站( [`http://dev.mysql.com/doc/index-other.html`](http://dev.mysql.com/doc/index-other.html) )上找到这个数据库。请随意下载它和任何其他示例数据库。它们都展示了数据库系统的各种设计。您还会发现练习查询数据很方便，因为它包含了许多简单的行。

### 注意

如果你想运行下面的例子，你需要安装第 [3 章](03.html)中描述的`world_x`示例数据库。

清单 4-5 展示了一个简单连接的例子。这里发生了很多事情，所以花点时间检查一下`SELECT`语句的各个部分，尤其是我是如何指定`JOIN`子句的。您可以忽略`LIMIT`选项，因为它只是限制了结果集中的行数。

```py
SQL > SELECT Name, Code, Language FROM world_x.Country JOIN world_x.CountryLanguage ON Country.Code = CountryLanguage.CountryCode LIMIT 10;
+-------------+------+------------+
| Name        | Code | Language   |
+-------------+------+------------+
| Aruba       | ABW  | Dutch      |
| Aruba       | ABW  | English    |
| Aruba       | ABW  | Papiamento |
| Aruba       | ABW  | Spanish    |
| Afghanistan | AFG  | Balochi    |
| Afghanistan | AFG  | Dari       |
| Afghanistan | AFG  | Pashto     |
| Afghanistan | AFG  | Turkmenian |
| Afghanistan | AFG  | Uzbek      |
| Angola      | AGO  | Ambo       |
+-------------+------+------------+
10 rows in set (0.0165 sec)

Listing 4-5Simple JOIN Example

```

### 警告

如果您系统的文件系统支持区分大小写的名称，请确保使用一致的命名。比如`world_x`和`World_X`在某些平台上是两个不同的名字。有关区分大小写的标识符的更多信息，请参见 [`https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html`](https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html) 。

这里我使用了一个`JOIN`子句，它接受两个指定的表，这样第一个表使用特定的列及其值连接到第二个表(`ON`指定匹配)。数据库服务器所做的是从表中读取每一行，并只返回那些列中的值指定匹配的行。一个表中不在另一个表中的任何行都不会被返回。

还要注意，我只包括了几个专栏。在本例中，我从`Country`表中指定了国家代码和洲，从`CountryLanguage`表中指定了语言列。如果列名不是惟一的(相同的列出现在每个表中)，我就必须用表名来指定它们，比如`Country.Name`。事实上，总是以这种方式限定列被认为是一种好的做法。

这个例子中有一个有趣的异常，我觉得有必要指出来。事实上，有些人会认为这是一个设计缺陷。注意，在`JOIN`子句中，我指定了表格和每个表格的列。这是正常且正确的，但是请注意，两个表中的列名不匹配。虽然这真的没有关系，并且只需要一点额外的输入，但是一些 DBA 会认为这是错误的，并且希望在两个表中使用相同的公共列名。

连接的另一个用途是检索公共数据、存档数据或查找数据。例如，假设您有一个表，其中存储了不变(或很少变)的事物的详细信息，例如与邮政编码相关联的城市或与身份证号相关联的名称(例如，社会保险号(SSN))。您可以将这些信息存储在一个单独的表中，并在需要时将数据连接到一个公共列(和值)上。在这种情况下，公共列可以用作外键，这是另一个高级概念。

外键用于维护数据完整性(即，如果一个表中的数据与另一个表相关，但这种关系需要保持一致)。例如，如果您想确保在删除主行时所有的细节行也被删除，您可以在主表中声明一个外键，指向细节表的一列(或多列)。有关外键的更多信息，请参见联机参考手册。 <sup>[6](#Fn6)</sup>

关于连接的讨论只涉及最基本的内容。事实上，连接可以说是数据库系统中最困难和最容易混淆的领域之一。如果您发现想要使用联接来组合几个表或扩展数据，以便从几个表中提供数据(外部联接)，您应该花一些时间深入学习数据库概念，如 Clare Churcher 的书*开始数据库设计(Apress，2012)* 。

### 其他高级概念

MySQL 中有更多可用的概念和命令，但有两个可能会引起人们的兴趣，那就是`PROCEDURE`和`FUNCTION`，它们有时被称为例程。我在这里介绍这些概念，以便如果您想探索它们，您可以理解它们是如何在高层次上使用的。

假设您需要运行几个命令来更改数据。也就是你需要在计算的基础上做一些复杂的改变。对于这些类型的操作，MySQL 提供了存储过程的概念。存储过程允许您在调用该过程时执行复合语句(一系列 SQL 命令)。存储过程有时被认为是一种主要用于定期维护的高级技术，但它们在更简单的情况下也很方便。

例如，假设您想要开发您的解决方案，但是由于您正在开发它，您需要定期重新开始，并且想要首先清除所有数据。如果只有一个表，存储过程不会有太大帮助，但是假设有几个表分布在几个数据库中(对于较大的解决方案来说并不少见)。在这种情况下，存储过程可能会有所帮助。

在 shell 中输入带有复合语句的命令时，您需要临时更改分隔符(分号),以便行尾的分号不会终止命令条目。例如，在用复合语句编写命令之前使用`DELIMITER //`，使用`//`结束命令，用`DELIMITER ;`将分隔符改回来。

假设您想执行一个复合语句并返回一个结果——您想将它用作一个函数。您可以使用函数通过执行计算、数据转换或简单的翻译来填充数据。因此，函数可用于提供值来填充列值、提供聚合、提供日期操作等等。

您已经看到了几个函数(`COUNT`、`AVG`)。这些被认为是内置函数，在线参考手册中有一整节专门介绍它们。但是，您也可以创建自己的函数。例如，您可能希望创建一个函数来对您的数据执行一些数据规范化。更具体地说，假设您有一个传感器，它产生一个特定范围内的值，但是根据该值和来自不同传感器或查找表的另一个值，您想要对该值进行加、减、平均等操作来校正它。您可以编写一个函数来实现这一点，并在触发器中调用它来填充计算列的值。

由于存储过程可能相当复杂，如果您决定使用它们，在尝试开发自己的存储过程之前，请阅读在线参考手册的“*CREATE PROCEDURE and CREATE FUNCTION Syntax*”一节。 <sup>[7](#Fn7)</sup> 创建存储过程的内容远不止这一部分。

### 换对象呢？

您可能想知道当您需要修改表、过程、触发器等时该怎么做。放心吧，你不必从头开始！MySQL 为每个对象提供了一个`ALTER`命令。也就是说，有一个`ALTER TABLE`、`ALTER PROCEDURE`等等。关于每个`ALTER`命令的更多信息，参见在线参考手册标题为*数据定义语句*的章节。 <sup>[8](#Fn8)</sup>

现在，我们已经对使用 SQL 命令和 MySQL 存储和检索关系数据有了一个较高的认识，让我们看看如何使用 X DevAPI 来编写使用相同关系数据的 Python 代码。我们终于要写点 Python 了！

## 使用 Python 管理数据库

现在我们已经很好地介绍了 SQL 和 MySQL 命令，我们可以将注意力转向一种令人兴奋的在 MySQL 中使用 SQL 数据库的新方法——使用 X DevAPI 编写 Python 脚本来合并代码和数据。

我们将从处理关系数据的角度开始探索 API，而不是对 X DevAPI 必须提供的所有功能进行艰苦、乏味的探索。在这一节中，我们将发现关于 X DevAPI 的足够多的知识，以便能够编写 Python 代码来处理关系数据库对象(数据库和表)。我们把更复杂的部分留到第 6 章来看 X DevAPI 对 JSON 文档的支持。

然而，我们仍然需要知道 X DevAPI 是什么以及它的主要特性。如前所述，我们将从处理关系数据的角度在本章和下一章探讨其中的一些。API 远不止这些，但是从一个已知的(或者至少是熟悉的)基础开始将有助于那些新手在应用中加入数据库支持。毕竟，X DevAPI 就是为了让从代码中访问数据变得容易！

您应该知道的第一件事是，shell 内置了对我们需要的几个库对象的支持。比如前面列出的`mysqlx`模块就是 shell 中的内置模块之一。我们将内置模块称为全局变量。shell 还包括以下库作为内置模块(有时称为库或对象)作为全局变量。

*   *会话*:如果已经建立了全局会话，则表示全局会话。

*   *db* :如果已经定义了一个模式，则表示该模式，例如，由 URI 类型的字符串定义。

*   *dba* :表示 AdminAPI，它是 InnoDB 集群的一个组件，使您能够管理服务器实例集群。有关 InnoDB 集群的更多信息，请参见第 [10](10.html) 章。

*   *mysqlx* :提供对连接到 MySQL 服务器产生的会话对象的操作。

*   *shell* :提供通用功能，例如配置 MySQL Shell。

*   *util* :提供实用函数，例如，在升级前检查服务器实例。

在学习将 X DevAPI 用于关系数据时，需要理解的关键概念包括。这些在 Python 代码中被表示(实现)为对象。也就是说，我们将使用一个或多个方法来创建对象，然后使用它的一个或多个方法来执行我们的代码以处理数据。

*   *CRUD* :创建、读取、更新和删除——对数据的基本操作

*   *数据库/模式*:一个或多个数据库级对象的容器，如表、视图、触发器等。

*   *Result* :来自一个读操作(SELECT)或其他操作的一组零行或多行，这些操作产生从服务器返回的值

*   *会话*:到 MySQL 服务器的连接，包括管理连接的属性

*   *表*:以特定布局格式化的数据容器，用于将数据存储在具有数据类型的预定义列中

这些概念中的大多数应该是熟悉的，或者至少足够熟悉，以至于学习使用它们不需要太多的努力。例如，作为 SQL 数据库用户，我们理解数据库(模式)、表和结果集的基本概念。代表这些概念的对象只不过是它们行为的模型，我们可以用它们作为方法来调用。

然而，三个最新的概念可能是`mysqlx`模块、会话和 CRUD 操作。让我们来看看每一个。

### MySQL X 模块

`mysqlx`模块是用 X DevAPI 编写应用的入口点。您可以将该模块视为一个库，其中包含几个可以在 Python 脚本中使用的对象。我们需要的最值得注意的对象是那些可用于连接和处理 MySQL 中的关系数据的类和方法，但是还有更多可用于 JSON 文档的对象。

要理解的关键概念是，对象是从其他对象上调用的方法生成的。更具体地说，当我们在对象`a`上调用方法`x()`时，它返回对象`b`的实例。例如，我们调用方法并将返回的对象赋给另一个变量，就像这个`b = a.x()`。一旦理解了这一点，就可以检查方法的返回类型，然后引用返回的对象类型来找出它提供了什么方法。

当使用`mysqlx`模块时，这一切都从返回一个`Session`对象 <sup>[9](#Fn9)</sup> 的连接开始——从`get_session()`方法返回的也是这个对象。从那里，我们可以调用会话中的方法，它们返回不同的对象。让我们看看`mysqlx`模块中有哪些类。表 [4-1](#Tab1) 显示了模块中可用的类别。

表 4-1

`mysqlx`模块中的类

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

班级

 | 

描述

 |
| --- | --- |
| `BaseResult` | 服务器返回的不同类型结果的基类 |
| `Collection` | 集合是一个容器，可用于在 MySQL 数据库中存储文档 |
| `CollectionAdd` | 集合上文档添加的处理程序 |
| `CollectionFind` | 集合上文档选择的处理程序 |
| `CollectionModify` | 更新集合中文档的操作 |
| `CollectionRemove` | 删除集合中文档的操作 |
| `DocResult` | 允许遍历由 Collection.find 操作返回的 DbDoc 对象 |
| `LockContention` | 常数来表示锁争用类型 |
| `Result` | 允许检索对数据库执行的非查询操作的相关信息 |
| `RowResult` | 允许遍历表返回的行对象。选择操作 |
| `Schema` | 表示从使用 X 协议创建的会话中检索的架构 |
| `Session` | 支持使用 X 协议与 MySQL 服务器进行交互 |
| `SqlExecute` | SQL 语句执行处理程序，支持参数绑定 |
| `SqlResult` | 允许在通过 Session.sql 对数据库执行操作后浏览结果信息 |
| `Table` | 表示模式上的表，通过使用 mysqlx 模块创建的会话进行检索 |
| `TableDelete` | 从表中删除数据的操作 |
| `TableInsert` | 表中插入操作的处理程序 |
| `TableSelect` | 表中记录选择的处理程序 |
| `TableUpdate` | 表中记录更新操作的处理程序 |
| `Type` | 常数来表示列对象上的数据类型 |

正如您所看到的，有几个类是由`mysqlx`模块提供的。如果这看起来有点难以承受，请不要担心。我们不需要所有这些来处理关系数据；大多数是为 JSON 文档(也称为文档存储)设计的。然而，我们将需要使用`Session`类。

### 注意

本书中的表格引用了在线 Doxygen 文档( [`https://dev.mysql.com/doc/dev/mysqlsh-api-python/8.0/`](https://dev.mysql.com/doc/dev/mysqlsh-api-python/8.0/) )中记录的 MySQL Shell 中实现的 Python X DevAPI。其他语言的 X DevAPI 在组织以及类和方法的命名方案上可能略有不同。

我们已经在第三章[中发现了会话。回想一下，我们使用`\connect` shell 命令与 shell 中的会话进行交互，这允许您在 shell 交互会话中建立连接。在 Python 中使用会话略有不同。接下来我们来看看`Session`类。](03.html)

#### 会话类

Session 类是我们在编写与数据交互的 Python 应用时将使用的主要类。我们使用该模块将连接信息以连接字符串或特定于语言的结构(Python 中的字典)的形式传递给服务器，以将连接参数作为 URI 或连接字典作为参数传递(而不是两者都作为)。获取会话对象最常用的方法如下所示。

```py
get_session(<URI or connection dictionary>)

```

下面显示了使用连接选项字典获取会话对象实例和使用连接字符串(URI)获取会话对象实例的示例。

```py
import mysqlx
mysqlx_session1 = mysqlx.get_session({'host': 'localhost', 'port': 33060, 'user': 'root', 'password': 'secret'})
mysqlx_session2 = mysqlx.get_session('root:secret@localhost:33060')

```

如果连接成功，结果变量将指向一个对象实例。如果失败，结果可能是一个错误或未初始化的连接。我们将在下一章看到如何处理这个问题。

一旦我们有了一个会话，我们就可以通过获取一个模式对象来开始处理我们的数据。

#### 模式类

X DevAPI 使用术语“模式”来指代一组集合，它们是文档的集合。然而，当处理关系数据时，我们使用“数据库”来指代表和类似对象的集合。人们可能会认为“模式”是“数据库”的同义词，对于 MySQL 的旧版本来说，这是正确的。然而，当使用文档存储和 X DevAPI 时，应该使用“模式”，而当引用关系数据时，应该使用“数据库”

### 模式或数据库:重要吗？

从 MySQL 5.0.2 开始，这两个术语通过 SQL 命令`CREATE DATABASE`和`CREATE SCHEMA`成为同义词。然而，其他数据库系统做出了区分。也就是说，在某些情况下，模式是表的集合，而数据库是模式的集合。其他人认为模式是定义数据结构的东西。如果您使用其他数据库系统，请确保检查定义，以便正确使用术语。

开始处理数据时，您需要做的第一件事是选择(获取)一个现有的模式，删除一个现有的模式，或者创建一个新的模式。您可能还想列出服务器上的模式。`Session`类提供了几个执行这些操作的方法，所有这些方法都返回一个`Schema`对象。表 [4-2](#Tab2) 列出了与模式相关的方法、参数和返回值。

表 4-2

会话类–模式方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

方法

 | 

返回

 | 

描述

 |
| --- | --- | --- |
| `create_schema(str name)` | 计划 | 在数据库上创建一个模式，并返回相应的对象 |
| `get_schema(str name)` | 计划 | 通过名称从当前会话中检索架构对象 |
| `get_default_schema()` | 计划 | 检索了配置为会话默认值的架构 |
| `get_current_schema()` | 计划 | 检索到会话中的活动架构 |
| `set_current_schema(str name)` | 计划 | 为此会话设置当前架构，并返回其架构对象 |
| `get_schemas()` | 目录 | 检索了会话中可用的架构 |
| `drop_schema(str name)` | 没有人 | 删除具有指定名称的架构 |

现在让我们来看看用于执行符合 ACID 的事务的事务方法。

#### 交易方式

事务提供了一种机制，允许一组操作作为单个原子操作执行。例如，如果为一个银行机构建立一个数据库，将资金从一个账户转移到另一个账户的宏操作将优选地被完整地执行(资金从一个账户转移到另一个账户),而不会中断。

事务允许将这些操作封装在一个原子操作中，如果在所有操作完成之前发生错误，该原子操作将取消任何更改，从而避免数据从一个表中删除，并且永远不会进入下一个表。包含在事务命令中的 SQL 语句形式的一组示例操作如下:

```py
START TRANSACTION;
UPDATE SavingsAccount SET Balance = Balance – 100
WHERE AccountNum = 123;
UPDATE CheckingAccount SET Balance = Balance + 100
WHERE AccountNum = 345;
COMMIT;

```

MySQL 的 InnoDB 存储引擎(默认存储引擎)支持确保数据完整性的 ACID 事务，能够在所有操作成功的情况下提交(保存)结果更改，或者在任何一个操作失败的情况下回滚(撤消)更改。

会话类实现了事务处理的方法，这些方法反映了前面显示的 SQL 命令。表 [4-3](#Tab3) 列出了交易方式。

表 4-3

交易方式

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

方法

 | 

返回

 | 

描述

 |
| --- | --- | --- |
| `start_transaction()` | 没有人 | 在服务器上启动事务上下文 |
| `commit()` | 没有人 | 提交调用 startTransaction()后执行的所有操作 |
| `rollback()` | 没有人 | 放弃调用 startTransaction()后执行的所有操作 |
| `set_savepoint(str name="")` | 潜艇用热中子反应堆（submarine thermal reactor 的缩写） | 创建或替换具有给定名称的事务保存点 |
| `release_savepoint(str name)` | 没有人 | 删除在事务中定义的保存点 |
| `rollback_to(str name)` | 没有人 | 将事务回滚到指定的保存点，而不终止事务 |

注意，最后三种方法允许您创建命名事务保存点，这是事务处理的一种高级形式。有关保存点和事务的更多信息，请参见服务器在线参考手册。<sup>[10](#Fn10)T3】</sup>

现在，让我们看看与服务器连接相关的方法。

#### 连接方法

下划线连接有两种方法。一个用于检查连接是否打开，另一个用于关闭连接。表 [4-4](#Tab4) 显示了`Session`类中剩余的可用实用方法。

表 4-4

连接方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

方法

 | 

返回

 | 

描述

 |
| --- | --- | --- |
| `close()` | 没有人 | 关闭会话 |
| `is_open()` | 弯曲件 | 如果已知会话是打开的，则返回 true |

#### 杂项方法

Session 类中还有几个实用方法。表 [4-5](#Tab5) 列出了附加功能。有关这些方法的更多信息，请参见 X DevAPI 在线参考。

表 4-5

杂项方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

方法

 | 

返回

 | 

描述

 |
| --- | --- | --- |
| `quote_name(str id)` | 潜艇用热中子反应堆（submarine thermal reactor 的缩写） | 转义标识符 |
| `get_uri()` | 潜艇用热中子反应堆（submarine thermal reactor 的缩写） | 返回会话的 URI |
| `set_fetch_warnings(bool enable)` | 没有人 | 启用或禁用警告生成 |
| `sql(str sql)` | sqlstatesment | 创建一个 SqlStatement 对象，以允许在目标 MySQL 服务器上运行收到的 SQL 语句 |

注意`sql()`方法。我们可以使用这个方法来发布 SQL 语句，但是一般来说，在处理数据时我们不需要这样做，因为有一个`Table`对象。一旦我们看到哪些 CRUD 操作可用于处理关系数据，我们将更详细地研究这个类。

### CRUD 操作(关系数据)

X DevAPI 实现了一个创建、读取、更新和删除(CRUD)模型，用于处理模式中包含的对象。模式可以包含任意数量的集合、文档、表、视图和其他关系数据对象(如触发器)。在这一节中，我们将看到 schema 和 tables 类的概述。CRUD 模型是为模式中的所有对象实现的，这些对象可以包含文档存储和关系数据的数据。

正如我们将在第 [6](06.html) 章中看到的，文档存储数据 CRUD 操作使用动词 add、find、modify 和 remove，而关系数据使用匹配等效 SQL 命令(insert、select、update 和 delete)的术语。表 [4-6](#Tab6) 快速展示了这些方法是如何命名的，以及每个方法的简要描述。注意，我们对文档存储数据使用`Collection`类，对关系数据使用`Table`类。

表 4-6

文档存储和关系数据的 CRUD 操作

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

CRUD 操作

 | 

描述

 | 

文档存储

 | 

关系数据

 |
| --- | --- | --- | --- |
| 创造 | 添加新项目/对象 | `collection.add()` | `table.insert()` |
| 阅读 | 检索/搜索数据 | `collection.find()` | `table.select()` |
| 更新 | 修改数据 | `collection.modify()` | `table.update()` |
| 删除 | 移除项目/对象 | `collection.remove()` | `table.delete()` |

在下面几节中，我们将看到处理关系数据(模式和表)所需的特定于每个类的方法。让我们从查看 Schema 类的细节开始。

#### 模式类

模式是存储数据的对象的容器。回想一下，这可以是文档存储数据的集合，也可以是关系数据的表或视图。就像过去处理关系数据一样，您必须选择(或使用)一个模式来存储集合、表或视图中的数据。

虽然您可以混合使用文档存储数据(集合)和关系数据(表、视图)，但为了便于记忆，我们将研究 Schema 类方法，因为它们与处理关系数据有关。

表 [4-7](#Tab7) 显示了集合和表格的操作方法。同样，在本章和下一章中，我们将只使用这些方法来处理表，但是看一下文档存储方法并没有什么坏处。注意，create 和 get 方法返回一个对象的实例。例如，`get_table()`方法返回一个`Table`对象。

表 4-7

模式类方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

方法

 | 

返回

 | 

描述

 |
| --- | --- | --- |
| `get_tables()` | 目录 | 返回该模式的表列表 |
| `get_collections()` | 目录 | 返回此架构的集合列表 |
| `get_table(str name)` | 桌子 | 返回该模式的给定名称的表 |
| `get_collection(str name)` | 募捐 | 返回此架构的给定名称的集合 |
| `get_collection_as_table(str name)` | 桌子 | 返回一个代表数据库集合的 Table 对象 |
| `create_collection(str name)` | 募捐 | 在当前架构中创建具有指定名称的新集合，并检索表示所创建的新集合的对象 |
| `drop_collection(str name)` | 没有人 | 删除指定的集合 |

现在，让我们看看`Table`类的方法。

#### 表格类

表的概念是关系数据的主要组织机制。在 X DevAPI 中，表是我们都熟悉的相同的关系数据结构。X DevAPI 有一个`Table`(您也可以将它们用于视图)类，包含 CRUD 操作(选择、插入、更新和删除)以及用于计算行数或基对象是否是视图的其他方法。表 [4-8](#Tab8) 显示了`Table`类的方法。

表 4-8

表格类

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

方法

 | 

返回

 | 

描述

 |
| --- | --- | --- |
| `insert()` | 表格插入 | 创建 TableInsert 对象以向表中插入新记录 |
| `insert(list columns)` | 表格插入 | 使用列列表插入一行 |
| `insert(str col1, str col2,...)` | 表格插入 | 使用列的参数列表插入一行 |
| `select()` | 表格选择 | 创建 TableSelect 对象以从表中检索行 |
| `select(list columns)` | 表格选择 | 创建 TableSelect 对象以从表中检索行 |
| `update()` | 表格更新 | 创建记录更新处理程序 |
| `delete()` | 表删除 | 创建记录删除处理程序 |
| `is_view()` | 弯曲件 | 指示此表对象是否表示数据库上的视图 |
| `count()` | （同 Internationalorganizations）国际组织 | 返回表格中的行数 |
| `get_name()` | 潜艇用热中子反应堆（submarine thermal reactor 的缩写） | 返回对象的名称 |
| `get_session()` | 目标 | 返回该数据库对象的会话对象 |
| `get_schema()` | 目标 | 返回该数据库对象的架构对象 |
| `exists_in_database()` | 弯曲件 | 验证该对象是否存在于数据库中 |

请注意，没有创建表的方法。我们必须使用`CREATE TABLE` SQL 命令或`sql()`方法来执行 SQL 语句。事实上，没有创建任何关系数据对象的方法。您必须使用 SQL 发出适当的 create 语句来创建对象。例如，在前面的例子中，要为我们的*工厂 _ 传感器*数据创建一个表，我们可以使用下面的`CREATE TABLE`语句。虽然我们之前已经看到了这一点，但是下面显示了一个 Python 代码片段，其中我们声明了一个变量来保存查询，并演示了使用`sql()`方法执行查询。

```py
...
CREATE_TBL = """
CREATE TABLE `factory_sensors`.`trailer_assembly` (
  `id` int auto_increment,
  `sensor_name` char(30) NOT NULL,
  `sensor_value` float DEFAULT NULL,
  `sensor_event` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sensor_units` char(15) DEFAULT NULL,
  PRIMARY KEY `sensor_id` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
"""
my_session = mysqlx.get_session(user_info)
my_db = my_session.create_schema('factory_sensors')
sql_res = my_session.sql(CREATE_TBL).execute()
my_tbl = my_db.get_table('trailer_assembly')
...

```

### 小费

没有创建表或视图的 create 方法。您必须将 SQL 命令传递给`sql()`方法来创建这些(和其他关系数据)对象。

现在我们已经创建了表格，我们可以使用`Table`对象插入数据。回想一下，我们在这里有一组对象。我们从`Session`对象`create_schema()`方法开始，该方法返回一个`Database`对象，我们将该对象保存到一个名为`my_db`的变量中。在我们创建了表格之后，我们调用了`my_db.get_table()`方法来获取`Table`对象。

在我们看到处理数据的例子之前，让我们看看处理关系数据的其他类和方法。表 [4-9](#Tab9) 列出了与关系数据的 CRUD 操作相关的每个类的方法。

表 4-9

关系数据的 CRUD 操作类

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

班级

 | 

方法

 | 

返回

 | 

描述

 |
| --- | --- | --- | --- |
| 表格选择 | 对表进行记录检索操作的语句 |
| `select (list searchExprStr)` | 表格选择 | 定义要从表中检索的列 |
| `where (str expression)` | 表格选择 | 设置搜索条件以过滤要从表中检索的记录 |
| `group_by (list searchExprStr)` | 表格选择 | 为检索到的行设置分组标准 |
| `having (str condition)` | 表格选择 | 为聚合函数运算中要考虑的记录设置条件 |
| `order_by (list sortExprStr)` | 表格选择 | 设置检索记录的顺序 |
| `limit (int numberOfRows)` | 表格选择 | 设置选择操作返回的最大行数 |
| `offset (int numberOfRows)` | 表格选择 | 当定义了限制时，设置结果集上要跳过的行数 |
| `bind (str name, Value value)` | 表格选择 | 将值绑定到此操作中使用的特定占位符 |
| `execute ()` | RowResult | 使用所有配置的选项执行选择操作 |
| 表格插入 | 对表执行插入操作的语句 |
| `insert ()` | 表格插入 | 初始化记录插入处理程序 |
| `insert (list columns)` | 表格插入 | 用接收到的列列表初始化记录插入处理程序 |
| `insert (str col1, str col2,...)` | 表格插入 | 用接收到的列列表初始化记录插入处理程序 |
| `values (Value, Value value,...)` | 表格插入 | 用给定值向插入操作添加新行 |
| `execute ()` | 结果 | 执行插入操作 |
| 表格更新 | 对表进行记录更新操作的语句 |
| `update ()` | 表格更新 | 已初始化更新操作 |
| `set (str attribute, Value value)` | 表格更新 | 添加更新操作 |
| `where (str expression)` | 表格更新 | 设置搜索条件以过滤要更新的记录 |
| `order_by (list sortExprStr)` | 表格更新 | 设置记录更新的顺序 |
| `limit (int numberOfRows)` | 表格更新 | 设置操作要更新的最大行数 |
| `bind (str name, Value value)` | 表格更新 | 将值绑定到此操作中使用的特定占位符 |
| `execute ()` | 结果 | 使用所有配置的选项执行删除操作 |
| 表删除 | 删除表的语句 |
| `delete ()` | 表删除 | 已初始化此记录删除处理程序 |
| `where (str expression)` | 表删除 | 设置搜索条件以过滤要从表中删除的记录 |
| `order_by (list sortExprStr)` | 表删除 | 设置删除记录的顺序 |
| `limit (int numberOfRows)` | 表删除 | 设置操作要删除的最大行数 |
| `bind (str name, Value value)` | 表删除 | 将值绑定到此操作中使用的特定占位符 |
| `execute ()` | 结果 | 使用所有配置的选项执行删除操作 |

哇，方法真多！请注意，语句类之间有一些相似之处。例如，大多数都有绑定参数、搜索条件等的方法。为了更好地理解这一点，让我们看看 X DevAPI 用户指南中 CRUD 操作的语法图( [`https://dev.mysql.com/doc/x-devapi-userguide/en/`](https://dev.mysql.com/doc/x-devapi-userguide/en/) )。

我们将使用这些类和方法的方式是一个称为方法链的概念，我们可以将我们的类和方法调用组合成一个“链”，在这个“链”中，我们通过使用点标记来扩展语法，为返回的对象调用方法。换句话说，如果`method_a()`返回一个具有名为`count()`的方法的对象的实例，我们可以像这样将它链接在一起:`method_a().count()`，从而避免存储中间对象的需要。

### 什么是方法链？

方法链接(也称为命名参数习惯用法)是面向对象编程中的一种设计约束，其中每个方法(支持链接)返回一个对象实例。因此，只需将调用添加到第一个方法的末尾，就可以访问(调用)返回对象上的任何方法。

例如，如果一个类`X`有一个方法`a()`，它用方法`b()`返回对象`Y`，我们可以如下将调用链接在一起。

```py
x = something.get_x()
res = x.a().b()

```

在这种情况下，`x.a()`方法首先执行，然后当它返回一个`Y`对象实例时，它调用 Y 对象实例上的`b()`方法。

有关方法链接概念的更多信息，请参见 [`https://en.wikipedia.org/wiki/Method_chaining`](https://en.wikipedia.org/wiki/Method_chaining) 。

以下部分演示了关系数据的 CRUD 操作的简单示例。回想一下，我们将使用从会话中检索的表对象(实例)来执行 CRUD 操作。让我们来看一个例子。

#### 创建数据

创建操作使用一个名为`insert()`的`Table`对象方法，该方法将一列列表作为参数。然后，我们可以使用方法链(见后面)将值列表作为参数传递，从而将`values()`方法用于`TableInsert`对象。这是因为 insert()方法返回了一个`TableInsert`类的实例。例如，我们用下面的`INSERT`查询在前面的部分添加了一行。

```py
INSERT INTO factory_sensors.trailer_assembly (sensor_name, sensor_value, sensor_units) VALUES ('paint_vat_temp', 32.815, 'Celsius');

```

为了在 Python 中执行这个，我们使用下面的语句。注意，我们使用了一个变量来存储列的列表。我们还使用方法链接来调用`values()`和`execute()`方法，以便在一条语句中完成行插入。

```py
...
COLUMNS = ['sensor_name', 'sensor_value', 'sensor_units']
my_tbl.insert(COLUMNS).values('paint_vat_temp', 32.815, 'Celsius').execute()
...

```

图 [4-1](#Fig1) 显示了读取操作的语法图。这里，这个链相当小，因为我们只有两个中间对象(`values()`和`execute()`的“所有者”)。如果这看起来有点奇怪，不要难过。从 SQL 语句的世界过渡到高级编码技术可能是一个挑战，但是通过实践和更多的例子，像这样链接方法将变得非常自然。

![img/478423_1_En_4_Fig1_HTML.jpg](img/478423_1_En_4_Fig1_HTML.jpg)

图 4-1

语法图- `Table.insert()`

#### 阅读日期

从表对象中读取数据是我们使用方法链接将对象方法链接在一起的另一种情况。如果您考虑典型的`SELECT`语句的复杂性，那么读操作也可能相当复杂就不足为奇了。然而，我们将在这个演示中保持简单，在下一章看更复杂的例子。

下面是获取表中所有行的`SELECT`语句。

```py
SELECT sensor_value, sensor_name, sensor_units FROM factory_sensors.trailer_assembly;

```

同样的方法链接也适用于`select()`方法，它返回一个`Table`对象，在那里我们链接了`where()`子句。在这个简单的例子中，我们没有一个`WHERE`子句，所以我们没有参数。我们仍然添加了`execute()`方法来运行查询。

```py
...
COLUMNS = ['sensor_name', 'sensor_value', 'sensor_units']
my_res = my_tbl.select(COLUMNS).execute()
...

```

图 [4-2](#Fig2) 显示了`Table`类的`select()`方法的语法图。在这里，我们看到不同的类和方法是如何通过链末端的`execute()`方法链接在一起的。链中描述的各种方法是可选的，但是大多数读操作将包括`where()`方法(子句)。

![img/478423_1_En_4_Fig2_HTML.jpg](img/478423_1_En_4_Fig2_HTML.jpg)

图 4-2

语法图- `Table.select()`

#### 更新数据

更新操作类似于读取操作，我们使用一个或多个方法来指定在典型的`UPDATE` SQL 查询中可以找到的子子句。下面是一个简单的例子，我们用等于 1.52 的传感器值更新行，改变传感器单位。请注意，我们使用了 MySQL 函数库的一个技巧来将浮点值转换为特定的小数，以消除舍入产生的错误(`sensor_units = 1.52`不起作用)。

```py
UPDATE factory_sensors.trailer_assembly SET sensor_units = 'inches' WHERE sensor_value LIKE 1.52;

```

为了在 Python 中执行这个，我们使用表对象的`update()`方法，将它与`TableUpdate`对象的`set()`和`where()`方法链接起来，并传入我们的参数。

```py
my_tbl.update().set().where('sensor_value LIKE 1.52').execute()

```

图 [4-3](#Fig3) 显示了更新操作的语法图。这类似于 read 操作，因为我们有几个共同的中间步骤，如`WHERE`子句、order by 等。

![img/478423_1_En_4_Fig3_HTML.jpg](img/478423_1_En_4_Fig3_HTML.jpg)

图 4-3

语法图- `Table.update()`

#### 删除数据

删除操作类似于读取和更新操作，我们使用一个或多个方法来指定在典型的`DELETE` SQL 查询中会找到的子子句。下面是一个简单的例子，我们删除了传感器值为> 30 的行。

```py
DELETE FROM factory_sensors.trailer_assembly WHERE sensor_value > 30;

```

为了在 Python 中执行这个，我们使用表对象的`delete()`方法，并用`TableDelete`对象的`where()`方法链接它，并传入我们的参数。

```py
my_tbl.delete().where('sensor_value > 30').execute()

```

图 [4-3](#Fig3) 显示了更新操作的语法图。这类似于更新操作，因为我们有几个共同的中间步骤，如`WHERE`子句、order by 等。

![img/478423_1_En_4_Fig4_HTML.jpg](img/478423_1_En_4_Fig4_HTML.jpg)

图 4-4

语法图- `Table.delete()`

在我们看到使用关系数据的完整 Python 示例之前，我们还应该探索一件事——使用结果集(有时称为数据集)。

#### 使用结果

到目前为止，我们已经看到了一些处理结果的简单例子，虽然看起来所有的结果都是同一个类，但是有几个结果类。返回的结果类的对象实例取决于操作。例如，每种类型的结果都有一个单独的类。结果有时被称为数据集或结果集。

表 [4-10](#Tab10) 显示了您在处理数据集和结果时会遇到的所有类及其方法。所有结果类都是从 BaseResult 对象派生的，该对象提供了一组属性和基方法。为了完整起见，我在表中重复了这些。

### 注意

类方法用()表示，属性用()表示。

表 4-10

处理数据集和结果的类和方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

班级

 | 

方法

 | 

返回

 | 

描述

 |
| --- | --- | --- | --- |
| 结果 | 允许检索对数据库执行的非查询操作的相关信息 |
| `get_affected_item_count()` | （同 Internationalorganizations）国际组织 | 最后一道工序中受影响的物件数量 |
| `get_auto_increment_value()` | （同 Internationalorganizations）国际组织 | (从插入操作中)自动生成的最后一个插入 id |
| `get_generated_ids()` | 目录 | 返回服务器上生成的文档 id 列表 |
| `affected_item_count` | （同 Internationalorganizations）国际组织 | 与 get_affected_itemCount()相同 |
| `auto_increment_value` | （同 Internationalorganizations）国际组织 | 与 get_auto_increment_value()相同 |
| `generated_ids` | 目录 | 与 get_generated_ids()相同 |
| `affected_items_count` | （同 Internationalorganizations）国际组织 | 与 get_affected_items_count()相同 |
| `warning_count` | （同 Internationalorganizations）国际组织 | 与 get_warning_count()相同 |
| `warnings_count` | （同 Internationalorganizations）国际组织 | 与 get_warnings_count()相同 |
| `warnings` | 目录 | 与 get_warnings()相同 |
| `execution_time` | 潜艇用热中子反应堆（submarine thermal reactor 的缩写） | 与 get_execution_time()相同 |
| RowResult | 允许遍历表返回的行对象。选择操作 |
| `fetch_one()` | 排 | 检索 rowresult 中的下一行 |
| `fetch_all()` | 目录 | 返回 DbDoc 对象列表，其中包含每个未读文档的元素 |
| `get_column_count()` | （同 Internationalorganizations）国际组织 | 检索当前结果的列数 |
| `get_column_names()` | 目录 | 获取当前结果中的列 |
| `get_columns()` | 目录 | 获取活动结果中列的列元数据 |
| `column_count` | （同 Internationalorganizations）国际组织 | 与 get_column_count()相同 |
| `column_names` | 目录 | 与 get_column_names()相同 |
| `columns` | 目录 | 与 get_columns()相同 |
| `affected_items_count` | （同 Internationalorganizations）国际组织 | 与 get_affected_items_count()相同 |
| `warning_count` | （同 Internationalorganizations）国际组织 | 与 get_warning_count()相同 |
| `warnings_count` | （同 Internationalorganizations）国际组织 | 与 get_warnings_count()相同 |
| `warnings` | 目录 | 与 get_warnings()相同 |
| `execution_time` | 潜艇用热中子反应堆（submarine thermal reactor 的缩写） | 与 get_execution_time()相同 |
| SqlResult | 表示 SQL 语句的结果 |
| `get_auto_increment_value()` | （同 Internationalorganizations）国际组织 | 返回插入的最后一条记录的标识符 |
| `get_affected_row_count()` | （同 Internationalorganizations）国际组织 | 返回受已执行查询影响的行数 |
| `has_data()` | 弯曲件 | 如果最后一个语句执行有结果集，则返回 true |
| `next_data_set()` | 弯曲件 | 准备 SqlResult 以从下一个结果开始读取数据(如果返回了许多结果) |
| `next_result()` | 弯曲件 | 准备 SqlResult 以从下一个结果开始读取数据(如果返回了许多结果) |
| `auto_increment_value` | （同 Internationalorganizations）国际组织 | 与 get_auto_increment_value()相同 |
| `affected_row_count` | （同 Internationalorganizations）国际组织 | 与 get_affected_row_count()相同 |
| `column_count` | （同 Internationalorganizations）国际组织 | 与 get_column_count()相同 |
| `column_names` | 目录 | 与 get_column_names()相同 |
| `columns` | 目录 | 与 get_columns()相同 |
| `affected_items_count` | （同 Internationalorganizations）国际组织 | 与 get_affected_items_count()相同 |
| `warning_count` | （同 Internationalorganizations）国际组织 | 与 get_warning_count()相同 |
| `warnings_count` | （同 Internationalorganizations）国际组织 | 与 get_warnings_count()相同 |
| `warnings` | 目录 | 与 get_warnings()相同 |
| `execution_time` | 潜艇用热中子反应堆（submarine thermal reactor 的缩写） | 与 get_execution_time()相同 |
| domresult | 允许遍历由 Collection.find 操作返回的 DbDoc 对象 |
| `fetch_one()` | 文件 | 在 domresult 上检索下一个 dbdoc |
| `fetch_all()` | 目录 | 返回 DbDoc 对象列表，其中包含每个未读文档的元素 |
| `affected_items_count` | （同 Internationalorganizations）国际组织 | 与 get_affected_items_count()相同 |
| `warning_count` | （同 Internationalorganizations）国际组织 | 与 get_warning_count()相同 |
| `warnings_count` | （同 Internationalorganizations）国际组织 | 与 get_warnings_count()相同 |
| `warnings` | 目录 | 与 get_warnings()相同 |
| `execution_time` | 潜艇用热中子反应堆（submarine thermal reactor 的缩写） | 与 get_execution_time()相同 |

有迭代器的三个类实现了两个方法:`fetch_one()`和`fetch_all()`。它们像您想象的那样工作，返回一个数据集或一组文档的一组对象。`fetch_one()`方法返回数据集中的下一个数据项，如果没有更多的数据项，则`NULL`返回所有的数据项。更具体地说，`fetch_one()`一次从服务器检索一个数据项，而`fetch_all()`一次从服务器检索所有数据。您使用哪一个将取决于数据集的大小和您想要如何处理数据。

那么，这在 Python 中是什么样子的呢？下面显示了一个简单的例子，执行一个读操作来获取表中的所有行(没有`WHERE`子句)。这里，我们首先检索表列的列表，以便打印它们。我们将使用两个循环:一个循环遍历列名列表，另一个循环遍历读取操作返回的行。

```py
column_names = my_res.get_column_names()
column_count = my_res.get_column_count()
for i in range(0,column_count):
    if i < column_count - 1:
        print "{0}, ".format(column_names[i]),
    else:
        print "{0}".format(column_names[i]),
print

```

在这里，我们看到了一些用于获得结果的 Python 语句。在这种情况下，我们使用的是`TableSelect`类，但是由于大多数结果类都有相同的方法，所以对于其他结果，您的代码也是类似的。您可能会注意到一些基本的格式化代码，使输出以逗号分隔。这只是为了演示。您自己的应用可能会一次消费一行数据，并对其进行处理。然而，获取列和获取行的概念是相同的。一旦你记下这些概念，我们只需要添加如何开始的概念。

### 开始编写 Python 脚本

现在是时候获取一些实际的代码了，我们可以使用这些代码来加强到目前为止所讨论的概念。让我们来看一个简单的例子。乍一看，这段代码似乎有点吓人，但它是一个非常简单的示例，包含您需要通过打开一个会话、创建新模式和创建表来连接到服务器的样板代码。从这里，我们看到了从对表对象的`select()`调用开始的 CRUD 操作的例子，以及使用 CRUD 操作的演示。

清单 [4-6](#PC36) 显示了一个 Python 脚本来创建之前使用的数据库和表，包括添加数据和执行简单的 select 查询。只是，这次我们用 Python 来做！如果您想继续，请打开 shell 并连接到您的服务器，如下所示。

```py
#
# Introducing the MySQL 8 Shell
#
# This example shows a simple X DevAPI script to work with relational data
#
# Dr. Charles A. Bell, 2019

from mysqlsh import mysqlx # needed in case you run the code outside of the shell

# SQL CREATE TABLE statement
CREATE_TBL = """
CREATE TABLE `factory_sensors`.`trailer_assembly` (
  `id` int auto_increment,
  `sensor_name` char(30) NOT NULL,
  `sensor_value` float DEFAULT NULL,
  `sensor_event` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sensor_units` char(15) DEFAULT NULL,
  PRIMARY KEY `sensor_id` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
"""

# column list, user data structure
COLUMNS = ['sensor_name', 'sensor_value', 'sensor_units']
user_info = {
  'host': 'localhost',
  'port': 33060,
  'user': 'root',
  'password': 'secret',
}

print("Listing 4-6 Example - Python X DevAPI Demo with Relational Data.")
# Get a session (connection)
my_session = mysqlx.get_session(user_info)
# Precautionary drop schema
my_session.drop_schema('factory_sensors')
# Create the database (schema)
my_db = my_session.create_schema('factory_sensors')
# Execute the SQL statement to create the table
sql_res = my_session.sql(CREATE_TBL).execute()
# Get the table object
my_tbl = my_db.get_table('trailer_assembly')
# Insert some rows (data)
my_tbl.insert(COLUMNS).values('paint_vat_temp', 32.815, 'Celsius').execute()
my_tbl.insert(COLUMNS).values('tongue_height_variance', 1.52, 'mm').execute()
my_tbl.insert(COLUMNS).values('ambient_temperature', 24.5, 'Celsius').execute()
my_tbl.insert(COLUMNS).values('gross_weight', 1241.01, 'pounds').execute()
# Execute a simple select (SELECT ∗ FROM)
print("\nShowing results after inserting all rows.")
my_res = my_tbl.select(COLUMNS).execute()
# Display the results . Demonstrates how to work with results
# Print the column names followed by the rows
column_names = my_res.get_column_names()
column_count = my_res.get_column_count()
for i in range(0,column_count):
    if i < column_count - 1:
        print "{0}, ".format(column_names[i]),
    else:
        print "{0}".format(column_names[i]),
print

for row in my_res.fetch_all():
    for i in range(0,column_count):
        if i < column_count - 1:
            print "{0}, ".format(row[i]),
        else:
            print "{0}".format(row[i]),
    print

# Update a row
my_tbl.update().set('sensor_units', 'inches').where('sensor_value LIKE 1.52').execute()
print("\nShowing results after updating row with sensor_value LIKE 1.52.")
# Execute a simple select (SELECT ∗ FROM)
my_res = my_tbl.select(COLUMNS).execute()
# Display the results
for row in my_res.fetch_all():
    print row
# Delete some rows
my_tbl.delete().where('sensor_value > 30').execute()
# Execute a simple select (SELECT ∗ FROM)
print("\nShowing results after deleting rows with sensor_value > 30.")
my_res = my_tbl.select(COLUMNS).execute()
# Display the results
for row in my_res.fetch_all():
    print row
# Delete the database (schema)
my_session.drop_schema('factory_sensors')

Listing 4-6Simple Relational Data Example

```

花点时间通读代码，确保找到 CRUD 操作。同样，这些都是非常简单的例子，只有一些关于`WHERE`子句表达式的小例子。注释行和额外的打印语句形成了一个指南，有助于使代码更易于阅读。我们将在下一章看到一个更详细的例子，完整地解释如何使用各种方法来限制输出(`WHERE`子句)。

现在，让我们看看代码的执行。在这种情况下，我们将使用 shell 的批处理执行特性来读取我们之前创建的文件并执行它。清单 [4-7](#PC37) 显示了运行脚本的命令和结果。

```py
C:\Users\cbell\MySQL Shell\source\Ch04>mysqlsh --py -f listing4-6.py
Listing 4-6 Example - Python X DevAPI Demo with Relational Data.

Showing results after inserting all rows.
sensor_name,  sensor_value,  sensor_units
paint_vat_temp,  32.815,  Celsius
tongue_height_variance,  1.52,  mm
ambient_temperature,  24.5,  Celsius
gross_weight,  1241.01,  pounds

Showing results after updating row with sensor_value LIKE 1.52.
[
    "paint_vat_temp",
    32.815,
    "Celsius"
]
[
    "tongue_height_variance",
    1.52,
    "inches"
]
[
    "ambient_temperature",
    24.5,
    "Celsius"
]
[
    "gross_weight",
    1241.01,
    "pounds"
]

Showing results after deleting rows with sensor_value > 30.
[
    "tongue_height_variance",
    1.52,
    "inches"
]
[
    "ambient_temperature",
    24.5,
    "Celsius"
]

Listing 4-7Executing the Sample Code

```

输出显示了第一个读取操作，该操作使用我们前面看到的处理结果的方法打印行，即以逗号分隔的输出形式打印列名和行，每行一行。另一个输出显示了结果是如何返回给 Python 的——它们是列表的列表！这就是为什么我们看到输出显示为行的字符串值列表。

花点时间再次浏览代码，确保您可以看到 CRUD 操作对数据的影响。也就是说，在每次读取、更新和删除操作之后，结果的输出应该略有不同。

### 连接器/Python 呢？

如果您一直在使用名为 Connector/Python 的 Python 数据库连接器，您可能会想知道这里有什么不同，而连接器却不能做到。在这一点上，你的直觉是正确的。到目前为止，我介绍的所有内容都可以用连接器和优秀的 Python 编程来完成。事实上，正是这种重叠表明 X DevAPI 已经实现了它的一个目标。

现在，您可能有兴趣知道连接器完全支持 X DevAPI，并且Shell使用了连接器。我们正在学习如何从一个不同的角度处理我们的数据——数据的角度就是代码。一旦你阅读了第 6 章，它将全部点击(如果它还没有)。

## 摘要

MySQL 中传统的数据存储和检索机制是 SQL 接口。这是大多数人熟悉的，事实上大多数人学习 SQL 是为了成为开发人员或数据库管理员。因此，对于许多人来说，学习像 MySQL Shell 这样的新工具最好从熟悉的 SQL 开始。事实上，这就是本章的全部内容。

在这一章中，我们看到了一个简单的游览，首先是在传统的 SQL 交互会话中使用 shell，在这个会话中我们发出 SQL 语句并处理关系数据。它很熟悉，并且演示了关系数据的基本概念。即使您以前没有使用过 SQL，这个小演示也足以让您上手。

然而，趋势是将我们的数据混合到我们的代码中，也就是说，使我们的数据成为代码的一部分。为此，我们需要一个强大的 API，让我们可以像处理代码中的对象一样处理数据。X DevAPI 就是答案。此外，我们还看到了对用于关系数据的 X DevAPI 的简要介绍。我们不仅学习了如何开始使用 X DevAPI，还看到了一些可用的 Python 代码，您可以使用它们开始编写自己的 Python 脚本。

但这仅仅是开始。我们真正需要的是一个更大的例子，可以作为编写更高级 Python 脚本的教程。下一章将更详细地介绍本章中介绍的概念。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

MySQL 命令列表中并不是所有的 SQL 命令都是真正的标准 SQL 命令。许多实用程序命令都是非标准的 SQL 命令。因此，如果您使用其他数据库系统，这些命令可能看起来相似，但略有不同。

  [2](#Fn2_source)

虽然在某些层面上非常不准确，但对于数据库新手来说，这种相似性是有效的。

  [3](#Fn3_source)

[T2`https://dev.mysql.com/doc/refman/8.0/en/access-control.html`](https://dev.mysql.com/doc/refman/8.0/en/access-control.html)

  [4](#Fn4_source)

[T2`https://dev.mysql.com/doc/refman/8.0/en/functions.html`](https://dev.mysql.com/doc/refman/8.0/en/functions.html)

  [5](#Fn5_source)

所以，如果不使用索引，你永远不要期望结果是相同的顺序！可以演示在一个系统上输入的相同数据在另一个系统(如系统)上输入时会有什么不同。这涉及到很多因素，包括字符集、操作系统等。这可能会导致订单不同。如果顺序是一个问题，使用索引。

  [6](#Fn6_source)

[T2`https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html`](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html)

  [7](#Fn7_source)

[T2`https://dev.mysql.com/doc/refman/8.0/en/create-procedure.html`](https://dev.mysql.com/doc/refman/8.0/en/create-procedure.html)

  [8](#Fn8_source)

[T2`https://dev.mysql.com/doc/refman/8.0/en/sql-syntax-data-definition.html`](https://dev.mysql.com/doc/refman/8.0/en/sql-syntax-data-definition.html)

  [9](#Fn9_source)

在这种情况下，对象是一个类的可执行实例。

  [10](#Fn10_source)

[T2`https://dev.mysql.com/doc/refman/8.0/en/savepoint.html`](https://dev.mysql.com/doc/refman/8.0/en/savepoint.html)

 </aside>