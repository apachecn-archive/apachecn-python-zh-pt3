# 3.三维图形

在本章中，您将学习如何在三维空间中创建、平移和旋转三维对象。您还将学习如何将它们投影并显示在计算机屏幕的二维表面上。物体的一般运动意味着平移和旋转。在前一章中，我从两个方面讨论了这一点。你看到了二维的平移是微不足道的。只需在 x 坐标上加上或减去一个量，就可以在 x 方向上平移，对于 y 方向也是如此。在三维空间，这仍然是微不足道的，尽管你现在能够在第三维空间，z 方向，简单地通过增加或减少一个物体的 z 坐标。然而，旋转是另一回事。该分析遵循您在二维空间中使用的方法，但由于您现在能够围绕三个坐标方向旋转对象，因此该分析变得复杂。在这一章中，我将不再进一步讨论 3D 平移，而是集中讨论 3D 旋转。

## 3.1 三维坐标系

在前面关于二维旋转的讨论中，您在二维 x，y 平面中旋转了二维对象。你现在通过引入第三个轴，z 轴，将这些概念扩展到三维，如图 [3-1](#Fig1) 所示。请注意，z 轴指向屏幕内部，而不是外部。这不是一个任意的选择。我们遵循右手定则惯例，通过 x 轴和 y 轴之间的较小角度，将 x 轴向 y 轴旋转，找到 z 轴的正方向。当以这种方式转动时，z 轴的正方向将指向右旋螺钉所遵循的方向。在这种情况下，螺钉会进入筛网；这就是 z 轴的正方向。我们可以基于一个左手螺旋构建一个完整的数学理论，但是最普遍使用的惯例是右手系统。有些书和论文把坐标轴标注为 x1，x2，x3。按照右手定则，如上所述，通过将 x1 旋转到 x2，可以找到 x3 的方向。在这项工作中，我们将继续使用 x，y，z 符号来表示方向。

![A456962_1_En_3_Fig1_HTML.jpg](A456962_1_En_3_Fig1_HTML.jpg)

图 3-1

Three-dimensional coordinate axes with point P at coordinates (x,y,z)

现在应该很清楚为什么我在前面的二维旋转的讨论中使用术语 Rz；它是指围绕 z 轴的旋转。当 x 向右，y 向下时，这表现为 x-y 平面中的顺时针旋转。如果 x 向右，y 向上，z 将指向屏幕外，绕 z 轴的正向旋转将表现为逆时针旋转。

按照二维旋转分析中使用的方法，在本章的剩余部分，我将讨论绕 x、y 和 z 轴的独立旋转，然后讨论绕所有三个轴的组合旋转。顺便说一下，当我说“绕 x 轴旋转”时，例如，我在暗示这等同于“绕 x 方向旋转”，反之亦然。虽然绕平行于 x 轴的假想轴的旋转与绕 x 轴的旋转并不完全相同，但区别只是平移的问题。我将交替使用这两个术语，除非会引起混淆。

图 [3-2](#Fig2) 显示了右侧的 x、y、z 系统。想象你站在原点，向 x 轴方向看去。如果你顺时针转动一个右旋的螺丝，它会沿着 x 轴的正方向前进。双向箭头是指示右旋方向 Rx 的常规方式；Ry 和 Rz 也是如此。

为什么我选择如图 [3-2](#Fig2) 所示的坐标系定向？标准 matplotlib 使用不同的方向，例如在 [`https://matplotlin.org/mpl_toolkits/mplot3d/tutorial.html#scatter-plots`](https://matplotlin.org/mpl_toolkits/mplot3d/tutorial.html#scatter-plots) 中所示。

![A456962_1_En_3_Fig2_HTML.jpg](A456962_1_En_3_Fig2_HTML.jpg)

图 3-2

Three-dimensional coordinate axes showing right-hand rotation around each coordinate direction

如前所述，图 [3-2](#Fig2) 中的方向更加直观。正在构建的对象位于由 x、y、z 轴定义的空间内。在这种情况下，观察者在空间之外向内看。该物体可以任意平移和旋转以给出任何期望的视图。你可以直视一个物体，也可以从上方或下方观看，就像第 10 章[中土星的照片所示。另一方面，matplotlib 方向是数据绘图常用的方向，也是你在第 9 章](10.html)[中要用到的方向；查看图](09.html) [9-1](09.html#Fig1) 至 [9-5](09.html#Fig5) 。如果你更喜欢标准的 matplotlib 系统，很容易改变到那个方向；就像在第 [9](09.html) 章中所做的那样，将轴旋转到任何你想要的方向，其中，为了使 z 指向上，你围绕全局 x 方向旋转-100 度(稍微向前倾斜 z)，全局 y 轴旋转-135 度，全局 z 方向旋转+8 度(参见清单 [9-1](#Par55) 中的第 191-193 行)。您可以通过围绕全局轴的小旋转来微调方向。在你完成这一章之后，如果你愿意，你会发现给背景平面着色很容易，如 matplotlib 所示。只要遵循右手定则，您可以任意确定轴的方向。

## 3.2 坐标平面上的投影

我们如何在二维电脑显示器上显示三维物体？我们通过将物体投影到三个二维坐标平面(x，y；x，z；和 y，z ),然后在监视器上绘制这些图像中的任何一个。图 [3-3](#Fig3) 显示了一条从 A 到 b 的三维线(黑色)。从绘图空间上方向下看 x，z 平面，您会看到它是一条红线，它是黑线在 x，z 平面上的投影。类似地，绿线显示了它在 y，z 平面上的投影；蓝线是它在 x，y 平面上的投影。我将只使用这些投影中的一个进行可视化，通常是 x，y 投影。

![A456962_1_En_3_Fig3_HTML.jpg](A456962_1_En_3_Fig3_HTML.jpg)

图 3-3

Projection of a three-dimensional line (black) onto the three coordinate planes: red=x,z projection, green=y,z projection, and blue=x,y projection

x，y 投影是通过在 x，y 平面上绘制一个点的 x 和 y 坐标获得的；对于一条直线，在直线端点的 x 和 y 坐标之间绘制一条直线。在从空间坐标(xA，yA，zA)到(xB，yB，zB)的黑线的情况下，在 xA，yA 和 xB，yB 之间绘制一条线:

```
plt.plot([xA,xB],[yA,yB],color='b')

```

这给你一条蓝线，它是在 x，y 平面上的投影，如图 [3-4](#Fig4) 所示。如果你想得到顶视图，你画出黑线的 z，x 坐标。如果使用普通坐标轴绘图，x 轴从左向右，y 轴从左向下，则 y 轴将替换 z 轴。这相当于绕 x 轴旋转-90 度。然后，在直线的 z 和 x 坐标之间绘制

```
plt.plot([zA,zB],[xA,xB],color='r')

```

去拿红线。要获得绿色的 y，z 投影，可以使用命令绘制 z 和 y 坐标

![A456962_1_En_3_Fig4_HTML.jpg](A456962_1_En_3_Fig4_HTML.jpg)

图 3-4

Projection of a three-dimensional line onto the x, y plane

```
plt.plot([zA,zB],[yA,yB],color='g')

```

在这种情况下，您必须重新定向屏幕坐标轴，使+z 从左向右穿过屏幕顶部，y 轴从右侧向下。这将给出从 x，y，z 坐标系之外的 z，y 视图。

注意，在投影到 x，y 平面的情况下，不使用对象的 z 坐标。但是你仍然需要它们来执行旋转。类似地，对于其他投影，投影不需要一个坐标，但旋转需要一个坐标，因此它必须包含在分析中。

为了简化一切，您将在接下来的大部分工作中使用 x，y 投影。正如您将看到的，围绕三个坐标方向旋转一个对象并将该对象的(x，y)坐标投影到 x，y 平面上将产生一个三维视图。

三维物体在二维坐标平面上的投影称为等距投影。它们通常用于工程和制图。这些图像看起来不像它们在人眼或照片中的样子，因为缺少艺术家所说的透视缩小，更普遍的说法是透视。举一个透视缩小的例子，如果你沿着铁路轨道向下看一排向远处延伸的电线杆，离你最近的电线杆看起来会比远处的电线杆高，当它们接近地平线时，铁轨看起来会合并。什么导致透视缩短？这仅仅是因为眼睛在远处比在近处能看到更多的区域。以电线杆为例，这是因为远处有更多的垂直空间，所以固定高度的电线杆所占的比例较小；对于铁轨来说，这是不断扩大的水平空间。等轴测投影不考虑透视缩小，但我会在第 [4](04.html) 章讨论透视变换时考虑。

![A456962_1_En_3_Fig5_HTML.jpg](A456962_1_En_3_Fig5_HTML.jpg)

图 3-5

Isometric vs. perspective views

虽然您已经看到了如何将一条简单的三维线及其端点投影到三个坐标平面上，但是您可能已经处理过由许多点和线组成的更复杂的对象。正如你所看到的，甚至一个圆也可以仅仅由点(点)或线构成，并且有任何程度的细化。

虽然是一个简单的例子，但三维线说明了您将在以下工作中使用的方法:根据具有坐标(x，y，z)的点和线在三维 x，y，z 空间内定义形状；通过旋转和平移对它们进行操作；将它们投影到 x，y 平面上。然后用它们的 x 和 y 坐标把它们画出来。因此，您可以将 3D 对象投影到计算机显示器的屏幕上。

在三维空间中旋转一个点意味着围绕 x、y 和 z 方向旋转它。在前一章中，你看到了如何围绕 z 方向，Rz，进行二维旋转。在这里，您将获得绕 y、x 和 z 方向旋转的三维变换。

## 3.3 绕 y 方向旋转

图 [3-6](#Fig6) 显示了围绕 y 方向 ry 旋转的单位矢量几何图形。这是俯视 x，y，z 系统顶部时看到的视图。y 轴伸入纸的平面。

![A456962_1_En_3_Fig6_HTML.jpg](A456962_1_En_3_Fig6_HTML.jpg)

图 3-6

Unit vectors for rotation about the y direction. This is a view looking down on the plotting space. The y axis runs into the plane of the paper.

按照第 [2](02.html) 章中使用的方法，一个位置最初由矢量 P 定义的点被旋转到 P<sup>′</sup>。定义 P 和 P’在 x、y、z(未旋转)和 x’、y’、z’(旋转)系统中的位置的矢量是

![$$ \mathbf{P}= xp\widehat{\mathbf{i}}+ yp\widehat{\mathbf{j}}+ zp\widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ1.gif)

【3-1】

![$$ {\mathbf{P}}^{\prime }=x{p}^{\prime}\widehat{\mathbf{i}}+y{p}^{\prime}\widehat{\mathbf{j}}+z{p}^{\prime}\widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ2.gif)

【3-2】

![$$ {\mathbf{P}}^{\prime }= xp{\widehat{\mathbf{i}}}^{\prime }+ yp{\widehat{\mathbf{j}}}^{\prime }+ zp{\widehat{\mathbf{k}}}^{\prime } $$](A456962_1_En_3_Chapter_Equ3.gif)

【3-3】其中 i\、j\和 k\是在 x、y 和 z 方向上的单位矢量，i\\\\\\\\\\\\\\\\\'和 k\\\\\\\\\\\\\\从图 [3-6](#Fig6) 可以看出

![$$ {\widehat{\mathbf{i}}}^{\prime }=\mathit{\cos}(Ry)\kern0.1em \widehat{\mathbf{i}}+(0)\widehat{\mathbf{j}}-\mathit{\sin}(Ry)\kern0.1em \widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ4.gif)

(3-4)

![$$ {\widehat{\mathbf{j}}}^{\prime }=(0)\kern0.1em \widehat{\mathbf{i}}+(1)\widehat{\mathbf{j}}-(0)\kern0.1em \widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ5.gif)

(3-5)

![$$ {\widehat{\mathbf{k}}}^{\prime }=\mathit{\sin}(Ry)\kern0.1em \widehat{\mathbf{i}}+(0)\widehat{\mathbf{j}}-\mathit{\cos}(Ry)\kern0.1em \widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ6.gif)

(3-6)

将它们代入方程 [3-3](#Equ3) 得到

![$$ {\mathbf{P}}^{\prime }= xp\left[\mathit{\cos}(Ry)\widehat{\mathbf{i}}-\mathit{\sin}(Ry)\widehat{\mathbf{k}}\right]+ yp\widehat{\mathbf{j}}+ zp\left[\mathit{\sin}(Ry)\widehat{\mathbf{i}}+\mathit{\cos}(Ry)\widehat{\mathbf{k}}\right] $$](A456962_1_En_3_Chapter_Equ7.gif)

(3-7)

分离成<sup>ˇ</sup>I、<sup>ˇ</sup>j、k<sup>ˇ</sup>分量，得到

![$$ {\mathbf{P}}^{\prime }=\underset{x{p}^{\prime }}{\underbrace{\left[ xpcos(Ry)+ zp\kern0.1em \mathit{\sin}(Ry)\right]}}\widehat{\mathbf{i}}+\underset{y{p}^{\prime }}{\underbrace{\left[ yp\right]}}\widehat{\mathbf{j}}+\underset{z{p}^{\prime }}{\underbrace{\left[- xp\kern0.1em \mathit{\sin}(Ry)+ zp\kern0.1em \mathit{\cos}(Ry)\right]}}\widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ8.gif)

(3-8))

用方程式 [3-2](#Equ2) 、

、![$$ x{p}^{\prime }= xp\kern0.1em \mathit{\cos}(Ry)+ zp\kern0.1em \mathit{\sin}(Ry) $$](A456962_1_En_3_Chapter_Equ9.gif)、

、

、【3-10】、

、

、【3-11】

等式 [3-9](#Equ9) 到 [3-11](#Equ11) 给出了旋转点在本地 x、y、z 系统中的坐标。当然，方程 [3-10](#Equ10) 中的 yp′= yp，因为 y 坐标不会随着绕 y 轴的旋转而改变。

方程 [3-9](#Equ9) 、 [3-10](#Equ10) 、 [3-11](#Equ11) 可以用矩阵形式表示，如方程 [3-12](#Equ12) :

![$$ \left[\begin{array}{c}x{p}^{\prime}\\ {}y{p}^{\prime}\\ {}z{p}^{\prime}\end{array}\right]=\left[\begin{array}{ccc}\mathit{\cos}(Ry)& 0& \mathit{\sin}(Ry)\\ {}0& 1& 0\\ {}-\mathit{\sin}(Ry)& 0& \mathit{\cos}(Ry)\end{array}\right]\kern0.1em \left[\begin{array}{c} xp\\ {} yp\\ {} zp\end{array}\right] $$](A456962_1_En_3_Chapter_Equ12.gif)

(3-12)所示

它可以缩写为

![$$ \left[{P}^{\hbox{'}}\right]=\left[ Ry\right]\kern0.1em \left[P\right] $$](A456962_1_En_3_Chapter_Equ13.gif)

(3-13)

【Ry】，y 轴旋转的变换矩阵，是

![$$ \left[ Ry\right]=\left[\begin{array}{ccc} Cy\left(1,1\right)& Cy\left(1,2\right)& Cy\left(1,3\right)\\ {} Cy\left(2,1\right)& Cy\left(2,2\right)& Cy\left(2,3\right)\\ {} Cy\left(3,1\right)& Cy\left(3,2\right)& Cy\left(3,3\right)\end{array}\right] $$](A456962_1_En_3_Chapter_Equ14.gif)

(3-14)

![$$ Cy\left(1,1\right)=\mathit{\cos}(Ry) $$](A456962_1_En_3_Chapter_Equ15.gif)

(3-15)

![$$ Cy\left(1,2\right)=0 $$](A456962_1_En_3_Chapter_Equ16.gif)

(3-16)

![$$ Cy\left(1,3\right)=\mathit{\sin}(Ry) $$](A456962_1_En_3_Chapter_Equ17.gif)

(3-17)

![$$ Cy\left(2,1\right)=0 $$](A456962_1_En_3_Chapter_Equ18.gif)

(3-18)

![$$ Cy\left(2,2\right)=0 $$](A456962_1_En_3_Chapter_Equ19.gif)

(3-19)

![$$ Cy\left(2,3\right)=0 $$](A456962_1_En_3_Chapter_Equ20.gif)

(3-20)

![$$ Cy\left(3,1\right)=-\mathit{\sin}(Ry) $$](A456962_1_En_3_Chapter_Equ21.gif)

(T23)

这些元素将在随后的程序中使用。

## 3.4 绕 x 方向旋转

图 [3-7](#Fig7) 显示了绕 x 方向旋转的单位矢量几何图形。

![A456962_1_En_3_Fig7_HTML.jpg](A456962_1_En_3_Fig7_HTML.jpg)

图 3-7

Unit vectors for rotation around the x direction. The x axis runs into the plane of the paper.

你看那个

![$$ {\widehat{\mathbf{i}}}^{\prime }=(1)\kern0.1em \widehat{\mathbf{i}}+(0)\widehat{\mathbf{j}}+(0)\kern0.1em \widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ24.gif)

(3-24)

![$$ {\widehat{\mathbf{j}}}^{\prime }=(0)\kern0.1em \widehat{\mathbf{i}}+\mathit{\cos}(Rx)\kern0.1em \widehat{\mathbf{j}}+\mathit{\sin}(Rx)\kern0.1em \widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ25.gif)

(3-25)

![$$ {\widehat{\mathbf{k}}}^{\prime }=(0)\kern0.1em \widehat{\mathbf{i}}-\mathit{\sin}(Rx)\kern0.1em \widehat{\mathbf{j}}+\mathit{\cos}(Rx)\kern0.1em \widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ26.gif)

(3-26)

按照上一节的方法，

![$$ \mathbf{P}= xp\widehat{\mathbf{i}}+ yp\widehat{\mathbf{j}}+ zp\widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ27.gif)

(3-27)

![$$ {\mathbf{P}}^{\prime }= xp\widehat{\mathbf{i}}+ yp\left[\mathit{\cos}(Rx)\widehat{\mathbf{j}}+\mathit{\sin}(Rx)\widehat{\mathbf{k}}\right]+ zp\left[-\mathit{\sin}(Rx)\widehat{\mathbf{j}}+\mathit{\cos}(Rx)\widehat{\mathbf{k}}\right] $$](A456962_1_En_3_Chapter_Equ28.gif)

(3-28)

![$$ =\underset{x{p}^{\prime }}{\underbrace{xp}}\widehat{\mathbf{i}}+\underset{y{p}^{\prime }}{\underbrace{\left[ yp\kern0.1em \mathit{\cos}(Rx)- zp\kern0.1em \mathit{\sin}(Rx)\right]}}\widehat{\mathbf{j}}+\underset{z{p}^{\prime }}{\underbrace{\left[ yp\kern0.1em \mathit{\sin}(Rx)+ zp\kern0.1em \mathit{\cos}(Rx)\right]}}\widehat{\mathbf{k}} $$](A456962_1_En_3_Chapter_Equ29.gif)

(3-29)

在矩阵形式中是

![$$ \left[\begin{array}{c}x{p}^{\prime}\\ {}y{p}^{\prime}\\ {}z{p}^{\prime}\end{array}\right]=\left[\begin{array}{ccc}1& 0& 0\\ {}0& \mathit{\cos}(Rx)& -\mathit{\sin}(Rx)\\ {}0& \mathit{\sin}(Rx)& \mathit{\cos}(Rx)\end{array}\right]\kern0.1em \left[\begin{array}{c} xp\\ {} yp\\ {} zp\end{array}\right] $$](A456962_1_En_3_Chapter_Equ30.gif)

(3-30)，可以缩写为

![$$ \left[{P}^{\hbox{'}}\right]=\left[ Rx\right]\kern0.1em \left[P\right] $$](A456962_1_En_3_Chapter_Equ31.gif)

(3-31)

这就引出了用于 x 方向旋转的变换矩阵

![$$ \left[ Rx\right]=\left[\begin{array}{ccc}1& 0& 0\\ {}0& \mathit{\cos}(Rx)& -\mathit{\sin}(Rx)\\ {}0& \mathit{\sin}(Rx)& \mathit{\cos}(Rx)\end{array}\right] $$](A456962_1_En_3_Chapter_Equ32.gif)

(3-32)

![$$ \left[ Rx\right]=\left[\begin{array}{ccc} Cx\left(1,1\right)& Cx\left(1,2\right)& Cx\left(1,3\right)\\ {} Cx\left(2,1\right)& Cx\left(2,2\right)& Cx\left(2,3\right)\\ {} Cx\left(3,1\right)& Cx\left(3,2\right)& Cx\left(3,3\right)\end{array}\right] $$](A456962_1_En_3_Chapter_Equ33.gif)

(3-33)

![$$ Cx\left(1,1\right)=1 $$](A456962_1_En_3_Chapter_Equ34.gif)

(3-34)

![$$ Cx\left(1,2\right)=0 $$](A456962_1_En_3_Chapter_Equ35.gif)

(3-35)

![$$ Cx\left(1,3\right)=0 $$](A456962_1_En_3_Chapter_Equ36.gif)

(3-36)

![$$ Cx\left(2,1\right)=0 $$](A456962_1_En_3_Chapter_Equ37.gif)

(3-37)

![$$ Cx\left(2,2\right)=\mathit{\cos}(Rx) $$](A456962_1_En_3_Chapter_Equ38.gif)

(3-38)

![$$ Cx\left(2,3\right)=-\mathit{\sin}(Rx) $$](A456962_1_En_3_Chapter_Equ39.gif)

## 3.5 绕 z 方向旋转

在第 [2](02.html) 章中，你推导出了绕 z 方向二维旋转的变换矩阵。你现在将在三维空间中做这件事。重复第 [2](02.html) :

![$$ \left[\begin{array}{c}x{p}^{\prime}\\ {}y{p}^{\prime}\end{array}\right]=\left[\begin{array}{cc}\mathit{\cos}(Rz)& -\mathit{\sin}(Rz)\\ {}\mathit{\sin}(Rz)& \mathit{\cos}(Rz)\end{array}\right]\kern0.1em \left[\begin{array}{c} xp\\ {} yp\end{array}\right] $$](A456962_1_En_3_Chapter_Equ43.gif)

(3-43)章中的二维 Rz 矩阵(方程 [3-43](#Equ43)

在三个维度中，你有以下几种:

![$$ \left[\begin{array}{c}x{p}^{\prime}\\ {}y{p}^{\prime}\\ {}z{p}^{\prime}\end{array}\right]=\left[\begin{array}{ccc}\mathit{\cos}(Rz)& -\mathit{\sin}(Rz)& 0\\ {}\mathit{\sin}(Rz)& \mathit{\cos}(Rz)& 0\\ {}0& 0& 1\end{array}\right]\kern0.1em \left[\begin{array}{c} xp\\ {} yp\\ {} zp\end{array}\right] $$](A456962_1_En_3_Chapter_Equ44.gif)

(3-44)

![$$ \left[ Rz\right]=\left[\begin{array}{ccc} Cz\left(1,1\right)& Cz\left(1,2\right)& Cz\left(1,3\right)\\ {} Cz\left(2,1\right)& Cz\left(2,2\right)& Cz\left(2,3\right)\\ {} Cz\left(3,1\right)& Cz\left(3,2\right)& Cz\left(3,3\right)\end{array}\right] $$](A456962_1_En_3_Chapter_Equ45.gif)

(3-45)

![$$ Cz\left(1,1\right)=\mathit{\cos}(Rz) $$](A456962_1_En_3_Chapter_Equ46.gif)

(3-46)

![$$ Cz\left(1,2\right)=-\mathit{\sin}(Rz) $$](A456962_1_En_3_Chapter_Equ47.gif)

(3-47)

![$$ Cz\left(1,3\right)=0 $$](A456962_1_En_3_Chapter_Equ48.gif)

(3-48)

![$$ Cz\left(2,1\right)=\mathit{\sin}(Rz) $$](A456962_1_En_3_Chapter_Equ49.gif)

(3-49)

![$$ Cz\left(2,2\right)=\mathit{\cos}(Rz) $$](A456962_1_En_3_Chapter_Equ50.gif)

(3-50)

![$$ Cz\left(2,3\right)=0 $$](A456962_1_En_3_Chapter_Equ51.gif)

(3-55)

通过简单地观察第一行中的 XP’不依赖于 zp，因此 C(1，3)=0，可以将二维矩阵方程扩展到方程 [3-44](#Equ44) 中的三维矩阵方程；在第二行中，yp’也不依赖于 zp，因此 c(2，3)= 0；在第三行中，ZP’不依赖于 XP’或 yp’，因此 C(3，1)和 C(3，2)都等于 0。C(3，3)=1，因为在绕 z 轴旋转后，z 坐标保持不变。

这三个转变概括起来就是:

![$$ \left[ Rx\right]=\left[\begin{array}{ccc}1& 0& 0\\ {}0& \mathit{\cos}(Rx)& -\mathit{\sin}(Rx)\\ {}0& \mathit{\sin}(Rx)& \mathit{\cos}(Rx)\end{array}\right] $$](A456962_1_En_3_Chapter_Equ55.gif)

(3-55)

![$$ \left[ Ry\right]=\left[\begin{array}{ccc}\mathit{\cos}(Ry)& 0& \mathit{\sin}(Ry)\\ {}0& 1& 0\\ {}-\mathit{\sin}(Ry)& 0& \mathit{\cos}(Ry)\end{array}\right] $$](A456962_1_En_3_Chapter_Equ56.gif)

(3-56)

![$$ \left[ Rz\right]=\left[\begin{array}{ccc}\mathit{\cos}(Rz)& -\mathit{\sin}(Rz)& 0\\ {}\mathit{\sin}(Rz)& \mathit{\cos}(Rz)& 0\\ {}0& 0& 1\end{array}\right] $$](A456962_1_En_3_Chapter_Equ57.gif)

(3-57)

## 3.6 绕坐标方向的单独旋转

图 [3-8](#Fig8) 显示了盒子(a)绕 x、y 和 z 方向的单独旋转。该图形是使用清单 [3-1](#Par55) 创建的。轮换是分开的，不是连续的。即，盒子(b)是旋转了 Rx 的盒子(a );盒子(c)被(a)旋转了 Ry；并且框(d)被(a)旋转了 Rz。旋转不是相加的，这意味着 Ry 没有加到 Rx 的结果上，Rz 没有加到 Rx 和 Ry 的结果上；它们分别是原始盒子(a)的独立旋转。旋转是围绕盒子的中心进行的。

![A456962_1_En_3_Fig8_HTML.jpg](A456962_1_En_3_Fig8_HTML.jpg)

图 3-8

Output from Listing [3-1](#Par55). Projection (a) of an unrotated box on the x,y plane, (b) rotated around the x direction by Rx=45°, (c) around the y direction by Ry=30°, and (d) around the z direction by Rz=30°. Double-headed red arrows show the direction of rotation using the right-hand rule convention. Heavy lines indicate the top and bottom. The boxes are rotated about their center, which is indicated by a black dot.

清单 [3-1](#Par55) 利用了函数和列表。如果没有它们，程序的规模将会翻倍。使用它们可以大大减小程序的大小。它可以通过使用数组来进一步缩短，但是节省将是最小的，并且倾向于模糊该方法。

图 [3-9](#Fig9) 显示了清单 [3-1](#Par55) 使用的角编号方案。角落的数字是蓝色的。它们是 Python 列表编号，从 0 开始。通常我们从 1 到 8 给角编号。然而，在 Python 中，列表中的第一个元素总是 0。在八角盒的情况下，最后一个，即第八个，是列表中的元素 7。比如第一个点的 x 坐标是 x[0]，第二个是 x[1]，依此类推。这就像把梯子的第一级编号为第零级。迷惑？是的。要怪就怪 C 编程语言吧，这个陷阱是从 C 语言遗留下来的。也许避免问题的最好方法是养成从 0 而不是从 1 开始编号的习惯，这就是我在图 [3-9](#Fig9) 中所做的。我可以在图 [3-9](#Fig9) 中使用不同的编号安排，但是从左上角开始并顺时针进行似乎是合理的(例如，我可以从右上角而不是左上角开始编号)。只要选择的方案和程序一致就没关系。

![A456962_1_En_3_Fig9_HTML.jpg](A456962_1_En_3_Fig9_HTML.jpg)

图 3-9

Numbering scheme for the box’s corners in Lsiting 3-1\. Lists at the upper right contain the coordinate values. They are the same as the lists in Listing [3-1](#Par55), lines 14, 15, and 16\. The center coordinates xc,yc,zc are not the same as used in Listing [3-1](#Par55). The z axis is not shown.

图中所示的列表定义了角坐标。每个列表中有八个元素，因为盒子中有八个角。角落 2 是列表中的第三个元素，其坐标为 x[3]=10，y[3]=-10，z[3]=3。这些是局部坐标；换句话说，它们相对于盒子的中心，也就是旋转的中心。

清单 [3-1](#Par55) 从在第 14-16 行定义列表[x]、[y]和[z]开始。这些线保存了盒子的角相对于其中心的坐标。第 18-20 行中的[xg]、[yg]和[zg]将在转换完成后保存全局绘图坐标。因为盒子有八个角，所以每个列表中保留八个空间。

接下来是旋转函数 rotx、roty 和 rotz 的定义。它们分别围绕 x、y 和 z 方向旋转点的坐标 xp、yp 和 zp。每个函数都返回一组新的坐标:xg、yg 和 zg，它们是旋转点的全局坐标。这些坐标将用于绘图。

查看 rotx 的定义，从第 23 行开始，当调用 rotx 进行关于 x 方向的变换时，rotx 接收盒子的中心坐标 xc，yc，zc，在这种情况下是旋转的中心，加上点的未旋转坐标 xp，yp，zp 和关于 x 方向的旋转角度 Rx。第 24 行的列表 a=[xp，yp，zp]包含未旋转点的坐标。这实际上是指向 xp，yp，zp 的向量。在第 25 行，b=[1，0，0]是等式 [3-55](#Equ55) 所示的 Rx 变换矩阵的第一行列表。第 26 行 xpp=np.inner(a，b)构成了这些列表的点或标量积。还有一个可以使用的 np.dot(a，b)函数。对于简单的非复数向量，np.inner(a，b)和 np.dot(a，b)给出相同的结果。但是对于更高维的数组，结果可能不同。

为了说明绕 x 方向旋转的 ypp 的计算，你已经看到向量 p<sup>′</sup>通过

![$$ \left[\begin{array}{c} xp p\\ {} yp p\\ {} zp p\end{array}\right]=\left[\begin{array}{ccc}1& 0& 0\\ {}0& \mathit{\cos}(Rx)& -\mathit{\sin}(Rx)\\ {}0& \mathit{\sin}(Rx)& \mathit{\cos}(Rx)\end{array}\right]\kern0.1em \left[\begin{array}{c} xp\\ {} yp\\ {} zp\end{array}\right] $$](A456962_1_En_3_Chapter_Equ58.gif)

(3-58)与 p 相关，其中 ypp(即 yp′)是旋转点的 y 坐标。程序中的第 27 行是等式 [3-57](#Equ57) 的第二行。a 和 b 的标量积在第 28 行形成，产生 ypp(yp’)。即

![$$ a=\left[ xp, yp, zp\right] $$](A456962_1_En_3_Chapter_Equ59.gif)

(3-59)

![$$ b=\left[0,\mathit{\cos}(Rx),-\mathit{\sin}(Rx)\right] $$](A456962_1_En_3_Chapter_Equ60.gif)

(3-60)

![$$ ypp=\mathrm{np}.\mathrm{inner}\left(\mathrm{a},\mathrm{b}\right) $$](A456962_1_En_3_Chapter_Equ61.gif)

(3-61)

![$$ = xp(0)+ yp\left(\mathit{\cos}(Rx)\right)+ zp\left(-\mathit{\sin}(Rx)\right) $$](A456962_1_En_3_Chapter_Equ62.gif)

(3-62)

![$$ = ypcos(Rx)- zpsin(Rx) $$](A456962_1_En_3_Chapter_Equ63.gif)

(3-63)也就是第 28 行。第 29 行和第 30 行使用等式 [3-57](#Equ57) 的第三行重复该过程，产生 zpp(ZP’)。第 31 行将盒子中心的坐标 xc，yc，zc 与 xpp，ypp，zpp 相加，从而相对于全局坐标系的原点平移旋转的点，产生全局绘图坐标[xg，yg，zg]。roty 和 rotz 遵循相同的结构，在它们的 b 表中使用[Ry]和[Rz]行。

接下来是第 56 行的函数绘图框。这将使用长方体的全局角坐标 xg、yg 和 zg 来绘制长方体。从第 57 行开始的循环通过用线连接前三个角来绘制顶部。线 60 通过在角 3 和 0 之间画一条线来封闭顶部。这还没有包括在循环中，循环是为了绘制一个角和下一个角。当你试图将角 3 与 0 连接时，问题就来了；循环中的算法不起作用。可以修改它来处理它，但是只添加第 60 行比使循环复杂化更容易。直到第 68 行的 plotbox 的其余部分完成了该框。第 70 行在其中心画了一个点。

第 72 行启动函数 plotboxx。这将转换角坐标，使其为 plotbox 的绘图做好准备。从第 73 行到第 74 行的循环通过调用 rotx 围绕 x 方向旋转所有八个角。第 76 行调用函数 plotbox，它进行绘图。对于围绕 y 和 z 方向的旋转，plotboxy 和 plotboxz 也是如此。

到目前为止，您一直在定义函数。你在这个程序中使用函数，因为许多操作是重复的。如果你试着用单个语句写这个程序，它至少会有两倍长。

程序的控制权在第 91 行和第 116 行之间。第 91-95 行绘制了第一个框(a)。因为第一个方框(a)是不旋转的，所以在第 91 行指定 Rx=0。使用带有 Rx=0 参数的函数 plotboxx 进行绘图。您可以对 plotboxy 使用 Ry=0，或对 plotboxz 使用 Rz=0。这无关紧要，因为旋转角度为 0。第 92-94 行指定了盒子的中心坐标。第 95 行调用 plotboxx。结果如图 [3-8](#Fig8) 所示为(a)。第 98-116 行产生旋转的盒子(b)、(c)和(d)。

以方框(b)为例总结该过程，旋转角度设置在第 98 行；盒子的中心坐标在第 99-101 行。然后，在第 102 行，调用函数 plotboxx。中心坐标和角度 Rx 作为参数传递。plotboxx 从第 72 行开始，通过调用 rotx 旋转八个角。plotboxx 不使用 xc、yc 和 zc，但是它将它们传递给需要它们的 rotx。rotx 旋转和平移坐标，产生 xg，yg，zg。第 76 行调用函数 plotbox，它进行绘图。

在第 91、98、105 和 112 行中，您使用了函数 radians()，它是从第 7 行的数学库中导入的。(注意，您可以为此使用 numpy)。它将角度参数转换为弧度参数，这是 sin()和 cos()所需要的。在早期的程序中，您使用 np.pi/180.进行了转换

```
  1   """
  2   4BOXES
  3   """
  4
  5   import numpy as np
  6   import matplotlib.pyplot as plt
  7   from math import sin, cos, radians #–or use numpy
  8
  9   plt.axis([0,150,100,0])
 10   plt.axis('on')
 11   plt.grid(True)
 12
 13   #————————————————————————-lists
 14   x=[-10,-10,10,10,-10,-10,10,10] #–un-rotated corner coordinates
 15   y=[-10,-10,-10,-10,10,10,10,10] #–relative to box's center
 16   z=[ -3, 3, 3, -3,-3, 3, 3,-3]
 17
 18   xg=[0,1,2,3,4,5,6,7] #–define global coordinates
 19   yg=[0,1,2,3,4,5,6,7]
 20   zg=[0,1,2,3,4,5,6,7]
 21
 22   #———————————————————–function definitions
 23   def rotx(xc,yc,zc,xp,yp,zp,Rx):
 24        a=[xp,yp,zp]
 25        b=[1,0,0] #———————————-[cx11,cx12,cx13]
 26        xpp=np.inner(a,b) #—–scalar product of a,b=xp*cx11+yp*cx12+ zp*cx13
 27        b=[0,cos(Rx),-sin(Rx)] #—————[cx21,cx22,cx23]
 28        ypp=np.inner(a,b)
 29        b=[0,sin(Rx),cos(Rx)] #—————[cx31,cx32,cx33]
 30        zpp=np.inner(a,b)
 31        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 32        return[xg,yg,zg]
 33
 34   def roty(xc,yc,zc,xp,yp,zp,Ry):
 35        a=[xp,yp,zp]
 36        b=[cos(Ry),0,sin(Ry)] #——————–[cx11,cx12,cx13]
 37        xpp=np.inner(a,  b)
 38        b=[0,1,0] #—————[cx21,cx22,cx23]
 39        ypp=np.inner(a,b) #——————–scalar product of a,b
 40        b=[-sin(Ry),0,cos(Ry)] #—————[cx31,cx32,cx33]
 41        zpp=np.inner(a,b)
 42        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 43        return[xg,yg,zg]
 44
 45   def rotz(xc,yc,zc,xp,yp,zp,Rz):
 46        a=[xp,yp,zp]
 47        b=[cos(Rz),-sin(Rz),0] #——————-[cx11,cx12,cx13]
 48        xpp=np.inner(a, b)
 49        b=[sin(Rz),cos(Rz),0] #—————[cx21,cx22,cx23]
 50        ypp=np.inner(a,b)
 51        b=[0,0,1] #—————[cx31,cx32,cx33]
 52        zpp=np.inner(a,b) #———————scalar product of a,b
 53        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 54        return[xg,yg,zg]
 55
 56   def plotbox(xg,yg,zg): # –plots the box using its rotated coordinates xg,yg,zg
 57        for i in (0,1,2): #———————————————-plot top
 58              plt.plot([xg[i],xg[i+1]],[yg[i],yg[i+1]],linewidth=3,color='k')
 59
 60        plt.plot([xg[3],xg[0]],[yg[3],yg[0]],linewidth=3,color='k') #-close top
 61
 62        for i in (4,5,6): #——————————————-plot bottom
 63              plt.plot([xg[i],xg[i+1]],[yg[i],yg[i+1]],linewidth=3,color='k')
 64
 65        plt.plot([xg[7],xg[4]],[yg[7],yg[4]],linewidth=3,color='k') #–close bottom
 66
 67        for i in (0,1,2,3): #——————————————plot sides
 68             plt.plot([xg[i],xg[i-4]],[yg[i],yg[i-4]],linewidth=1,color='k')
 69
 70        plt.scatter(xc,yc,s=5) #–plot a dot at the center
 71
 72   def plotboxx(xc,yc,zc,Rx):
 73        for i in (0,1,2,3,4,5,6,7): #————————–rotate eight corners
 74              [xg[i],yg[i],zg[i]]=rotx(xc,yc,zc,x[i],y[i],z[i],Rx)
 75
 76        plotbox(xg,yg,zg)
 77
 78   def plotboxy(xc,yc,zc,Ry):
 79        for i in (0,1,2,3,4,5,6,7): #————————–rotate eight corners
 80             [xg[i],yg[i],zg[i]]=roty(xc,yc,zc,x[i],y[i],z[i],Ry)
 81
 82        plotbox(xg,yg,zg)
 83
 84   def plotboxz(xc,yc,zc,Rz):
 85        for i in (0,1,2,3,4,5,6,7): #————————–rotate eight corners
 86              [xg[i],yg[i],zg[i]]=rotz(xc,yc,zc,x[i],y[i],z[i],Rz)
 87
 88        plotbox(xg,yg,zg)
 89
 90   #——————————————————————–R=0 box(a)
 91   Rx=radians(0)
 92   xc=25 #—————box (a) center coordinates
 93   yc=40
 94   zc=20
 95   plotboxx(xc,yc,zc,Rx) #–since Rx=0 we could use plotboxy or plotboxz
 96
 97   #———————————————————————Rx box(b)
 98   Rx=radians(45)
 99   xc=55
100   yc=40
101   zc=20
102   plotboxx(xc,yc,zc,Rx)
103
104   #——————————————————————–Ry box (c)
105   Ry=radians(30)
106   xc=85
107   yc=40
108   zc=20
109   plotboxy(xc,yc,zc,Ry)
110
111   #——————————————————————–Rz box (d)
112   Rz=radians(30)
113   xc=115
114   yc=40
115   zc=20
116   plotboxz(xc,yc,zc,Rz)
117
118   #————————————————————————-notes
119   plt.text(23,63,'(a)')
120   plt.text(53,63,'(b)')
121   plt.text(83,63,'(c)')
122   plt.text(112,63,'(d)')
123   plt.text(21,73,'R=0')
124   plt.text(47,73,'Rx=45°')
125   plt.text(77,73,'Ry=30°')
126   plt.text(107,73,'Rz=30°')
127   plt.arrow(42,40,25,0,head_width=2,head_length=3,color='r') #–red arrows
128   plt.arrow(42,40,28,0,head_width=2,head_length=3,color='r')
129   plt.arrow(85,25,0,27,head_width=2,head_length=2,color='r')
130   plt.arrow(85,25,0,29,head_width=2,head_length=2,color='r')
131   plt.plot([8,130],[8,8],color='k') #–axes
132   plt.plot([8,8],[8,85],color='k')
133   plt.text(120,6,'X')
134   plt.text(3,80,'Y')
135   plt.scatter(115,40,s=30,color='r') #———–red dot center of box (d)
136
137   plt.show()
Listing 3-1Program 4BOXES

```

## 3.7 围绕坐标方向的连续旋转

在清单 [3-1](#Par55) 中，您操作了由第 14、15 和 16 行中的列表定义的盒子的初始角坐标。该程序产生了围绕 x、y 和 z 坐标方向的单独旋转。在本节中，您从相同的一组角坐标开始，但您按顺序旋转。即，在绕 x 方向(b)旋转 Rx 之后，旋转 Ry 被加到 Rx (c)的结果上。然后将 Rz 加到 Ry (d)的结果上。因此，旋转不像以前那样是独立的，而是相加的。这可以通过在每次旋转后用一组新的坐标替换第 14、15 和 16 行中的 x、y 和 z 定义来实现。也就是说，长方体的角坐标在每次旋转后都会更新，以便下一次旋转从更新后的坐标开始。这可以通过简单地修改清单 [3-1](#Par55) 中第 72-88 行之间的函数 plotboxx、plotboxy 和 plotboxz 来实现。在清单 [3-2](#Par57) 中，添加了 74b、80b 和 86b 行。在每次旋转后，它们通过用变换后的坐标 xg，yg，zg 替换初始的角坐标 x，y，z 来进行更新。该代码替换了清单 [3-1](#Par55) 中的第 72-88 行。

![A456962_1_En_3_Fig10_HTML.jpg](A456962_1_En_3_Fig10_HTML.jpg)

图 3-10

Sequential rotations of a box. Box (a) is rotated by Rx=30° to (b), then by an additional rotation of Ry=30° to (c), and then by an additional rotation of Rz=15° to (d). x and y axes show direction only. Coordinate values are indicated by the grid.

```
71
72   def plotboxx(xc,yc,zc,Rx):
73         for i in (0,1,2,3,4,5,6,7): #————————–rotate eight corners
74                [xg[i],yg[i],zg[i]]=rotx(xc,yc,zc,x[i],y[i],z[i],Rx)
74b               [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
75
76         plotbox(xg,yg,zg)
77
78   def plotboxy(xc,yc,zc,Ry):
79         for i in (0,1,2,3,4,5,6,7): #————————–rotate eight corners
80                 [xg[i],yg[i],zg[i]]=roty(xc,yc,zc,x[i],y[i],z[i],Ry)
80b                [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
81
82         plotbox(xg,yg,zg)
83
84   def plotboxz(xc,yc,zc,Rz):
85         for i in (0,1,2,3,4,5,6,7): #————————–rotate eight corners
86                [xg[i],yg[i],zg[i]]=rotz(xc,yc,zc,x[i],y[i],z[i],Rz)
86b               [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
87
88         plotbox(xg,yg,zg)
89
Listing 3-2Program 4BOXESUPDATE

```

变换参数在第 91-116 行由旋转 Rx、Ry 和 Rz 的值以及盒子中心坐标 xc、yc、zc 设置。

该程序中的旋转顺序是硬连线的，以产生图 [3-10](#Fig10) ，首先是(a)，然后是(b)、(c)和(d)。在一般程序中，旋转和中心坐标的顺序和值可以通过移动代码段或通过键盘输入顺序来设置。你将很快做到这两点。但首先，你要做圆周的连续旋转。

![A456962_1_En_3_Fig11_HTML.jpg](A456962_1_En_3_Fig11_HTML.jpg)

图 3-11

Sequential rotations of a circle created by Listing [3-3](#Par64). Circle (a) is rotated by Rx=45° to (b), then by an additional rotation of Ry=70° to (c), and then by an additional rotation of Rz=90° to (d). Red indicates the upper half of circle. x and y axes show direction only, not coordinate values, which are indicated by the grid.

清单 [3-3](#Par64) 类似于清单 [3-1](#Par55) 和 [3-2](#Par57) 的前一个修改版本，其中您对一个盒子进行了顺序旋转。在那个程序中，盒子有八个角，每次旋转都要变换和更新。这里你有一个圆，它有更多的点要变换和更新。

在第 23-38 行中，您用围绕圆周的点的局部和全局坐标的起始值填充第 33 和 38 行之间的列表。它们间隔 dphi=5，如线 25 所示。如第 27 行所示，圆的半径为 10。空列表已经在第 14-20 行定义过了。随着从第 29 行开始的循环以角度φ围绕圆前进，第 30 至 32 行计算每个点的局部坐标。第 33-38 行使用 append()函数将坐标添加到列表中，该函数将元素添加到列表中。例如，通过循环线 33 的每个循环，将当前角度φ处的 xp 的局部值附加(添加)到 x 列表。因为此时您只是在填充列表，所以您可以使用 xp、yp、zp 来填充第 36-38 行的 xg、yg 和 zg 列表。注意，在这个圆的初始定义中，zp=0(程序行 32)。也就是说，圆在 x，y 平面上开始是平的。随后的旋转将围绕该初始方向。

第 41-72 行像以前一样定义了转换函数。圆形绘图功能从第 75-86 行开始延伸。线条用于绘制圆。绘图循环从 78-82 运行。第 86 行在中心画了一个点。

使用 range(len(x))函数给出列表中元素的数量，而不是计算圆周围的点数。你可以用 x 的长度作为度量，因为所有的列表都有相同的长度。第 79-82 行绘制了上半部分的红色和下半部分的绿色。第 83-84 行更新了最后一个 xg any yg 全局坐标，以便像以前一样绘制线条时使用。由于在绘图时只使用了 xg 和 yg，所以这里不需要包含 zg。第 89-108 行像清单 [3-1](#Par55) 和 [3-2](#Par57) 中那样转换坐标。不同之处在于，这里你必须处理 len(x)长的列表，而以前你只有八个角。

```
  1   """
  2   SEQUENTIALCIRCLES
  3   """
  4
  5   import numpy as np
  6   import matplotlib.pyplot as plt
  7   from math import sin, cos, radians
  8
  9   plt.axis([0,150,100,0])
 10   plt.axis('on')
 11   plt.grid(True)
 12
 13   #——————————————————————define lists
 14   x=[]
 15   y=[]
 16   z=[]
 17
 18   xg=[]
 19   yg=[]
 20   zg=[]
 21
 22   #——————————————fill lists with starting coordinates
 23   phi1=radians(0)
 24   phi2=radians(360)
 25   dphi=radians(5) #–circumferential points spaced 5 degrees
 26
 27   r=10 #–circle's radius
 28
 29   for phi in np.arange(phi1,phi2+dphi,dphi): #–establish coordinates of circumferential points
 30         xp=r*cos(phi)
 31         yp=r*sin(phi)
 32   zp=0
 33   x.append(xp)   #–fill lists
 34   y.append(yp)
 35   z.append(zp)
 36   xg.append(xp)
 37   yg.append(yp)
 38   zg.append(zp)
 39
 40   #—————————————————–define rotation functions
 41   def rotx(xc,yc,zc,xp,yp,zp,Rx):
 42        a=[xp,yp,zp]
 43        b=[1,0,0] #———————————-[cx11,cx12,cx13]
 44        xpp=np.inner(a,b) #—–scalar product of a,b=xp*cx11+yp*cx12+ zp*cx13
 45        b=[0,cos(Rx),-sin(Rx)] #—————[cx21,cx22,cx23]
 46        ypp=np.inner(a,b)
 47        b=[0,sin(Rx),cos(Rx)] #—————[cx31,cx32,cx33]
 48        zpp=np.inner(a,b)
 49        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 50        return[xg,yg,zg]
 51
 52   def roty(xc,yc,zc,xp,yp,zp,Ry):
 53        a=[xp,yp,zp]
 54        b=[cos(Ry),0,sin(Ry)] #——————–[cx11,cx12,cx13]
 55        xpp=np.inner(a, b)
 56        b=[0,1,0] #—————[cx21,cx22,cx23]
 57        ypp=np.inner(a,b) #——————–scalar product of a,b
 58        b=[-sin(Ry),0,cos(Ry)] #—————[cx31,cx32,cx33]
 59        zpp=np.inner(a,b)
 60        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 61        return[xg,yg,zg]
 62
 63   def rotz(xc,yc,zc,xp,yp,zp,Rz):
 64        a=[xp,yp,zp]
 65        b=[cos(Rz),-sin(Rz),0] #——————-[cx11,cx12,cx13]
 66        xpp=np.inner(a, b)
 67        b=[sin(Rz),cos(Rz),0] #—————[cx21,cx22,cx23]
 68        ypp=np.inner(a,b)
 69        b=[0,0,1] #—————[cx31,cx32,cx33]
 70        zpp=np.inner(a,b) #———————scalar product of a,b
 71        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 72        return[xg,yg,zg]
 73
 74   #——————————————————define circle plotting function
 75   def plotcircle(xg,yg,zg):
 76        lastxg=xg[0]
 77        lastyg=yg[0]
 78        for i in range(len(x)): #—–len(x)=length of all lists
 79              if i < len(x)/2: #—–half green
 80                     plt.plot([lastxg,xg[i]],[lastyg,yg[i]],linewidth=1,color='g')
 81              else:
 82                     plt.plot([lastxg,xg[i]],[lastyg,yg[i]],linewidth=1,color='r')
 83        lastxg=xg[i]
 84        lastyg=yg[i]
 85
 86        plt.scatter(xc,yc,s=5) #–plot a dot at the center
 87
 88   #———————————————–transform coordinates and plot
 89   def plotcirclex(xc,yc,zc,Rx): #—————-transform & plot Rx circle
 90       for i in range(len(x)): #–for i in range(len(x)): ok too
 91              [xg[i],yg[i],zg[i]]=rotx(xc,yc,zc,x[i],y[i],z[i],Rx)
 92              [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
 93
 94       plotcircle(xg,yg,zg) #—————plot
 95
 96   def plotcircley(xc,yc,zc,Ry):
 97        for i in range(len(x)): #—————–transform & plot Ry circle
 98              [xg[i],yg[i],zg[i]]=roty(xc,yc,zc,x[i],y[i],z[i],Ry)
 99              [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
100
101        plotcircle(xg,yg,zg)
102
103   def plotcirclez(xc,yc,zc,Rz):
104        for i in range(len(x)): #—————–transform &  plot Rz circle
105              [xg[i],yg[i],zg[i]]=rotz(xc,yc,zc,x[i],y[i],z[i],Rz)
106              [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
107
108        plotcircle(xg,yg,zg)
109
110   #——————————————————————plot circles
111   Rx=radians(0)
112   xc=25 #—————circle (a) center coordinates
113   yc=40
114   zc=20
115   plotcirclex(xc,yc,zc,Rx) #–since R=0 we could use plotcircley or plotcirclez
116
117   #—————————————————————–Rx circle (b)
118   Rx=radians(45)
119   xc=55
120   yc=40
121   zc=20
122   plotcirclex(xc,yc,zc,Rx)
123
124   #—————————————————————–Ry circle (c)
125   Ry=radians(70)
126   xc=85
127   yc=40
128   zc=20
129   plotcircley(xc,yc,zc,Ry)
130
131   #—————————————————————–Rz circle (d)
132   Rz=radians(90)
133   xc=115
134   yc=40
135   zc=20
136   plotcirclez(xc,yc,zc,Rz)
137
138   #——————————————————————-notes
139   plt.text(23,63,'(a)')
140   plt.text(53,63,'(b)')
141   plt.text(83,63,'(c)')
142   plt.text(112,63,'(d)')
143   plt.text(21,73,'R=0')
144   plt.text(47,73,'Rx=45
°
')
145   plt.text(77,73,'Ry=70
°
')
146   plt.text(107,73,'Rz=90
°
')
147   plt.arrow(42,40,25,0,head_width=2,head_length=3,color='r') #–red arrows
148   plt.arrow(42,40,28,0,head_width=2,head_length=3,color='r')
149   plt.arrow(85,25,0,27,head_width=2,head_length=2,color='r')
150   plt.arrow(85,25,0,29,head_width=2,head_length=2,color='r')
151   plt.plot([8,130],[8,8],color='k') #–axes
152   plt.plot([8,8],[8,85],color='k')
153   plt.text(120,6,'X')
154   plt.text(3,80,'Y')
155   plt.scatter(115,40,s=30,color='r') #———–red dot center of box (d)
156
157   plt.show()
Listing 3-3Program SEQUENTIALCIRCLES

```

## 3.8 矩阵串联

将图 [3-12](#Fig12) 与图 3-11 进行比较，您可以看到，虽然 Rx、Ry 和 Rz 在两个图中具有相同的值，但是(c)和(d)中的圆的方向是不同的。这是因为图 [3-11](#Fig11) 中的旋转顺序是 Rx、Ry、Rz，而图 [3-12](#Fig12) 中的旋转顺序是 Rx、Rz、Ry。显然，轮换的顺序很重要。

![A456962_1_En_3_Fig12_HTML.jpg](A456962_1_En_3_Fig12_HTML.jpg)

图 3-12

Circle (a) is rotated sequentially by Rx=45° to (b), then by an additional rotation of Rz=90° to (c), followed by an additional rotation of Ry=70 to (d). Red indicates the lower half of circle. x and y axes show direction only, not coordinate values, which are indicated by the grid.

你可以自己证明这一点。拿一本书，正面朝上放在桌子边上，顶部朝右。想象桌子的边缘是从左到右的 x 方向。接下来，绕 x 方向旋转 90 度，再绕 z 方向旋转 90 度。这是 RxRz。这本书会倒过来，正面对着你。然后颠倒顺序，先绕 z 方向旋转，再绕 x 方向旋转。这是 RzRx。正如你所看到的，在这两种情况下，你会得到这本书不同的最终方向。

虽然您已经通过在程序代码中排序和更新旋转坐标来执行顺序旋转，但从数学上讲，这相当于矩阵乘法。例如，下面的等式产生矢量[P]的旋转 Rx，随后是旋转 Rz。两次旋转产生矢量[P′]。

![$$ \left[{P}^{\prime}\right]=\left[ Rz\right]\kern0.1em \left[ Rx\right]\kern0.1em \left[P\right] $$](A456962_1_En_3_Chapter_Equ64.gif)

(3-64)

[Rx]对向量[P]进行运算，[Rz]然后对[Rx][P]的结果进行运算。按 Rz 依次旋转 Rx、

、![$$ \left[{P}^{\prime}\right]=\left[ Rx\right]\kern0.1em \left[ Rz\right]\kern0.1em \left[P\right] $$](A456962_1_En_3_Chapter_Equ65.gif)、

(3-65)

一般来说，

![$$ \left[ Rx\right]\kern0.1em \left[ Rz\right]\ne \left[ Rz\right]\kern0.1em \left[ Rx\right] $$](A456962_1_En_3_Chapter_Equ66.gif)

(3-66)

您可以通过一个使用二维矩阵的简单示例来说明这一点。考虑 A 和 B 两个矩阵，其中

![$$ \left[A\right]=\left[\begin{array}{cc}a& b\\ {}c& d\end{array}\right] $$](A456962_1_En_3_Chapter_Equ67.gif)

(3-67)

![$$ \left[B\right]=\left[\begin{array}{cc}e& f\\ {}g& h\end{array}\right] $$](A456962_1_En_3_Chapter_Equ68.gif)

(3-68)

![$$ AB=\left[\begin{array}{cc}a& b\\ {}c& d\end{array}\right]\kern0.1em \left[\begin{array}{cc}e& f\\ {}g& h\end{array}\right]=\left[\begin{array}{cc} ae+ bg& af+ bh\\ {} ce+ dg& cf+ dh\end{array}\right] $$](A456962_1_En_3_Chapter_Equ69.gif)

(3-69)

![$$ BA=\left[\begin{array}{cc}e& f\\ {}g& h\end{array}\right]\kern0.1em \left[\begin{array}{cc}a& b\\ {}c& d\end{array}\right]=\left[\begin{array}{cc} ae+ cf& be+ df\\ {} ag+ ch& bg+ dh\end{array}\right] $$](A456962_1_En_3_Chapter_Equ70.gif)

(3-70)

![$$ \therefore AB\ne BA $$](A456962_1_En_3_Chapter_Equ71.gif)

(3-71)

对于仅围绕三个不同坐标方向的三次旋转，有六种可能的变换序列组合:

![$$ RxRyRz $$](A456962_1_En_3_Chapter_Equ72.gif)

【3-72】

![$$ RxRzRy $$](A456962_1_En_3_Chapter_Equ73.gif)

【3-73】

![$$ RyRxRz $$](A456962_1_En_3_Chapter_Equ74.gif)

【3-74】

![$$ RyRzRx $$](A456962_1_En_3_Chapter_Equ75.gif)

【3-75】

![$$ RzRxRy $$](A456962_1_En_3_Chapter_Equ76.gif)

【3-76】

![$$ RzRyRx $$](A456962_1_En_3_Chapter_Equ77.gif)

【3-77】

这些组合中的每一个都包括三次单独的旋转。您可以将方程 [3-55](#Equ55) 、 [3-56](#Equ56) 和 [3-57](#Equ57) 中所示的三个变换矩阵相乘，以获得每种组合的单个变换矩阵。然后你可以写一个程序来执行这些组合:选择一个组合，输入三个角度，然后得到最终的旋转。但是如果你想要三次以上的旋转，比如 RyRzRxRyRz 呢？那将需要大量的矩阵乘法！很明显，通过将序列编码到 Python 程序中并在每次转换后更新坐标，可以更容易地合并序列，正如您在这里所学的那样。

为了生成图 [3-12](#Fig12) ，清单 [3-3](#Par64) 的第 110-136 行被清单 [3-4](#Par74) 中的代码替换。

```
109
110   #——————————————————————plot circles
111   Rx=radians(0)
112   xc=25 #—————circle (a) center coordinates
113   yc=40
114   zc=20
115   plotcirclex(xc,yc,zc,Rx) #–since R=0 we could use plotcircley or plotcirclez
116
117   #—————————————————————–Rx circle (b)
118   Rx=radians(45)
119   xc=55
120   yc=40
121   zc=20
122   plotcirclex(xc,yc,zc,Rx)
123
124   #—————————————————————–Rz circle (d)
125   Rz=radians(90)
126   xc=85
127   yc=40
128   zc=20
129   plotcirclez(xc,yc,zc,Rz)
130
131   #—————————————————————–Ry circle (c)
132   Ry=radians(70)
133   xc=115
134   yc=40
135   zc=20
136   plotcircley(xc,yc,zc,Ry)
137
Listing 3-4Program SEQUENTIALCIRCLESUPDATE

```

这里，您执行了操作 RxRzRy，颠倒了最后两个转换的顺序。圆圈(a)如前所述绘制，Rx=0，在第 111 行。同样如前所述，接下来绘制圆(b ), Rx = 45 度，在线 118 中。不同之处在于第 124-136 行，其中旋转 Ry 和 Rz 颠倒，Rz 在 Ry 之前绘制。角度值与之前相同。重新排列绘图顺序很容易；只需剪切和粘贴部分代码。但是一定要更新中心坐标 xc、yc 和 zc。您可以通过引入 input()函数使程序更加用户友好，这将使您能够通过键盘输入转换的顺序。然后，您可以输入旋转 Rx、Ry 或 Rz，以及任意顺序的数量和中心坐标。接下来你会这么做。

## 3.9 具有功能程序结构的键盘数据输入

正如你在矩阵连接的讨论中看到的，重新安排程序中的循环顺序是一个有用的选择。然而，正如您将在本节中看到的，通过键盘输入数据更令人满意。您还将使用函数式编程结构，其中几行代码控制执行各种操作的各种预定义函数。这将使你在控制程序时有很大的灵活性。

列表 [3-5](#Par81) 产生如图 [3-13](#Fig13) 至 [3-16](#Fig16) 所示的结果。第一张图显示了绕 x 方向旋转 0°的圆；第二个绕 y 方向 60°；第三个绕 x 方向 45°；第四个绕 z 方向旋转 90°。所有旋转都将添加到圆的先前方向。旋转轴和数量通过键盘输入。旋转方向的顺序无关紧要，旋转的次数也无关紧要。

参考清单 [3-5](#Par81) ，第 111-113 行指定了圆的中心坐标。所有的圆都有相同的中心坐标。第 115 行中的 while True:语句保持数据输入循环运行，因此您可以进行无限次数的顺序循环。第 116 行要求您在 Spyder 输出窗格中指定旋转轴。用小写字母输入 x、y 或 z。要退出循环，按回车键。(重要提示:如果您使用的是 Spyder 控制台，请确保在输入任何内容之前，在“输出”窗格中用光标单击鼠标。如果你忘记并把它留在程序窗格中，你可能会在程序的某个地方得到一个不需要的 x、y 或 z。如果发生这种情况，请转到屏幕顶部，打开一个新的控制台。这实质上是重新开始程序。).如果输入 x(小写)，第 118 行要求输入旋转角度 r x。以正角或负角的形式输入。input()函数返回一个字符串。float 命令将其转换为浮点数。第 119 行然后调用函数 plotcirclex()，该函数绘制旋转的圆。Ry 和 Rz 旋转以类似的方式执行。请注意，旋转的顺序或次数没有限制。第 126 行检查您是否为 axis 输入了一个空白，在这种情况下，第 127 行退出程序。所有的圆都围绕同一个中心 xc，yc，zc 旋转。如果希望能够移动每个圆的中心，只需在第 115 行和第 116 行之间添加输入()行作为中心坐标。

第 89-108 行旋转并更新圆周点的坐标，如清单 [3-3](#Par64) 所示。在函数 plotcircle()中，第 71-86 行进行绘图。每次调用该函数时，轴和网格都会被重新绘制。第 86 行显示了最新的情节。

这个程序是程序控制的一个重要例证。仅仅 115 和 127 之间的几行就控制了程序的整个操作，并在控制操作顺序和使用的数据方面提供了很大的灵活性。在其他编程语言中，如 Basic 和 Fortran，这被称为自顶向下编程。在这些语言中，相当于 Python 函数的子例程通常放在底部，而控制代码放在顶部。在 Python 中，通常将函数放在顶部，控件放在底部，这种风格称为自底向上编程。无论控制是在顶部还是底部，这种程序结构都被称为函数式编程，因为控制代码使用函数来执行各种操作。由于控制数据是通过键盘输入的，它提供了相当大的灵活性。

![A456962_1_En_3_Fig16_HTML.jpg](A456962_1_En_3_Fig16_HTML.jpg)

图 3-16

The previous circle is rotated around the z axis by 90°

![A456962_1_En_3_Fig15_HTML.jpg](A456962_1_En_3_Fig15_HTML.jpg)

图 3-15

The previous circle is rotated around the y axis by 45°

![A456962_1_En_3_Fig14_HTML.jpg](A456962_1_En_3_Fig14_HTML.jpg)

图 3-14

The previous circle is rotated around the y axis by 60°

![A456962_1_En_3_Fig13_HTML.jpg](A456962_1_En_3_Fig13_HTML.jpg)

图 3-13

The circle is rotated around the x axis by 0°

```
  1   """
  2   KEYBOARDDATAENTRY
  3   """
  4
  5   import numpy as np
  6   import matplotlib.pyplot as plt
  7   from math import sin, cos, radians
  8
  9   #——————————————————————-define  lists
 10   x=[]
 11   y=[]
 12   z=[]
 13
 14   xg=[]
 15   yg=[]
 16   zg=[]
 17
 18   #——————————————fill lists with starting coordinates
 19   phi1=radians(0)
 20   phi2=radians(360)
 21   dphi=radians(5) #–circumferential points spaced 5 degrees
 22
 23   radius=15 #–circle's radius
 24
 25   for phi in np.arange(phi1,phi2+dphi,dphi): #–establish coordinates of circumferential points
 26         xp=radius*cos(phi)
 27         yp=radius*sin(phi)
 28         zp=0
 29         x.append(xp) #–fill lists
 30         y.append(yp)
 31         z.append(zp)
 32         xg.append(xp)
 33         yg.append(yp)
 34         zg.append(zp)
 35
 36   #—————————————————–define rotation functions
 37   def rotx(xc,yc,zc,xp,yp,zp,Rx):
 38        a=[xp,yp,zp]
 39        b=[1,0,0] #———————————-[cx11,cx12,cx13]
 40        xpp=np.inner(a,b) #—–scalar product of a,b=xp*cx11+yp*cx12+ zp*cx13
 41        b=[0,cos(Rx),-sin(Rx)] #—————[cx21,cx22,cx23]
 42        ypp=np.inner(a,b)
 43        b=[0,sin(Rx),cos(Rx)] #—————[cx31,cx32,cx33]
 44        zpp=np.inner(a,b)
 45        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 46        return[xg,yg,zg]
 47
 48   def roty(xc,yc,zc,xp,yp,zp,Ry):
 49        a=[xp,yp,zp]
 50        b=[cos(Ry),0,sin(Ry)] #——————–[cx11,cx12,cx13]
 51        xpp=np.inner(a, b)
 52        b=[0,1,0] #—————[cx21,cx22,cx23]
 53        ypp=np.inner(a,b) #——————–scalar product of a,b
 54        b=[-sin(Ry),0,cos(Ry)] #—————[cx31,cx32,cx33]
 55        zpp=np.inner(a,b)
 56        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 57        return[xg,yg,zg]
 58
 59   def rotz(xc,yc,zc,xp,yp,zp,Rz):
 60        a=[xp,yp,zp]
 61        b=[cos(Rz),-sin(Rz),0] #——————-[cx11,cx12,cx13]
 62        xpp=np.inner(a, b)
 63        b=[sin(Rz),cos(Rz),0] #—————[cx21,cx22,cx23]
 64        ypp=np.inner(a,b)
 65        b=[0,0,1] #—————[cx31,cx32,cx33]
 66        zpp=np.inner(a,b) #———————scalar product of a,b
 67        [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
 68        return[xg,yg,zg]
 69
 70   #———————————————–define circle plotting function
 71   def plotcircle(xg,yg,zg):
 72        lastxg=xg[0]
 73        lastyg=yg[0]
 74        for i in range(len(x)): #–for i in range(len(x)): ok too
 75               if i < len(x)/2: #—–half green
 76                      plt.plot([lastxg,xg[i]],[lastyg,yg[i]],linewidth=1  ,color='g')
 77               else:
 78                     plt.plot([lastxg,xg[i]],[lastyg,yg[i]],linewidth=1  ,color='r')
 79        lastxg=xg[i]
 80        lastyg=yg[i]
 81
 82        plt.scatter(xc,yc,s=5,color='k') #–plot a dot at the center
 83        plt.axis([0,150,100,0]) #–replot axes and grid
 84        plt.axis('on')
 85        plt.grid(True)
 86        plt.show() #–plot latest rotation
 87
 88   #————————————————transform coordinates and plot
 89   def plotcirclex(xc,yc,zc,Rx): #————-transform and plot Rx circle
 90        for i in range(len(x)):
 91               [xg[i],yg[i],zg[i]]=rotx(xc,yc,zc,x[i],y[i],z[i],Rx)
 92               [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
 93
 94        plotcircle(xg,yg,zg) #—————plot
 95
 96   def plotcircley(xc,yc,zc,Ry):
 97         for i in range(len(x)): #—————–transform and plot Ry circle
 98                [xg[i],yg[i],zg[i]]=roty(xc,yc,zc,x[i],y[i],z[i],Ry)
 99                [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
100
101        plotcircle(xg,yg,zg)
102
103   def plotcirclez(xc,yc,zc,Rz):
104        for i in range(len(x)): #—————–transform and plot Rz circle
105               [xg[i],yg[i],zg[i]]=rotz(xc,yc,zc,x[i],y[i],z[i],Rz)
106               [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
107
108        plotcircle(xg,yg,zg)
109
110   #——————————————————————plot circles
111   xc=75 #–center coordinates
112   yc=50
113   zc=50
114
115   while True:
116        axis=input('x, y or z?: ') #–input axis of rotation (lower case)
117        if axis == 'x': #–if x axis
118               Rx=radians(float(input('Rx degrees?: ')))
119               plotcirclex(xc,yc,zc,Rx) #–call function plotcirclex
120        if axis == 'y':
121              Ry=radians(float(input('Ry degrees?: ')))
122              plotcircley(xc,yc,zc,Ry)
123        if axis == 'z':
124               Rz=radians(float(input('Rz degrees?: ')))
125               plotcirclez(xc,yc,zc,Rz)
126        if axis == ":
127               break
Listing 3-5Program KEYBOARDDATAENTRY

```

## 3.10 摘要

在本章中，您学习了如何构建三维坐标轴和三维形状，并围绕三个坐标方向旋转它们。这涉及到围绕三个坐标方向的旋转变换的推导。您看到了将对象从其原始方向旋转一次与按顺序旋转之间的区别，在顺序旋转中，每次后续旋转都使用对象在前一次旋转中的坐标作为起点。您探讨了轮换顺序很重要的观点；Rx，Ry，Rz 不会产生与 Rx，Rz，Ry 相同的结果。这是通过矩阵串联显示的。最后，您开发了一个程序，可以通过键盘输入顺序旋转，而不是在程序中指定它们。所有这些工作都涉及到列表的使用。