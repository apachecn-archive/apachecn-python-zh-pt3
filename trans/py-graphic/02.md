# 2.二维图形

在这一章中，你将学习如何用点和线构建二维图像。在第 [1](01.html) 章中，你学习了用 Python 创建图像的基本工具。在这一章中，你将在这一点上展开并学习在二维空间中创建、平移和旋转形状的方法。你还将学习相对坐标的概念，这将在本书的其余部分广泛使用。像往常一样，您将通过示例程序探索这些概念。

## 2.1 从点到线

您看到了如何使用命令创建一行

```py
plt.plot([x1,x2],[y1,y2],attributes)

```

这将绘制一条从(x1，y1)到(x2，y2)的线，其属性指定线的宽度、颜色和样式。有时，可能需要使用点来构建一条线。图 [2-1](#Fig1) 和 [2-2](#Fig2) 显示了几何图形:一条从点 1 开始到点 2 结束的斜线。它的长度是 q。图 [2-2](#Fig2) 中显示的直线是坐标 x，y 处的点 p。绘制直线时，从 1 开始，逐步向 2 推进，计算每一步 p 的坐标，并在每一步绘制一个点。这种分析利用了向量，向量将在以后广泛使用。

请注意，在这些模型中没有坐标轴。这种分析是一般性的；它适用于任何二维正交坐标方向。

![A456962_1_En_2_Fig1_HTML.jpg](A456962_1_En_2_Fig1_HTML.jpg)

图 2-1

Geometry for creating a line from dots (a)

![A456962_1_En_2_Fig2_HTML.jpg](A456962_1_En_2_Fig2_HTML.jpg)

图 2-2

Geometry for creating a line from dots (b)

要从点 1 向点 2 前进，首先要确定从 1 到 2 的方向。这将表示为一个单位矢量(单位矢量将以带帽的粗体显示；粗体全向量):

![$$ \widehat{\mathbf{u}}=ux\widehat{\mathbf{i}}+uy\widehat{\mathbf{j}} $$](A456962_1_En_2_Chapter_Equ1.gif)

(2-1)其中 Iˇ和 jˇ为 x、y 方向的单位向量；ux 和 uy 是在 x 和 y 方向上的标量分量。

ux 是与 x 轴夹角的余弦值；uy 是与 y 轴之间角度的余弦值。ux 和 uy 通常被称为方向余弦。很容易证明它们是余弦:与 x 轴之间角度的余弦为 UX/| 0 |，其中| 0 |是的标量幅度。由于\是单位向量，| \ | = 1；。角度的余弦则为 ux/(1)=ux。uy 也一样。

记住

![$$ \left|\widehat{\mathbf{u}}\right|=1 $$](A456962_1_En_2_Chapter_Equ2.gif)

(2-2)是很重要的，因为这个特性使你能够乘以一个量级来得到一个位置向量。例如，通过将乘以 L，可以得到从点 1 到 p 的向量 v1p，其中 L 是从 1 到 p 的距离，L 给出向量的大小，而给出向量的方向。那么从点 1 到 p 的向量就是

![$$ \mathbf{v}\mathbf{l}\mathbf{p}=L\left(ux\;\widehat{\mathbf{i}}+uy\;\widehat{\mathbf{j}}\right) $$](A456962_1_En_2_Chapter_Equ3.gif)

(2-3)

可以从坐标值计算 ux 和 uy 为

![$$ ux=A/Q=\left(x2\hbox{-} x1\right)/Q $$](A456962_1_En_2_Chapter_Equ4.gif)

(2-4)

![$$ uy=B/Q=\left(y2\hbox{-} y1\right)/Q $$](A456962_1_En_2_Chapter_Equ5.gif)

(2-5)其中(x1，y1)和(x2，y2)为点 1 和 2 的坐标，

![$$ Q=\sqrt{{\left(x2\hbox{-} x1\right)}^2+{\left(y2\hbox{-} y1\right)}^2} $$](A456962_1_En_2_Chapter_Equ6.gif)

(2-6)

清单 [2-1](#Par11) 给出了两个用点画线的例子。结果如图 [2-3](#Fig3) 所示。更小的点和更近的间距将产生更细的线(绿色)，这几乎与使用 plt.plot([x1，x2]，[y1，y2])函数获得的线一样好。

![A456962_1_En_2_Fig3_HTML.jpg](A456962_1_En_2_Fig3_HTML.jpg)

图 2-3

Dot lines created by Listing [2-1](#Par11)

```py
1   """
2   DOTLINE
3   """
4
5   import matplotlib.pyplot as plt
6   import numpy as np
7
8   plt.axis([-20,130,80,-20])
9
10  plt.axis('on')
11  plt.grid(True)
12
13  plt.arrow(0,0,20,0,head_length=4,head_width=3,color='k')
14  plt.arrow(0,0,0,20,head_length=4,head_width=3,color='k')
15  plt.text(15,-3,'x')
16  plt.text(-5,15,'y')
17
18  #———————————————————green line
19  x1=20
20  x2=120
21  y1=40
22  y2=20
23
24  q=np.sqrt((x2-x1)**2+(y2-y1)**2)
25  ux=(x2-x1)/q
26  uy=(y2-y1)/q
27
28  for l in np.arange(0,q,.5):
29        px=x1+l*ux
30        py=y1+l*uy
31        plt.scatter(px,py,s=1,color='g')
32
33  #———————————————————————————————————————————blue line
34  x1=20
35  x2=120
36  y1=45
37  y2=25
38
39  q=np.sqrt((x2-x1)**2+(y2-y1)**2)
40  ux=(x2-x1)/q
41  uy=(y2-y1)/q
42
43  for l in np.arange(0,q,2):
44        px=x1+l*ux
45        py=y1+l*uy
46        plt.scatter(px,py,s=1,color='b')
47
48  plt.show()
Listing 2-1Program DOTLINE

```

这个程序应该是不言自明的，因为定义与先前的分析是一致的。

## 2.2 点画

有趣的图案可以通过将点排列成几何图案来创建。图 [2-4](#Fig4) 显示了一些例子。在所有这三种情况下，这些点都以二维 x，y 矩阵排列。您可以改变点的大小、颜色以及矩阵的 x 和 y 限制。每个矩阵都创建有嵌套的 for 循环，如清单 [2-2](#Par16) ，第 20-22、25- 35 和 40-45 行所示。这些嵌套循环在 x 方向扫描，然后在每个 x 处，在 y 方向扫描，从而填充一个矩形区域。蒙德里安是由三个单独的点矩形加上一个大红点。

![A456962_1_En_2_Fig4_HTML.jpg](A456962_1_En_2_Fig4_HTML.jpg)

图 2-4

Dot art created created by Listing [2-2](#Par16)

在第 7 行，您导入了 random。这是一个随机函数库，您可以在第 42、43 和 44 行中使用它来产生随机的原色 r、g、b 分量。它们混合在第 45 行中。您将使用 random 的 random.randrange(a，b，c)函数来获取随机值。您也可以使用 numpy 中包含的随机函数，尽管语法有点不同。这里使用随机库是为了说明除了 numpy 还有其他数学库。

random.randrange(a，b，c)返回介于 a 和 b 之间的随机数，增量为 c。a、b 和 c 必须是整数。为了获得广泛的随机数选择，在第 42-44 行中设 a=1，b=100，c=1。但是第 42 行中的 rr 必须在 0 和 1.0 之间，所以在第 42 行中除以 100。这为颜色混合的红色分量 rr 提供了一个介于 0 和 1.0 之间的随机值。类似地，对于第 43 和 44 行中的 rg 和 rb，绿色和蓝色分量。如你所见，Klee 中的结果相当有趣。

```py
1   """
2   DOTART
3   """
4
5   import matplotlib.pyplot as plt
6   import numpy as np
7   import random
8
9   plt.axis([10,140,90,-10])
10
11  plt.axis('off')
12  plt.grid(False)
13
14  plt.arrow(0,0,20,0,head_length=4,head_width=3,color='k')
15  plt.arrow(0,0,0,20,head_length=4,head_width=3,color='k')
16  plt.text(15,-3,'x')
17  plt.text(-5,15,'y')
18
19  #————————————————————————————————————————————-plot Seurat

20  for x in np.arange(20,40,4):
21        for y in np.arange(10,60,4):
22              plt.scatter(x,y,s=8,color='b')
23
24  #————————————————————————————————————————————–plot Mondrian

25  for x in np.arange(60,80,1):
26        for y in np.arange(10,40,1):
27              plt.scatter(x,y,s=8,color='y')
28
29  for x in np.arange(60,80,1):
30        for y in np.arange(40,60):
31              plt.scatter(x,y,s=8,color='g')
32
33  for x in np.arange(65,80,1):
34        for y in np.arange(25,30,1):
35              plt.scatter(x,y,s=8,color='b')
36
37  plt.scatter(70,30,s=50,color='r')
38
39  #————————————————————————————————————————————plot Klee

40  for x in np.arange(100,120,2):
41        for y in np.arange(10,60,2):
42              rr=random.randrange(0,100,1)/100 #–random red 0<=rr<=1
43              rg=random.randrange(0,100,1)/100 #–random green 0<=rg<=1
44              rb=random.randrange(0,100,1)/100 #–random blue 0<=rb<=1
45        plt.scatter(x,y,s=25,color=(rr,rg,rb))
46
47  #————————————————————————————————————————————labels
48  plt.text(105,67,'Klee')
49  plt.text(60,67,'Mondrian')
50  plt.text(21,67,'Seurat')
51
52  plt.show()
Listing 2-2Program DOTART

```

## 2.3 由点形成的圆弧

清单 [2-3](#Par19) 使用点绘制圆弧。这是你第一个处理圆坐标，角度和三角函数的程序。清单 [2-3](#Par19) 所用的几何形状如图 [2-5](#Fig5) 所示。输出如图 [2-6](#Fig6) 所示。

清单 [2-3](#Par19) 中的第 25-31 行绘制了弧线。曲率中心在(xc，yc)处，如第 20 行和第 21 行中所定义的。线 22 中的曲率半径是 r。圆弧从点 1 开始，该点相对于 x 轴成角度 p1。它终止于点 2，该点成角度 p2。这些角度分别为 20 度和 70 度，在第 25 行和第 26 行中设置，它们被转换为弧度，这是 np.sin()和 np.cos()所需的单位。在后面的程序中，您将使用 radians()函数，该函数将参数从角度转换为弧度。如线 27 所示，弧上的点间隔开角度增量 dp。dp 设置为圆弧 p2-p1 所跨越的总角度除以 100。更宽的间距，比如(p2-p1)/20，特别是当与更小的点尺寸结合时，将给出更粗糙的弧。从第 28 行到第 31 行的循环使用 arange()函数将每个点的角度增加 dp。第 29 行和第 30 行计算每个点相对于全局 x，y 系统的坐标，该系统的原点在(0，0)。全局坐标是用于绘图的坐标。xp=r*np.cos(p)和 yp=r*np。(sin(p)是 p 沿弧相对于(xc，yc)处弧的曲率中心的坐标。这些是本地坐标。必须将曲率中心的坐标(xc，yc)添加到局部坐标中，以获得相对于 x=0，y=0 的全局坐标。这是在第 29 行和第 30 行完成的。第 31 行使用全局坐标在每个位置绘制了一个大小为 1 的绿点。结果如图 [2-5](#Fig5) 所示，代码如清单 [2-4](#Par21) 所示。

![A456962_1_En_2_Fig6_HTML.jpg](A456962_1_En_2_Fig6_HTML.jpg)

图 2-6

Circular arc created with np.scatter() dots

![A456962_1_En_2_Fig5_HTML.jpg](A456962_1_En_2_Fig5_HTML.jpg)

图 2-5

Geometric model used for creating a circular arc with scatter() dots, created by Listing [2-4](#Par21)

```py
1   """
2   PARC
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7
8   plt.axis([-10,140,90,-10])
9
10  plt.axis('on')
11  plt.grid(True)
12
13  #—————————————————————————————————————————————axes
14  plt.arrow(0,0,20,0,head_length=4,head_width=3,color='k')
15  plt.arrow(0,0,0,20,head_length=4,head_width=3,color='k')
16
17  plt.text(16,-3,'x')
18  plt.text(-5,17,'y')
19
20  xc=20

21  yc=20

22  r=40

23
24  #——————————————————————————————————————————plot arc
25  p1=20*np.pi/180

26  p2=70*np.pi/180

27  dp=(p2-p1)/100

28  for p in np.arange(p1,p2,dp):

29      x=xc+r*np.cos(p)

30      y=yc+r*np.sin(p)

31      plt.scatter(x,y,s=1,color='g')

32
33  #———————————————————————————————————————————labels
34  plt.text(61,34,'(x1,y1)')
35  plt.text(16,60,'(x2,y2)')
36  plt.scatter(xc,yc,s=10,color='k')
37  plt.text(xc+4,yc-4,'(xc,yc)',color='k')
38
39  plt.show()
Listing 2-3Program PARC

```

(以下是创建图形 [2-5](#Fig5) 的程序)

```py
1   """
2   PARCGEOMETRY
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7
8   plt.axis([-10,140,90,-10])
9
10  plt.axis('off')
11  plt.grid(False)
12
13  #—————————————————————————————————————coordinate axes
14  plt.arrow(0,0,20,0,head_length=4,head_width=3,color='k')
15  plt.arrow(0,0,0,20,head_length=4,head_width=3,color='k')
16
17  #———————————————————————————————————————————labels
18  plt.text(16,-3,'x')
19  plt.text(-5,17,'y')
20
21  #———————————————————————————————————————main arc
22  xc=20
23  yc=20
24  r=40
25  plt.scatter(xc,yc,color='b',s=5)
26
27  phi1=20*np.pi/180.
28  phi2=70*np.pi/180.
29  dphi=(phi2-phi1)/20.
30  for phi in np.arange(phi1,phi2,dphi):
31       x=xc+r*np.cos(phi)
32       y=yc+r*np.sin(phi)
33       plt.scatter(x,y,s=2,color='g')
34
35  plt.plot([xc,xc+r*np.cos(phi1)],[yc,yc+r*np.sin(phi1)],color='k')
36
37  x1=xc+(r+3)*np.cos(phi1)
38  x2=xc+(r+10)*np.cos(phi1)
39  y1=yc+(r+3)*np.sin(phi1)
40  y2=yc+(r+10)*np.sin(phi1)
41  plt.plot([x1,x2],[y1,y2],color='k')
42
43  x1=xc+(r+3)*np.cos(phi2)
44  x2=xc+(r+30)*np.cos(phi2)
45  y1=yc+(r+3)*np.sin(phi2)
46  y2=yc+(r+30)*np.sin(phi2)
47  plt.plot([x1,x2],[y1,y2],color='k')
48
49  plt.plot([xc,xc+r*np.cos(phi2)],[yc,yc+r*np.sin(phi2)],color='k')
50
51  phihalf=(phi1+phi2)*.5
52  phi3=phihalf-dphi/2
53  phi4=phihalf+dphi/2
54
55  plt.plot([xc,xc+r*np.cos(phi3)],[yc,yc+r*np.sin(phi3)],color='k')
56  plt.plot([xc,xc+r*np.cos(phi4)],[yc,yc+r*np.sin(phi4)],color='k')
57
58  x1=xc+(r+3)*np.cos(phi3)
59  x2=xc+(r+15)*np.cos(phi3)
60  y1=yc+(r+3)*np.sin(phi3)
61  y2=yc+(r+15)*np.sin(phi3)
62  plt.plot([x1,x2],[y1,y2],color='k')
63
64  x1=xc+(r+3)*np.cos(phi4)
65  x2=xc+(r+15)*np.cos(phi4)
66  y1=yc+(r+3)*np.sin(phi4)
67  y2=yc+(r+15)*np.sin(phi4)
68  plt.plot([x1,x2],[y1,y2],color='k')
69
70  #———————————————————————————————————————————P1 arc
71  dphi=(phi3)/100.
72  for phi in np.arange(0,phi1/2-3.2*np.pi/180,dphi):
73       x=xc+(r+5)*np.cos(phi)
74       y=yc+(r+5)*np.sin(phi)
75       plt.scatter(x,y,s=.1,color='k')
76
77  for phi in np.arange(phi1/2+3.3*np.pi/180,phi1,dphi):
78       x=xc+(r+5)*np.cos(phi)
79       y=yc+(r+5)*np.sin(phi)
80       plt.scatter(x,y,s=.1,color='k')
81
82  #————————————————————————————————————————————P2 arc
83  dphi=(phi3)/100.
84  for phi in np.arange(0,phi2/2-3.2*np.pi/180,dphi):
85       x=xc+(r+25)*np.cos(phi)
86       y=yc+(r+25)*np.sin(phi)
87       plt.scatter(x,y,s=.1,color='k')
88
89  dphi=(phi3)/100.
90  for phi in np.arange(phi2/2+3.2*np.pi/180,phi2,dphi):
91       x=xc+(r+25)*np.cos(phi)
92       y=yc+(r+25)*np.sin(phi)
93       plt.scatter(x,y,s=.1,color='k')
94
95  #————————————————————————————————————————————P arc
96  dphi=(phi3)/100.
97  for phi in np.arange(0,phi3/2-.5*np.pi/180,dphi):
98       x=xc+(r+13)*np.cos(phi)
99       y=yc+(r+13)*np.sin(phi)
100      plt.scatter(x,y,s=.1,color='k')
101
102 dphi=(phi3)/100.
103 for phi in np.arange(phi3/2+9.*np.pi/180,phi3,dphi):
104      x=xc+(r+13)*np.cos(phi)
105      y=yc+(r+13)*np.sin(phi)
106      plt.scatter(x,y,s=.1,color='k')
107
108 #————————————————————————————————————————dp arc
109 dphi=(phi3)/100.
110 for phi in np.arange(phi3+5*dphi,phi3+25*dphi,dphi):
111      x=xc+(r+13)*np.cos(phi)
112      y=yc+(r+13)*np.sin(phi)
113      plt.scatter(x,y,s=.1,color='k')
114
115 plt.plot([xc,100],[yc,yc],'k')
116 plt.plot([xc,xc],[yc,80],'k')
117
118 #————————————————————————————————————————labels
119 plt.text(71,58,'p2',size='small')
120 plt.text(66,44,'p',size='small')
121 plt.text(63,29,'p1',size='small')
122 plt.text(45,66,'dp',size='small')
123 plt.text(41,26,'r')
124 plt.text(3,17,'(xc,yc)',size='small')
125 plt.plot([xc+r*np.cos(phi3),xc+r*np.cos(phi3)],[yc-8,yc+r*np.sin(phi3)],'k:')
126 plt.plot([xc,xc],[yc-2,yc-8],'k:')
127 plt.text(25,17,'R*cos(p)',size='small')
128
129 plt.plot([xc-8,xc+r*np.cos(phi3)],[yc+r*np.sin(phi3),yc+r*np.sin(phi3)],'k:')
130 plt.plot([xc-2,xc-8],[yc,yc],'k:')
131 plt.text(13,27,'R*sin(p)',size='small',rotation=90)
132
133 plt.text(49,30,'(x1,y1)',size='small')
134 plt.text(20,62,'(x2,y2)',size='small')
135 plt.text(51,49,'(xp,yp)',size='small')
136
137 #——————————————————————————————————————————arrow heads
138 plt.arrow(47,79,-2,1,head_length=3,head_width=2,color='k')
139 plt.arrow(62,53,-2,2,head_length=2.9,head_width=2,color='k')
140 plt.arrow(64,31,-.9,3,head_length=2,head_width=2,color='k')
141 plt.arrow(52,63,3,-3,head_length=2,head_width=2,color='k')
142
143 plt.show()
Listing 2-4Program PARCGEOMETRY

```

## 2.4 线段圆弧

您可以使用点之间的直线段来创建更精细的弧，而不是使用 np.scatter()在沿弧的点上绘制点。如果将清单 [2-3](#Par19) 中从第 24 行开始的“绘制圆弧”例程替换为

```py
24  #—————————————————————————————————plot arc
25  p1=20*np.pi/180
26  p2=70*np.pi/180
27  dp=(p2-p1)/100
28  xlast=xc+r*np.cos(p1)

29  ylast=yc+r*np.sin(p1)

30  for p in np.arange(p1+dp,p2,dp):

31        x=xc+r*np.cos(p)

32        y=yc+r*np.sin(p)

33        plt.plot([xlast,x],[ylast,y],color='g')

34        xlast=x

35        ylast=y

```

你会得到如图 [2-7](#Fig7) 所示的圆弧。在上面代码的第 28 和 29 行中，您定义了 xlast 和 ylast。这些是绘制在上一个线段末端的最后 x 和 y 坐标值。因为在循环开始之前，您刚刚开始绘制圆弧，所以它们最初被设置为等于 p=p1 处的圆弧起点。您将需要他们绘制第 33 行中的第一个弧段。参数 p、p1、p2 和 dp 与之前相同。想象循环 30-35 刚刚开始运行。第 31 行和第 32 行计算第一个线段末端的全局坐标，该线段 dp 到圆弧中。使用先前设置的值 xlast 和 ylast，它们是 28 和 29 中该线段起点的坐标，第 33 行绘制了第一条线段。第 34 行和第 35 行将第一段的终点坐标更新为 xlast，ylast。这些将被用作第二条线段的起始坐标。循环继续到弧的终点，使用前一段的终点作为下一段的起点。请注意，在第 30 行中，循环从 p1+dp 开始，这是第一条线段的结束角度。这实际上没有必要，循环的起点可以像以前一样设置为 p1，在这种情况下，第一条线段的长度为零。该循环将像以前一样继续到弧的末端。

![A456962_1_En_2_Fig7_HTML.jpg](A456962_1_En_2_Fig7_HTML.jpg)

图 2-7

Circular arc created with plt.plot() line segments

在以后的工作中，您有时会使用由点而不是线段构成的曲线。尽管点不会产生很好的结果，但它们避免了复杂的绘图算法，这种算法有时会模糊脚本的逻辑。但是，线段确实会产生较好的结果，所以您也将使用它们。

## 2.5 圈

一整圈不过是 360 弧。通过将上一部分中圆弧的起点和终点角度更改为 p1=0 度和 p2=360 度，可以形成一个完整的圆。这是在清单 [2-5](#Par28) 的第 24 和 25 行中完成的。输出如图 [2-8](#Fig8) 所示。在不同的位置绘制了三个圆和一个实心圆盘。它们有不同的颜色和宽度。绿色圆圈的一半用实线绘制，另一半用虚线 29-37 绘制。绘制实线或虚线的决定由第 32 行和第 35 行之间的 if 逻辑做出。这将更改第 33 行的 linestyle 属性。蓝色实心圆盘是通过绘制半径从 r1=0 到圆盘外径 r2 的同心圆制成的。当然，您也可以使用 np.scatter()函数制作一个实心磁盘。通过查看清单 [2-5](#Par28) 中的脚本，您应该能够理解这里使用的逻辑来创建各种圆。

这个程序本可以通过使用函数来缩短。为了清楚起见，通过使用剪切和粘贴来复制冗余代码的部分，使其保持开放。

![A456962_1_En_2_Fig8_HTML.jpg](A456962_1_En_2_Fig8_HTML.jpg)

图 2-8

Circles created by Listing [2-5](#Par28)

```py
1   """
2   CIRCLES
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7
8   plt.axis([-75,75,50,-50])
9
10  plt.axis('on')
11  plt.grid(True)
12
13  plt.arrow(0,0,20,0,head_length=4,head_width=3,color='k')
14  plt.arrow(0,0,0,20,head_length=4,head_width=3,color='k')
15
16  plt.text(16,-3,'x')
17  plt.text(-5,17,'y')
18
19  #——————————————————————————————————–green circle
20  xc=0
21  yc=0
22  r=40
23
24  p1=0*np.pi/180

25  p2=360*np.pi/180

26  dp=(p2-p1)/100
27  xlast=xc+r*np.cos(p1)
28  ylast=yc+r*np.sin(p1)
29  for p in np.arange(p1,p2+dp,dp):
30        x=xc+r*np.cos(p)
31        y=yc+r*np.sin(p)
32        if p > 90*np.pi/180 and p < 270*np.pi/180:

33             plt.plot([xlast,x],[ylast,y],color='g',linestyle=':')

34        else:

35             plt.plot([xlast,x],[ylast,y],color='g')

36        xlast=x
37        ylast=y
38
39  plt.scatter(xc,yc,s=15,color='g')
40
41  #————————————————————————————————————————red circle
42  xc=-20
43  yc=-20
44  r=10
45
46  p1=0*np.pi/180
47  p2=360*np.pi/180
48  dp=(p2-p1)/100
49  xlast=xc+r*np.cos(p1)
50  ylast=yc+r*np.sin(p1)
51  for p in np.arange(p1,p2+dp,dp):
52        x=xc+r*np.cos(p)
53        y=yc+r*np.sin(p)
54        plt.plot([xlast,x],[ylast,y],linewidth=4,color='r')
55        xlast=x
56        ylast=y
57
58  plt.scatter(xc,yc,s=15,color='r')
59
60  #—————————————————————————————————————————purple circle
61  xc=20
62  yc=20
63  r=50
64
65  p1=0*np.pi/180
66  p2=360*np.pi/180
67  dp=(p2-p1)/100
68  xlast=xc+r*np.cos(p1)
69  ylast=yc+r*np.sin(p1)
70  for p in np.arange(p1,p2+dp,dp):
71        x=xc+r*np.cos(p)
72        y=yc+r*np.sin(p)
73        plt.plot([xlast,x],[ylast,y],linewidth=2,color=(.8,0,.8))
74        xlast=x
75        ylast=y
76
77  plt.scatter(xc,yc,color=(.5,0,.5))
78
79  #———————————————————————————————————————————blue disc
80  xc=-53
81  yc=-30
82  r1=0
83  r2=10
84  dr=1
85
86  p1=0*np.pi/180
87  p2=360*np.pi/180
88  dp=(p2-p1)/100
89  xlast=xc+r1*np.cos(p1)
90  ylast=yc+r1*np.sin(p1)
91  for r in np.arange(r1,r2,dr):
92        for p in np.arange(p1,p2+dp,dp):
93              x=xc+r*np.cos(p)
94              y=yc+r*np.sin(p)
95              plt.plot([xlast,x],[ylast,y],linewidth=2,color=(0,0,.8))
96              xlast=x
97              ylast=y
98
99  plt.show()
Listing 2-5Program CIRCLES

```

## 2.6 点光盘

图 [2-9](#Fig9) 中显示了用不同点模式创建的两个圆盘。标记为“r，p”的圆盘是通过在传统的极坐标 r，p 阵列中放置点来绘制的，其中 r 是距中心的半径，p 是角度。该算法从清单 [2-6](#Par32) 中的第 21 行开始。清单 [2-6](#Par32) 中的脚本应该是不言自明的。这个图的唯一问题是，点不是均匀分布的，而是随着半径的增加而进一步分开。在某些情况下，这可能是不希望的。

![A456962_1_En_2_Fig9_HTML.jpg](A456962_1_En_2_Fig9_HTML.jpg)

图 2-9

Discs created by different dot patterns in Listing [2-6](#Par32) where “r,p” contains simple polar coordinates and “equal arc” has modified polar coordinates

从第 38 行开始的“等弧”圆盘在视觉上看起来更好。与“r，p”光盘一样，这些点在径向上等距分布。然而，在“等弧”盘中，在每个径向位置的圆周方向上的点的数量随着半径的增加而变大，从而保持点之间的圆周弧间距恒定。使用的模型如图 [2-10](#Fig10) 所示。dc 是 rmax 处点 a 和 b 之间的圆周间距，rmax 是磁盘的外边缘。dp 是半径 a 和 b 之间的角间距，为了在圆盘上获得更均匀的间距，在所有半径上保持 dc 不变。典型的径向位置显示为 r=rmax/2。该半径处的 dc 与 rmax 处的相同，等于 dc。为了适应这种间距，相邻点之间的角度必须增加到 drp。

在清单 [2-6](#Par32) 的第 44 行，圆盘的外径被设置为 20。第 45 行的径向间距设置为 2。请记住，圆弧上两点之间的圆周间距是 r×dp，其中 r 是半径，dp 是两点之间的角度，第 46 行计算 dc，其中您已将 rmax 处的点数任意设置为每π弧度 40(整个圆周 80)。从线 48 开始的循环从 r=dr 开始，并在径向上以步长 dr 前进到 rmax。在每个值或 r 处，在线 49 中计算保持圆周间距等于 dc 所需的点之间的角度 dpr。然后，从第 50 行开始的循环沿圆周方向放置这些点。

![A456962_1_En_2_Fig10_HTML.jpg](A456962_1_En_2_Fig10_HTML.jpg)

图 2-10

Model for “equal arc” disc used by Listing [2-6](#Par32)

```py
1   """
2   DOTDISCS
3   """
4
5   import matplotlib.pyplot as plt
6   import numpy as np
7   import random as rnd
8
9   plt.axis([0,150,100,0])
10
11  plt.axis('off')
12  plt.grid(False)
13
14  plt.arrow(0,0,20,0,head_length=4,head_width=3,color='k')
15  plt.arrow(0,0,0,20,head_length=4,head_width=3,color='k')
16
17  plt.text(16,-3,'x')
18  plt.text(-5,17,'y')
19
20  #—————————————————————————————————————————simple r,p dot pattern
21  xc=40
22  yc=25
23
24  p1=0
25  p2=2*np.pi
26  dp=np.pi/20
27
28  rmax=20
29  dr=2
30
31  for r in np.arange(dr,rmax,dr):
32        for p in np.arange(p1,p2,dp):
33              x=xc+r*np.cos(p)
34              y=yc+r*np.sin(p)
35              plt.scatter(x,y,s=2,color='k')
36
37  #—————————————————————————————————————————equal arc length dot pattern
38  xc=40
39  yc=70
40
41  p1=0
42  p2=2*np.pi
43
44  rmax=20
45  dr=2
46  dc=np.pi*rmax/40

47
48  for r in np.arange(dr,rmax,dr):

49       dpr=dc/r

50       for p in np.arange(p1,p2,dpr):

51            x=xc+r*np.cos(p)

52            y=yc+r*np.sin(p)

53            plt.scatter(x,y,s=2,color='k')

54
55  #————————————————————————————————————————————————————labels
56  plt.text(38,66,'r,p')
57  plt.text(95,66,'equal arc')
58
59  plt.show()
Listing 2-6Program DOTDISCS

```

## 2.7 椭圆

椭圆如图 [2-12](#Fig12) 所示。他们是通过列举 [2-7](#Par42) 得出的。清单 [2-7](#Par42) 使用的型号如图 [2-11](#Fig11) 所示。这是由清单 [2-8](#Par44) 绘制的。尺寸 a 称为半长，因为它指的是较大宽度的一半；b 是半小调。2a 和 2b 是主要尺寸和次要尺寸。

我们都很熟悉的椭圆的方程是，

![$$ \frac{x^2}{a^2}+\frac{y^2}{b^2}=1 $$](A456962_1_En_2_Chapter_Equ7.gif)

(2-7)

在 a=b=r 的特殊情况下，这退化为一个圆，如在

![$$ {x}^2+{y}^2={r}^2 $$](A456962_1_En_2_Chapter_Equ8.gif)

(2-8)中，其中 r 是半径。

绘制椭圆时可以使用的一种策略是从 x=-a 开始，使用等式 [2-7](#Equ7) 在+x 方向前进，计算每个 x 处的 y，然后像过去一样，从最后一步绘制一个点或一条线段。y 坐标很容易从方程 [2-7](#Equ7) 导出为

![$$ y=b\sqrt{1-\frac{x^2}{a^2}} $$](A456962_1_En_2_Chapter_Equ9.gif)

(2-9)

这似乎很容易。图 [2-12](#Fig12) 中的绿色椭圆就是这样画出来的。但是，有一个问题。看清单 [2-7](#Par42) ，第 48、49、50 行；当 x 接近+a 时，等式 [2-9](#Equ9) 和第 48 行中的平方根给出不确定的结果，第 48 行试图取一个非常接近零的数的平方根。这是由 Python 计算中的舍入误差造成的。这种现象表现为椭圆+a 侧的间隙。在绿色椭圆的算法中，该间隙由线 54 和 55 封闭。这样你可以得到一个像样的椭圆，但你必须小心。

另一种方法是使用极坐标，如图 [2-11](#Fig11) 所示。您希望将椭圆上某点的坐标(xp，yp)确定为角度 p 的函数。通过改变 p，您将获得绘制椭圆所需的信息。要确定(xp，yp)与 p 的关系，请注意它位于椭圆和径向线的交点上。这一点用红点表示。顺便说一句，正如可以看到的，该点似乎并不正好位于交叉点上。这是因为用于调整清单 [2-8](#Par44) 第 8 行 x 轴值的比例因子有点偏离。您使用尺子进行粗略测量，然后对计算结果进行四舍五入以确定比例因子。由此产生的微小误差在这里显示出来。直线的方程可以从下面确定:

![$$ xp=r\; cos(p) $$](A456962_1_En_2_Chapter_Equ10.gif)

(2-10)

![$$ yp=r\; sin(p) $$](A456962_1_En_2_Chapter_Equ11.gif)

(2-11)

综合以上，

![$$ \frac{yp}{xp}=\frac{r\; sin(p)}{r\; cos(p)}= tan(p) $$](A456962_1_En_2_Chapter_Equ12.gif)

(2-12)

![$$ yp=xp\; tan(p) $$](A456962_1_En_2_Chapter_Equ13.gif)

(2-13)

你知道(xp，yp)位于直线和椭圆的交点。这就是 xp 和 yp 满足直线和椭圆方程的地方。将方程 [2-13](#Equ13) 代入方程 [2-7](#Equ7) 、

、![$$ \frac{x{p}^2}{a^2}+\frac{x{p}^2ta{n}^2p}{b^2}=1 $$](A456962_1_En_2_Chapter_Equ14.gif)、

(2-14)即可确定该点的坐标，得出

、![$$ xp= ab{\left[{b}^2+{a}^2ta{n}^2(p)\right]}^{-\frac{1}{2}} $$](A456962_1_En_2_Chapter_Equ15.gif)、

、【2-15】、![$$ yp= ab{\left[{a}^2+{b}^2\frac{1}{ta{n}^2(p)}\right]}^{-\frac{1}{2}} $$](A456962_1_En_2_Chapter_Equ16.gif)、、【2-16】

![A456962_1_En_2_Fig11_HTML.jpg](A456962_1_En_2_Fig11_HTML.jpg)

图 2-11

Model created by Listing [2-8](#Par44) and used by Listing [2-7](#Par42)

等式 [2-15](#Equ15) 和 [2-16](#Equ16) 在清单 [2-7](#Par42) 中实现，以绘制第 20 行和第 36 行之间的红色椭圆、第 39 行和第 55 行之间的绿色椭圆以及第 58 行和第 69 行中的蓝色椭圆。输出如图 [2-12](#Fig12) 所示。当绘制绿色椭圆时，程序从-a 循环到+a，并使用等式 [2-9](#Equ9) 计算 y 值。如前所述，这可能会在 x=+a 处的椭圆端点附近导致舍入误差，从而在椭圆中留下一个间隙。这在第 54 行和第 55 行得到了纠正，它们画了一些短线来缩小这个间隙。请注意，蓝色椭圆是填充的。这是通过线 69 完成的，它画出了从椭圆顶部到底部的垂直线。

![A456962_1_En_2_Fig12_HTML.jpg](A456962_1_En_2_Fig12_HTML.jpg)

图 2-12

Ellipses created by Listing [2-7](#Par42)

```py
1   """
2   ELLIPSES
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7
8   plt.axis([-75,75,50,-50])
9
10  plt.axis('on')
11  plt.grid(True)
12
13  plt.arrow(0,0,60,0,head_length=4,head_width=3,color='k')
14  plt.arrow(0,0,0,45,head_length=4,head_width=3,color='k')
15
16  plt.text(58,-3,'x')
17  plt.text(-5,44,'y')
18
19  #————————————————————————————————————————red ellipse
20  a=40
21  b=20.
22  p1=0
23  p2=180*np.pi/180
24  dp=.2*np.pi/180
25
26  xplast=a
27  yplast=0
28  for p in np.arange(p1,p2,dp):
29          xp=np.abs(a*b*(b*b+a*a*(np.tan(p))**2.)**-.5)
30          yp=np.abs(a*b*(a*a+b*b/(np.tan(p)**2.))**-.5)
31          if p > np.pi/2:
32               xp=-xp
33          plt.plot([xplast,xp],[yplast,yp],color='r')
34          plt.plot([xplast,xp],[-yplast,-yp],color='r')
35          xplast=xp
36          yplast=yp
37
38  #————————————————————————————————————————green ellipse
39  a=20.
40  b=40.
41  xp1=-a
42  xp2=a
43  dx=.1
44
45  xplast=-a
46  yplast=0
47  for xp in np.arange(xp1,xp2,dx):
48       yp=b*(1-xp**2./a**2.)**.5

49       plt.plot([xplast,xp],[yplast,yp],linewidth=1,color='g')

50       plt.plot([xplast,xp],[-yplast,-yp],linewidth=1,color='g')

51       xplast=xp
52       yplast=yp
53
54  plt.plot([xplast,a],[yplast,0],linewidth=1,color='g'

55  plt.plot([xplast,a],[-yplast,0],linewidth=1,color='g'

56
57  #—————————————————————————————————————blue ellipse
58  a=5.
59  b=15.
60  p1=0
61  p2=180*np.pi/180
62  dp=.2*np.pi/180
63
64  for p in np.arange(p1,p2,dp):
65        xp=np.abs(a*b*(b*b+a*a*(np.tan(p))**2.)**-.5)
66        yp=np.abs(a*b*(a*a+b*b/(np.tan(p)**2.))**-.5)
67        if p > np.pi/2:
68             xp=-xp
69        plt.plot([xp,xp],[yp,-yp],linewidth=1,color='b')

70
71  plt.show()
Listing 2-7
Program

ELLIPSES

```

(以下程序用于创建图 [2-11](#Fig11) 。)

```py
1   """
2   ELLIPSEMODEL
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7
8   plt.axis([-75,75,50,-50])
9
10  plt.axis('on')
11  plt.grid(True)
12
13  plt.arrow(0,0,60,0,head_length=4,head_width=3,color='k')
14  plt.arrow(0,0,0,40,head_length=4,head_width=3,color='k')
15
16  plt.text(58,-3,'x')
17  plt.text(-5,40,'y')
18
19  #——————————————————————————————————————ellipse
20  a=50.
21  b=30.
22  p1=0.
23  p2=180.*np.pi/180.
24  dp=(p2-p1)/180.
25
26  xplast=a
27  yplast=0
28  for p in np.arange(p1,p2+dp,dp):
29        xp=np.abs(a*b*(b*b+a*a*(np.tan(p))**2.)**-.5)
30        yp=np.abs(a*b*(a*a+b*b/(np.tan(p)**2.))**-.5)
31        if p > np.pi/2:
32             xp=-xp
33        plt.plot([xplast,xp],[yplast,yp],color='k')
34        plt.plot([xplast,xp],[-yplast,-yp],color='k')
35        xplast=xp
36        yplast=yp
37
38  #———————————————————————————————————————————line
39  plt.plot([0,40],[0,40],color='k')
40
41  #———————————————————————————————————————————point
42  p=45.*np.pi/180.
43  xp=np.abs(a*b*(b*b+a*a*(np.tan(p))**2.)**-.5)
44  yp=np.abs(a*b*(a*a+b*b/(np.tan(p)**2.))**-.5)
45  plt.scatter(xp,yp,s=20,color='r')
46
47  #—————————————————————————————————————————labels
48  plt.text(23,-3,'a',color='k')
49  plt.text(-5,15,'b',color='k')
50  plt.text(32,28,'(xp,yp)')
51  plt.text(30,12,'p')
52  plt.text(10,18,'r')
53
54  #——————————————————————————————————————————p arc
55  p1=0
56  p2=45*np.pi/180
57  dp=(p2-p1)/180
58  r=30
59  for p in np.arange(p1,p2,dp):
60        x=r*np.cos(p)
61        y=r*np.sin(p)
62        plt.scatter(x,y,s=.1,color='r')
63
64  plt.arrow(25,17.5,-1,1,head_length=3,head_width=2,color='r')
65
66  plt.show()
Listing 2-8Program ELLIPSEMODEL

```

## 2.8 2D 译本

在二维空间中，物体具有三个独立的自由度:它可以绕一个垂直于平面的轴方向旋转，并且可以在平面内的两个方向(x 和 y)平移。纯平移意味着物体移动而不旋转；纯旋转意味着物体旋转而不平移。图 [2-13](#Fig13) 中的对象是纯翻译的例子。三角形(黑色)在没有旋转的情况下向右(绿色)平移(移动)，然后向下(红色)。用 Python 来完成这件事很简单，尤其是在使用清单 [2-9](#Par46) 中的列表时。例如，要将一个对象向右移动 dx 的量，只需将 dx 加到 x 坐标上，然后重新绘制它。类似地，对于 y 方向，只需将 dy 添加到 y 坐标，然后重新绘制。在从第 45 行开始的循环中，通过将 x 坐标增加 10 个单位，将蓝色小框平移穿过绘图区域。

![A456962_1_En_2_Fig13_HTML.jpg](A456962_1_En_2_Fig13_HTML.jpg)

图 2-13

Examples of translation created by Listing [2-9](#Par46)

```py
1   """
2   2DTRANSLATION
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7
8   x1=-10
9   x2=140
10  y1=90
11  y2=-10
12  plt.axis([x1,x2,y1,y2])
13
14  plt.axis('on')
15  plt.grid(True)
16
17  plt.title('Translation')
18
19  #—————————————————————————————————————————————————triangle
20  x=[20,30,40,20]
21  y=[40,20,40,40]
22  plt.plot(x,y,color='k')
23  plt.plot(x,y,color='k')
24  plt.plot(x,y,color='k')
25
26  #——————————————————————————————————————translate triangle dx=60
27  x=[60,70,80,60]
28  plt.plot(x,y,color='g')
29  plt.plot(x,y,color='g')
30  plt.plot(x,y,color='g')
31
32  #——————————————————————————————————————translate triangle dy=40
33  y=[80,60,80,80]
34  plt.plot(x,y,color='r')
35  plt.plot(x,y,color='r')
36  plt.plot(x,y,color='r')
37
38  #——————————————————————————————————————————————————————box
39  x=[0,0,5,5,0]
40  y=[55,50,50,55,55]
41  plt.plot(x,y,'b')
42
43  #————————————————————————————————————————————translate box
44  y=[55,50,50,55,55]
45  for x in np.arange(0,130,10):

46       x=[x,x,x+5,x+5,x]

47       plt.plot(x,y,'b')

48
49  plt.show()
Listing 2-9Program 2DTRANSLATION

```

## 2.9 2D 旋转

到目前为止，在这一章中，你已经看到了如何使用点和线在二维平面上构建图像。在本节中，您将学习如何在二维平面对象自身的平面内旋转该对象。一个你可能想要旋转的 2D 对象，比如一个矩形，或者更复杂的东西，通常由任意数量的点和线组成。当然，线是由它们的端点或一系列点定义的，如果这些点是由点构成的话。如您所见，曲线也可以由线段或点构成。如果您可以确定如何旋转一个点，那么您将能够旋转任何由点定义的平面对象。在第 [3](03.html) 章，你将把这些概念推广到三维物体绕三个坐标方向的旋转。

图 [2-14](#Fig14) 显示了三个坐标系:蓝色的 xg，yg 系是全局坐标系。它的数值大小和全局原点的位置(xg=0，yg=0)由 plt.axis([x1，x2，y1，y2])语句中的值定义。这是您在绘图时使用的系统。所有绘图坐标都应与该系统相关。比如写 plt.scatter(xg，yg)，xg 和 yg 应该是相对于蓝色的 xg，yg 系统如图所示。

![A456962_1_En_2_Fig14_HTML.jpg](A456962_1_En_2_Fig14_HTML.jpg)

图 2-14

2D rotation model

黑色的 x，y 系统是本地系统。局部系统中的一个位置(xp，yp)等价于全局系统中的(xc+xp，yc+yp)。您可以使用本地系统，通过指定组成形状的点的坐标来构造形状。例如，如果要在绘图区域的某个地方绘制一个圆，可以将(xc，yc)放置在圆的中心，参照局部(黑色)系统计算定义圆的点，然后通过将每个点平移 xc 和 yc，将这些点关联回 xg，yg(蓝色)系统进行绘图。

图 [2-14](#Fig14) 显示了一个点 P，该点通过顺时针角度 Rz 旋转到 P’处的一个新位置。红色坐标系旋转角度 Rz。p 随之旋转。P′在旋转系统(xp，yp)中的坐标与它们在本地系统中的坐标相同。但是，在全球体系中，它们显然是不同的。你现在的目标是确定 P '在局部系统中的坐标，然后在全局系统中，这样你就可以绘制它了。

我使用术语 Rz 来表示角度，因为在 x，y 平面中的顺时针旋转实际上是围绕 z 方向的旋转，z 方向指向纸面。第 [1](01.html) 章对此进行了说明。这将在第 [3](03.html) 章中详细解释。

图 [2-14](#Fig14) 显示点 P 处于未旋转位置。它相对于局部 x，y 系统(黑色)的坐标是(xp，yp)。它的位置由向量 P，

![$$ \mathbf{P}=xp\widehat{\mathbf{i}}+yp\widehat{\mathbf{j}} $$](A456962_1_En_2_Chapter_Equ17.gif)

(2-17)定义其中 Iˇ和 jˇ是 x 和 y 方向的单位向量。

在 P 旋转通过角度 Rz 之后，它到达相对于 x，y(黑色)系统的坐标(x′，y′)处的新位置 P′(红色)。P′由向量 P′(红色)定义为，

![$$ {\mathbf{P}}^{\mathbf{\prime}}=x{p}^{\mathit{\prime}}\widehat{\mathbf{i}}+y{p}^{\mathit{\prime}}\widehat{\mathbf{j}} $$](A456962_1_En_2_Chapter_Equ18.gif)

(2-18)

P’相对于旋转的 x’，y’系统的坐标是(xp，yp)。因此，P’的位置也由向量

![$$ {\mathbf{P}}^{\mathbf{\prime}}=xp{\widehat{\mathbf{i}}}^{\mathbf{\prime}}+yp{\widehat{\mathbf{j}}}^{\mathbf{\prime}} $$](A456962_1_En_2_Chapter_Equ19.gif)

(2-19)定义，其中 I’和 j’是 x’和 y’方向上的单位向量。

你现在的任务是确定 I’和 j’相对于 I’和 j’的关系，然后将它们代入方程 [2-19](#Equ19) 。这将给出 P’相对于局部 x，y 系统的坐标。通过简单地将 xc 和 yc 相加，你将得到 P '在全球系统中的坐标，这是你绘图所需要的。

四个单位向量显示在(xc，yc)处。Iˇ和 jˇ指向 x 和 y 方向；I′和 j′指向 x′和 y′方向。通过查看图 [2-14](#Fig14) ，可以看到

![$$ {\widehat{\mathbf{i}}}^{\mathbf{\prime}}=\underset{X\; component}{\underbrace{cos(Rz)}}\kern0.24em \widehat{\mathbf{i}}+\underset{Y\; component}{\underbrace{sin(Rz)}}\kern0.24em \widehat{\mathbf{j}} $$](A456962_1_En_2_Chapter_Equ20.gif)

(2-20)

![$$ {\widehat{\mathbf{j}}}^{\mathbf{\prime}}=\underset{X\; component}{\underbrace{\mathit{\hbox{-}} sin(Rz)}}\kern0.24em \widehat{\mathbf{i}}+\underset{Y\; component}{\underbrace{cos(Rz)}}\kern0.24em \widehat{\mathbf{j}} $$](A456962_1_En_2_Chapter_Equ21.gif)

(2-21)

将这些代入方程 2-19，你得到

![$$ \mathbf{p}\mathbf{\hbox{'}}=xp\left[ cos(Rz)\widehat{\mathbf{i}}+ sin(Rz)\widehat{\mathbf{j}}\right]+yp\left[- sin(Rz)\widehat{\mathbf{i}}+ cos(Rz)\widehat{\mathbf{j}}\right] $$](A456962_1_En_2_Chapter_Equ22.gif)

(2-22)

这可以分为 x 和 y 分量，

![$$ {\mathbf{P}}^{\mathbf{\prime}}=x{p}^{\mathit{\prime}}\widehat{\mathbf{i}}+y{p}^{\mathit{\prime}}\widehat{\mathbf{j}} $$](A456962_1_En_2_Chapter_Equ23.gif)

(2-23)其中

![$$ x{p}^{\mathit{\prime}}=xp\left[ cos(Rz)\right]+yp\left[- sin(Rz)\right] $$](A456962_1_En_2_Chapter_Equ24.gif)

(2-24)

![$$ y{p}^{\mathit{\prime}}=xp\left[ sin(Rz)\right]+yp\left[ cos(Rz)\right] $$](A456962_1_En_2_Chapter_Equ25.gif)

(2-25)

这最后两个方程是你将一个点从(xp，yp)通过角度 Rz 旋转到新坐标(XP′，yp′)所需要的全部。注意，两组坐标(xp，yp)和(XP′，yp′)，都是相对于局部 x，y 轴的。然后，xc 和 yc 可以轻松地转换它们，以便在全球系统中进行绘图。

在 yp=0 的特殊情况下，即当 P 在旋转前位于 x 轴 x=xp 处时，方程 [2-24](#Equ24) 和 [2-25](#Equ25) 退化为

![$$ x{p}^{\mathit{\prime}}=xp\; cos(Rz) $$](A456962_1_En_2_Chapter_Equ26.gif)

(2-26)

![$$ y{p}^{\mathit{\prime}}=xp\; sin(Rz) $$](A456962_1_En_2_Chapter_Equ27.gif)

(2-27)，这可以从图 [2-14](#Fig14) 中很容易地得到验证。当然，你关心的是旋转一个一般的点，它最初在 x，y 平面的任何地方，所以你需要方程 [2-24](#Equ24) 和 [2-25](#Equ25) 中包含的完整公式。这些可以用矩阵形式表示为

![$$ \left[\begin{array}{c}\hfill x{p}^{\mathit{\prime}}\hfill \\ {}\hfill y{p}^{\mathit{\prime}}\hfill \end{array}\right]=\left[\begin{array}{cc}\hfill cos(Rz)\hfill & \hfill \mathit{\hbox{-}} sin(Rz)\hfill \\ {}\hfill sin(Rz)\hfill & \hfill cos(Rz)\hfill \end{array}\right]\left[\begin{array}{c}\hfill xp\hfill \\ {}\hfill yp\hfill \end{array}\right] $$](A456962_1_En_2_Chapter_Equ28.gif)

(2-28)，可以缩写为

![$$ \left[{P}^{\mathit{\prime}}\right]=\left[Rz\right]\left[P\right] $$](A456962_1_En_2_Chapter_Equ29.gif)

(2-29)

[P′]和[P]矩阵通常被称为列向量，因为它们包含向量 P 和 P′的分量。[Rz]是变换矩阵；它将 P 矢量转换成 P’矢量，在这种情况下是通过旋转角度 Rz。这些向量如图 [2-15](#Fig15) 所示，其中 P 定义了未旋转点 P1(黑色)和旋转点 P′(红色)在 P3 的位置。可以将[Rz]改写为

![$$ \left[Rz\right]=\left[\begin{array}{cc}\hfill C\left(1,1\right)\hfill & \hfill C\left(1,2\right)\hfill \\ {}\hfill C\left(2,1\right)\hfill & \hfill C\left(2,2\right)\hfill \end{array}\right] $$](A456962_1_En_2_Chapter_Equ30.gif)

(2-30)

![$$ C\left(1,1\right)= cos(Rz) $$](A456962_1_En_2_Chapter_Equ31.gif)

(2-31)

![$$ C\left(1,2\right)=- sin(Rz) $$](A456962_1_En_2_Chapter_Equ32.gif)

(2-32)

![$$ C\left(2,1\right)= sin(Rz) $$](A456962_1_En_2_Chapter_Equ33.gif)

(2-33)

![$$ C\left(2,2\right)= cos(Rz) $$](A456962_1_En_2_Chapter_Equ34.gif)

(2-34)

等式 [2-31](#Equ31) 到 [2-34](#Equ34) 中的定义将在随后的 Python 程序中使用。它们代表在 x，y 平面中顺时针方向的旋转；使用负值的 Rz 以逆时针方向旋转。注意，[Rz]纯粹是旋转角度 Rz 的函数。

要将 XP′和 yp′转换成 xg 和 yg，只需将 xc 加到 XP′上，将 yc 加到 yp′上，如

![$$ xg=xc+x{p}^{\mathit{\prime}} $$](A456962_1_En_2_Chapter_Equ35.gif)

(2-35)

![$$ yg=yc+y{p}^{\mathit{\prime}} $$](A456962_1_En_2_Chapter_Equ36.gif)

(2-36)

在矩阵形式中，

![$$ \left[\begin{array}{c}\hfill xg\hfill \\ {}\hfill yg\hfill \end{array}\right]=\left[\begin{array}{c}\hfill xc\hfill \\ {}\hfill yc\hfill \end{array}\right]+\left[\begin{array}{cc}\hfill cos(Rz)\hfill & \hfill \mathit{\hbox{-}} sin(Rz)\hfill \\ {}\hfill sin(Rz)\hfill & \hfill cos(Rz)\hfill \end{array}\right]\left[\begin{array}{c}\hfill xp\hfill \\ {}\hfill yp\hfill \end{array}\right] $$](A456962_1_En_2_Chapter_Equ37.gif)

(2-37)，可缩写为

![$$ \underset{global}{\underbrace{\left[ Pg\right]}}=\underset{center}{\underbrace{\left[C\right]}}+\left[Rz\right]\underset{local}{\underbrace{\left[P\right]}} $$](A456962_1_En_2_Chapter_Equ38.gif)

(2-38)或在向量形式中，如图 [2-15](#Fig15) 、

![$$ \mathbf{P}g={\mathbf{C}}+{\mathbf{P}}^{\mathbf{\prime}} $$](A456962_1_En_2_Chapter_Equ39.gif)

(2-39)

![A456962_1_En_2_Fig15_HTML.jpg](A456962_1_En_2_Fig15_HTML.jpg)

图 2-15

Rotation of a point P1 from Rz=0<sup>°</sup> (black) to Rz=30<sup>°</sup> (green), 60<sup>°</sup> (red), and 90<sup>°</sup> (grey). Vectors drawn from xg=0, yg=0 to Point 3 at Rz=60<sup>°</sup> illustrating Equation [2-38](#Equ38). Plotted by Listing [2-10](#Par72).

作为上述概念的一个例子，列表 [2-10](#Par72) 从(xp，yp)=(60，0)的原始未旋转位置以 30 度的增量旋转一个点 P1 大约(xc，yc)。结果如图 [2-15](#Fig15) 所示。旋转中心的坐标(xc，yc)设置在第 16 行和第 17 行。

清单 [2-10](#Par72) 的第 28-37 行定义了一个函数 rotz(xp1，yp1，Rz)，它使用方程 [2-31](#Equ31) 到 [2-34](#Equ34) 中的变换矩阵【Rz】的元素以及旋转角度 Rz 来计算并返回变换(旋转和平移)后的坐标(xg，yg)。函数 rotz 中的第 35 行和第 36 行将本地坐标与 xg，yg 系统相关联，用于绘图。注意 rotz 旋转每个点，同时在第 35 行和第 36 行平移 xc 和 yc。这将使全球系统中的坐标为绘图做好准备。你旋转这个点四次:Rz=0，30，60，90。使用函数 rotz(xp，yp，Rz)可以避免对每个点的变换进行编码。

第 39 行和第 40 行将 P 的原始坐标设置为(60，0)。需要注意的是，这些坐标是相对于旋转中心(xc，yc)的。第 43 行开始计算第一个点。这是在 Rz=0 时。第 44 行将 Rz 从度转换为弧度。稍后，我将展示如何使用 radians()函数来做到这一点。第 45 行调用函数 rotz(xp，yp，Rz)。xp 和 yp 设置在第 39 和 40 行；Rz 设置在第 43 行。该函数返回第 37 行中旋转点的坐标(xg，yg)。因为 Rz 在第一次变换中为零，所以它们与未旋转点 P1 的坐标相同。

P2 点的绘制从第 50 行开始。您在第 50 行中将旋转角度设置为 30 度。程序和以前一样，P2 被标为灰点。部分 P3 和 P4 增加 Rz 到 60 和 90 度，绘制红色和最后的灰点。

第 74、77、80 和 83 行说明了 Latex 在打印文本时的使用。例如，看第 74 行，

```py
plt.text(28,6,r'$\mathbf{C}$',color='k')

```

文本从坐标 xg=28，yg=6 开始。正如在第 [1](01.html) 章中所讨论的，r 告诉 Python 把字符串当作原始的。这使得 Latex 代码所需的反斜杠保留在美元符号之间；在本例中为$\mathbf{C}$。\mathbf{}将大括号{}之间的内容加粗。在第 80 行，^{\prime}在 p 旁边放了一个上标撇。如果不包括前缀 r，这将不起作用。

![A456962_1_En_2_Fig16_HTML.jpg](A456962_1_En_2_Fig16_HTML.jpg)

图 2-16

Rotation of a rectangle around its center from Listing [2-11](#Par80)

```py
1
2   """
3   2DROT1
4   """
5   import matplotlib.pyplot as plt
6   import numpy as np
7
8   plt.axis([-10,140,90,-10])
9   plt.axis('on')
10  plt.grid(True)
11
12  #————————————————————————–axes
13  plt.arrow(0,0,40,0,head_length=4,head_width=2,color='b')
14  plt.arrow(0,0,0,40,head_length=4,head_width=2,color='b')
15
16  xc=40

17  yc=10

18
19  plt.plot([xc-30,xc+90],[yc,yc],linewidth=1,color='k') #—-X

20  plt.plot([xc,xc],[yc-5,yc+75],linewidth=1,color='k') #—-Y

21
22  plt.text(30,-2,'Xg',color='b')
23  plt.text(-7,33,'Yg',color='b')
24  plt.scatter(xc,yc,s=20,color='k')
25  plt.text(xc+3,yc-2,'(xc,yc)')
26
27  #—————————————————–define rotation matrix rz
28  def rotz(xp,yp,rz): #——–xp,yp=un-rotated coordinates relative to xc,yc
29       c11=np.cos(rz)

30       c12=-np.sin(rz)

31       c21=np.sin(rz)

32       c22=np.cos(rz)

33       xpp=xp*c11+yp*c12 #—-xpp,ypp=rotated coordinates relative to xc,yc
34       ypp=xp*c21+yp*c22

35       xg=xc+xpp #—-xg,yg=rotated coordinates relative to xg,yg
36       yg=yc+ypp

37       return [xg,yg]

38
39  xp=60 #————————————-coordinates of first point P1 relative to xc,yc
40  yp=0

41
42  #——————————————————————————————P1
43  rz=0

44  rz=rz*np.pi/180

45  [xg,yg]=rotz(xp,yp,rz)

46  plt.scatter(xg,yg,s=30,color='k' )
47  plt.text(xg+1,yg+6,'P1',color='k')
48
49  #——————————————————————————————————P2
50  rz=30

51  rz=rz*np.pi/180
52  [xg,yg]=rotz(xp,yp,rz)
53  plt.scatter(xg,yg,s=30,color='grey')
54  plt.text(xg+1,yg+6,'P2',color='grey')
55
56  #——————————————————————————————————P3
57  rz=60
58  rz=rz*np.pi/180
59  [xg,yg]=rotz(xp,yp,rz)
60  plt.scatter(xg,yg,s=30,color='r')
61  plt.text(xg+1,yg+6,'P3',color='r')
62  xpp3=xg #——save for later in line 76
63  ypp3=yg
64
65  #——————————————————————————————————P4
66  rz=90
67  rz=rz*np.pi/180
68  [xg,yg]=rotz(xp1,yp1,rz)
69  plt.scatter(xg,yg,s=30,color='grey')
70  plt.text(xp2+1,yp2+6,'P4',color='grey')
71
72  #————————————————————————————————————————————————plot vectors
73  plt.arrow(0,0,xc-4,yc-1,head_length=4,head_width=2,color='k')
74  plt.text(28,6,r'$\mathbf{C}$',color='k')
75
76  plt.arrow(0,0,xpp3-3,ypp3-3,head_length=4,head_width=2,color='b')
77  plt.text(45,50,r'$\mathbf{Pg}$',color='b')
78
79  plt.arrow(xc,yc,xpp3-2-xc,ypp3-5-yc,head_length=4,head_width=2,color='r')
80  plt.text(61,40,r'$\mathbf{P^{\prime}}$',color='r')
81
82  plt.arrow(xc,yc,xp-4,yp,head_length=4,head_width=2,color='k')
83  plt.text(80,yc-2,r'$\mathbf{P}$',color='k')
84
85  plt.show()
Listing 2-10Program 2DROT1

```

接下来，你围绕它的中心旋转一个矩形，如图 [2-16](#Fig16) 所示。旋转中心是(xc，yc)处的点 c。黑色矩形显示的是未旋转方向的矩形。它的角编号为 1-4，如图所示。程序绘制未旋转的矩形，然后围绕 c 点将其旋转到旋转后的位置，并以红色显示。

由于矩形是由其角点定义的，您可以通过围绕 c 旋转角点来旋转矩形。方法详见清单 [2-11](#Par80) 。首先，绘制未旋转的矩形(黑色)。它的四个角点的局部坐标是相对于第 42-49 行中的旋转中心 c 指定的。这些点被标记并绘制为第 51-58 行中的点，其中通过将第 55-58 行中的 xc 和 yc 相加将局部坐标转换为全局坐标。

接下来，用线将角连接起来。第 61-68 行通过 xc 和 yc 转换局部角坐标。这些点被标记为 xg 和 yg，以表示它们相对于全局标绘轴。它们在第 70 行和第 71 行中被设置为列表，然后在第 73 行中被绘制，这在连续的 xg、yg 对之间绘制了线。

注意第 70 行和第 71 行中坐标对的顺序。当调用第 73 行时，它将(xg1，yg1)连接到(xg2，yg2)，然后(xg2，yg2)连接到(xg3，yg3)，依此类推。但是当它到达角 4 时，它必须将角 4 连接回角 1，以便闭合矩形；因此，在 70 和 71 的末尾,( xg4，yg4)连接到(xg1，yg1)。

旋转矩形的绘制从第 76 行开始。Rz 是旋转角度。它在这里被设置为 45 度，然后在第 77 行从度转换为弧度(您可以使用 radians()函数来完成此操作)。

函数 rotz(xp，yp，Rz)在第 29-38 行中定义。等式 [2-31](#Equ31) 到 [2-34](#Equ34) 中所示的旋转变换矩阵的元素在第 30-33 行被求值。xp 和 yp 是未旋转点的坐标。使用等式 [2-24](#Equ24) 和 [2-25](#Equ25) 在第 34 和 35 行评估旋转系统中的坐标 xpp 和 ypp(XP’和 yp’)。xg 和 yg 是旋转和平移后在全球系统中的坐标，根据等式 [2-35](#Equ35) 和 [2-36](#Equ36) 在第 36-37 行中计算。注意，这些线旋转这些点，同时相对于点 c 平移它们。转换后的坐标作为列表返回到第 38 行。

第 80-101 行通过调用函数 rotz(xp，yp，Rz)逐个转换每个角坐标。例如，行 80-83 将角 1 从局部的未旋转坐标 xp1，yp1 变换到全局坐标 xg 和 yg。剩下的三个点以同样的方式变换。使用列表在线 104-107 中用红色绘制连接角的线。

```py
1   """
2   2DROTRECTANGLE
3   """
4
5   import matplotlib.pyplot as plt
6   import numpy as np
7
8   plt.axis([-10,150,100,-10])
9   plt.axis('on')
10  plt.grid(True)
11
12  #————————————————————————————————————————————————————–axes
13  plt.arrow(0,0,40,0,head_length=4,head_width=2,color='b')
14  plt.arrow(0,0,0,40,head_length=4,head_width=2,color='b')
15  plt.text(30,-3,'Xg',color='b')
16  plt.text(-8,34,'Yg',color='b')
17
18  xc=75 #————————————————–center of rotation
19  yc=50
20  plt.plot([xc-40,xc+60],[yc,yc],linewidth=1,color='grey') #—-X
21  plt.plot([xc,xc],[yc-40,yc+45],linewidth=1,color='grey') #—-Y
22  plt.text(127,48,'X')
23  plt.text(70,90,'Y')
24
25  plt.scatter(xc,yc,s=20,color='k') #—plot center of rotation
26  plt.text(70,49,'c')
27
28  #———————————————————————————————————————————-define function rotz
29  def rotz(xp,yp,rz):

30      c11=np.cos(rz)

31      c12=-np.sin(rz)

32      c21=np.sin(rz)

33      c22=np.cos(rz)

34      xpp=xp*c11+yp*c12 #————-relative to xc,yc
35      ypp=xp*c21+yp*c22

36      xg=xc+xpp #—-relative to xg,yg
37      yg=yc+ypp

38      return [xg,yg]

39
40  #——————————————————————————————————————————–plot unrotated rectangle
41  #—————————————————–rectangle corner coordinates in X,Y system
42  xp1=-20

43  xp2=+20

44  xp3=+20

45  xp4=-20

46  yp1=-5

47  yp2=-5

48  yp3=+5

49  yp4=+5

50
51  plt.text(50,45,'1') #——————-label
52  plt.text(97,45,'2')

53  plt.text(97,57,'3')

54  plt.text(50,57,'4')

55  plt.scatter(xp1+xc,yp1+yc,s=10,color='k')

56  plt.scatter(xp2+xc,yp2+yc,s=10,color='k')

57  plt.scatter(xp3+xc,yp3+yc,s=10,color='k')

58  plt.scatter(xp4+xc,yp4+yc,s=10,color='k')

59
60  #——————————————————————————–plot unrotated rectangle
61  xg1=xc+xp1 #——————–corner coordinates in Xg,Yg system
62  yg1=yc+yp1

63  xg2=xc+xp2

64  yg2=yc+yp2

65  xg3=xc+xp3

66  yg3=yc+yp3

67  xg4=xc+xp4

68  yg4=yc+yp4

69
70  xg=[xg1,xg2,xg3,xg4,xg1]

71  yg=[yg1,yg2,yg3,yg4,yg1]

72
73  plt.plot((xg),(yg),color='k')

74
75  #———————————————————————–rotate rectangle corner coordinates
76  rz=45

77  rz=rz*np.pi/180

78
79  #———————————————————————————————————–point 1
80  xp=xp1

81  yp=yp1

82  [xg,yg]=rotz(xp,yp,rz)

83  [xg1,yg1]=[xg,yg]

84
85  #———————————————————————————————————–point 2
86  xp=xp2

87  yp=yp2

88  [xg,yg]=rotz(xp,yp,rz)

89  [xg2,yg2]=[xg,yg]

90
91  #———————————————————————————————————–point 3
92  xp=xp3

93  yp=yp3

94  [xg,yg]=rotz(xp,yp,rz)

95  [xg3,yg3]=[xg,yg]

96
97  #———————————————————————————————————–point 4
98  xp=xp4

99  yp=yp4

100 [xg,yg]=rotz(xp,yp,rz)

101 [xg4,yg4]=[xg,yg]

102
103 #———————————————————————————————————–plot rotated rectangle
104 xg=[xg1,xg2,xg3,xg4,xg1]

105 yg=[yg1,yg2,yg3,yg4,yg1]

106
107 plt.plot(xg,yg,color='r')

108
109 plt.show()
Listing 2-11Program 2DROTRECTANGLE

```

总结一下这个过程，首先使用局部 x，y 系统中位于坐标 xp，yp 的点构造一个对象，在这个例子中是一个简单的矩形。这是通过指定相对于旋转中心 c 的坐标来完成的。接下来，指定 Rz，计算变换矩阵的元素，通过 Rz 变换每个坐标，通过 xc，yc 平移旋转的点，以将所有内容都放入全局 xg，yg 系统，然后进行绘图。转换由函数 rotz(xp，yp，rz)执行，该函数同时旋转坐标并将坐标转换为 xg，yg 系统以进行绘制。在这种情况下，您首先转换所有的坐标，然后在最后使用列表进行绘制。在一些程序中，你将在变换后立即绘制点或线。

接下来，围绕矩形的左下角旋转矩形。如图 [2-17](#Fig17) 所示。执行此操作的程序(未列出)与清单 [2-11](#Par80) 类似，只是旋转中心改为

![$$ xc=55 $$](A456962_1_En_2_Chapter_Equ40.gif)

(2-40)

![$$ yc=55 $$](A456962_1_En_2_Chapter_Equ41.gif)

(2-41)并且角坐标改为

![$$ xp1=0 $$](A456962_1_En_2_Chapter_Equ42.gif)

(2-42)

![$$ xp2=+50 $$](A456962_1_En_2_Chapter_Equ43.gif)

(2-43)

![$$ xp3=+50 $$](A456962_1_En_2_Chapter_Equ44.gif)

(2-44)

![$$ xp4=0 $$](A456962_1_En_2_Chapter_Equ45.gif)

(2-42)

这些尺寸相对于旋转中心，(xc，yc)。

![A456962_1_En_2_Fig17_HTML.jpg](A456962_1_En_2_Fig17_HTML.jpg)

图 2-17

Rotation of a rectangle about a corner

旋转中心 c 不必与物体邻接；你可以把它放在任何地方，只要相对于旋转中心的角坐标被更新。

图 [2-18](#Fig18) 显示了一个构建和旋转圆形物体的例子。显然，如果没有一些与众不同的特征，你将无法看到一个圆是否被旋转了，所以你将开始圆的上半部分设为绿色，下半部分设为红色。你也可以在直径上加一个横条，两端各有一个点。图 [2-19](#Fig19) 为清单 [2-12](#Par92) 生成图 [2-18](#Fig18) 所用的模型。

如图 [2-19](#Fig19) 和 [2-18](#Fig18) 所示，参照清单 [2-12](#Par92) ，在 41 和 42 行程序中，以 xcc，ycc 为圆心，构造起始圆。它的半径 r=10，设置在第 43 行。在第 45-47 行的步长 dp 中，角度 p 从 P1 = 0°开始，到 p2=2π。请注意，您没有使用角度定义 Rz，因为 p 是关于点 xcc，ycc(圆心)的局部角度，而不是旋转中心 xc，yc。沿着圆的周长的点在局部坐标中的第 55 和 56 行中计算。当 alpha=0 时，这会产生起始圆。

在第 57 行的函数调用中使用 alpha 说明您可以为角度使用任何名称，即使在第 29 行的函数定义中使用了 Rz。您正在将一个数字从函数调用传递给一个函数。它两端的名字并不重要；该函数接收的值将与调用该函数时的值相同。

![A456962_1_En_2_Fig19_HTML.jpg](A456962_1_En_2_Fig19_HTML.jpg)

图 2-19

Model used by Listing [2-12](#Par92)

![A456962_1_En_2_Fig18_HTML.jpg](A456962_1_En_2_Fig18_HTML.jpg)

图 2-18

Circles rotated about point c from Listing [2-12](#Par92)

当 alpha >0 时，绘制其他四个圆。从第 53 行开始的 alpha 循环围绕旋转中心顺时针移动圆心(xcc，ycc ),步进为 dalpha，这在第 51 行设置。通过调用 rotz 在第 57 行转换局部坐标。在 rotz 函数调用中包含 Alpha 具有使圆绕其自身中心旋转的效果(xcc，ycc)。第 58-61 行确定每个圆周点是否位于 p=0 和 p=π之间。如果是这样，该点将被标绘为红色，否则标绘为绿色。因此，圆圈的上半部分是红色的，下半部分是绿色的。第 62-70 行绘制了直径条和点。

这种方法的一个重要特征是，不仅圆的中心以步长 dα围绕点 c 旋转，而且每个圆本身也围绕其自身的中心旋转，这可以从旋转的圆中的红色和绿色扇区以及直径条的重新定向中看出。在下一个程序中，您将围绕 c 点旋转每个圆的中心，同时保持每个圆不围绕自己的中心旋转。

为什么我在这个演示中使用圆形？主要是因为它说明了如何在相对于旋转中心的任何位置构造圆形并旋转它们。它说明了知道旋转中心位置的重要性；它不一定与圆心相同。

在这种情况下，你在圆的平面内旋转，这显然不是很有启发性。但是稍后，当我展示如何在三维空间中旋转对象(例如一个圆)时，这些概念将变得有用。在圆形的情况下，当旋转出其平面时，它产生一个椭圆形，这对于在三维空间中描绘圆形和球形物体如圆柱体和球体是必不可少的。简单地将一个圆绕坐标方向旋转出平面，就得到一个椭圆。

```py
1   """
2   2DROTCIRCLE1
3   """
4
5   import matplotlib.pyplot as plt
6   import numpy as np
7
8   plt.axis([-10,150,100,-10])
9   plt.axis('on')
10  plt.grid(True)
11
12  #————————————————————————————————————————————————————–axes
13  plt.arrow(0,0,40,0,head_length=4,head_width=2,color='b')
14  plt.arrow(0,0,0,40,head_length=4,head_width=2,color='b')
15  plt.text(30,-3,'Xg',color='b')
16  plt.text(-8,34,'Yg',color='b')
17
18  xc=80 #————————————————–center of rotation
19  yc=30
20  plt.plot([xc-50,xc+60],[yc,yc],linewidth=1,color='grey') #—-X
21  plt.plot([xc,xc],[yc-35,yc+60],linewidth=1,color='grey') #—-Y
22  plt.text(xc+50,yc-2,'X')
23  plt.text(xc-5,yc+55,'Y')
24
25  plt.scatter(xc,yc,s=20,color='k') #—plot center of rotation
26  plt.text(xc-5,yc-3,'c')
27
28  #———————————————————————————————————————–define rotation matrix Rz
29  def rotz(xp,yp,rz):
30       c11=np.cos(rz)
31       c12=-np.sin(rz)
32       c21=np.sin(rz)
33       c22=np.cos(rz)
34       xpp=xp*c11+yp*c12 #—-rotated coordinates relative to xc,yc
35       ypp=xp*c21+yp*c22
36       xg=xc+xpp #—-rotated coordinates relative to xg,yg
37       yg=yc+ypp
38       return [xg,yg]
39
40  #——————————————————————————————————————————————————plot circles
41  xcc=25 #–xcc,ycc=center of starting circle in local X,Y system
42  ycc=0

43  r=10 #—radius
44
45  p1=0 #——–p1,p2=angles around circle center
46  p2=2*np.pi

47  dp=(p2-p1)/100

48
49  alpha1=0 #—–angles around xc,yc
50  alpha2=2*np.pi
51  dalpha=(alpha2-alpha1)/5
52
53  for alpha in np.arange(alpha1,alpha2,dalpha):
54        for p in np.arange(p1,p2,dp):
55             xp=xcc+r*np.cos(p) #——xp,yp=coordinates relative to local X,Y system
56             yp=ycc+r*np.sin(p)

57             [xg,yg]=rotz(xp,yp,alpha)

58             if p < np.pi:

59                  plt.scatter(xg,yg,s=1,color='r') #——plot lower half red
60             else:

61                  plt.scatter(xg,yg,s=1,color='g') #——plot upper half green
62             xp1=xcc+r #——plot diameter bars and bar end points
63             yp1=0

64             [xg1,yg1]=rotz(xp1,yp1,alpha)

65             xp2=xcc-r

66             yp2=0

67             [xg2,yg2]=rotz(xp2,yp2,alpha)

68             plt.plot([xg1,xg2],[yg1,yg2],color='b')

69             plt.scatter(xg1,yg1,s=10,color='b')

70             plt.scatter(xg2,yg2,s=10,color='b')

71
72  plt.text(xc+31,yc-13,'starting circle')
73  plt.arrow(xc+31,yc-13,-3,2,head_length=2,head_width=1)
74
75  plt.show()
Listing 2-12Program 2DROTCIRCLE1

```

如图 [2-20](#Fig20) 所示，列表 [2-13](#Par96) 以角度 dα为增量旋转起始圆，同时保持每个圆的方向不变。该程序与前一个程序类似，只是每个圆的局部中心绕 c 点旋转，而由起始圆定义的圆周点保持不旋转。程序应该是不言自明的。

请注意清单 [2-12](#Par92) 和 [2-13](#Par96) 之间的区别。在清单 [2-12](#Par92) 中，旋转发生在第 53-70 行。在每个角度α处，围绕圆周的每个点的坐标在线 55 和 56 中确定。然后在第 57 行使用函数 rotz(xp，yp，alpha)对这些进行转换。也就是说，圆周上的每个点都旋转了角度α。这具有旋转整个圆的效果，如图 [2-18](#Fig18) 所示。然而，在清单 [2-13](#Par96) 中，绘图是在第 41-68 行完成的。在这里，只有圆心在第 50 行和第 51 行旋转。在第 55 行，rotz(xp，yp，0)在其参数中使用角度 p=0。这具有不旋转圆本身的效果，仅旋转其中心，如图 [2-20](#Fig20) 所示。

![A456962_1_En_2_Fig20_HTML.jpg](A456962_1_En_2_Fig20_HTML.jpg)

图 2-20

Circles with centers rotated about point c from Listing [2-13](#Par96)

您应该使用哪种旋转方法:图 [2-18](#Fig18) 或 [2-20](#Fig20) 所示的方法？这取决于你的应用。在一种情况下，您可能希望整个对象(包括组成它的点)围绕一个中心旋转，而在另一种情况下，您可能只希望对象的中心旋转，而对象保持其原始方向。见图 [2-21](#Fig21) 。

![A456962_1_En_2_Fig21_HTML.jpg](A456962_1_En_2_Fig21_HTML.jpg)

图 2-21

Model used by Listing [2-13](#Par96)

```py
1   """
2   2DROTCIRCLE2
3   """
4
5   import matplotlib.pyplot as plt
6   import numpy as np
7
8   plt.axis([-10,150,100,-10])
9   plt.axis('on')
10  plt.grid(True)
11
12  #————————————————————————————————————————————————————–axes
13  plt.arrow(0,0,40,0,head_length=4,head_width=2,color='b')
14  plt.arrow(0,0,0,40,head_length=4,head_width=2,color='b')
15  plt.text(30,-3,'Xg',color='b')
16  plt.text(-8,34,'Yg',color='b')
17
18  xc=80 #—————————————————center of rotation
19  yc=30
20  plt.plot([xc-50,xc+60],[yc,yc],linewidth=1,color='grey') #—-X
21  plt.plot([xc,xc],[yc-35,yc+60],linewidth=1,color='grey') #—-Y
22  plt.text(xc+50,yc-2,'X')
23  plt.text(xc-5,yc+55,'Y')
24
25  plt.scatter(xc,yc,s=20,color='k') #—plot center of rotation
26  plt.text(xc-5,yc-3,'c')
27
28  #————————————————————————————————————————define rotation matrix Rz
29  def rotz(xp,yp,rz):
30       c11=np.cos(rz)
31       c12=-np.sin(rz)
32       c21=np.sin(rz)
33       c22=np.cos(rz)
34       xpp=xp*c11+yp*c12 #—-relative to xc,yc
35       ypp=xp*c21+yp*c22
36       xg=xc+xpp #—-relative to xg,yg
37       yg=yc+ypp
38       return [xg,yg]
39
40  #————————————————————————————————————————————plot circles
41  p1=0
42  p2=2*np.pi
43  dp=(p2-p1)/100
44
45  alpha1=0
46  alpha2=2*np.pi
47  dalpha=(alpha2-alpha1)/5
48
49  for alpha in np.arange(alpha1,alpha2,dalpha):
50        xcc=25*np.cos(alpha)

51        ycc=25*np.sin(alpha)

52        for p in np.arange(p1,p2,dp):
53             xp=xcc+r*np.cos(p)
54             yp=ycc+r*np.sin(p)
55             [xg,yg]=rotz(xp,yp,0)

56             if p < np.pi:
57                  plt.scatter(xg,yg,s=1,color='r')
58             else:
59                  plt.scatter(xg,yg,s=1,color='g')
60             xp1=xcc+r
61             yp1=ycc+0
62             [xg1,yg1]=rotz(xp1,yp1,0)
63             xp2=xcc-r
64             yp2=ycc+0
65             [xg2,yg2]=rotz(xp2,yp2,0)
66             plt.plot([xg1,xg2],[yg1,yg2],color='b')
67             plt.scatter(xg1,yg1,s=10,color='b')
68             plt.scatter(xg2,yg2,s=10,color='b')
69
70  plt.text(xc+34,yc-10,'starting circle')
71  plt.arrow(xc+34,yc-10,-2,2,head_length=1,head_ width=1)
72
73  plt.show()
Listing 2-13Program 2DROTCIRCLE2

```

## 2.10 摘要

在这一章中，你看到了如何使用点和线来构建二维图形。您学习了相对坐标的概念，特别是本地系统，它用于构建具有相对于中心的坐标值的图像，在旋转的情况下，它可以用作旋转的中心，以及用于绘图的全球系统。您已经看到了如何将局部坐标转换到全局坐标系中进行绘图，全局坐标系的原点是通过 plt.axes()函数定义的。你看到了如何从点构造线；将彩色圆点排列成艺术图案；并使用点和线段绘制圆弧、圆盘、圆和椭圆。然后你学习了平移(容易)和旋转(不那么容易)的概念。您将所有这些应用于点、矩形和圆形。在下一章，你将把这些想法扩展到三个维度。