# 5.十字路口

在这一章中，你将开发算法，告诉你线和平面与各种物体相交的位置。当您删除隐藏线和跟踪对象投射的阴影时，您开发的技术将会很有用。您还将学习如何用球体显示直线和平面的交点。正如您将看到的，没有一种神奇的算法可以满足所有情况；每一种都需要自己的方法。虽然您可能永远不需要这些算法中的一些，例如与扇形相交的直线，但是这些依赖于基于向量的几何的过程非常有趣，应该会为您提供在遇到不同情况时所需的工具。

除了使用向量，这些解中的许多可以通过分析得出。例如，与球体相交的直线的解可以通过将直线的方程与球体的方程结合起来得到。结果是一个二次方程，当求解时，产生入口和出口点。如果您处理的对象可以用简单的方程来表示，那么这种方法既快速又简单。然而，基于向量的过程虽然看起来更复杂，但实际上非常简单和直观。他们也可以更灵活，更能适应不同寻常的情况。您将在这里使用它们。

## 5.1 与矩形平面相交的直线

图 [5-1](#Fig1) 显示了与矩形平面相交的直线。你将开发算法和程序来寻找交点，称为命中点。这里你规定平面是有限的，但它不一定是有限的。通过分析，你会发现这里没有任何东西要求平面是有限的。你也可以从假设平面是矩形开始。它不一定是矩形的，但是现在，保持有限的矩形更容易。

![A456962_1_En_5_Fig1_HTML.jpg](A456962_1_En_5_Fig1_HTML.jpg)

图 5-1

Geometry of a line intersecting a rectangular plane

平面在 0、1、2 和 3 处有角。这些相对于(xc，yc，zc)处的旋转中心具有(x0，y0，z0) - (x3，y3，z3)的局部坐标。该线从 x[4]，y[4]，z[4]开始，到 x[5]，y[5]，z[5]结束。它在命中点与平面相交。

角 0 处有三个单位向量；③、![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq1.gif)和![$$ \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq2.gif)。单位矢量![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq3.gif)从 0 角指向 1 角；③从 0 到 3。![$$ \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq4.gif)是平面法线。![$$ \widehat{\mathbf{l}} $$](A456962_1_En_5_Chapter_IEq5.gif)是指从 4 到 5 的直线上的单位向量。Q <sub>45</sub> 是 4 到 5 的距离。Q <sub>h</sub> 是 4 到命中点的距离。Q <sub>n</sub> 是从 4 到平面的垂直距离。你的任务是确定击中点的位置(xh，yh，zh)。使用向量几何，您可以写出以下关系:

距离 4→5:![$$ a=x\left[5\right]-x\left[4\right] $$](A456962_1_En_5_Chapter_Equ1.gif)(5-1)

![$$ b=y\left[5\right]-y\left[4\right] $$](A456962_1_En_5_Chapter_Equ2.gif)

(5-2)

(5-3)

(5-4)

单位向量 4→5:

![$$ lx=\frac{a}{Q_{45}} $$](A456962_1_En_5_Chapter_Equ5.gif)

(5-5)

![$$ ly=\frac{b}{Q_{45}} $$](A456962_1_En_5_Chapter_Equ6.gif)

(5-6)

![$$ lz=\frac{c}{Q_{45}} $$](A456962_1_En_5_Chapter_Equ7.gif)

(5-7)

![$$ \widehat{\mathbf{I}}= lx\widehat{\mathbf{i}}+ ly\widehat{\mathbf{j}}+ lz\widehat{\mathbf{k}} $$](A456962_1_En_5_Chapter_Equ8.gif)

(5-8)

距离 0→3:![$$ a=x\left[3\right]-x\left[0\right] $$](A456962_1_En_5_Chapter_Equ9.gif)(5-9)

![$$ b=y\left[3\right]-y\left[0\right] $$](A456962_1_En_5_Chapter_Equ10.gif)

(5-10)

(5-11)

(5-12)

单位向量 0→3:

![$$ ux=\frac{a}{Q_{03}} $$](A456962_1_En_5_Chapter_Equ13.gif)

(5-13)

![$$ uy=\frac{b}{Q_{03}} $$](A456962_1_En_5_Chapter_Equ14.gif)

(5-14)

![$$ uz=\frac{c}{Q_{03}} $$](A456962_1_En_5_Chapter_Equ15.gif)

(5-15)

![$$ \widehat{\mathbf{u}}= ux\widehat{\mathbf{i}}+ uy\widehat{\mathbf{j}}+ uz\widehat{\mathbf{k}} $$](A456962_1_En_5_Chapter_Equ16.gif)

(5-16)

距离 0→1:![$$ a=x\left[1\right]-x\left[0\right] $$](A456962_1_En_5_Chapter_Equ17.gif)(5-17)

![$$ b=y\left[1\right]-y\left[0\right] $$](A456962_1_En_5_Chapter_Equ18.gif)

(5-18)

(5-19)

(5-20)

单位向量 0→1:

![$$ vx=\frac{a}{Q_{01}} $$](A456962_1_En_5_Chapter_Equ21.gif)

(5-21)

![$$ vy=\frac{b}{Q_{01}} $$](A456962_1_En_5_Chapter_Equ22.gif)

(5-22)

![$$ vz=\frac{c}{Q_{01}} $$](A456962_1_En_5_Chapter_Equ23.gif)

(5-23)

![$$ \widehat{\mathbf{v}}= vx\widehat{\mathbf{i}}+ vy\widehat{\mathbf{j}}+ vz\widehat{\mathbf{k}} $$](A456962_1_En_5_Chapter_Equ24.gif)

(5-24)

单位矢量![$$ \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq6.gif):

![$$ \widehat{\mathbf{n}}=\widehat{\mathbf{u}}\times \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_Equ25.gif)

(5-25)

![$$ =\left[\begin{array}{ccc}\widehat{\mathbf{i}}& \widehat{\mathbf{j}}& \widehat{\mathbf{k}}\\ {} ux& uy& uz\\ {} vx& vy& vz\end{array}\right] $$](A456962_1_En_5_Chapter_Equ26.gif)

(5-26)

![$$ \widehat{\mathrm{n}}=\widehat{\mathbf{i}}\underset{nx}{\underbrace{\left( uy\cdotp vz- uz\cdotp vy\right)}}+\widehat{\mathbf{j}}\underset{ny}{\underbrace{\left( uz\cdotp vx- ux\cdotp vz\right)}}+\widehat{\mathbf{k}}\underset{nz}{\underbrace{\left( ux\cdotp vy- uy\cdotp vx\right)}} $$](A456962_1_En_5_Chapter_Equ27.gif)

(5-27)

![$$ \widehat{\mathbf{n}}= nx\widehat{\mathbf{i}}+ ny\widehat{\mathbf{j}}+ nz\widehat{\mathbf{k}} $$](A456962_1_En_5_Chapter_Equ28.gif)

(5-28)

![$$ nx= uy\cdotp vz- uz\cdotp vy $$](A456962_1_En_5_Chapter_Equ29.gif)

(5-29)

![$$ ny= uz\cdotp vx- ux\cdotp vz $$](A456962_1_En_5_Chapter_Equ30.gif)

(5-30)

![$$ nz= ux\cdotp vy- uy\cdotp vx $$](A456962_1_En_5_Chapter_Equ31.gif)

(5-31)

向量 0→4:

![$$ {\mathbf{V}}_{04}=v{x}_{04}\widehat{\mathbf{i}}+v{y}_{04}\widehat{\mathbf{j}}+v{z}_{04}\widehat{\mathbf{k}} $$](A456962_1_En_5_Chapter_Equ32.gif)

(5-32)

![$$ v{x}_{04}=x\left[4\right]-x\left[0\right] $$](A456962_1_En_5_Chapter_Equ33.gif)

(5-33)

![$$ v{y}_{04}=y\left[4\right]-y\left[0\right] $$](A456962_1_En_5_Chapter_Equ34.gif)

(5-34)

![$$ v{z}_{04}=z\left[4\right]-z\left[0\right] $$](A456962_1_En_5_Chapter_Equ35.gif)

(5-35)

与平面垂直距离 4:

![$$ {Q}_n=\left|{\mathbf{V}}_{04}\cdotp \widehat{\mathbf{n}}\right| $$](A456962_1_En_5_Chapter_Equ36.gif)

(5-36)

命中点:

![$$ {Q}_n={Q}_h\kern0.1em \mathit{\cos}(p) $$](A456962_1_En_5_Chapter_Equ37.gif)

(5-37)

![$$ {Q}_h=\frac{Q_n}{\mathit{\cos}(p)} $$](A456962_1_En_5_Chapter_Equ38.gif)

(5-38)

![$$ \mathit{\cos}(p)=\widehat{\mathbf{l}}\cdotp \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_Equ39.gif)

(5-39)

![$$ = lx\cdotp nx+ ly\cdotp ny+ lz\cdotp nz $$](A456962_1_En_5_Chapter_Equ40.gif)

(5-40)

![$$ xh=x\left[4\right]+{Q}_h lx $$](A456962_1_En_5_Chapter_Equ41.gif)

(5-41)

![$$ yh=y\left[4\right]+{Q}_h ly $$](A456962_1_En_5_Chapter_Equ42.gif)

(5-42)

![$$ zh=z\left[4\right]+{Q}_h lz $$](A456962_1_En_5_Chapter_Equ43.gif)

(5-43)

您可以通过测试来查看命中点是否位于平面的边界内。图 [5-2](#Fig2) 显示了几何形状。向量 V0h 从 0 角运行到命中点 h，up 和 vp 分别是 V0h 在 03 和 01 方向上的投影。为了测试入界或出界命中，

如果 up < 0 or up > Q03 命中出界

如果 vp < 0 or vp > Q01 命中出界

以 xh、yh、zh 为命中点 h 的坐标，可以计算出 up 和 vp 如下:

![$$ a= xh-x\left[0\right] $$](A456962_1_En_5_Chapter_Equ44.gif)

(5-44)

![$$ b= yh-y\left[0\right] $$](A456962_1_En_5_Chapter_Equ45.gif)

(5-45)

![$$ c= zh-z\left[0\right] $$](A456962_1_En_5_Chapter_Equ46.gif)

(5-46)

![$$ \mathbf{V}\mathbf{0}\mathbf{h}=a\widehat{\mathbf{i}}+b\widehat{\mathbf{j}}+c\widehat{\mathbf{k}} $$](A456962_1_En_5_Chapter_Equ47.gif)

(5-47)

![A456962_1_En_5_Fig2_HTML.jpg](A456962_1_En_5_Fig2_HTML.jpg)

图 5-2

Out-of-bounds geometry

为了找到答案，你把 V0h 投影到 03 方向。要做到这一点，你需要 V0h 与:

![$$ up=a\cdotp ux+b\cdotp uy+c\cdotp uz $$](A456962_1_En_5_Chapter_Equ48.gif)

(5-48)的点积

求 vp，你取 V0h 与![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq7.gif) :

![$$ vp=a\cdotp vx+b\cdotp vy+c\cdotp vz $$](A456962_1_En_5_Chapter_Equ49.gif)

(5-49)的点积

如果你认为从 4 到 5 的线是有限的，你可以测试它是否足够长到平面。从图 [5-1](#Fig1) 、

、![$$ a= xh-x\left[4\right] $$](A456962_1_En_5_Chapter_Equ50.gif)、

、

、![$$ b= yh-y\left[4\right] $$](A456962_1_En_5_Chapter_Equ51.gif)、

、【5-51】、![$$ c= zh-z\left[4\right] $$](A456962_1_En_5_Chapter_Equ52.gif)、、【5-52】、

、

、【5-53】如果 Q45 < Qh 线太短，没有命中

所有这些都被合并到清单 [5-1](#Par29) 中，该清单与第 [3](03.html) 章中的清单 [3-5](03.html#Par81) 具有相同的结构，尽管一些功能和操作被改变了。在该程序中，旋转方向和旋转量通过键盘输入。轮换是相加的；例如，如果系统首先旋转 Rx=40 度，然后旋转 Rx=10 度，则总角度为 50 度。Ry 和 Rz 的操作类似。

清单 [5-1](#Par29) 中的一些数据是硬连接的，例如矩形平面和与之相交的直线的定义。它们显示在第 18–20 行的列表中。每个列表中有六个元素，编号为[0]-[5]: [0]-[3]是平面的四个角，而[4]和[5]是直线的起点和终点。它们与图 [5-1](#Fig1) 和 [5-2](#Fig2) 中的图相配合。要修改平面和直线，只需在列表中输入新的数字。例如，项目[5]是该行的结尾。要在+y 方向下拉，增加 y[5]。列表中的数字是相对于旋转中心(xc，yc，zc)的局部坐标，旋转中心位于平面的中心。第 14-16 行显示了这些值。

定义一个平面只需要三个点。这里你有一个四角矩形平面。如果您改变平面的角坐标，请确保它们位于同一平面。最简单的方法是从位于或平行于其中一个坐标平面的平面开始。稍后可以将其旋转出该坐标平面。在第 19 行，y 列表的前四个元素都是零。它描述了一个在 y=0 时平行于 x，z 平面的平面。此外，如果改变[x]或[z]列表，请确保平面保持矩形，因为在此分析中，命中点的计算假设是这样的。

围绕坐标方向旋转坐标的旋转函数 rotx、roty 和 rotz 包含在第 28-35 行中。它们与先前程序中使用的相同，因此没有列出。

线 45 在线与平面相交的命中点(xhg，yhg)处画出一个点。如果命中点位于平面的边界内，则圆点的颜色为红色；如果在外面，它就是蓝色的。如果从[4]到[5]的线太短，并且从未到达平面，则颜色变为绿色，并且在线的末端[5]处放置一个点。这如图 [5-5](#Fig5) 所示。命中点的计算由函数 hitpoint(x，y，z)执行，该函数从第 53 行开始。该程序遵循上述方程 [5-1](#Equ1) 至 [5-49](#Equ49) 中的分析，应该是不言自明的。

数据输入发生在行 154-166。这类似于清单 [3-5](03.html#Par81) 。输出样本如图 [5-3](#Fig3) 、 [5-4](#Fig4) 和 [5-5](#Fig5) 所示。参数包含在标题中。

![A456962_1_En_5_Fig5_HTML.jpg](A456962_1_En_5_Fig5_HTML.jpg)

图 5-5

Example of a line too short, in which case a green dot appears at coordinate [5]: x[4]=-40, y[4]=-20, z[4]=15, x[5]=-20, y[5]=-10, z[5]=0, Rx=30°, Ry=45°, Rz°=20

![A456962_1_En_5_Fig4_HTML.jpg](A456962_1_En_5_Fig4_HTML.jpg)

图 5-4

Line intersecting the plane defined by a rectangle. The hit point lies outside the rectangle’s boundaries: y[5]=-5, Rx=45°, Ry=45°, Rz°=20.

![A456962_1_En_5_Fig3_HTML.jpg](A456962_1_En_5_Fig3_HTML.jpg)

图 5-3

Line intersecting the plane defined by a rectangle. The hit point lies within the plane’s boundaries: y[5]=+5, Rx=45°, Ry=45°, Rz°=20

```
1   """
2   LRP
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7   from math import sin, cos, radians,sqrt
8
9   #——————————————fill lists with starting coordinates
10  xg=[ ]
11  yg=[ ]
12  zg=[ ]
13
14  xc=80 #————————center coordinates
15  yc=40
16  zc=40
17
18  x=[-40,-40,40,40,-40,50] #—system (plane and line geometry)
19  y=[0,0,0,0,-20,3]
20  z=[-10,10,10,-10,15,-10]
21
22  for i in range(len(x)):
23        xg.append(x[i]+xc)
24        yg.append(y[i]+yc)
25        zg.append(z[i]+zc)
26
27  #——————————————————define  rotation  functions
28  def rotx(xc,yc,zc,xp,yp,zp,Rx):
29       (same as in prior programs)
30
31  def  roty(xc,yc,zc,xp,yp,zp,Ry):
32        (same as in prior programs)
33
34  def rotz(xc,yc,zc,xp,yp,zp,Rz):
35       (same as in prior programs)
36
37  #———————————————-plot  plane, line and hit point
38  def plotsystem(xg,yg,zg,xh,yh,xhg,yhg,hitcolor):
39       plt.plot([xg[0],xg[1]],[yg[0],yg[1]],color='k')  #—————plot plane
40       plt.plot([xg[1],xg[2]],[yg[1],yg[2]],color='k')
41       plt.plot([xg[2],xg[3]],[yg[2],yg[3]],color='k')
42       plt.plot([xg[3],xg[0]],[yg[3],yg[0]],color='k')
43       plt.plot([xg[4],xg[5]],[yg[4],yg[5]],color='b') #———plot line
44
45       if hitcolor="g": #——————plot hit point at [5]
46             plot.scatter(xg[5],yg[5],s=20,color=hitcolor)
47       else: #——————plot hit point at h
48             plt.scatter(xhg,yhg,s=20,color=hitcolor)
49
50       plt.axis([0,150,100,0]) #———replot axes and grid
51       plt.axis('on')
52       plt.grid(False)
53       plt.show() #———plot latest rotation
54
55  #—————————————find hit point coordinates and color
56  def hitpoint(x,y,z):
57       a=x[5]-x[4]
58       b=y[5]-y[4]
59       c=z[5]-z[4]
60       Q45=sqrt(a*a+b*b+c*c)  #———distance  point  4  to  5
61
62       lx=a/Q45 #———unit vector components point 4 to 5
63       ly=b/Q45
64       lz=c/Q45
65
66       a=x[3]-x[0]
67       b=y[3]-y[0]
68       c=z[3]-z[0]
69       Q03=sqrt(a*a+b*b+c*c) #———distance 0 to 3
70
71       ux=a/Q03 #———unit vector 0 to 3
72       uy=b/Q03
73       uz=c/Q03
74
75       a=x[1]-x[0]
76       b=y[1]-y[0]
77       c=z[1]-z[0]
78       Q01=sqrt(a*a+b*b+c*c) #———distance 0 to 1
79
80       vx=a/Q01 #———unit vector 0 to 1
81       vy=b/Q01
82       vz=c/Q01
83
84       nx=uy*vz-uz*vy #———normal unit vector
85       ny=uz*vx-ux*vz
86       nz=ux*vy-uy*vx
87
88       vx1b=x[4]-x[0] #———vector components 0 to 4
89       vy1b=y[4]-y[0]
90       vz1b=z[4]-z[0]
91
92       Qn=(vx1b*nx+vy1b*ny+vz1b*nz) #———perpendicular distance 4 to plane
93
94       cosp=lx*nx+ly*ny+lz*nz #——cos of angle p
95       Qh=abs(Qn/cosp) #———distance 4 to hit point
96
97       xh=x[4]+Qh*lx  #———hit  point  coordinates
98       yh=y[4]+Qh*ly
99       zh=z[4]+Qh*lz
100
101      xhg=xh+xc #———global hit point coordinates
102      yhg=yh+yc
103      zhg=zh+zc
104
105  #————————————————————out of bounds check
106      a=xh-x[0] #——components of vector V0h
107      b=yh-y[0]
108      c=zh-z[0]
109
110      up=a*ux+b*uy+c*uz #———dot products
111      vp=a*vx+b*vy+c*vz
112
113      hitcolor='r' #———if inbounds plot red hit point
114      if up<0: #———change color to blue if hit point out of bounds
115           hitcolor='b'
116
117      if up>Q03:
118           hitcolor='b'
119
120      if vp<0:
121           hitcolor='b'
122
123      if vp>Q01:
124           hitcolor='b'
125
126      a=x[5]-x[4]
127      b=y[5]-y[4]
128      c=z[5]-z[4]
129      Q45=sqrt(a*a+b*b+c*c)
130
131      if Q45 < Qh:
132           hitcolor='g'
133
134      return xh,yh,xhg,yhg,hitcolor
135
136 #————————————————transform  coordinates  and  plot
137 def  plotx(xc,yc,zc,Rx):   #———transform  &  plot  Rx  system
138       for i in range(len(x)):
139             [xg[i],yg[i],zg[i]]=rotx(xc,yc,zc,x[i],y[i],z[i],Rx)
140             [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
141
142       xh,yh,xhg,yhg,hitcolor=hitpoint(x,y,z) #———returns xh,yh,xhg,yhg
143
144       plotsystem(xg,yg,zg,xh,yh,xhg,yhg,hitcolor) #———plot
145
146 def ploty(xc,yc,zc,Ry):  #———transform & plot Ry system
147      for i in range(len(x)):
148            [xg[i],yg[i],zg[i]]=roty(xc,yc,zc,x[i],y[i],z[i],Ry)
149            [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
150
151      xh,yh,xhg,yhg,hitcolor=hitpoint(x,y,z)
152
153      plotsystem(xg,yg,zg,xh,yh,xhg,yhg,hitcolor)
154
155 def plotz(xc,yc,zc,Rz):   #———transform  &  plot  Rz  system
156      for i in range(len(x)):
157            [xg[i],yg[i],zg[i]]=rotz(xc,yc,zc,x[i],y[i],z[i],Rz)
158            [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
159
160      xh,yh,xhg,yhg,hitcolor=hitpoint(x,y,z)
161
162      plotsystem(xg,yg,zg,xh,yh,xhg,yhg,hitcolor)
163
164 #—————————————————-input data and plot system
165 while True:
166      axis=input('x, y or z?: ') #———input axis of rotation (lower case)
167      if axis == 'x': #—if x axis
168            Rx=radians(float(input('Rx Degrees?: '))) #———input degrees
169            plotx(xc,yc,zc,Rx) #–call function plotx
170      if axis == 'y':
171            Ry=radians(float(input('Ry Degrees?: '))) #———input degrees
172            ploty(xc,yc,zc,Ry)
173      if axis == 'z':
174            Rz=radians(float(input('Rz Degrees?: '))) #———input degrees
175            plotz(xc,yc,zc,Rz)
176      if axis == ":
177            break #—quit the program
Listing 5-1Program LRP

```

## 5.2 与三角形平面相交的直线

几乎任何平面都可以由一组三角形平面构成，而曲面可以用三角形来近似，因此我们对三角形平面感兴趣。

图 [5-6](#Fig6) 显示了一条线与一个三角形平面相交的几何图形。清单 [5-3](#Par42) 中使用的算法与清单 [5-1](#Par29) 中使用的算法基本相同。一个区别是列表的长度当然更短，因为三角形少了一个角。另一个原因是对命中点是在三角形内还是在三角形外的检查是不同的。

在继续列出 [5-3](#Par42) 之前，你将开发一个简单的方法来确定一个命中点是在三角形内还是在三角形外。图 [5-7](#Fig7) 显示了用于越界计算的几何图形。列表 [5-2](#Par39) 产生如图 [5-8](#Fig8) 所示的输出，并修改定义点 3 坐标的列表，如图 [5-9](#Fig9) 所示。在图 [5-8](#Fig8) 中，击球出界；在图 [5-9](#Fig9) 中，它在三角形内。

![A456962_1_En_5_Fig6_HTML.jpg](A456962_1_En_5_Fig6_HTML.jpg)

图 5-6

Geometry of a line intersecting a triangular plane

图 [5-7](#Fig7) 显示了三个三角形:由点 0、1 和 2 定义的黑色三角形是基础三角形，也就是你所关心的三角形。它的面积为 a。由点 0、1 和 3(命中点)定义的三角形的面积为 A1。点 0、3 和 2 之间的第三个三角形的面积为 A2。很容易看出，如果 A1+A2 > A，命中点出界；如果 A1+A2 < A，则在界内。如果你能计算出三个三角形的面积，你将有一个简单的方法来确定命中点是在基本三角形之内还是之外。为此，你依靠一个简单的表达式来确定三角形的面积:

![$$ s=\left(a+b+c\right)/2 $$](A456962_1_En_5_Chapter_Equ54.gif)

【5-54】

![$$ A=\sqrt{s\left(s-a\right)\kern0.1em \left(s-b\right)\kern0.1em \left(s-c\right)} $$](A456962_1_En_5_Chapter_Equ55.gif)

【5-55】其中 A、b 和 c 是三角形三条边的长度，A 是它的面积。这就是众所周知的赫伦公式，以亚历山大的英雄命名，他是一位大约公元 10-70 年的希腊工程师和数学家。

这种关系在清单 [5-2](#Par39) 和随后的清单 [5-3](#Par42) 中使用。在清单 [5-2](#Par39) 中，程序的大部分都与评估图 [5-7](#Fig7) 中所示线条的长度有关。然后使用 Heron 公式计算三个区域:A、A1 和 A2。清单 [5-2](#Par39) 的第 114-117 行决定命中点是在基本三角形的内部还是外部。它产生图 [5-8](#Fig8) 。程序 THT2(未显示)与 THT1(列表 [5-2](#Par39) )相同，但调整了列表，将命中点放在三角形内。产生图 [5-9](#Fig9) 。调整后的列表包括

x=[40，30，80，55]

y=[60，10，60，45]

z=[0，0，0，0]

从这些列表中可以看到，生命值被移到了(55，45，0)。

![A456962_1_En_5_Fig9_HTML.jpg](A456962_1_En_5_Fig9_HTML.jpg)

图 5-9

In bounds, hit produced by modified Listing [5-2](#Par39)

![A456962_1_En_5_Fig8_HTML.jpg](A456962_1_En_5_Fig8_HTML.jpg)

图 5-8

Out of bounds, no hit produced by Listing [5-2](#Par39)

![A456962_1_En_5_Fig7_HTML.jpg](A456962_1_En_5_Fig7_HTML.jpg)

图 5-7

Model for out-of-bounds test

```
1   """
2   THT1
3   """
4
5   import matplotlib.pyplot as plt
6   import numpy as np
7   from math import sin, cos, radians, sqrt
8
9   plt.axis([0,150,100,0])
10
11  plt.axis('on')
12  plt.grid(True)
13
14  x=[40,30,80,75] #———plane
15  y=[60,10,60,40]
16  z=[0,0,0,0]
17
18  plt.plot([x[0],x[1]],[y[0],y[1]],color='k') #——plot plane A
19  plt.plot([x[1],x[2]],[y[1],y[2]],color='k')
20  plt.plot([x[2],x[0]],[y[2],y[0]],color='k')
21  plt.scatter(x[3],y[3],s=20,color='r')
22
23  plt.plot([x[0],x[3]],[y[0],y[3]],linestyle=':',color='r') #plot planes
24  plt.plot([x[1],x[3]],[y[1],y[3]],linestyle=':',color='r')
25  plt.plot([x[2],x[3]],[y[2],y[3]],linestyle=':',color='r')
26
27  plt.text(35,63,'0') #——label corners
28  plt.text(25,10,'1')
29  plt.text(83,63,'2')
30  plt.text(x[3]+2,y[3],'3')
31
32  a=x[1]-x[0] #——calculate dimensions
33  b=y[1]-y[0]
34  c=z[1]-z[0]
35  Q01=sqrt(a*a+b*b+c*c)
36
37  a=x[2]-x[1]
38  b=y[2]-y[1]
39  c=z[2]-z[1]
40  Q12=sqrt(a*a+b*b+c*c)
41
42  a=x[2]-x[0]
43  b=y[2]-y[0]
44  c=z[2]-z[0]
45  Q02=sqrt(a*a+b*b+c*c)
46
47  a=x[1]-x[3]
48  b=y[1]-y[3]
49  c=z[1]=z[3]
50  Q13=sqrt(a*a+b*b+c*c)
51
52  a=x[2]-x[3]
53  b=y[2]-y[3]
54  c=z[2]-z[3]
55  Q23=sqrt(a*a+b*b+c*c)
56
57  a=x[0]-x[3]
58  b=y[0]-y[3]
59  c=z[0]-z[3]
60  Q03=sqrt(a*a+b*b+c*c)
61
62  s=(Q01+Q12+Q02)/2 #——calculate areas A, A1 and A2
63  A=sqrt(s*(s-Q01)*(s-Q12)*(s-Q02))
64
65  s1=(Q01+Q03+Q13)/2
66  A1=sqrt(s1*(s1-Q01)*(s1-Q03)*(s1-Q13))
67
68  s2=(Q02+Q23+Q03)/2
69  A2=sqrt(s2*(s2-Q02 )*(s2-Q23)*(s2-Q03))
70
71  plt.arrow(70,55,10,15,linewidth=.5,color='grey') #——label area A
72  plt.text(82,73,'A',color='k')
73
74  plt.text(100,40,'A=') #——plot output
75  dle='%7.0f'%  (A)
76  dls=str(dle)
77  plt.text(105,40,dls)
78
79  plt.text(100,45,'A1=',color='r')
80  dle='%7.0f'% (A1)
81  dls=str(dle)

82  plt.text(105,45,dls)
83
84  plt.text(100,50,'A2=',color='r')
85  dle='%7.0f'% (A2)
86  dls=str(dle)
87  plt.text(105,50,dls)
88
89  plt.text(91,55,'A1+A2=',color='r')
90  dle='%7.0f'%  (A1+A2)
91  dls=str(dle)
92  plt.text(106,55,dls)
93
94  plt.text(100,40,'A=')
95  dle='%7.0f'%  (A)
96  dls=str(dle)
97  plt.text(105,40,dls)
98
99  plt.text(100,45,'A1=',color='r')
100 dle='%7.0f'% (A1)
101 dls=str(dle)
102 plt.text(105,45,dls)
103
104 plt.text(100,50,'A2=',color='r')
105 dle='%7.0f'% (A2)
106 dls=str(dle)
107 plt.text(105,50,dls)
108
109 plt.text(91,55,'A1+A2=',color='r')
110 dle="%7.0f'% (A1+A2)
111 dls=str(dle)
112 plt.text(106,55,dls)
113
114 if A1+A2 > A:
115      plt.text(100,63,'OUT, NO HIT')
116 else:
117      plt.text(100,63,'IN, HIT')
118
119 plt.show()

Listing 5-2Program THT1

```

清单 [5-3](#Par42) 描绘了一条线和一个三角形之间的点击点。它与清单 [5-1](#Par29) 相似，除了它使用上面开发的内部或外部测试。输出示例如图 [5-10](#Fig10) 、 [5-11](#Fig11) 和 [5-12](#Fig12) 所示。值得注意的一个区别是单位矢量![$$ \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq8.gif)的计算，它垂直于三角形的平面。在清单 [5-1](#Par29) 中，这是通过取\与 v\的叉积找到的。由于和![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq9.gif)之间的角度为 90°<sup>，这产生了一个垂直于两者的单位矢量，这意味着垂直于平面，并且大小为 1。这是因为![$ \left|\widehat{\mathbf{u}}\times \widehat{\mathbf{v}}\right|=\left|\widehat{\mathbf{u}}\right|\kern0.1em \left|\widehat{\mathbf{v}}\right|\kern0.1em \sin \left(\alpha \right) $](A456962_1_En_5_Chapter_IEq10.gif)中α是和![$ \widehat{\mathbf{v}} $](A456962_1_En_5_Chapter_IEq11.gif)之间的角度。当α等于 90°时<sup>、</sup>、![$ \left|\widehat{\mathbf{u}}\times \widehat{\mathbf{v}}\right|=(1)(1)(1)=1 $](A456962_1_En_5_Chapter_IEq12.gif)。</sup>

![A456962_1_En_5_Fig12_HTML.jpg](A456962_1_En_5_Fig12_HTML.jpg)

图 5-12

Line too short, no hit. x[3]=-40, x[4]=-10, y[3]=-20, y[4]=-5, z[3]=15, z[4]=0, Rx=0, Ry=0, Rz=0 (produced by Listing [5-3](#Par42))

![A456962_1_En_5_Fig11_HTML.jpg](A456962_1_En_5_Fig11_HTML.jpg)

图 5-11

Out-of-bounds hit. x[3]=-60, x[4]=40, y[3]=-20, y[4]=5, z[3]=15, z[4]=0, Rx=-90, Ry=45, Rz=20 (produced by Listing [5-3](#Par42))

![A456962_1_En_5_Fig10_HTML.jpg](A456962_1_En_5_Fig10_HTML.jpg)

图 5-10

In-bounds hit. x[3]=-60, x[4]=70, y[3]=-20, y[4]=20, z[3]=15, z[4]=0, Rx=-90, Ry=45, Rz=20 (produced by Listing [5-3](#Par42))

然而，对于一般的非直角三角形，角度不是 90°<sup>,因此由叉积产生的向量虽然垂直于平面，但不具有值 1；换句话说，它不是一个单位向量。第 88 行和第 91 行之间的算法通过规范化![$ \widehat{\mathbf{n}} $](A456962_1_En_5_Chapter_IEq13.gif)的组件来进行修正。这是通过将它们除以![$ \widehat{\mathbf{n}} $](A456962_1_En_5_Chapter_IEq14.gif)的幅度来实现的。在第 88 行，magn 是矢量分量归一化之前![$ \widehat{\mathbf{n}} $](A456962_1_En_5_Chapter_IEq15.gif)的大小。根据角度α，其值将在 0 和 1 之间。将![$ \widehat{\mathbf{n}} $](A456962_1_En_5_Chapter_IEq16.gif)的每个分量除以 magn，使![$ \widehat{\mathbf{n}} $](A456962_1_En_5_Chapter_IEq17.gif)成为一个单位向量。</sup>

```
1   """
2   LTP
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7   from math import sin, cos, radians,sqrt
8
9   #——————————————fill lists with starting coordinates
10  xg=[ ]
11  yg=[ ]
12  zg=[ ]
13
14  xc=80 #————————center coordinates
15  yc=40
16  zc=40
17
18  x=[-10,-30,20,-40,-10]
19  y=[0,0,0,-20,-5]
20  z=[0,30,0,15,0]
21
22  for i in range(len(x)):
23        xg.append(x[i]+xc)
24        yg.append(y[i]+yc)
25        zg.append(z[i]+zc)
26
27  #—————————————————–define  rotation  functions
28  def rotx(xc,yc,zc,xp,yp,zp,Rx):
29       (same as in prior programs)
30
31  def  roty(xc,yc,zc,xp,yp,zp,Ry):
32       (same as in prior programs)
33
34  def rotz(xc,yc,zc,xp,yp,zp,Rz):
35       (same as in prior programs)
36
37  #———————————————-define  system  plotting  functions
38  def plotsystem(xg,yg,zg,xh,yh,xhg,yhg,hitcolor):
39       plt.plot([xg[0],xg[1]],[yg[0],yg[1]],color='k')  #—————plot plane
40       plt.plot([xg[1],xg[2]],[yg[1],yg[2]],color='k')
41       plt.plot([xg[2],xg[0]],[yg[2],yg[0]],color='k')
42       plt.plot([xg[3],xg[4]],[yg[3],yg[4]],color='g') #———plot line
43       plt.scatter(xc,yc,s=10,color='k') #———plot center of rotation
44
45       if hitcolor=='g':
46            plt.scatter(xg[4],yg[4],s=20,color=hitcolor)
47       else:
48            plt.scatter(xhg,yhg,s=20,color=hitcolor) #——————plot hit point
49
50       plt.axis([0,150,100,0]) #———replot axes and grid
51       plt.axis('on')
52       plt.grid(True)
53       plt.show() #———plot latest rotation
54
55  #————————————-calculate hit point coordinates and color
56  def hitpoint(x,y,z):
57       a=x[4]-x[3]
58       b=y[4]-y[3]
59       c=z[4]-z[3]
60       Q34=sqrt(a*a+b*b+c*c)  #———distance point 3 to 4
61
62       lx=a/Q34 #———unit vector components point 3 to 4
63       ly=b/Q34
64       lz=c/Q34
65
66       a=x[2]-x[0]
67       b=y[2]-y[0]
68       c=z[2]-z[0]
69       Q02=sqrt(a*a+b*b+c*c) #———distance 0 to 3
70
71       ux=a/Q02 #———unit vector 0 to 3
72       uy=b/Q02
73       uz=c/Q02
74
75       a=x[1]-x[0]
76       b=y[1]-y[0]
77       c=z[1]-z[0]
78       Q01=sqrt(a*a+b*b+c*c) #———distance 0 to 1
79
80       vx=a/Q01 #———unit vector 0 to 1
81       vy=b/Q01
82       vz=c/Q01
83
84       nx=uy*vz-uz*vy #———normal unit vector
85       ny=uz*vx-ux*vz
86       nz=ux*vy-uy*vx
87  #——————————–correct magnitude of unit vector ^n
88       magn=sqrt(nx*nx+ny*ny+nz*nz)
89       nx=nx/magn
90       ny=ny/magn
91       nz=nz/magn
92  #——————————————————————
93       a=x[3]-x[0] #———vector components 0 to 3
94       b=y[3]-y[0]
95       c=z[3]-z[0]
96
97       Qn=(a*nx+b*ny+c*nz) #———perpendicular distance 3 to plane
98
99       cosp=lx*nx+ly*ny+lz*nz #———cos of angle p
100      Qh=abs(Qn/cosp) #———distance 4 to hit point
101
102      xh=x[3]+Qh*lx #———hit point coordinates
103      yh=y[3]+Qh*ly
104      zh=z[3]+Qh*lz
105
106      xhg=xh+xc #———global hit point coordinates
107      yhg=yh+yc
108      zhg=zh+zc
109
110 #————————————————————out of bounds check
111      a=x[1]-x[2]
112      b=y[1]-y[2]
113      c=z[1]-z[2]
114      Q12=sqrt(a*a+b*b+c*c)
115
116      a=x[1]-xh
117      b=y[1]-yh
118      c=z[1]-zh
119      Q1h=sqrt(a*a+b*b+c*c)
120
121      a=x[2]-xh
122      b=y[2]-yh
123      c=z[2]-zh
124      Q2h=sqrt(a*a+b*b+c*c)
125
126      a=x[0]-xh
127      b=y[0]-yh
128      c=z[0]-zh
129      Q0h=sqrt(a*a+b*b+c*c)
130
131      s=(Q01+Q12+Q02)/2 #—area A
132      A=sqrt(s*(s-Q01)*(s-Q12)*(s-Q02))
133
134      s1=(Q01+Q0h+Q1h)/2 #———area A1
135      A1=sqrt(s1*(s1-Q01)*(s1-Q0h)*(s1-Q1h))
136
137      s2=(Q02+Q2h+Q0h)/2 #—area A2
138      A2=sqrt(s2*(s2-Q02)*(s2-Q2h)*(s2-Q0h))
139
140      hitcolor='r' #———if within bounds plot red hit point
141
142      if A1+A2 > A: #———if out of bounds plot blue hit point
143           hitcolor='b'
144
145      a=x[4]-x[3]
146      b=y[4]-y[3]
147      c=z[4]-z[3]
148      Q34=sqrt(a*a+b*b+c*c)
149
150      if Q34 < Qh: #———if line too short plot green at end of line
151           hitcolor='g'
152
153      return xh,yh,xhg,yhg,hitcolor
154
155 #————————————————transform coordinates and plot
156 def plotx(xc,yc,zc,Rx):   #———transform & plot Rx system
157      for i in range(len(x)):
158            [xg[i],yg[i],zg[i]]=rotx(xc,yc,zc,x[i],y[i],z[i],Rx)   
159            [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
160
161      xh,yh,xhg,yhg,hitcolor=hitpoint(x,y,z) #———returns xh,yh,xhg,yhg
162
163      plotsystem(xg,yg,zg,xh,yh,xhg,yhg,hitcolor) #———plot plane, line, hit point
164
165      def ploty(xc,yc,zc,Ry):  #———transform & plot Ry system
166      for i in range(len(x)):
167           [xg[i],yg[i],zg[i]]=roty(xc,yc,zc,x[i],y[i],z[i],Ry)
168           [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
169
170      xh,yh,xhg,yhg,hitcolor=hitpoint(x,y,z)
171
172      plotsystem(xg,yg,zg,xh,yh,xhg,yhg,hitcolor)
173
174 def plotz(xc,yc,zc,Rz):   #———transform  &  plot  Rz  system
175      for i in range(len(x)):
176            [xg[i],yg[i],zg[i]]=rotz(xc,yc,zc,x[i],y[i],z[i],Rz)
177            [x[i],y[i],z[i]]=[xg[i]-xc,yg[i]-yc,zg[i]-zc]
178
179      xh,yh,xhg,yhg,hitcolor=hitpoint(x,y,z)
180
181      plotsystem(xg,yg,zg,xh,yh,xhg,yhg,hitcolor)
182
183 #——————————————————input data and plot system
184      while True:
185           axis=input('x, y or z?: ') #———input axis of rotation (lower case)
186           if axis == 'x': #—if x axis
187                     Rx=radians(float(input('Rx Degrees?: '))) #———input degrees of rotation
188                     plotx(xc,yc,zc,Rx) #–call function plotx
189           if axis == 'y':
190                     Ry=radians(float(input('Ry Degrees?: '))) #———input degrees of rotation
191                     ploty(xc,yc,zc,Ry)
192           if axis == 'z':
193                     Rz=radians(float(input('Rz Degrees?: '))) #———input degrees of rotation
194                     plotz(xc,yc,zc,Rz)
195           if axis == ":
196                     break #———quit the program
Listing 5-3Program LTP

```

## 5.3 与圆相交的线

确定与圆平面相交的直线的命中点是否在圆内是微不足道的。如图 [5-13](#Fig13) 所示，如果圆心到命中点的距离大于圆的半径，则位于圆外:

如果 rh > r 未命中

![A456962_1_En_5_Fig13_HTML.jpg](A456962_1_En_5_Fig13_HTML.jpg)

图 5-13

Model for out-of-bounds test for a circle

我们不会写一个单独的程序来演示这一点。您应该能够通过修改清单 [5-1](#Par29) 或清单 [5-3](#Par42) 来自己完成这项工作。只需用定义圆的周长和线坐标的点填充 x[ ]、y[ ]、z[ ]，并修改函数 plotsystem 和 hitpoint。

## 5.4 与扇形相交的直线

在本节中，您将开发一个程序来确定与圆的扇形平面相交的直线的命中点是在扇形内部还是外部。图 [5-14](#Fig14) 所示为扇形。它的圆心在 0 点，半径为 r，命中点在 3 点。rh 是从 0 到击中点的距离。你的目标是确定命中点是在扇区内还是扇区外。(我们不会在这里开发一个完整的三维程序；您将看到内部或外部算法是如何工作的。)它可以很容易地合并到前面的任何程序中，比如清单 [5-3](#Par42) 。

![A456962_1_En_5_Fig14_HTML.jpg](A456962_1_En_5_Fig14_HTML.jpg)

图 5-14

Model for determining whether a line intersecting a circular sector is in or out of bounds. 3=hit point.

点 0 处有五个单位向量:③从 0 到 2 的点；![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq18.gif)从 0 到 1 分；和ĥ从 0 到 3 的生命值。![$$ \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq19.gif)是垂直于扇形平面的单位矢量。因为它向上指向平面外，所以没有显示。![$$ \widehat{\mathbf{u}}\times \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq20.gif)是③与![$$ \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq21.gif)叉积的结果；![$$ \widehat{\mathbf{n}}\times \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq22.gif)来自![$$ \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq23.gif)和![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq24.gif)的叉积。

您的策略是首先确定 Rh>r，在这种情况下，命中点在径向方向的扇区之外。然后你拿ĥ和![$$ \widehat{\mathbf{u}}\times \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq25.gif)的点积。如果结果是肯定的，则命中点在 0-2 侧的扇区之外。然后你拿ĥ和![$$ \widehat{\mathbf{n}}\times \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq26.gif)的点积。如果为正，则命中点在 0-1 侧出界。

在清单 [5-4](#Par51) 中，第 14-16 行的列表中定义了局部坐标(相对于点 0)。列表中的最后一个元素定义了命中点(点 3)的坐标。第 18-20 行中的 xc、yc 和 zc 是点 0 的全局坐标。命中测试算法从第 23 行开始。基于前面的讨论，大部分应该是不言自明的。请注意第 52-58 行。这就是法向矢量![$$ \widehat{\mathbf{n}} $$](A456962_1_En_5_Chapter_IEq27.gif)的计算方法，它是通过取与![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq28.gif)的叉积。如前所述，只有当和![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq29.gif)相互垂直时，才会产生一个单位矢量(大小为 1)。由于在一般扇区中它们之间的角度不一定是 90 度，所以矢量必须被归一化。发生在第 55-58 行。与ĥ的点积发生在第 64 行，与ĥ的点积发生在第 70 行。第 72 行假设命中颜色是红色，这意味着命中在扇区内。如果 A 为正，则它位于扇区之外，在这种情况下，第 74 行中的命中颜色变为蓝色。第 76 行和第 77 行对扇区的另一侧执行相同的测试。第 79 行和第 80 行检查在径向方向上位于扇区外部的命中点。图 [5-15](#Fig15) 和 [5-16](#Fig16) 显示了两次样品运行。你可以通过改变第 14-15 行列表中第 3 点的坐标来移动生命值。您只需更改击中点的 x 和 y 坐标，因为它被假定位于 z=0 平面上，就像扇形一样。

![A456962_1_En_5_Fig16_HTML.jpg](A456962_1_En_5_Fig16_HTML.jpg)

图 5-16

In-bounds or out-of-bounds test produced by Listing [5-4](#Par51): red=in, blue=out

![A456962_1_En_5_Fig15_HTML.jpg](A456962_1_En_5_Fig15_HTML.jpg)

图 5-15

In-bounds or out-of-bounds test produced by Listing [5-4](#Par51): red=in, blue=out

```
1   """
2    LCSTEST
3   """
4
5   import matplotlib.pyplot as plt
6   import numpy as np
7   from math import sin, cos, radians, degrees, sqrt, acos
8
9   plt.axis([0,150,100,0])
10
11  plt.axis('on')
12  plt.grid(True)
13
14  x=[0,20,40,5]
15  y=[0,-35,0,-25]
16  z=[0,0,0,0]
17
18  xc=40
19  yc=60
20  zc=0
21
22  #——————————————hit test
23  a=x[3]-x[0]
24  b=y[3]-y[0]
25  c=z[3]-z[0]
26  rh=sqrt(a*a+b*b+c*c)
27
28  a=x[3]-x[0]
29  b=y[3]-y[0]
30  c=z[3]-z[0]
31  Q0h=sqrt(a*a+b*b+c*c)
32  hx=a/Q0h #———unit vector 0 to hit point
33  hy=b/Q0h
34  hz=c/Q0h
35
36  a=x[2]-x[0]
37  b=y[2]-y[0]
38  c=z[2]-z[0]
39  Q02=sqrt(a*a+b*b+c*c)
40  ux=a/Q02 #———unit vector 0 to 3
41  uy=b/Q02
42  uz=c/Q02
43
44  a=x[1]-x[0]
45  b=y[1]-y[0]
46  c=z[1]-z[0]
47  Q01=sqrt(a*a+b*b+c*c)
48  vx=a/Q01 #———unit vector 0 to 1
49  vy=b/Q01
50  vz=c/Q01
51
52  a=uy*vz-uz*vy #———vector uˆxvˆ normal to plane
53  b=uz*vx-ux*vz
54  c=ux*vy-uy*vx
55  Quxv=sqrt(a*a*b*b+c*c) #———normalize uˆxvˆ
56  nx=a/Quxv
57  ny=b/Quxv
58  nz=c/Quxv
59
60  uxnx=uy*nz-uz*ny #———unit vector uˆxvˆ
61  uxny=uz*nx-ux*nz
62  uxnz=ux*ny-uy*nx
63
64  A=uxnx*hx+uxny*hy+uxnz*hz #———dot product uˆxvˆ with hˆ
65
66  nxvx=ny*vz-nz*vy #———unit vector uˆxvˆ
67  nxvy=nz*vx-nx*vz
68  nxvz=nx*vy-ny*vx
69
70  B=nxvx*hx+nxvy*hy+nxvz*hz #———dot product uˆxvˆ with hˆ
71
72  hitcolor='r'
73  if A>0:  #—out
74       hitcolor='b'
75
76  if B>0: #—out
77       hitcolor='b'
78
79  if rh>r: #—out
80      hitcolor='b'
81
82  plt.scatter(x[3]+xc,y[3]+yc,s=20,color=hitcolor)
83
84  #————————————-plot   arc
85  r=40
86  phi1=0
87  phi2=-radians(60)
88  dphi=(phi2-phi1)/180
89  xlast=xc+r
90  ylast=yc+0
91  for phi in np.arange(phi1,phi2,dphi):
92      x=xc+r*cos(phi)
93      y=yc+r*sin(phi)
94      plt.plot([xlast,x],[ylast,y],color='k')
95      xlast=x
96      ylast=y
97
98
99  #————————————-labels
100 print('rh=',rh)
101 print('r=',r)
102 plt.arrow(xc,yc,40,0)
103 plt.arrow(xc,yc,20,-35,linewidth=.5,color='k')
103 plt.text(33,61,'0')
104 plt.text(52,27,'1')
105 plt.text(82,65,'2')
106
107  plt.show()
Listing 5-4Program LCSTEST

```

## 5.5 与球体相交的线

清单 [5-5](#Par61) 的输出图 [5-17](#Fig17) ，显示了一条与球体相交的线。入口点和出口点显示为红色。图 [5-18](#Fig18) 为清单 [5-5](#Par61) 使用的型号。这条线从 B 开始，到 e 结束。

![A456962_1_En_5_Fig18_HTML.jpg](A456962_1_En_5_Fig18_HTML.jpg)

图 5-18

Model for a line intersecting a sphere

![A456962_1_En_5_Fig17_HTML.jpg](A456962_1_En_5_Fig17_HTML.jpg)

图 5-17

Line intersecting a sphere, produced by Listing [5-5](#Par61)

要找到入口撞击点，从 B 开始，沿着直线向 e 逐渐移动点 p。在每一步，计算 Qpc，即 p 和 c 之间的距离。如果 Qpc 小于或等于球体的半径 rs，则表示您已经接触到球体，并绘制出红点。你继续沿着球内的线移动 p，不画任何东西(你可以画一条虚线)，一边移动一边计算 Qpc，直到 Qpc 等于或大于 rs。在这一点上，p 离开球体，并绘制另一个红点。p 继续沿着 E 线移动，一路上画出黑点。您可以像以前的程序那样使用短线段，而不是用点画线。

要沿线移动 p，您需要使用参数 t，它是 B 到 p 的距离。要获得 p 的坐标，您需要构造单位向量，它沿线指向

![$$ a= xe- xb $$](A456962_1_En_5_Chapter_Equ56.gif)

【5-56】

![$$ b= ye- yb $$](A456962_1_En_5_Chapter_Equ57.gif)

【5-57】

![$$ c= ze- zb $$](A456962_1_En_5_Chapter_Equ58.gif)

【5-58】

![$$ Qbe=\sqrt{a^2+{b}^2+{c}^2} $$](A456962_1_En_5_Chapter_Equ59.gif)

【5-59】

![$$ ux=a/ Qbe $$](A456962_1_En_5_Chapter_Equ60.gif)

【5-60】

![$$ uy=b/ Qbe $$](A456962_1_En_5_Chapter_Equ61.gif)

【5-66】p 的坐标是这样的

![$$ xp= xb+ uxt $$](A456962_1_En_5_Chapter_Equ63.gif)

(5-63)

![$$ yp= yb+ uyt $$](A456962_1_En_5_Chapter_Equ64.gif)

(5-64)

![$$ zp= zb+ uzt $$](A456962_1_En_5_Chapter_Equ65.gif)

(5-65)

Qpc 很容易确定:

![$$ a= xc- xp $$](A456962_1_En_5_Chapter_Equ66.gif)

(5-66)

![$$ b= yc- yp $$](A456962_1_En_5_Chapter_Equ67.gif)

(5-67)

![$$ c= zc- zp $$](A456962_1_En_5_Chapter_Equ68.gif)

(5-68)

![$$ Qpc=\sqrt{a^2+{b}^2+{c}^2} $$](A456962_1_En_5_Chapter_Equ69.gif)

(5-69)

在清单 [5-5](#Par61) 中，球体的中心坐标设置在第 18-20 行。球体由经度(垂直)线和纬度(水平)线组成。第 10-16 行中的列表包含经度的局部和全局坐标。这些列表的初始填充发生在第 25-38 行，它们在 z=0 平面上创建了一个半圆。如图 [5-19](#Fig19) 所示，点 p 位于圆周上坐标 xp，yp，zp 处，其中

![$$ xp= rs\kern0.1em \mathit{\cos}\left(\phi \right) $$](A456962_1_En_5_Chapter_Equ70.gif)

(5-70)

![$$ yp= rs\kern0.1em \mathit{\sin}\left(\phi \right) $$](A456962_1_En_5_Chapter_Equ71.gif)

(5-71)

![$$ zp=0 $$](A456962_1_En_5_Chapter_Equ72.gif)

(5-72)

它们被设置在第 30-32 行。ϕ是围绕 z 方向的角度。从-90 到+90 运行。你不需要经度的后半部分，所以它们不会被标绘。这个半圆将围绕 y 方向旋转，以创建椭圆形经度。它们相隔 10 个<sup>如 74 行中设定的 T5。因为它们只绕 y 方向旋转，所以程序只包含旋转函数 roty:在这个模型中不需要 rotx 和 rotz。经度的绘制发生在第 72-77 行。</sup>

纬度绘制在 80-97 行。图 [5-21](#Fig21) 显示了球体在 x，y 平面内的前视图。每个纬度本质上是一个半径为 R1 的圆，其中

![$$ xl= rs\kern0.1em \mathit{\cos}\left(\phi \right) $$](A456962_1_En_5_Chapter_Equ73.gif)

(5-73)

这是在程序的第 89 行计算的。从前面看，纬度显示为一条直线，因为在这个程序中您没有旋转球体。

从第 88 行开始的ϕ循环以 10 的增量将ϕ从-90 调整到+ 90 。每增加一次，就绘制一个新的纬度。其半径由上面的公式 [5-73](#Equ73) 给出。从第 92 行开始的α循环以 10 的增量从α=0 到 180 扫过圆形纬度的正面。图 [5-22](#Fig22) 对此进行了说明，该图显示了从 x、z 平面向下看的俯视图。

![A456962_1_En_5_Fig22_HTML.jpg](A456962_1_En_5_Fig22_HTML.jpg)

图 5-22

Sphere latitude - x,z view

![A456962_1_En_5_Fig21_HTML.jpg](A456962_1_En_5_Fig21_HTML.jpg)

图 5-21

Sphere latitude - x,y view

![A456962_1_En_5_Fig20_HTML.jpg](A456962_1_En_5_Fig20_HTML.jpg)

图 5-20

x,y view of sphere longitude rotated by Ry=60°

![A456962_1_En_5_Fig19_HTML.jpg](A456962_1_En_5_Fig19_HTML.jpg)

图 5-19

x,y view of sphere longitude shown at starting position Ry=0\. Rotation around the y direction in 10° increments will produce longitudes.

```
1   """
2   LS
3   """
4
5   import numpy as np
6   import matplotlib.pyplot as plt
7   from math import sin, cos, radians, sqrt
8
9   #—————————————————————————lists
10  x=[ ]
11  y=[ ]
12  z=[ ]
13
14  xg=[ ]
15  yg=[ ]
16  zg=[ ]
17
18  xc=80 #——sphere center
19  yc=50
20  zc=0
21
22  rs=40 #———sphere radius
23
24  #————————————————————fill longitude lists
25  phi1=radians(-90)
26  phi2=radians(90)
27  dphi=radians(10)
28
29  for phi in np.arange(phi1,phi2,dphi):
30       xp=rs*cos(phi)
31       yp=rs*sin(phi)
32       zp=0
33       x.append(xp)
34       y.append(yp)
35       z.append(zp)
36       xg.append(xp)
37       yg.append(yp)
38       zg.append(zp)
39
40  #==============================================define rotation function
41  def roty(xc,yc,zc,xp,yp,zp,Ry):
42       a=[xp,yp,zp]
43       b=[cos(Ry),0,sin(Ry)] #———————[cx11,cx12,cx13]
44       xpp=np.inner(a, b)
45       b=[0,1,0] #—————[cx21,cx22,cx23]
46       ypp=np.inner(a,b) #——————–scalar product of a,b
47       b=[-sin(Ry),0,cos(Ry)] #—————[cx31,cx32,cx33]
48       zpp=np.inner(a,b)
49       [xg,yg,zg]=[xpp+xc,ypp+yc,zpp+zc]
50       return[xg,yg,zg]
51
52  #=========================================================
53  def plotsphere(xg,yg,zg):
54       lastxg=xg[0]
55       lastyg=yg[0]
56       for i in range(len(x)):
57             if i < len(x)/2:
58                   plt.plot([lastxg,xg[i]],[lastyg,yg[i]],linewidth=1,color='k')
59             else:
60                   plt.plot([lastxg,xg[i]],[lastyg,yg[i]],linewidth=1,color='k')
61       lastxg=xg[i]
62       lastyg=yg[i]
63
64  #================================================transform coordinates
65  def plotspherey(xc,yc,zc,Ry):
66       for i in range(len(x)): #—————transform and plot Ry sphere
67             [xg[i],yg[i],zg[i]]=roty(xc,yc,zc,x[i],y[i],z[i],Ry)
68
69  plotsphere(xg,yg,zg)  #———plot rotated coordinates
70
71  #—————————————————plot longitudes
72  Ry1=radians(0)
73  Ry2=radians(180)
74  dRy=radians(10)
75
76  for Ry in np.arange(Ry1,Ry2,dRy):
77       plotspherey(xc,yc,zc,Ry)
78
79  #————————————————–plot latitudes
80  alpha1=radians(0)
81  alpha2=radians(180)
82  dalpha=radians(10)
83
84  phi1=radians(-90)
85  phi2=radians(90)
86  dphi=radians(10)
87
88  for phi in np.arange(phi1,phi2,dphi):
89       r=rs*cos(phi) #————————latitude radius
90       xplast=xc+r
91       yplast=yc+rs*sin(phi)
92       for  alpha  in  np.arange(alpha1,alpha2,dalpha):
93            xp=xc+r*cos(alpha)
94            yp=yplast
95            plt.plot([xplast,xp],[yplast,yp],color='k')
96            xplast=xp
97            yplast=yp
98
99  #—————————————————line and hit points
100 xb=-60 #—line beginning
101 yb=-30
102 zb=-20
103
104 xe=60 #——line end
105 ye=30
106 ze=-40
107
108 a=xe-xb
109 b=ye-yb
110 c=ze-zb
111 Qbe=sqrt(a*a+b*b+c*c)  #———line length
112 ux=a/Qbe #—unit vector uˆ
113 uy=b/Qbe
114 uz=c/Qbe
115
116 dt=1
117 for t in np.arange(0,Qbe,dt):
118       xp=xb+ux*t
119       yp=yb+uy*t
120       zp=zb+uz*t
121       Qpc=sqrt(xp*xp+yp*yp+zp*zp)
122       if Qpc > rs:
123            plt.scatter(xp+xc,yp+yc,s=5,color='k')
124       if Qpc <= rs:
125            plt.scatter(xp+xc,yp+yc,s=80,color='r')
126       tlast=t
127       break
128
129 for t in np.arange(tlast,Qbe,dt):
130       xp=xb+ux*t
131       yp=yb+uy*t
132       zp=zb+uz*t
133       Qpc=sqrt(xp*xp+yp*yp+zp*zp)
134       if Qpc >= rs:
135            plt.scatter(xp+xc,yp+yc,s=80,color='r')
136       tlast=t
137       break
138
139 for t in np.arange(tlast,Qbe,dt):
140       xp=xb+ux*t
141       yp=yb+uy*t
142       zp=zb+uz*t
143       Qpc=sqrt(xp*xp+yp*yp+zp*zp)
144       if Qpc >= rs:
145            plt.scatter(xp+xc,yp+yc,s=5,color='k')
146
147 plt.axis([0,150,100,0]) #–plot axes and grid
148 plt.axis('off')
149 plt.grid(False)
150
151  plt.show()
Listing 5-5Program LS

```

## 5.6 与球体相交的平面

在本节中，您将学习一种绘制与球体相交的平面矩形的技术。图 [5-23](#Fig23) 显示了清单 [5-6](#Par66) 的输出；图 [5-24](#Fig24) 显示了该清单使用的模型。

这里的策略是使用上一节中开发的算法，将与球体相交的直线作为基本元素。通过将平面表示为一系列平行线，可以很容易地找到平面与球体的交点。图 [5-23](#Fig23) 显示了拐角 1 处的单位矢量。和以前一样，这从第一行的开始指向结束。在角 1 也有单位矢量![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq32.gif)。这指向角 3。通过沿着从 1 到 3 的线一小步一小步地前进，你可以构建与从 1 到 2 的第一条线平行的线。沿着每一条线，以 t 为增量，你可以找到平面上各点的坐标。为了在![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq33.gif)方向前进，您引入参数 s，它是从角 1 到新线起点的距离。要得到那条线的终点的坐标，使用 vˇ和 s 从点 2 开始执行相同的操作，如在

![$$ xe=x2+ vx\cdotp s $$](A456962_1_En_5_Chapter_Equ74.gif)

【5-74】

![$$ ye= yr+ vy\cdotp s $$](A456962_1_En_5_Chapter_Equ75.gif)

【5-75】

![$$ ze=z2+ vz\cdotp s $$](A456962_1_En_5_Chapter_Equ76.gif)

【5-76】中，xe、ye 和 ze 是线的终点的坐标；x2、y2 和 z2 是点 2 的坐标；而 vx，vy，vz 是单位矢量![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq34.gif)的分量。

使用参数 t 和 s 在平面上向下和横向递增，允许您扫过平面的表面。在每个点 p，你计算从 p 到球心的距离。如果它等于或小于球体的半径，你就击中了。

我不会列出产生图 [5-23](#Fig23) 的整个程序，因为它与清单 [5-5](#Par61) 非常相似，除了增加了一个在![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq35.gif)方向扫过的 s 循环。程序的控制从第 27 行开始。第 27-37 行定义了平面拐角 1、2 和 3 的坐标。在第 39-53 行建立单位向量\u 和![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq36.gif)。第 55 和 56 行设置 dt 和 ds 中的扫描增量。循环 57-64 在![$$ \widehat{\mathbf{v}} $$](A456962_1_En_5_Chapter_IEq37.gif)方向扫描，建立每条线的起点和终点坐标。从第 1 行开始的函数平面确定每一行和球体是否有命中。对于每个 s，从第 3 行开始的循环在{\\ F2 }方向沿着该行前进，计算沿着该行的每个点 p 的坐标 xp、yp、zp。第 10 行计算 p 到球体中心的距离。第 11 行说，如果距离大于球体的半径，画一个黑点。如果它小于或等于半径，第 18 行绘制一个无色点。直到第 24 行的其余逻辑确定该线是否从球体中出现，在这种情况下，黑点的绘制继续。结果如图 [5-23](#Fig23) 所示。

![A456962_1_En_5_Fig24_HTML.jpg](A456962_1_En_5_Fig24_HTML.jpg)

图 5-24

Model for Listing [5-6](#Par66)

![A456962_1_En_5_Fig23_HTML.jpg](A456962_1_En_5_Fig23_HTML.jpg)

图 5-23

Plane intersecting a sphere produced by Listing [5-6](#Par66)

```
"""
PS
"""
import numpy as np
import matplotlib.pyplot as plt
from math import sin, cos, radians, sqrt
.

(similar to Program LS)
.

    #===================================================plane
1   def plane(xb,yb,zb,xe,ye,ze,Q12,dt):
2        hit='off'
3        for t in np.arange(0,Q12,dt): #———B to hit
4             xp=xb+ux*t
5             yp=yb+uy*t
6             zp=zb+uz*t
7             xpg=xc+xp
8             ypg=yc+yp
9             zpg=zc+zp
10            Qpc=sqrt(xp*xp+yp*yp+zp*zp)
11            if Qpc>=rs:
12                 plt.scatter(xpg,ypg,s=.5,color='k')
13            if Qpc<=rs:
14                 if hit=='off':
15                       hit='on'
16            if Qpc<rs:
17                 if hit=='on':
18                       plt.scatter(xpg,ypg,s=10,color=")
19            if Qpc>=rs:
20                 if hit=='on':
21                      hit='off'
22            if Qpc>rs:
23                 if hit=='off':
24                      plt.scatter(xpg,ypg,s=.5,color='k')
25
26  #———————————————————scan  across  plane
27  x1=-40
28  y1=-30
29  z1=-20
30
31  x2=60
32  y2=25
33  z2=-35
34
35  x3=-65
36  y3=-20
37  z3=-50
38
39  a=x2-x1
40  b=y2-y1
41  c=z2-z1
42  Q12=sqrt(a*a+b*b+c*c)
43  ux=a/Q12
44  uy=b/Q12
45  uz=c/Q12
46
47  a=x3-x1
48  b=y3-y1
49  c=z3-z1
50  Q13=sqrt(a*a+b*b+c*c)
51  vx=a/Q13
52  vy=b/Q13
53  vz=c/Q13
54
55  dt=.7 #————————————scan increment
56  ds=.7
57  for s in np.arange(0,Q13,ds):
58       sbx=x1+s*vx
59       sby=y1+s*vy
60       sbz=z1+s*vz
61       sex=x2+s*vx
62       sey=y2+s*vy
63       sez=z2+s*vz
64       plane(sbx,sby,sbz,sex,sey,sez,Q12,dt)
65
66  plt.axis([0,150,100,0]) #–replot axes and grid
67  plt.axis('off')
68  plt.grid(False)
69
70  plt.show() #–plot latest rotation

Listing 5-6Program PS

```

## 5.7 总结

在本章中，您学习了如何预测三维直线或平面是否会与三维曲面或立体相交。为什么要为此烦恼呢？因为这是消除隐藏线的基础，你会在第六章看到。在绘制可能位于另一个曲面或对象 B 后面的曲面 A 时，可以一小步一小步地进行，在每一步绘制一个分散点(或一小段线段)。如果 A 上的点被 B 隐藏，则不要绘制它。为了确定它是否被观察者隐藏，你画一条从 A 点到观察者的假想线(即在-z 方向)。如果你能确定从 A 开始的那条线是否与它前面的一个表面或物体 B 相交，那么你就知道它是否被隐藏了。虽然您不能为每一种可能的情况开发隐藏线算法(您在这里开发了矩形平面、三角形平面、圆形扇形、圆形和球形)，但是通过了解如何为这些对象开发隐藏线算法，您应该能够利用一点创造力为其他表面和对象开发自己的隐藏线算法。也许线三角形平面是最有用的，因为复杂的表面和物体通常可以用三角形的集合来近似。你会在第六章[中看到更多。](06.html)